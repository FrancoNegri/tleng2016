Created by PLY version 3.8 (http://www.dabeaz.com/ply)

Unused terminals:

    RES
    COMMENT
    BEGIN
    END

Grammar

Rule 0     S' -> g
Rule 1     g -> sentencia g
Rule 2     g -> ctrl g
Rule 3     g -> empty
Rule 4     sentencia -> varsOps ;
Rule 5     sentencia -> func ;
Rule 6     sentencia -> varAsig ;
Rule 7     sentencia -> RETURN ;
Rule 8     ctrl -> if
Rule 9     ctrl -> loop
Rule 10    loop -> WHILE ( expBool ) bloque
Rule 11    loop -> DO bloque WHILE ( expBool ) ;
Rule 12    loop -> FOR ( varAsig ; expBool ; varsOps ) bloque
Rule 13    if -> IF ( expBool ) THEN bloque else
Rule 14    else -> ELSE bloque
Rule 15    else -> empty
Rule 16    bloque -> sentencia
Rule 17    bloque -> { g }
Rule 18    func -> funcReturn
Rule 19    func -> funcVoid
Rule 20    funcReturn -> funcInt
Rule 21    funcReturn -> funcString
Rule 22    funcReturn -> funcBool
Rule 23    funcInt -> MULTIESCALAR ( vec , eMat , param )
Rule 24    funcInt -> LENGTH ( vec )
Rule 25    funcString -> CAPITALIZAR ( expString )
Rule 26    funcBool -> COLINEALES ( vec , vec )
Rule 27    funcVoid -> PRINT ( valores )
Rule 28    param -> expBool
Rule 29    param -> empty
Rule 30    empty -> <empty>
Rule 31    vec -> ID = [ elem ]
Rule 32    elem -> valores , elem
Rule 33    elem -> valores
Rule 34    valores -> eMat
Rule 35    valores -> expBool
Rule 36    valores -> expString
Rule 37    valores -> varYVals
Rule 38    valores -> funcReturn
Rule 39    valores -> reg
Rule 40    valores -> ID . ID
Rule 41    varYVals -> ID
Rule 42    varYVals -> vecVal
Rule 43    vecVal -> ID m
Rule 44    m -> [ INT ]
Rule 45    m -> [ INT ] m
Rule 46    reg -> { campos }
Rule 47    campos -> ID : valores , campos
Rule 48    campos -> valores
Rule 49    varsOps -> MENOSMENOS sMM
Rule 50    varsOps -> MASMAS sMM
Rule 51    varsOps -> sMM
Rule 52    sMM -> ID MASMAS
Rule 53    sMM -> ID MENOSMENOS
Rule 54    sMM -> ID
Rule 55    varAsig -> valores MULEQ varAsig
Rule 56    varAsig -> valores DIVEQ varAsig
Rule 57    varAsig -> sIgual
Rule 58    sIgual -> valores MASEQ sIgual
Rule 59    sIgual -> valores MENOSEQ sIgual
Rule 60    sIgual -> asig
Rule 61    asig -> ID = asig
Rule 62    asig -> ID . ID = asig
Rule 63    asig -> vec
Rule 64    asig -> valores
Rule 65    eMat -> eMat + p
Rule 66    eMat -> eMat - p
Rule 67    eMat -> p
Rule 68    p -> p * exp
Rule 69    p -> p / exp
Rule 70    p -> p % exp
Rule 71    p -> exp
Rule 72    exp -> exp ^ iSing
Rule 73    exp -> iSing
Rule 74    iSing -> - paren
Rule 75    iSing -> + paren
Rule 76    iSing -> paren
Rule 77    paren -> ( eMat )
Rule 78    paren -> INT
Rule 79    paren -> varYVals
Rule 80    paren -> FLOAT
Rule 81    paren -> varsOps
Rule 82    paren -> funcInt
Rule 83    expString -> expString + STRING
Rule 84    expString -> STRING
Rule 85    expString -> varYVals
Rule 86    expString -> funcString
Rule 87    expBool -> or ? expBool : expBool
Rule 88    expBool -> or
Rule 89    or -> or OR and
Rule 90    or -> and
Rule 91    and -> and AND eq
Rule 92    and -> eq
Rule 93    eq -> eq EQEQ tBool
Rule 94    eq -> eq DISTINTO tBool
Rule 95    eq -> mayor
Rule 96    mayor -> tCompare > tCompare
Rule 97    mayor -> menor
Rule 98    menor -> tCompare < tCompare
Rule 99    menor -> not
Rule 100   not -> NOT not
Rule 101   not -> tBool
Rule 102   tBool -> ( expBool )
Rule 103   tBool -> BOOL
Rule 104   tBool -> varYVals
Rule 105   tBool -> funcBool
Rule 106   tCompare -> eMat
Rule 107   tCompare -> varsOps
Rule 108   tCompare -> varYVals

Terminals, with rules where they appear

%                    : 70
(                    : 10 11 12 13 23 24 25 26 27 77 102
)                    : 10 11 12 13 23 24 25 26 27 77 102
*                    : 68
+                    : 65 75 83
,                    : 23 23 26 32 47
-                    : 66 74
.                    : 40 62
/                    : 69
:                    : 47 87
;                    : 4 5 6 7 11 12 12
<                    : 98
=                    : 31 61 62
>                    : 96
?                    : 87
AND                  : 91
BEGIN                : 
BOOL                 : 103
CAPITALIZAR          : 25
COLINEALES           : 26
COMMENT              : 
DISTINTO             : 94
DIVEQ                : 56
DO                   : 11
ELSE                 : 14
END                  : 
EQEQ                 : 93
FLOAT                : 80
FOR                  : 12
ID                   : 31 40 40 41 43 47 52 53 54 61 62 62
IF                   : 13
INT                  : 44 45 78
LENGTH               : 24
MASEQ                : 58
MASMAS               : 50 52
MENOSEQ              : 59
MENOSMENOS           : 49 53
MULEQ                : 55
MULTIESCALAR         : 23
NOT                  : 100
OR                   : 89
PRINT                : 27
RES                  : 
RETURN               : 7
STRING               : 83 84
THEN                 : 13
WHILE                : 10 11
[                    : 31 44 45
]                    : 31 44 45
^                    : 72
error                : 
{                    : 17 46
}                    : 17 46

Nonterminals, with rules where they appear

and                  : 89 90 91
asig                 : 60 61 62
bloque               : 10 11 12 13 14
campos               : 46 47
ctrl                 : 2
eMat                 : 23 34 65 66 77 106
elem                 : 31 32
else                 : 13
empty                : 3 15 29
eq                   : 91 92 93 94
exp                  : 68 69 70 71 72
expBool              : 10 11 12 13 28 35 87 87 102
expString            : 25 36 83
func                 : 5
funcBool             : 22 105
funcInt              : 20 82
funcReturn           : 18 38
funcString           : 21 86
funcVoid             : 19
g                    : 1 2 17 0
iSing                : 72 73
if                   : 8
loop                 : 9
m                    : 43 45
mayor                : 95
menor                : 97
not                  : 99 100
or                   : 87 88 89
p                    : 65 66 67 68 69 70
param                : 23
paren                : 74 75 76
reg                  : 39
sIgual               : 57 58 59
sMM                  : 49 50 51
sentencia            : 1 16
tBool                : 93 94 101
tCompare             : 96 96 98 98
valores              : 27 32 33 47 48 55 56 58 59 64
varAsig              : 6 12 55 56
varYVals             : 37 79 85 104 108
varsOps              : 4 12 81 107
vec                  : 23 24 26 26 63
vecVal               : 42

Parsing method: LALR

state 0

    (0) S' -> . g
    (1) g -> . sentencia g
    (2) g -> . ctrl g
    (3) g -> . empty
    (4) sentencia -> . varsOps ;
    (5) sentencia -> . func ;
    (6) sentencia -> . varAsig ;
    (7) sentencia -> . RETURN ;
    (8) ctrl -> . if
    (9) ctrl -> . loop
    (30) empty -> .
    (49) varsOps -> . MENOSMENOS sMM
    (50) varsOps -> . MASMAS sMM
    (51) varsOps -> . sMM
    (18) func -> . funcReturn
    (19) func -> . funcVoid
    (55) varAsig -> . valores MULEQ varAsig
    (56) varAsig -> . valores DIVEQ varAsig
    (57) varAsig -> . sIgual
    (13) if -> . IF ( expBool ) THEN bloque else
    (10) loop -> . WHILE ( expBool ) bloque
    (11) loop -> . DO bloque WHILE ( expBool ) ;
    (12) loop -> . FOR ( varAsig ; expBool ; varsOps ) bloque
    (52) sMM -> . ID MASMAS
    (53) sMM -> . ID MENOSMENOS
    (54) sMM -> . ID
    (20) funcReturn -> . funcInt
    (21) funcReturn -> . funcString
    (22) funcReturn -> . funcBool
    (27) funcVoid -> . PRINT ( valores )
    (34) valores -> . eMat
    (35) valores -> . expBool
    (36) valores -> . expString
    (37) valores -> . varYVals
    (38) valores -> . funcReturn
    (39) valores -> . reg
    (40) valores -> . ID . ID
    (58) sIgual -> . valores MASEQ sIgual
    (59) sIgual -> . valores MENOSEQ sIgual
    (60) sIgual -> . asig
    (23) funcInt -> . MULTIESCALAR ( vec , eMat , param )
    (24) funcInt -> . LENGTH ( vec )
    (25) funcString -> . CAPITALIZAR ( expString )
    (26) funcBool -> . COLINEALES ( vec , vec )
    (65) eMat -> . eMat + p
    (66) eMat -> . eMat - p
    (67) eMat -> . p
    (87) expBool -> . or ? expBool : expBool
    (88) expBool -> . or
    (83) expString -> . expString + STRING
    (84) expString -> . STRING
    (85) expString -> . varYVals
    (86) expString -> . funcString
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (46) reg -> . { campos }
    (61) asig -> . ID = asig
    (62) asig -> . ID . ID = asig
    (63) asig -> . vec
    (64) asig -> . valores
    (68) p -> . p * exp
    (69) p -> . p / exp
    (70) p -> . p % exp
    (71) p -> . exp
    (89) or -> . or OR and
    (90) or -> . and
    (43) vecVal -> . ID m
    (31) vec -> . ID = [ elem ]
    (72) exp -> . exp ^ iSing
    (73) exp -> . iSing
    (91) and -> . and AND eq
    (92) and -> . eq
    (74) iSing -> . - paren
    (75) iSing -> . + paren
    (76) iSing -> . paren
    (93) eq -> . eq EQEQ tBool
    (94) eq -> . eq DISTINTO tBool
    (95) eq -> . mayor
    (77) paren -> . ( eMat )
    (78) paren -> . INT
    (79) paren -> . varYVals
    (80) paren -> . FLOAT
    (81) paren -> . varsOps
    (82) paren -> . funcInt
    (96) mayor -> . tCompare > tCompare
    (97) mayor -> . menor
    (106) tCompare -> . eMat
    (107) tCompare -> . varsOps
    (108) tCompare -> . varYVals
    (98) menor -> . tCompare < tCompare
    (99) menor -> . not
    (100) not -> . NOT not
    (101) not -> . tBool
    (102) tBool -> . ( expBool )
    (103) tBool -> . BOOL
    (104) tBool -> . varYVals
    (105) tBool -> . funcBool

    RETURN          shift and go to state 13
    $end            reduce using rule 30 (empty -> .)
    MENOSMENOS      shift and go to state 23
    MASMAS          shift and go to state 28
    IF              shift and go to state 53
    WHILE           shift and go to state 35
    DO              shift and go to state 45
    FOR             shift and go to state 18
    ID              shift and go to state 52
    PRINT           shift and go to state 15
    MULTIESCALAR    shift and go to state 55
    LENGTH          shift and go to state 11
    CAPITALIZAR     shift and go to state 57
    COLINEALES      shift and go to state 1
    STRING          shift and go to state 51
    {               shift and go to state 32
    -               shift and go to state 50
    +               shift and go to state 20
    (               shift and go to state 5
    INT             shift and go to state 27
    FLOAT           shift and go to state 56
    NOT             shift and go to state 30
    BOOL            shift and go to state 41

    and                            shift and go to state 44
    funcBool                       shift and go to state 2
    ctrl                           shift and go to state 46
    funcInt                        shift and go to state 14
    menor                          shift and go to state 3
    loop                           shift and go to state 43
    eq                             shift and go to state 16
    vecVal                         shift and go to state 47
    if                             shift and go to state 48
    sentencia                      shift and go to state 17
    eMat                           shift and go to state 49
    asig                           shift and go to state 19
    mayor                          shift and go to state 4
    sMM                            shift and go to state 6
    vec                            shift and go to state 7
    sIgual                         shift and go to state 21
    reg                            shift and go to state 22
    empty                          shift and go to state 42
    iSing                          shift and go to state 12
    funcVoid                       shift and go to state 54
    expString                      shift and go to state 24
    tCompare                       shift and go to state 37
    func                           shift and go to state 38
    paren                          shift and go to state 36
    not                            shift and go to state 8
    varAsig                        shift and go to state 39
    g                              shift and go to state 25
    funcString                     shift and go to state 26
    funcReturn                     shift and go to state 9
    valores                        shift and go to state 40
    p                              shift and go to state 10
    varsOps                        shift and go to state 58
    exp                            shift and go to state 59
    tBool                          shift and go to state 31
    varYVals                       shift and go to state 33
    or                             shift and go to state 34
    expBool                        shift and go to state 29

state 1

    (26) funcBool -> COLINEALES . ( vec , vec )

    (               shift and go to state 60


state 2

    (22) funcReturn -> funcBool .
    (105) tBool -> funcBool .

  ! reduce/reduce conflict for MULEQ resolved using rule 22 (funcReturn -> funcBool .)
  ! reduce/reduce conflict for DIVEQ resolved using rule 22 (funcReturn -> funcBool .)
  ! reduce/reduce conflict for MASEQ resolved using rule 22 (funcReturn -> funcBool .)
  ! reduce/reduce conflict for MENOSEQ resolved using rule 22 (funcReturn -> funcBool .)
  ! reduce/reduce conflict for ; resolved using rule 22 (funcReturn -> funcBool .)
  ! reduce/reduce conflict for ) resolved using rule 22 (funcReturn -> funcBool .)
  ! reduce/reduce conflict for } resolved using rule 22 (funcReturn -> funcBool .)
  ! reduce/reduce conflict for , resolved using rule 22 (funcReturn -> funcBool .)
  ! reduce/reduce conflict for ] resolved using rule 22 (funcReturn -> funcBool .)
    ;               reduce using rule 22 (funcReturn -> funcBool .)
    MULEQ           reduce using rule 22 (funcReturn -> funcBool .)
    DIVEQ           reduce using rule 22 (funcReturn -> funcBool .)
    MASEQ           reduce using rule 22 (funcReturn -> funcBool .)
    MENOSEQ         reduce using rule 22 (funcReturn -> funcBool .)
    )               reduce using rule 22 (funcReturn -> funcBool .)
    }               reduce using rule 22 (funcReturn -> funcBool .)
    ,               reduce using rule 22 (funcReturn -> funcBool .)
    ]               reduce using rule 22 (funcReturn -> funcBool .)
    EQEQ            reduce using rule 105 (tBool -> funcBool .)
    DISTINTO        reduce using rule 105 (tBool -> funcBool .)
    AND             reduce using rule 105 (tBool -> funcBool .)
    ?               reduce using rule 105 (tBool -> funcBool .)
    OR              reduce using rule 105 (tBool -> funcBool .)

  ! MULEQ           [ reduce using rule 105 (tBool -> funcBool .) ]
  ! DIVEQ           [ reduce using rule 105 (tBool -> funcBool .) ]
  ! MASEQ           [ reduce using rule 105 (tBool -> funcBool .) ]
  ! MENOSEQ         [ reduce using rule 105 (tBool -> funcBool .) ]
  ! ;               [ reduce using rule 105 (tBool -> funcBool .) ]
  ! )               [ reduce using rule 105 (tBool -> funcBool .) ]
  ! }               [ reduce using rule 105 (tBool -> funcBool .) ]
  ! ,               [ reduce using rule 105 (tBool -> funcBool .) ]
  ! ]               [ reduce using rule 105 (tBool -> funcBool .) ]


state 3

    (97) mayor -> menor .

    EQEQ            reduce using rule 97 (mayor -> menor .)
    DISTINTO        reduce using rule 97 (mayor -> menor .)
    AND             reduce using rule 97 (mayor -> menor .)
    ?               reduce using rule 97 (mayor -> menor .)
    OR              reduce using rule 97 (mayor -> menor .)
    ;               reduce using rule 97 (mayor -> menor .)
    MULEQ           reduce using rule 97 (mayor -> menor .)
    DIVEQ           reduce using rule 97 (mayor -> menor .)
    MASEQ           reduce using rule 97 (mayor -> menor .)
    MENOSEQ         reduce using rule 97 (mayor -> menor .)
    }               reduce using rule 97 (mayor -> menor .)
    )               reduce using rule 97 (mayor -> menor .)
    :               reduce using rule 97 (mayor -> menor .)
    ,               reduce using rule 97 (mayor -> menor .)
    ]               reduce using rule 97 (mayor -> menor .)


state 4

    (95) eq -> mayor .

    EQEQ            reduce using rule 95 (eq -> mayor .)
    DISTINTO        reduce using rule 95 (eq -> mayor .)
    AND             reduce using rule 95 (eq -> mayor .)
    ?               reduce using rule 95 (eq -> mayor .)
    OR              reduce using rule 95 (eq -> mayor .)
    MULEQ           reduce using rule 95 (eq -> mayor .)
    DIVEQ           reduce using rule 95 (eq -> mayor .)
    MASEQ           reduce using rule 95 (eq -> mayor .)
    MENOSEQ         reduce using rule 95 (eq -> mayor .)
    ;               reduce using rule 95 (eq -> mayor .)
    )               reduce using rule 95 (eq -> mayor .)
    }               reduce using rule 95 (eq -> mayor .)
    :               reduce using rule 95 (eq -> mayor .)
    ,               reduce using rule 95 (eq -> mayor .)
    ]               reduce using rule 95 (eq -> mayor .)


state 5

    (77) paren -> ( . eMat )
    (102) tBool -> ( . expBool )
    (65) eMat -> . eMat + p
    (66) eMat -> . eMat - p
    (67) eMat -> . p
    (87) expBool -> . or ? expBool : expBool
    (88) expBool -> . or
    (68) p -> . p * exp
    (69) p -> . p / exp
    (70) p -> . p % exp
    (71) p -> . exp
    (89) or -> . or OR and
    (90) or -> . and
    (72) exp -> . exp ^ iSing
    (73) exp -> . iSing
    (91) and -> . and AND eq
    (92) and -> . eq
    (74) iSing -> . - paren
    (75) iSing -> . + paren
    (76) iSing -> . paren
    (93) eq -> . eq EQEQ tBool
    (94) eq -> . eq DISTINTO tBool
    (95) eq -> . mayor
    (77) paren -> . ( eMat )
    (78) paren -> . INT
    (79) paren -> . varYVals
    (80) paren -> . FLOAT
    (81) paren -> . varsOps
    (82) paren -> . funcInt
    (96) mayor -> . tCompare > tCompare
    (97) mayor -> . menor
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (49) varsOps -> . MENOSMENOS sMM
    (50) varsOps -> . MASMAS sMM
    (51) varsOps -> . sMM
    (23) funcInt -> . MULTIESCALAR ( vec , eMat , param )
    (24) funcInt -> . LENGTH ( vec )
    (106) tCompare -> . eMat
    (107) tCompare -> . varsOps
    (108) tCompare -> . varYVals
    (98) menor -> . tCompare < tCompare
    (99) menor -> . not
    (43) vecVal -> . ID m
    (52) sMM -> . ID MASMAS
    (53) sMM -> . ID MENOSMENOS
    (54) sMM -> . ID
    (100) not -> . NOT not
    (101) not -> . tBool
    (102) tBool -> . ( expBool )
    (103) tBool -> . BOOL
    (104) tBool -> . varYVals
    (105) tBool -> . funcBool
    (26) funcBool -> . COLINEALES ( vec , vec )

    -               shift and go to state 50
    +               shift and go to state 20
    (               shift and go to state 5
    INT             shift and go to state 27
    FLOAT           shift and go to state 56
    ID              shift and go to state 65
    MENOSMENOS      shift and go to state 23
    MASMAS          shift and go to state 28
    MULTIESCALAR    shift and go to state 55
    LENGTH          shift and go to state 11
    NOT             shift and go to state 30
    BOOL            shift and go to state 41
    COLINEALES      shift and go to state 1

    and                            shift and go to state 44
    funcBool                       shift and go to state 61
    funcInt                        shift and go to state 62
    menor                          shift and go to state 3
    eq                             shift and go to state 16
    mayor                          shift and go to state 4
    eMat                           shift and go to state 63
    vecVal                         shift and go to state 47
    sMM                            shift and go to state 6
    paren                          shift and go to state 36
    varsOps                        shift and go to state 64
    tCompare                       shift and go to state 37
    not                            shift and go to state 8
    p                              shift and go to state 10
    iSing                          shift and go to state 12
    exp                            shift and go to state 59
    tBool                          shift and go to state 31
    varYVals                       shift and go to state 66
    or                             shift and go to state 34
    expBool                        shift and go to state 67

state 6

    (51) varsOps -> sMM .

    ^               reduce using rule 51 (varsOps -> sMM .)
    *               reduce using rule 51 (varsOps -> sMM .)
    /               reduce using rule 51 (varsOps -> sMM .)
    %               reduce using rule 51 (varsOps -> sMM .)
    ,               reduce using rule 51 (varsOps -> sMM .)
    +               reduce using rule 51 (varsOps -> sMM .)
    -               reduce using rule 51 (varsOps -> sMM .)
    MULEQ           reduce using rule 51 (varsOps -> sMM .)
    DIVEQ           reduce using rule 51 (varsOps -> sMM .)
    MASEQ           reduce using rule 51 (varsOps -> sMM .)
    MENOSEQ         reduce using rule 51 (varsOps -> sMM .)
    ;               reduce using rule 51 (varsOps -> sMM .)
    >               reduce using rule 51 (varsOps -> sMM .)
    <               reduce using rule 51 (varsOps -> sMM .)
    EQEQ            reduce using rule 51 (varsOps -> sMM .)
    DISTINTO        reduce using rule 51 (varsOps -> sMM .)
    AND             reduce using rule 51 (varsOps -> sMM .)
    ?               reduce using rule 51 (varsOps -> sMM .)
    OR              reduce using rule 51 (varsOps -> sMM .)
    )               reduce using rule 51 (varsOps -> sMM .)
    }               reduce using rule 51 (varsOps -> sMM .)
    :               reduce using rule 51 (varsOps -> sMM .)
    ]               reduce using rule 51 (varsOps -> sMM .)


state 7

    (63) asig -> vec .

    ;               reduce using rule 63 (asig -> vec .)


state 8

    (99) menor -> not .

    EQEQ            reduce using rule 99 (menor -> not .)
    DISTINTO        reduce using rule 99 (menor -> not .)
    AND             reduce using rule 99 (menor -> not .)
    ?               reduce using rule 99 (menor -> not .)
    OR              reduce using rule 99 (menor -> not .)
    MULEQ           reduce using rule 99 (menor -> not .)
    DIVEQ           reduce using rule 99 (menor -> not .)
    MASEQ           reduce using rule 99 (menor -> not .)
    MENOSEQ         reduce using rule 99 (menor -> not .)
    ;               reduce using rule 99 (menor -> not .)
    )               reduce using rule 99 (menor -> not .)
    }               reduce using rule 99 (menor -> not .)
    ,               reduce using rule 99 (menor -> not .)
    ]               reduce using rule 99 (menor -> not .)
    :               reduce using rule 99 (menor -> not .)


state 9

    (18) func -> funcReturn .
    (38) valores -> funcReturn .

  ! reduce/reduce conflict for ; resolved using rule 18 (func -> funcReturn .)
    ;               reduce using rule 18 (func -> funcReturn .)
    MULEQ           reduce using rule 38 (valores -> funcReturn .)
    DIVEQ           reduce using rule 38 (valores -> funcReturn .)
    MASEQ           reduce using rule 38 (valores -> funcReturn .)
    MENOSEQ         reduce using rule 38 (valores -> funcReturn .)

  ! ;               [ reduce using rule 38 (valores -> funcReturn .) ]


state 10

    (67) eMat -> p .
    (68) p -> p . * exp
    (69) p -> p . / exp
    (70) p -> p . % exp

    +               reduce using rule 67 (eMat -> p .)
    -               reduce using rule 67 (eMat -> p .)
    MULEQ           reduce using rule 67 (eMat -> p .)
    DIVEQ           reduce using rule 67 (eMat -> p .)
    MASEQ           reduce using rule 67 (eMat -> p .)
    MENOSEQ         reduce using rule 67 (eMat -> p .)
    ;               reduce using rule 67 (eMat -> p .)
    >               reduce using rule 67 (eMat -> p .)
    <               reduce using rule 67 (eMat -> p .)
    ,               reduce using rule 67 (eMat -> p .)
    )               reduce using rule 67 (eMat -> p .)
    }               reduce using rule 67 (eMat -> p .)
    ]               reduce using rule 67 (eMat -> p .)
    EQEQ            reduce using rule 67 (eMat -> p .)
    DISTINTO        reduce using rule 67 (eMat -> p .)
    AND             reduce using rule 67 (eMat -> p .)
    ?               reduce using rule 67 (eMat -> p .)
    OR              reduce using rule 67 (eMat -> p .)
    :               reduce using rule 67 (eMat -> p .)
    *               shift and go to state 68
    /               shift and go to state 70
    %               shift and go to state 69


state 11

    (24) funcInt -> LENGTH . ( vec )

    (               shift and go to state 71


state 12

    (73) exp -> iSing .

    ^               reduce using rule 73 (exp -> iSing .)
    *               reduce using rule 73 (exp -> iSing .)
    /               reduce using rule 73 (exp -> iSing .)
    %               reduce using rule 73 (exp -> iSing .)
    +               reduce using rule 73 (exp -> iSing .)
    -               reduce using rule 73 (exp -> iSing .)
    MASEQ           reduce using rule 73 (exp -> iSing .)
    MENOSEQ         reduce using rule 73 (exp -> iSing .)
    ;               reduce using rule 73 (exp -> iSing .)
    >               reduce using rule 73 (exp -> iSing .)
    <               reduce using rule 73 (exp -> iSing .)
    MULEQ           reduce using rule 73 (exp -> iSing .)
    DIVEQ           reduce using rule 73 (exp -> iSing .)
    )               reduce using rule 73 (exp -> iSing .)
    }               reduce using rule 73 (exp -> iSing .)
    EQEQ            reduce using rule 73 (exp -> iSing .)
    DISTINTO        reduce using rule 73 (exp -> iSing .)
    AND             reduce using rule 73 (exp -> iSing .)
    ?               reduce using rule 73 (exp -> iSing .)
    OR              reduce using rule 73 (exp -> iSing .)
    :               reduce using rule 73 (exp -> iSing .)
    ,               reduce using rule 73 (exp -> iSing .)
    ]               reduce using rule 73 (exp -> iSing .)


state 13

    (7) sentencia -> RETURN . ;

    ;               shift and go to state 72


state 14

    (20) funcReturn -> funcInt .
    (82) paren -> funcInt .

  ! reduce/reduce conflict for MULEQ resolved using rule 20 (funcReturn -> funcInt .)
  ! reduce/reduce conflict for DIVEQ resolved using rule 20 (funcReturn -> funcInt .)
  ! reduce/reduce conflict for MASEQ resolved using rule 20 (funcReturn -> funcInt .)
  ! reduce/reduce conflict for MENOSEQ resolved using rule 20 (funcReturn -> funcInt .)
  ! reduce/reduce conflict for ; resolved using rule 20 (funcReturn -> funcInt .)
  ! reduce/reduce conflict for , resolved using rule 20 (funcReturn -> funcInt .)
  ! reduce/reduce conflict for ] resolved using rule 20 (funcReturn -> funcInt .)
  ! reduce/reduce conflict for } resolved using rule 20 (funcReturn -> funcInt .)
  ! reduce/reduce conflict for ) resolved using rule 20 (funcReturn -> funcInt .)
    ;               reduce using rule 20 (funcReturn -> funcInt .)
    MULEQ           reduce using rule 20 (funcReturn -> funcInt .)
    DIVEQ           reduce using rule 20 (funcReturn -> funcInt .)
    MASEQ           reduce using rule 20 (funcReturn -> funcInt .)
    MENOSEQ         reduce using rule 20 (funcReturn -> funcInt .)
    )               reduce using rule 20 (funcReturn -> funcInt .)
    }               reduce using rule 20 (funcReturn -> funcInt .)
    ,               reduce using rule 20 (funcReturn -> funcInt .)
    ]               reduce using rule 20 (funcReturn -> funcInt .)
    ^               reduce using rule 82 (paren -> funcInt .)
    *               reduce using rule 82 (paren -> funcInt .)
    /               reduce using rule 82 (paren -> funcInt .)
    %               reduce using rule 82 (paren -> funcInt .)
    +               reduce using rule 82 (paren -> funcInt .)
    -               reduce using rule 82 (paren -> funcInt .)
    >               reduce using rule 82 (paren -> funcInt .)
    <               reduce using rule 82 (paren -> funcInt .)

  ! MULEQ           [ reduce using rule 82 (paren -> funcInt .) ]
  ! DIVEQ           [ reduce using rule 82 (paren -> funcInt .) ]
  ! MASEQ           [ reduce using rule 82 (paren -> funcInt .) ]
  ! MENOSEQ         [ reduce using rule 82 (paren -> funcInt .) ]
  ! ;               [ reduce using rule 82 (paren -> funcInt .) ]
  ! ,               [ reduce using rule 82 (paren -> funcInt .) ]
  ! ]               [ reduce using rule 82 (paren -> funcInt .) ]
  ! }               [ reduce using rule 82 (paren -> funcInt .) ]
  ! )               [ reduce using rule 82 (paren -> funcInt .) ]


state 15

    (27) funcVoid -> PRINT . ( valores )

    (               shift and go to state 73


state 16

    (92) and -> eq .
    (93) eq -> eq . EQEQ tBool
    (94) eq -> eq . DISTINTO tBool

    AND             reduce using rule 92 (and -> eq .)
    ?               reduce using rule 92 (and -> eq .)
    OR              reduce using rule 92 (and -> eq .)
    MASEQ           reduce using rule 92 (and -> eq .)
    MENOSEQ         reduce using rule 92 (and -> eq .)
    ;               reduce using rule 92 (and -> eq .)
    )               reduce using rule 92 (and -> eq .)
    MULEQ           reduce using rule 92 (and -> eq .)
    DIVEQ           reduce using rule 92 (and -> eq .)
    }               reduce using rule 92 (and -> eq .)
    :               reduce using rule 92 (and -> eq .)
    ,               reduce using rule 92 (and -> eq .)
    ]               reduce using rule 92 (and -> eq .)
    EQEQ            shift and go to state 74
    DISTINTO        shift and go to state 75


state 17

    (1) g -> sentencia . g
    (1) g -> . sentencia g
    (2) g -> . ctrl g
    (3) g -> . empty
    (4) sentencia -> . varsOps ;
    (5) sentencia -> . func ;
    (6) sentencia -> . varAsig ;
    (7) sentencia -> . RETURN ;
    (8) ctrl -> . if
    (9) ctrl -> . loop
    (30) empty -> .
    (49) varsOps -> . MENOSMENOS sMM
    (50) varsOps -> . MASMAS sMM
    (51) varsOps -> . sMM
    (18) func -> . funcReturn
    (19) func -> . funcVoid
    (55) varAsig -> . valores MULEQ varAsig
    (56) varAsig -> . valores DIVEQ varAsig
    (57) varAsig -> . sIgual
    (13) if -> . IF ( expBool ) THEN bloque else
    (10) loop -> . WHILE ( expBool ) bloque
    (11) loop -> . DO bloque WHILE ( expBool ) ;
    (12) loop -> . FOR ( varAsig ; expBool ; varsOps ) bloque
    (52) sMM -> . ID MASMAS
    (53) sMM -> . ID MENOSMENOS
    (54) sMM -> . ID
    (20) funcReturn -> . funcInt
    (21) funcReturn -> . funcString
    (22) funcReturn -> . funcBool
    (27) funcVoid -> . PRINT ( valores )
    (34) valores -> . eMat
    (35) valores -> . expBool
    (36) valores -> . expString
    (37) valores -> . varYVals
    (38) valores -> . funcReturn
    (39) valores -> . reg
    (40) valores -> . ID . ID
    (58) sIgual -> . valores MASEQ sIgual
    (59) sIgual -> . valores MENOSEQ sIgual
    (60) sIgual -> . asig
    (23) funcInt -> . MULTIESCALAR ( vec , eMat , param )
    (24) funcInt -> . LENGTH ( vec )
    (25) funcString -> . CAPITALIZAR ( expString )
    (26) funcBool -> . COLINEALES ( vec , vec )
    (65) eMat -> . eMat + p
    (66) eMat -> . eMat - p
    (67) eMat -> . p
    (87) expBool -> . or ? expBool : expBool
    (88) expBool -> . or
    (83) expString -> . expString + STRING
    (84) expString -> . STRING
    (85) expString -> . varYVals
    (86) expString -> . funcString
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (46) reg -> . { campos }
    (61) asig -> . ID = asig
    (62) asig -> . ID . ID = asig
    (63) asig -> . vec
    (64) asig -> . valores
    (68) p -> . p * exp
    (69) p -> . p / exp
    (70) p -> . p % exp
    (71) p -> . exp
    (89) or -> . or OR and
    (90) or -> . and
    (43) vecVal -> . ID m
    (31) vec -> . ID = [ elem ]
    (72) exp -> . exp ^ iSing
    (73) exp -> . iSing
    (91) and -> . and AND eq
    (92) and -> . eq
    (74) iSing -> . - paren
    (75) iSing -> . + paren
    (76) iSing -> . paren
    (93) eq -> . eq EQEQ tBool
    (94) eq -> . eq DISTINTO tBool
    (95) eq -> . mayor
    (77) paren -> . ( eMat )
    (78) paren -> . INT
    (79) paren -> . varYVals
    (80) paren -> . FLOAT
    (81) paren -> . varsOps
    (82) paren -> . funcInt
    (96) mayor -> . tCompare > tCompare
    (97) mayor -> . menor
    (106) tCompare -> . eMat
    (107) tCompare -> . varsOps
    (108) tCompare -> . varYVals
    (98) menor -> . tCompare < tCompare
    (99) menor -> . not
    (100) not -> . NOT not
    (101) not -> . tBool
    (102) tBool -> . ( expBool )
    (103) tBool -> . BOOL
    (104) tBool -> . varYVals
    (105) tBool -> . funcBool

    RETURN          shift and go to state 13
    $end            reduce using rule 30 (empty -> .)
    }               reduce using rule 30 (empty -> .)
    MENOSMENOS      shift and go to state 23
    MASMAS          shift and go to state 28
    IF              shift and go to state 53
    WHILE           shift and go to state 35
    DO              shift and go to state 45
    FOR             shift and go to state 18
    ID              shift and go to state 52
    PRINT           shift and go to state 15
    MULTIESCALAR    shift and go to state 55
    LENGTH          shift and go to state 11
    CAPITALIZAR     shift and go to state 57
    COLINEALES      shift and go to state 1
    STRING          shift and go to state 51
    {               shift and go to state 32
    -               shift and go to state 50
    +               shift and go to state 20
    (               shift and go to state 5
    INT             shift and go to state 27
    FLOAT           shift and go to state 56
    NOT             shift and go to state 30
    BOOL            shift and go to state 41

    and                            shift and go to state 44
    funcBool                       shift and go to state 2
    ctrl                           shift and go to state 46
    funcInt                        shift and go to state 14
    menor                          shift and go to state 3
    loop                           shift and go to state 43
    eq                             shift and go to state 16
    vecVal                         shift and go to state 47
    if                             shift and go to state 48
    sentencia                      shift and go to state 17
    eMat                           shift and go to state 49
    asig                           shift and go to state 19
    mayor                          shift and go to state 4
    sMM                            shift and go to state 6
    vec                            shift and go to state 7
    sIgual                         shift and go to state 21
    reg                            shift and go to state 22
    empty                          shift and go to state 42
    iSing                          shift and go to state 12
    funcVoid                       shift and go to state 54
    expString                      shift and go to state 24
    tCompare                       shift and go to state 37
    func                           shift and go to state 38
    paren                          shift and go to state 36
    not                            shift and go to state 8
    varAsig                        shift and go to state 39
    g                              shift and go to state 76
    funcString                     shift and go to state 26
    funcReturn                     shift and go to state 9
    valores                        shift and go to state 40
    p                              shift and go to state 10
    varsOps                        shift and go to state 58
    exp                            shift and go to state 59
    tBool                          shift and go to state 31
    varYVals                       shift and go to state 33
    or                             shift and go to state 34
    expBool                        shift and go to state 29

state 18

    (12) loop -> FOR . ( varAsig ; expBool ; varsOps ) bloque

    (               shift and go to state 77


state 19

    (60) sIgual -> asig .

    ;               reduce using rule 60 (sIgual -> asig .)


state 20

    (75) iSing -> + . paren
    (77) paren -> . ( eMat )
    (78) paren -> . INT
    (79) paren -> . varYVals
    (80) paren -> . FLOAT
    (81) paren -> . varsOps
    (82) paren -> . funcInt
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (49) varsOps -> . MENOSMENOS sMM
    (50) varsOps -> . MASMAS sMM
    (51) varsOps -> . sMM
    (23) funcInt -> . MULTIESCALAR ( vec , eMat , param )
    (24) funcInt -> . LENGTH ( vec )
    (43) vecVal -> . ID m
    (52) sMM -> . ID MASMAS
    (53) sMM -> . ID MENOSMENOS
    (54) sMM -> . ID

    (               shift and go to state 78
    INT             shift and go to state 27
    FLOAT           shift and go to state 56
    ID              shift and go to state 65
    MENOSMENOS      shift and go to state 23
    MASMAS          shift and go to state 28
    MULTIESCALAR    shift and go to state 55
    LENGTH          shift and go to state 11

    funcInt                        shift and go to state 62
    sMM                            shift and go to state 6
    varsOps                        shift and go to state 79
    paren                          shift and go to state 80
    varYVals                       shift and go to state 81
    vecVal                         shift and go to state 47

state 21

    (57) varAsig -> sIgual .

    ;               reduce using rule 57 (varAsig -> sIgual .)


state 22

    (39) valores -> reg .

    MULEQ           reduce using rule 39 (valores -> reg .)
    DIVEQ           reduce using rule 39 (valores -> reg .)
    MASEQ           reduce using rule 39 (valores -> reg .)
    MENOSEQ         reduce using rule 39 (valores -> reg .)
    }               reduce using rule 39 (valores -> reg .)
    ;               reduce using rule 39 (valores -> reg .)
    ,               reduce using rule 39 (valores -> reg .)
    ]               reduce using rule 39 (valores -> reg .)
    )               reduce using rule 39 (valores -> reg .)


state 23

    (49) varsOps -> MENOSMENOS . sMM
    (52) sMM -> . ID MASMAS
    (53) sMM -> . ID MENOSMENOS
    (54) sMM -> . ID

    ID              shift and go to state 83

    sMM                            shift and go to state 82

state 24

    (36) valores -> expString .
    (83) expString -> expString . + STRING

    MULEQ           reduce using rule 36 (valores -> expString .)
    DIVEQ           reduce using rule 36 (valores -> expString .)
    MASEQ           reduce using rule 36 (valores -> expString .)
    MENOSEQ         reduce using rule 36 (valores -> expString .)
    }               reduce using rule 36 (valores -> expString .)
    ;               reduce using rule 36 (valores -> expString .)
    ,               reduce using rule 36 (valores -> expString .)
    ]               reduce using rule 36 (valores -> expString .)
    )               reduce using rule 36 (valores -> expString .)
    +               shift and go to state 84


state 25

    (0) S' -> g .



state 26

    (21) funcReturn -> funcString .
    (86) expString -> funcString .

  ! reduce/reduce conflict for MULEQ resolved using rule 21 (funcReturn -> funcString .)
  ! reduce/reduce conflict for DIVEQ resolved using rule 21 (funcReturn -> funcString .)
  ! reduce/reduce conflict for MASEQ resolved using rule 21 (funcReturn -> funcString .)
  ! reduce/reduce conflict for MENOSEQ resolved using rule 21 (funcReturn -> funcString .)
  ! reduce/reduce conflict for ; resolved using rule 21 (funcReturn -> funcString .)
    ;               reduce using rule 21 (funcReturn -> funcString .)
    MULEQ           reduce using rule 21 (funcReturn -> funcString .)
    DIVEQ           reduce using rule 21 (funcReturn -> funcString .)
    MASEQ           reduce using rule 21 (funcReturn -> funcString .)
    MENOSEQ         reduce using rule 21 (funcReturn -> funcString .)
    +               reduce using rule 86 (expString -> funcString .)

  ! MULEQ           [ reduce using rule 86 (expString -> funcString .) ]
  ! DIVEQ           [ reduce using rule 86 (expString -> funcString .) ]
  ! MASEQ           [ reduce using rule 86 (expString -> funcString .) ]
  ! MENOSEQ         [ reduce using rule 86 (expString -> funcString .) ]
  ! ;               [ reduce using rule 86 (expString -> funcString .) ]


state 27

    (78) paren -> INT .

    ^               reduce using rule 78 (paren -> INT .)
    *               reduce using rule 78 (paren -> INT .)
    /               reduce using rule 78 (paren -> INT .)
    %               reduce using rule 78 (paren -> INT .)
    +               reduce using rule 78 (paren -> INT .)
    -               reduce using rule 78 (paren -> INT .)
    MULEQ           reduce using rule 78 (paren -> INT .)
    DIVEQ           reduce using rule 78 (paren -> INT .)
    MASEQ           reduce using rule 78 (paren -> INT .)
    MENOSEQ         reduce using rule 78 (paren -> INT .)
    ;               reduce using rule 78 (paren -> INT .)
    >               reduce using rule 78 (paren -> INT .)
    <               reduce using rule 78 (paren -> INT .)
    )               reduce using rule 78 (paren -> INT .)
    EQEQ            reduce using rule 78 (paren -> INT .)
    DISTINTO        reduce using rule 78 (paren -> INT .)
    AND             reduce using rule 78 (paren -> INT .)
    ?               reduce using rule 78 (paren -> INT .)
    OR              reduce using rule 78 (paren -> INT .)
    }               reduce using rule 78 (paren -> INT .)
    :               reduce using rule 78 (paren -> INT .)
    ,               reduce using rule 78 (paren -> INT .)
    ]               reduce using rule 78 (paren -> INT .)


state 28

    (50) varsOps -> MASMAS . sMM
    (52) sMM -> . ID MASMAS
    (53) sMM -> . ID MENOSMENOS
    (54) sMM -> . ID

    ID              shift and go to state 83

    sMM                            shift and go to state 85

state 29

    (35) valores -> expBool .

    MULEQ           reduce using rule 35 (valores -> expBool .)
    DIVEQ           reduce using rule 35 (valores -> expBool .)
    MASEQ           reduce using rule 35 (valores -> expBool .)
    MENOSEQ         reduce using rule 35 (valores -> expBool .)
    }               reduce using rule 35 (valores -> expBool .)
    ;               reduce using rule 35 (valores -> expBool .)
    ,               reduce using rule 35 (valores -> expBool .)
    ]               reduce using rule 35 (valores -> expBool .)
    )               reduce using rule 35 (valores -> expBool .)


state 30

    (100) not -> NOT . not
    (100) not -> . NOT not
    (101) not -> . tBool
    (102) tBool -> . ( expBool )
    (103) tBool -> . BOOL
    (104) tBool -> . varYVals
    (105) tBool -> . funcBool
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (26) funcBool -> . COLINEALES ( vec , vec )
    (43) vecVal -> . ID m

    NOT             shift and go to state 30
    (               shift and go to state 86
    BOOL            shift and go to state 41
    ID              shift and go to state 89
    COLINEALES      shift and go to state 1

    funcBool                       shift and go to state 61
    not                            shift and go to state 87
    tBool                          shift and go to state 31
    varYVals                       shift and go to state 88
    vecVal                         shift and go to state 47

state 31

    (101) not -> tBool .

    EQEQ            reduce using rule 101 (not -> tBool .)
    DISTINTO        reduce using rule 101 (not -> tBool .)
    AND             reduce using rule 101 (not -> tBool .)
    ?               reduce using rule 101 (not -> tBool .)
    OR              reduce using rule 101 (not -> tBool .)
    MULEQ           reduce using rule 101 (not -> tBool .)
    DIVEQ           reduce using rule 101 (not -> tBool .)
    MASEQ           reduce using rule 101 (not -> tBool .)
    MENOSEQ         reduce using rule 101 (not -> tBool .)
    ;               reduce using rule 101 (not -> tBool .)
    )               reduce using rule 101 (not -> tBool .)
    :               reduce using rule 101 (not -> tBool .)
    }               reduce using rule 101 (not -> tBool .)
    ,               reduce using rule 101 (not -> tBool .)
    ]               reduce using rule 101 (not -> tBool .)


state 32

    (46) reg -> { . campos }
    (47) campos -> . ID : valores , campos
    (48) campos -> . valores
    (34) valores -> . eMat
    (35) valores -> . expBool
    (36) valores -> . expString
    (37) valores -> . varYVals
    (38) valores -> . funcReturn
    (39) valores -> . reg
    (40) valores -> . ID . ID
    (65) eMat -> . eMat + p
    (66) eMat -> . eMat - p
    (67) eMat -> . p
    (87) expBool -> . or ? expBool : expBool
    (88) expBool -> . or
    (83) expString -> . expString + STRING
    (84) expString -> . STRING
    (85) expString -> . varYVals
    (86) expString -> . funcString
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (20) funcReturn -> . funcInt
    (21) funcReturn -> . funcString
    (22) funcReturn -> . funcBool
    (46) reg -> . { campos }
    (68) p -> . p * exp
    (69) p -> . p / exp
    (70) p -> . p % exp
    (71) p -> . exp
    (89) or -> . or OR and
    (90) or -> . and
    (25) funcString -> . CAPITALIZAR ( expString )
    (43) vecVal -> . ID m
    (23) funcInt -> . MULTIESCALAR ( vec , eMat , param )
    (24) funcInt -> . LENGTH ( vec )
    (26) funcBool -> . COLINEALES ( vec , vec )
    (72) exp -> . exp ^ iSing
    (73) exp -> . iSing
    (91) and -> . and AND eq
    (92) and -> . eq
    (74) iSing -> . - paren
    (75) iSing -> . + paren
    (76) iSing -> . paren
    (93) eq -> . eq EQEQ tBool
    (94) eq -> . eq DISTINTO tBool
    (95) eq -> . mayor
    (77) paren -> . ( eMat )
    (78) paren -> . INT
    (79) paren -> . varYVals
    (80) paren -> . FLOAT
    (81) paren -> . varsOps
    (82) paren -> . funcInt
    (96) mayor -> . tCompare > tCompare
    (97) mayor -> . menor
    (49) varsOps -> . MENOSMENOS sMM
    (50) varsOps -> . MASMAS sMM
    (51) varsOps -> . sMM
    (106) tCompare -> . eMat
    (107) tCompare -> . varsOps
    (108) tCompare -> . varYVals
    (98) menor -> . tCompare < tCompare
    (99) menor -> . not
    (52) sMM -> . ID MASMAS
    (53) sMM -> . ID MENOSMENOS
    (54) sMM -> . ID
    (100) not -> . NOT not
    (101) not -> . tBool
    (102) tBool -> . ( expBool )
    (103) tBool -> . BOOL
    (104) tBool -> . varYVals
    (105) tBool -> . funcBool

    ID              shift and go to state 91
    STRING          shift and go to state 51
    {               shift and go to state 32
    CAPITALIZAR     shift and go to state 57
    MULTIESCALAR    shift and go to state 55
    LENGTH          shift and go to state 11
    COLINEALES      shift and go to state 1
    -               shift and go to state 50
    +               shift and go to state 20
    (               shift and go to state 5
    INT             shift and go to state 27
    FLOAT           shift and go to state 56
    MENOSMENOS      shift and go to state 23
    MASMAS          shift and go to state 28
    NOT             shift and go to state 30
    BOOL            shift and go to state 41

    and                            shift and go to state 44
    funcBool                       shift and go to state 2
    funcInt                        shift and go to state 14
    menor                          shift and go to state 3
    eq                             shift and go to state 16
    vecVal                         shift and go to state 47
    eMat                           shift and go to state 49
    mayor                          shift and go to state 4
    sMM                            shift and go to state 6
    paren                          shift and go to state 36
    reg                            shift and go to state 22
    varsOps                        shift and go to state 64
    expString                      shift and go to state 24
    tCompare                       shift and go to state 37
    campos                         shift and go to state 90
    not                            shift and go to state 8
    funcString                     shift and go to state 92
    funcReturn                     shift and go to state 93
    valores                        shift and go to state 94
    p                              shift and go to state 10
    iSing                          shift and go to state 12
    exp                            shift and go to state 59
    tBool                          shift and go to state 31
    varYVals                       shift and go to state 33
    or                             shift and go to state 34
    expBool                        shift and go to state 29

state 33

    (37) valores -> varYVals .
    (85) expString -> varYVals .
    (79) paren -> varYVals .
    (108) tCompare -> varYVals .
    (104) tBool -> varYVals .

  ! reduce/reduce conflict for MULEQ resolved using rule 37 (valores -> varYVals .)
  ! reduce/reduce conflict for DIVEQ resolved using rule 37 (valores -> varYVals .)
  ! reduce/reduce conflict for MASEQ resolved using rule 37 (valores -> varYVals .)
  ! reduce/reduce conflict for MENOSEQ resolved using rule 37 (valores -> varYVals .)
  ! reduce/reduce conflict for ; resolved using rule 37 (valores -> varYVals .)
  ! reduce/reduce conflict for ) resolved using rule 37 (valores -> varYVals .)
  ! reduce/reduce conflict for , resolved using rule 37 (valores -> varYVals .)
  ! reduce/reduce conflict for } resolved using rule 37 (valores -> varYVals .)
  ! reduce/reduce conflict for ] resolved using rule 37 (valores -> varYVals .)
  ! reduce/reduce conflict for + resolved using rule 79 (paren -> varYVals .)
  ! reduce/reduce conflict for MULEQ resolved using rule 37 (valores -> varYVals .)
  ! reduce/reduce conflict for DIVEQ resolved using rule 37 (valores -> varYVals .)
  ! reduce/reduce conflict for MASEQ resolved using rule 37 (valores -> varYVals .)
  ! reduce/reduce conflict for MENOSEQ resolved using rule 37 (valores -> varYVals .)
  ! reduce/reduce conflict for ; resolved using rule 37 (valores -> varYVals .)
  ! reduce/reduce conflict for , resolved using rule 37 (valores -> varYVals .)
  ! reduce/reduce conflict for ] resolved using rule 37 (valores -> varYVals .)
  ! reduce/reduce conflict for } resolved using rule 37 (valores -> varYVals .)
  ! reduce/reduce conflict for ) resolved using rule 37 (valores -> varYVals .)
  ! reduce/reduce conflict for > resolved using rule 79 (paren -> varYVals .)
  ! reduce/reduce conflict for < resolved using rule 79 (paren -> varYVals .)
  ! reduce/reduce conflict for MULEQ resolved using rule 37 (valores -> varYVals .)
  ! reduce/reduce conflict for DIVEQ resolved using rule 37 (valores -> varYVals .)
  ! reduce/reduce conflict for MASEQ resolved using rule 37 (valores -> varYVals .)
  ! reduce/reduce conflict for MENOSEQ resolved using rule 37 (valores -> varYVals .)
  ! reduce/reduce conflict for ; resolved using rule 37 (valores -> varYVals .)
  ! reduce/reduce conflict for ) resolved using rule 37 (valores -> varYVals .)
  ! reduce/reduce conflict for } resolved using rule 37 (valores -> varYVals .)
  ! reduce/reduce conflict for , resolved using rule 37 (valores -> varYVals .)
  ! reduce/reduce conflict for ] resolved using rule 37 (valores -> varYVals .)
    MULEQ           reduce using rule 37 (valores -> varYVals .)
    DIVEQ           reduce using rule 37 (valores -> varYVals .)
    MASEQ           reduce using rule 37 (valores -> varYVals .)
    MENOSEQ         reduce using rule 37 (valores -> varYVals .)
    }               reduce using rule 37 (valores -> varYVals .)
    ;               reduce using rule 37 (valores -> varYVals .)
    ,               reduce using rule 37 (valores -> varYVals .)
    ]               reduce using rule 37 (valores -> varYVals .)
    )               reduce using rule 37 (valores -> varYVals .)
    ^               reduce using rule 79 (paren -> varYVals .)
    *               reduce using rule 79 (paren -> varYVals .)
    /               reduce using rule 79 (paren -> varYVals .)
    %               reduce using rule 79 (paren -> varYVals .)
    +               reduce using rule 79 (paren -> varYVals .)
    -               reduce using rule 79 (paren -> varYVals .)
    >               reduce using rule 79 (paren -> varYVals .)
    <               reduce using rule 79 (paren -> varYVals .)
    EQEQ            reduce using rule 104 (tBool -> varYVals .)
    DISTINTO        reduce using rule 104 (tBool -> varYVals .)
    AND             reduce using rule 104 (tBool -> varYVals .)
    ?               reduce using rule 104 (tBool -> varYVals .)
    OR              reduce using rule 104 (tBool -> varYVals .)

  ! +               [ reduce using rule 85 (expString -> varYVals .) ]
  ! MULEQ           [ reduce using rule 85 (expString -> varYVals .) ]
  ! DIVEQ           [ reduce using rule 85 (expString -> varYVals .) ]
  ! MASEQ           [ reduce using rule 85 (expString -> varYVals .) ]
  ! MENOSEQ         [ reduce using rule 85 (expString -> varYVals .) ]
  ! ;               [ reduce using rule 85 (expString -> varYVals .) ]
  ! )               [ reduce using rule 85 (expString -> varYVals .) ]
  ! ,               [ reduce using rule 85 (expString -> varYVals .) ]
  ! }               [ reduce using rule 85 (expString -> varYVals .) ]
  ! ]               [ reduce using rule 85 (expString -> varYVals .) ]
  ! MULEQ           [ reduce using rule 79 (paren -> varYVals .) ]
  ! DIVEQ           [ reduce using rule 79 (paren -> varYVals .) ]
  ! MASEQ           [ reduce using rule 79 (paren -> varYVals .) ]
  ! MENOSEQ         [ reduce using rule 79 (paren -> varYVals .) ]
  ! ;               [ reduce using rule 79 (paren -> varYVals .) ]
  ! ,               [ reduce using rule 79 (paren -> varYVals .) ]
  ! ]               [ reduce using rule 79 (paren -> varYVals .) ]
  ! }               [ reduce using rule 79 (paren -> varYVals .) ]
  ! )               [ reduce using rule 79 (paren -> varYVals .) ]
  ! >               [ reduce using rule 108 (tCompare -> varYVals .) ]
  ! <               [ reduce using rule 108 (tCompare -> varYVals .) ]
  ! MULEQ           [ reduce using rule 104 (tBool -> varYVals .) ]
  ! DIVEQ           [ reduce using rule 104 (tBool -> varYVals .) ]
  ! MASEQ           [ reduce using rule 104 (tBool -> varYVals .) ]
  ! MENOSEQ         [ reduce using rule 104 (tBool -> varYVals .) ]
  ! ;               [ reduce using rule 104 (tBool -> varYVals .) ]
  ! )               [ reduce using rule 104 (tBool -> varYVals .) ]
  ! }               [ reduce using rule 104 (tBool -> varYVals .) ]
  ! ,               [ reduce using rule 104 (tBool -> varYVals .) ]
  ! ]               [ reduce using rule 104 (tBool -> varYVals .) ]


state 34

    (87) expBool -> or . ? expBool : expBool
    (88) expBool -> or .
    (89) or -> or . OR and

    ?               shift and go to state 96
    )               reduce using rule 88 (expBool -> or .)
    MULEQ           reduce using rule 88 (expBool -> or .)
    DIVEQ           reduce using rule 88 (expBool -> or .)
    MASEQ           reduce using rule 88 (expBool -> or .)
    MENOSEQ         reduce using rule 88 (expBool -> or .)
    ;               reduce using rule 88 (expBool -> or .)
    :               reduce using rule 88 (expBool -> or .)
    }               reduce using rule 88 (expBool -> or .)
    ,               reduce using rule 88 (expBool -> or .)
    ]               reduce using rule 88 (expBool -> or .)
    OR              shift and go to state 95


state 35

    (10) loop -> WHILE . ( expBool ) bloque

    (               shift and go to state 97


state 36

    (76) iSing -> paren .

    ^               reduce using rule 76 (iSing -> paren .)
    *               reduce using rule 76 (iSing -> paren .)
    /               reduce using rule 76 (iSing -> paren .)
    %               reduce using rule 76 (iSing -> paren .)
    +               reduce using rule 76 (iSing -> paren .)
    -               reduce using rule 76 (iSing -> paren .)
    >               reduce using rule 76 (iSing -> paren .)
    <               reduce using rule 76 (iSing -> paren .)
    ;               reduce using rule 76 (iSing -> paren .)
    ,               reduce using rule 76 (iSing -> paren .)
    ]               reduce using rule 76 (iSing -> paren .)
    MULEQ           reduce using rule 76 (iSing -> paren .)
    DIVEQ           reduce using rule 76 (iSing -> paren .)
    MASEQ           reduce using rule 76 (iSing -> paren .)
    MENOSEQ         reduce using rule 76 (iSing -> paren .)
    EQEQ            reduce using rule 76 (iSing -> paren .)
    DISTINTO        reduce using rule 76 (iSing -> paren .)
    AND             reduce using rule 76 (iSing -> paren .)
    ?               reduce using rule 76 (iSing -> paren .)
    OR              reduce using rule 76 (iSing -> paren .)
    )               reduce using rule 76 (iSing -> paren .)
    }               reduce using rule 76 (iSing -> paren .)
    :               reduce using rule 76 (iSing -> paren .)


state 37

    (96) mayor -> tCompare . > tCompare
    (98) menor -> tCompare . < tCompare

    >               shift and go to state 99
    <               shift and go to state 98


state 38

    (5) sentencia -> func . ;

    ;               shift and go to state 100


state 39

    (6) sentencia -> varAsig . ;

    ;               shift and go to state 101


state 40

    (55) varAsig -> valores . MULEQ varAsig
    (56) varAsig -> valores . DIVEQ varAsig
    (58) sIgual -> valores . MASEQ sIgual
    (59) sIgual -> valores . MENOSEQ sIgual
    (64) asig -> valores .

    MULEQ           shift and go to state 104
    DIVEQ           shift and go to state 105
    MASEQ           shift and go to state 103
    MENOSEQ         shift and go to state 102
    ;               reduce using rule 64 (asig -> valores .)


state 41

    (103) tBool -> BOOL .

    EQEQ            reduce using rule 103 (tBool -> BOOL .)
    DISTINTO        reduce using rule 103 (tBool -> BOOL .)
    AND             reduce using rule 103 (tBool -> BOOL .)
    ?               reduce using rule 103 (tBool -> BOOL .)
    OR              reduce using rule 103 (tBool -> BOOL .)
    )               reduce using rule 103 (tBool -> BOOL .)
    MULEQ           reduce using rule 103 (tBool -> BOOL .)
    DIVEQ           reduce using rule 103 (tBool -> BOOL .)
    MASEQ           reduce using rule 103 (tBool -> BOOL .)
    MENOSEQ         reduce using rule 103 (tBool -> BOOL .)
    ;               reduce using rule 103 (tBool -> BOOL .)
    }               reduce using rule 103 (tBool -> BOOL .)
    :               reduce using rule 103 (tBool -> BOOL .)
    ,               reduce using rule 103 (tBool -> BOOL .)
    ]               reduce using rule 103 (tBool -> BOOL .)


state 42

    (3) g -> empty .

    $end            reduce using rule 3 (g -> empty .)
    }               reduce using rule 3 (g -> empty .)


state 43

    (9) ctrl -> loop .

    RETURN          reduce using rule 9 (ctrl -> loop .)
    MENOSMENOS      reduce using rule 9 (ctrl -> loop .)
    MASMAS          reduce using rule 9 (ctrl -> loop .)
    IF              reduce using rule 9 (ctrl -> loop .)
    WHILE           reduce using rule 9 (ctrl -> loop .)
    DO              reduce using rule 9 (ctrl -> loop .)
    FOR             reduce using rule 9 (ctrl -> loop .)
    ID              reduce using rule 9 (ctrl -> loop .)
    PRINT           reduce using rule 9 (ctrl -> loop .)
    MULTIESCALAR    reduce using rule 9 (ctrl -> loop .)
    LENGTH          reduce using rule 9 (ctrl -> loop .)
    CAPITALIZAR     reduce using rule 9 (ctrl -> loop .)
    COLINEALES      reduce using rule 9 (ctrl -> loop .)
    STRING          reduce using rule 9 (ctrl -> loop .)
    {               reduce using rule 9 (ctrl -> loop .)
    -               reduce using rule 9 (ctrl -> loop .)
    +               reduce using rule 9 (ctrl -> loop .)
    (               reduce using rule 9 (ctrl -> loop .)
    INT             reduce using rule 9 (ctrl -> loop .)
    FLOAT           reduce using rule 9 (ctrl -> loop .)
    NOT             reduce using rule 9 (ctrl -> loop .)
    BOOL            reduce using rule 9 (ctrl -> loop .)
    $end            reduce using rule 9 (ctrl -> loop .)
    }               reduce using rule 9 (ctrl -> loop .)


state 44

    (90) or -> and .
    (91) and -> and . AND eq

    ?               reduce using rule 90 (or -> and .)
    OR              reduce using rule 90 (or -> and .)
    )               reduce using rule 90 (or -> and .)
    MULEQ           reduce using rule 90 (or -> and .)
    DIVEQ           reduce using rule 90 (or -> and .)
    MASEQ           reduce using rule 90 (or -> and .)
    MENOSEQ         reduce using rule 90 (or -> and .)
    ;               reduce using rule 90 (or -> and .)
    ,               reduce using rule 90 (or -> and .)
    ]               reduce using rule 90 (or -> and .)
    }               reduce using rule 90 (or -> and .)
    :               reduce using rule 90 (or -> and .)
    AND             shift and go to state 106


state 45

    (11) loop -> DO . bloque WHILE ( expBool ) ;
    (16) bloque -> . sentencia
    (17) bloque -> . { g }
    (4) sentencia -> . varsOps ;
    (5) sentencia -> . func ;
    (6) sentencia -> . varAsig ;
    (7) sentencia -> . RETURN ;
    (49) varsOps -> . MENOSMENOS sMM
    (50) varsOps -> . MASMAS sMM
    (51) varsOps -> . sMM
    (18) func -> . funcReturn
    (19) func -> . funcVoid
    (55) varAsig -> . valores MULEQ varAsig
    (56) varAsig -> . valores DIVEQ varAsig
    (57) varAsig -> . sIgual
    (52) sMM -> . ID MASMAS
    (53) sMM -> . ID MENOSMENOS
    (54) sMM -> . ID
    (20) funcReturn -> . funcInt
    (21) funcReturn -> . funcString
    (22) funcReturn -> . funcBool
    (27) funcVoid -> . PRINT ( valores )
    (34) valores -> . eMat
    (35) valores -> . expBool
    (36) valores -> . expString
    (37) valores -> . varYVals
    (38) valores -> . funcReturn
    (39) valores -> . reg
    (40) valores -> . ID . ID
    (58) sIgual -> . valores MASEQ sIgual
    (59) sIgual -> . valores MENOSEQ sIgual
    (60) sIgual -> . asig
    (23) funcInt -> . MULTIESCALAR ( vec , eMat , param )
    (24) funcInt -> . LENGTH ( vec )
    (25) funcString -> . CAPITALIZAR ( expString )
    (26) funcBool -> . COLINEALES ( vec , vec )
    (65) eMat -> . eMat + p
    (66) eMat -> . eMat - p
    (67) eMat -> . p
    (87) expBool -> . or ? expBool : expBool
    (88) expBool -> . or
    (83) expString -> . expString + STRING
    (84) expString -> . STRING
    (85) expString -> . varYVals
    (86) expString -> . funcString
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (46) reg -> . { campos }
    (61) asig -> . ID = asig
    (62) asig -> . ID . ID = asig
    (63) asig -> . vec
    (64) asig -> . valores
    (68) p -> . p * exp
    (69) p -> . p / exp
    (70) p -> . p % exp
    (71) p -> . exp
    (89) or -> . or OR and
    (90) or -> . and
    (43) vecVal -> . ID m
    (31) vec -> . ID = [ elem ]
    (72) exp -> . exp ^ iSing
    (73) exp -> . iSing
    (91) and -> . and AND eq
    (92) and -> . eq
    (74) iSing -> . - paren
    (75) iSing -> . + paren
    (76) iSing -> . paren
    (93) eq -> . eq EQEQ tBool
    (94) eq -> . eq DISTINTO tBool
    (95) eq -> . mayor
    (77) paren -> . ( eMat )
    (78) paren -> . INT
    (79) paren -> . varYVals
    (80) paren -> . FLOAT
    (81) paren -> . varsOps
    (82) paren -> . funcInt
    (96) mayor -> . tCompare > tCompare
    (97) mayor -> . menor
    (106) tCompare -> . eMat
    (107) tCompare -> . varsOps
    (108) tCompare -> . varYVals
    (98) menor -> . tCompare < tCompare
    (99) menor -> . not
    (100) not -> . NOT not
    (101) not -> . tBool
    (102) tBool -> . ( expBool )
    (103) tBool -> . BOOL
    (104) tBool -> . varYVals
    (105) tBool -> . funcBool

    {               shift and go to state 109
    RETURN          shift and go to state 13
    MENOSMENOS      shift and go to state 23
    MASMAS          shift and go to state 28
    ID              shift and go to state 52
    PRINT           shift and go to state 15
    MULTIESCALAR    shift and go to state 55
    LENGTH          shift and go to state 11
    CAPITALIZAR     shift and go to state 57
    COLINEALES      shift and go to state 1
    STRING          shift and go to state 51
    -               shift and go to state 50
    +               shift and go to state 20
    (               shift and go to state 5
    INT             shift and go to state 27
    FLOAT           shift and go to state 56
    NOT             shift and go to state 30
    BOOL            shift and go to state 41

    and                            shift and go to state 44
    funcBool                       shift and go to state 2
    funcInt                        shift and go to state 14
    menor                          shift and go to state 3
    bloque                         shift and go to state 107
    eq                             shift and go to state 16
    vecVal                         shift and go to state 47
    sentencia                      shift and go to state 108
    eMat                           shift and go to state 49
    asig                           shift and go to state 19
    mayor                          shift and go to state 4
    sMM                            shift and go to state 6
    vec                            shift and go to state 7
    sIgual                         shift and go to state 21
    reg                            shift and go to state 22
    iSing                          shift and go to state 12
    funcVoid                       shift and go to state 54
    expString                      shift and go to state 24
    tCompare                       shift and go to state 37
    func                           shift and go to state 38
    paren                          shift and go to state 36
    not                            shift and go to state 8
    varAsig                        shift and go to state 39
    funcString                     shift and go to state 26
    funcReturn                     shift and go to state 9
    valores                        shift and go to state 40
    p                              shift and go to state 10
    varsOps                        shift and go to state 58
    exp                            shift and go to state 59
    tBool                          shift and go to state 31
    varYVals                       shift and go to state 33
    or                             shift and go to state 34
    expBool                        shift and go to state 29

state 46

    (2) g -> ctrl . g
    (1) g -> . sentencia g
    (2) g -> . ctrl g
    (3) g -> . empty
    (4) sentencia -> . varsOps ;
    (5) sentencia -> . func ;
    (6) sentencia -> . varAsig ;
    (7) sentencia -> . RETURN ;
    (8) ctrl -> . if
    (9) ctrl -> . loop
    (30) empty -> .
    (49) varsOps -> . MENOSMENOS sMM
    (50) varsOps -> . MASMAS sMM
    (51) varsOps -> . sMM
    (18) func -> . funcReturn
    (19) func -> . funcVoid
    (55) varAsig -> . valores MULEQ varAsig
    (56) varAsig -> . valores DIVEQ varAsig
    (57) varAsig -> . sIgual
    (13) if -> . IF ( expBool ) THEN bloque else
    (10) loop -> . WHILE ( expBool ) bloque
    (11) loop -> . DO bloque WHILE ( expBool ) ;
    (12) loop -> . FOR ( varAsig ; expBool ; varsOps ) bloque
    (52) sMM -> . ID MASMAS
    (53) sMM -> . ID MENOSMENOS
    (54) sMM -> . ID
    (20) funcReturn -> . funcInt
    (21) funcReturn -> . funcString
    (22) funcReturn -> . funcBool
    (27) funcVoid -> . PRINT ( valores )
    (34) valores -> . eMat
    (35) valores -> . expBool
    (36) valores -> . expString
    (37) valores -> . varYVals
    (38) valores -> . funcReturn
    (39) valores -> . reg
    (40) valores -> . ID . ID
    (58) sIgual -> . valores MASEQ sIgual
    (59) sIgual -> . valores MENOSEQ sIgual
    (60) sIgual -> . asig
    (23) funcInt -> . MULTIESCALAR ( vec , eMat , param )
    (24) funcInt -> . LENGTH ( vec )
    (25) funcString -> . CAPITALIZAR ( expString )
    (26) funcBool -> . COLINEALES ( vec , vec )
    (65) eMat -> . eMat + p
    (66) eMat -> . eMat - p
    (67) eMat -> . p
    (87) expBool -> . or ? expBool : expBool
    (88) expBool -> . or
    (83) expString -> . expString + STRING
    (84) expString -> . STRING
    (85) expString -> . varYVals
    (86) expString -> . funcString
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (46) reg -> . { campos }
    (61) asig -> . ID = asig
    (62) asig -> . ID . ID = asig
    (63) asig -> . vec
    (64) asig -> . valores
    (68) p -> . p * exp
    (69) p -> . p / exp
    (70) p -> . p % exp
    (71) p -> . exp
    (89) or -> . or OR and
    (90) or -> . and
    (43) vecVal -> . ID m
    (31) vec -> . ID = [ elem ]
    (72) exp -> . exp ^ iSing
    (73) exp -> . iSing
    (91) and -> . and AND eq
    (92) and -> . eq
    (74) iSing -> . - paren
    (75) iSing -> . + paren
    (76) iSing -> . paren
    (93) eq -> . eq EQEQ tBool
    (94) eq -> . eq DISTINTO tBool
    (95) eq -> . mayor
    (77) paren -> . ( eMat )
    (78) paren -> . INT
    (79) paren -> . varYVals
    (80) paren -> . FLOAT
    (81) paren -> . varsOps
    (82) paren -> . funcInt
    (96) mayor -> . tCompare > tCompare
    (97) mayor -> . menor
    (106) tCompare -> . eMat
    (107) tCompare -> . varsOps
    (108) tCompare -> . varYVals
    (98) menor -> . tCompare < tCompare
    (99) menor -> . not
    (100) not -> . NOT not
    (101) not -> . tBool
    (102) tBool -> . ( expBool )
    (103) tBool -> . BOOL
    (104) tBool -> . varYVals
    (105) tBool -> . funcBool

    RETURN          shift and go to state 13
    $end            reduce using rule 30 (empty -> .)
    }               reduce using rule 30 (empty -> .)
    MENOSMENOS      shift and go to state 23
    MASMAS          shift and go to state 28
    IF              shift and go to state 53
    WHILE           shift and go to state 35
    DO              shift and go to state 45
    FOR             shift and go to state 18
    ID              shift and go to state 52
    PRINT           shift and go to state 15
    MULTIESCALAR    shift and go to state 55
    LENGTH          shift and go to state 11
    CAPITALIZAR     shift and go to state 57
    COLINEALES      shift and go to state 1
    STRING          shift and go to state 51
    {               shift and go to state 32
    -               shift and go to state 50
    +               shift and go to state 20
    (               shift and go to state 5
    INT             shift and go to state 27
    FLOAT           shift and go to state 56
    NOT             shift and go to state 30
    BOOL            shift and go to state 41

    and                            shift and go to state 44
    funcBool                       shift and go to state 2
    ctrl                           shift and go to state 46
    funcInt                        shift and go to state 14
    menor                          shift and go to state 3
    loop                           shift and go to state 43
    eq                             shift and go to state 16
    vecVal                         shift and go to state 47
    if                             shift and go to state 48
    sentencia                      shift and go to state 17
    eMat                           shift and go to state 49
    asig                           shift and go to state 19
    mayor                          shift and go to state 4
    sMM                            shift and go to state 6
    vec                            shift and go to state 7
    sIgual                         shift and go to state 21
    reg                            shift and go to state 22
    empty                          shift and go to state 42
    iSing                          shift and go to state 12
    funcVoid                       shift and go to state 54
    expString                      shift and go to state 24
    tCompare                       shift and go to state 37
    func                           shift and go to state 38
    paren                          shift and go to state 36
    not                            shift and go to state 8
    varAsig                        shift and go to state 39
    g                              shift and go to state 110
    funcString                     shift and go to state 26
    funcReturn                     shift and go to state 9
    valores                        shift and go to state 40
    p                              shift and go to state 10
    varsOps                        shift and go to state 58
    exp                            shift and go to state 59
    tBool                          shift and go to state 31
    varYVals                       shift and go to state 33
    or                             shift and go to state 34
    expBool                        shift and go to state 29

state 47

    (42) varYVals -> vecVal .

    >               reduce using rule 42 (varYVals -> vecVal .)
    <               reduce using rule 42 (varYVals -> vecVal .)
    EQEQ            reduce using rule 42 (varYVals -> vecVal .)
    DISTINTO        reduce using rule 42 (varYVals -> vecVal .)
    AND             reduce using rule 42 (varYVals -> vecVal .)
    ?               reduce using rule 42 (varYVals -> vecVal .)
    OR              reduce using rule 42 (varYVals -> vecVal .)
    MULEQ           reduce using rule 42 (varYVals -> vecVal .)
    DIVEQ           reduce using rule 42 (varYVals -> vecVal .)
    MASEQ           reduce using rule 42 (varYVals -> vecVal .)
    MENOSEQ         reduce using rule 42 (varYVals -> vecVal .)
    ;               reduce using rule 42 (varYVals -> vecVal .)
    )               reduce using rule 42 (varYVals -> vecVal .)
    }               reduce using rule 42 (varYVals -> vecVal .)
    :               reduce using rule 42 (varYVals -> vecVal .)
    ,               reduce using rule 42 (varYVals -> vecVal .)
    ]               reduce using rule 42 (varYVals -> vecVal .)
    ^               reduce using rule 42 (varYVals -> vecVal .)
    *               reduce using rule 42 (varYVals -> vecVal .)
    /               reduce using rule 42 (varYVals -> vecVal .)
    %               reduce using rule 42 (varYVals -> vecVal .)
    +               reduce using rule 42 (varYVals -> vecVal .)
    -               reduce using rule 42 (varYVals -> vecVal .)


state 48

    (8) ctrl -> if .

    RETURN          reduce using rule 8 (ctrl -> if .)
    MENOSMENOS      reduce using rule 8 (ctrl -> if .)
    MASMAS          reduce using rule 8 (ctrl -> if .)
    IF              reduce using rule 8 (ctrl -> if .)
    WHILE           reduce using rule 8 (ctrl -> if .)
    DO              reduce using rule 8 (ctrl -> if .)
    FOR             reduce using rule 8 (ctrl -> if .)
    ID              reduce using rule 8 (ctrl -> if .)
    PRINT           reduce using rule 8 (ctrl -> if .)
    MULTIESCALAR    reduce using rule 8 (ctrl -> if .)
    LENGTH          reduce using rule 8 (ctrl -> if .)
    CAPITALIZAR     reduce using rule 8 (ctrl -> if .)
    COLINEALES      reduce using rule 8 (ctrl -> if .)
    STRING          reduce using rule 8 (ctrl -> if .)
    {               reduce using rule 8 (ctrl -> if .)
    -               reduce using rule 8 (ctrl -> if .)
    +               reduce using rule 8 (ctrl -> if .)
    (               reduce using rule 8 (ctrl -> if .)
    INT             reduce using rule 8 (ctrl -> if .)
    FLOAT           reduce using rule 8 (ctrl -> if .)
    NOT             reduce using rule 8 (ctrl -> if .)
    BOOL            reduce using rule 8 (ctrl -> if .)
    $end            reduce using rule 8 (ctrl -> if .)
    }               reduce using rule 8 (ctrl -> if .)


state 49

    (34) valores -> eMat .
    (65) eMat -> eMat . + p
    (66) eMat -> eMat . - p
    (106) tCompare -> eMat .

    MULEQ           reduce using rule 34 (valores -> eMat .)
    DIVEQ           reduce using rule 34 (valores -> eMat .)
    MASEQ           reduce using rule 34 (valores -> eMat .)
    MENOSEQ         reduce using rule 34 (valores -> eMat .)
    }               reduce using rule 34 (valores -> eMat .)
    ;               reduce using rule 34 (valores -> eMat .)
    ,               reduce using rule 34 (valores -> eMat .)
    ]               reduce using rule 34 (valores -> eMat .)
    )               reduce using rule 34 (valores -> eMat .)
    +               shift and go to state 111
    -               shift and go to state 112
    >               reduce using rule 106 (tCompare -> eMat .)
    <               reduce using rule 106 (tCompare -> eMat .)


state 50

    (74) iSing -> - . paren
    (77) paren -> . ( eMat )
    (78) paren -> . INT
    (79) paren -> . varYVals
    (80) paren -> . FLOAT
    (81) paren -> . varsOps
    (82) paren -> . funcInt
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (49) varsOps -> . MENOSMENOS sMM
    (50) varsOps -> . MASMAS sMM
    (51) varsOps -> . sMM
    (23) funcInt -> . MULTIESCALAR ( vec , eMat , param )
    (24) funcInt -> . LENGTH ( vec )
    (43) vecVal -> . ID m
    (52) sMM -> . ID MASMAS
    (53) sMM -> . ID MENOSMENOS
    (54) sMM -> . ID

    (               shift and go to state 78
    INT             shift and go to state 27
    FLOAT           shift and go to state 56
    ID              shift and go to state 65
    MENOSMENOS      shift and go to state 23
    MASMAS          shift and go to state 28
    MULTIESCALAR    shift and go to state 55
    LENGTH          shift and go to state 11

    funcInt                        shift and go to state 62
    sMM                            shift and go to state 6
    varsOps                        shift and go to state 79
    paren                          shift and go to state 113
    varYVals                       shift and go to state 81
    vecVal                         shift and go to state 47

state 51

    (84) expString -> STRING .

    +               reduce using rule 84 (expString -> STRING .)
    MULEQ           reduce using rule 84 (expString -> STRING .)
    DIVEQ           reduce using rule 84 (expString -> STRING .)
    MASEQ           reduce using rule 84 (expString -> STRING .)
    MENOSEQ         reduce using rule 84 (expString -> STRING .)
    ;               reduce using rule 84 (expString -> STRING .)
    )               reduce using rule 84 (expString -> STRING .)
    ,               reduce using rule 84 (expString -> STRING .)
    }               reduce using rule 84 (expString -> STRING .)
    ]               reduce using rule 84 (expString -> STRING .)


state 52

    (52) sMM -> ID . MASMAS
    (53) sMM -> ID . MENOSMENOS
    (54) sMM -> ID .
    (40) valores -> ID . . ID
    (41) varYVals -> ID .
    (61) asig -> ID . = asig
    (62) asig -> ID . . ID = asig
    (43) vecVal -> ID . m
    (31) vec -> ID . = [ elem ]
    (44) m -> . [ INT ]
    (45) m -> . [ INT ] m

  ! reduce/reduce conflict for MULEQ resolved using rule 41 (varYVals -> ID .)
  ! reduce/reduce conflict for DIVEQ resolved using rule 41 (varYVals -> ID .)
  ! reduce/reduce conflict for MASEQ resolved using rule 41 (varYVals -> ID .)
  ! reduce/reduce conflict for MENOSEQ resolved using rule 41 (varYVals -> ID .)
  ! reduce/reduce conflict for ; resolved using rule 41 (varYVals -> ID .)
  ! reduce/reduce conflict for + resolved using rule 41 (varYVals -> ID .)
  ! reduce/reduce conflict for ^ resolved using rule 41 (varYVals -> ID .)
  ! reduce/reduce conflict for * resolved using rule 41 (varYVals -> ID .)
  ! reduce/reduce conflict for / resolved using rule 41 (varYVals -> ID .)
  ! reduce/reduce conflict for % resolved using rule 41 (varYVals -> ID .)
  ! reduce/reduce conflict for - resolved using rule 41 (varYVals -> ID .)
  ! reduce/reduce conflict for > resolved using rule 41 (varYVals -> ID .)
  ! reduce/reduce conflict for < resolved using rule 41 (varYVals -> ID .)
    MASMAS          shift and go to state 116
    MENOSMENOS      shift and go to state 119
    .               shift and go to state 115
    MULEQ           reduce using rule 41 (varYVals -> ID .)
    DIVEQ           reduce using rule 41 (varYVals -> ID .)
    MASEQ           reduce using rule 41 (varYVals -> ID .)
    MENOSEQ         reduce using rule 41 (varYVals -> ID .)
    ;               reduce using rule 41 (varYVals -> ID .)
    +               reduce using rule 41 (varYVals -> ID .)
    ^               reduce using rule 41 (varYVals -> ID .)
    *               reduce using rule 41 (varYVals -> ID .)
    /               reduce using rule 41 (varYVals -> ID .)
    %               reduce using rule 41 (varYVals -> ID .)
    -               reduce using rule 41 (varYVals -> ID .)
    >               reduce using rule 41 (varYVals -> ID .)
    <               reduce using rule 41 (varYVals -> ID .)
    EQEQ            reduce using rule 41 (varYVals -> ID .)
    DISTINTO        reduce using rule 41 (varYVals -> ID .)
    AND             reduce using rule 41 (varYVals -> ID .)
    ?               reduce using rule 41 (varYVals -> ID .)
    OR              reduce using rule 41 (varYVals -> ID .)
    =               shift and go to state 118
    [               shift and go to state 117

  ! ;               [ reduce using rule 54 (sMM -> ID .) ]
  ! ^               [ reduce using rule 54 (sMM -> ID .) ]
  ! *               [ reduce using rule 54 (sMM -> ID .) ]
  ! /               [ reduce using rule 54 (sMM -> ID .) ]
  ! %               [ reduce using rule 54 (sMM -> ID .) ]
  ! +               [ reduce using rule 54 (sMM -> ID .) ]
  ! -               [ reduce using rule 54 (sMM -> ID .) ]
  ! MULEQ           [ reduce using rule 54 (sMM -> ID .) ]
  ! DIVEQ           [ reduce using rule 54 (sMM -> ID .) ]
  ! MASEQ           [ reduce using rule 54 (sMM -> ID .) ]
  ! MENOSEQ         [ reduce using rule 54 (sMM -> ID .) ]
  ! >               [ reduce using rule 54 (sMM -> ID .) ]
  ! <               [ reduce using rule 54 (sMM -> ID .) ]

    m                              shift and go to state 114

state 53

    (13) if -> IF . ( expBool ) THEN bloque else

    (               shift and go to state 120


state 54

    (19) func -> funcVoid .

    ;               reduce using rule 19 (func -> funcVoid .)


state 55

    (23) funcInt -> MULTIESCALAR . ( vec , eMat , param )

    (               shift and go to state 121


state 56

    (80) paren -> FLOAT .

    ^               reduce using rule 80 (paren -> FLOAT .)
    *               reduce using rule 80 (paren -> FLOAT .)
    /               reduce using rule 80 (paren -> FLOAT .)
    %               reduce using rule 80 (paren -> FLOAT .)
    +               reduce using rule 80 (paren -> FLOAT .)
    -               reduce using rule 80 (paren -> FLOAT .)
    MULEQ           reduce using rule 80 (paren -> FLOAT .)
    DIVEQ           reduce using rule 80 (paren -> FLOAT .)
    MASEQ           reduce using rule 80 (paren -> FLOAT .)
    MENOSEQ         reduce using rule 80 (paren -> FLOAT .)
    ;               reduce using rule 80 (paren -> FLOAT .)
    >               reduce using rule 80 (paren -> FLOAT .)
    <               reduce using rule 80 (paren -> FLOAT .)
    )               reduce using rule 80 (paren -> FLOAT .)
    EQEQ            reduce using rule 80 (paren -> FLOAT .)
    DISTINTO        reduce using rule 80 (paren -> FLOAT .)
    AND             reduce using rule 80 (paren -> FLOAT .)
    ?               reduce using rule 80 (paren -> FLOAT .)
    OR              reduce using rule 80 (paren -> FLOAT .)
    }               reduce using rule 80 (paren -> FLOAT .)
    :               reduce using rule 80 (paren -> FLOAT .)
    ,               reduce using rule 80 (paren -> FLOAT .)
    ]               reduce using rule 80 (paren -> FLOAT .)


state 57

    (25) funcString -> CAPITALIZAR . ( expString )

    (               shift and go to state 122


state 58

    (4) sentencia -> varsOps . ;
    (81) paren -> varsOps .
    (107) tCompare -> varsOps .

  ! shift/reduce conflict for ; resolved as shift
  ! reduce/reduce conflict for > resolved using rule 81 (paren -> varsOps .)
  ! reduce/reduce conflict for < resolved using rule 81 (paren -> varsOps .)
    ;               shift and go to state 123
    ^               reduce using rule 81 (paren -> varsOps .)
    *               reduce using rule 81 (paren -> varsOps .)
    /               reduce using rule 81 (paren -> varsOps .)
    %               reduce using rule 81 (paren -> varsOps .)
    +               reduce using rule 81 (paren -> varsOps .)
    -               reduce using rule 81 (paren -> varsOps .)
    MULEQ           reduce using rule 81 (paren -> varsOps .)
    DIVEQ           reduce using rule 81 (paren -> varsOps .)
    MASEQ           reduce using rule 81 (paren -> varsOps .)
    MENOSEQ         reduce using rule 81 (paren -> varsOps .)
    >               reduce using rule 81 (paren -> varsOps .)
    <               reduce using rule 81 (paren -> varsOps .)
    }               reduce using rule 81 (paren -> varsOps .)

  ! ;               [ reduce using rule 81 (paren -> varsOps .) ]
  ! >               [ reduce using rule 107 (tCompare -> varsOps .) ]
  ! <               [ reduce using rule 107 (tCompare -> varsOps .) ]


state 59

    (71) p -> exp .
    (72) exp -> exp . ^ iSing

    *               reduce using rule 71 (p -> exp .)
    /               reduce using rule 71 (p -> exp .)
    %               reduce using rule 71 (p -> exp .)
    +               reduce using rule 71 (p -> exp .)
    -               reduce using rule 71 (p -> exp .)
    MULEQ           reduce using rule 71 (p -> exp .)
    DIVEQ           reduce using rule 71 (p -> exp .)
    MASEQ           reduce using rule 71 (p -> exp .)
    MENOSEQ         reduce using rule 71 (p -> exp .)
    ;               reduce using rule 71 (p -> exp .)
    >               reduce using rule 71 (p -> exp .)
    <               reduce using rule 71 (p -> exp .)
    }               reduce using rule 71 (p -> exp .)
    )               reduce using rule 71 (p -> exp .)
    ,               reduce using rule 71 (p -> exp .)
    EQEQ            reduce using rule 71 (p -> exp .)
    DISTINTO        reduce using rule 71 (p -> exp .)
    AND             reduce using rule 71 (p -> exp .)
    ?               reduce using rule 71 (p -> exp .)
    OR              reduce using rule 71 (p -> exp .)
    :               reduce using rule 71 (p -> exp .)
    ]               reduce using rule 71 (p -> exp .)
    ^               shift and go to state 124


state 60

    (26) funcBool -> COLINEALES ( . vec , vec )
    (31) vec -> . ID = [ elem ]

    ID              shift and go to state 126

    vec                            shift and go to state 125

state 61

    (105) tBool -> funcBool .

    EQEQ            reduce using rule 105 (tBool -> funcBool .)
    DISTINTO        reduce using rule 105 (tBool -> funcBool .)
    AND             reduce using rule 105 (tBool -> funcBool .)
    ?               reduce using rule 105 (tBool -> funcBool .)
    OR              reduce using rule 105 (tBool -> funcBool .)
    )               reduce using rule 105 (tBool -> funcBool .)
    MULEQ           reduce using rule 105 (tBool -> funcBool .)
    DIVEQ           reduce using rule 105 (tBool -> funcBool .)
    MASEQ           reduce using rule 105 (tBool -> funcBool .)
    MENOSEQ         reduce using rule 105 (tBool -> funcBool .)
    ;               reduce using rule 105 (tBool -> funcBool .)
    }               reduce using rule 105 (tBool -> funcBool .)
    :               reduce using rule 105 (tBool -> funcBool .)
    ,               reduce using rule 105 (tBool -> funcBool .)
    ]               reduce using rule 105 (tBool -> funcBool .)


state 62

    (82) paren -> funcInt .

    ^               reduce using rule 82 (paren -> funcInt .)
    *               reduce using rule 82 (paren -> funcInt .)
    /               reduce using rule 82 (paren -> funcInt .)
    %               reduce using rule 82 (paren -> funcInt .)
    )               reduce using rule 82 (paren -> funcInt .)
    +               reduce using rule 82 (paren -> funcInt .)
    -               reduce using rule 82 (paren -> funcInt .)
    EQEQ            reduce using rule 82 (paren -> funcInt .)
    DISTINTO        reduce using rule 82 (paren -> funcInt .)
    AND             reduce using rule 82 (paren -> funcInt .)
    ?               reduce using rule 82 (paren -> funcInt .)
    OR              reduce using rule 82 (paren -> funcInt .)
    MULEQ           reduce using rule 82 (paren -> funcInt .)
    DIVEQ           reduce using rule 82 (paren -> funcInt .)
    MASEQ           reduce using rule 82 (paren -> funcInt .)
    MENOSEQ         reduce using rule 82 (paren -> funcInt .)
    ;               reduce using rule 82 (paren -> funcInt .)
    }               reduce using rule 82 (paren -> funcInt .)
    :               reduce using rule 82 (paren -> funcInt .)
    ,               reduce using rule 82 (paren -> funcInt .)
    ]               reduce using rule 82 (paren -> funcInt .)
    >               reduce using rule 82 (paren -> funcInt .)
    <               reduce using rule 82 (paren -> funcInt .)


state 63

    (77) paren -> ( eMat . )
    (65) eMat -> eMat . + p
    (66) eMat -> eMat . - p
    (106) tCompare -> eMat .

    )               shift and go to state 127
    +               shift and go to state 111
    -               shift and go to state 112
    >               reduce using rule 106 (tCompare -> eMat .)
    <               reduce using rule 106 (tCompare -> eMat .)


state 64

    (81) paren -> varsOps .
    (107) tCompare -> varsOps .

  ! reduce/reduce conflict for > resolved using rule 81 (paren -> varsOps .)
  ! reduce/reduce conflict for < resolved using rule 81 (paren -> varsOps .)
    ^               reduce using rule 81 (paren -> varsOps .)
    *               reduce using rule 81 (paren -> varsOps .)
    /               reduce using rule 81 (paren -> varsOps .)
    %               reduce using rule 81 (paren -> varsOps .)
    +               reduce using rule 81 (paren -> varsOps .)
    -               reduce using rule 81 (paren -> varsOps .)
    MULEQ           reduce using rule 81 (paren -> varsOps .)
    DIVEQ           reduce using rule 81 (paren -> varsOps .)
    MASEQ           reduce using rule 81 (paren -> varsOps .)
    MENOSEQ         reduce using rule 81 (paren -> varsOps .)
    ;               reduce using rule 81 (paren -> varsOps .)
    >               reduce using rule 81 (paren -> varsOps .)
    <               reduce using rule 81 (paren -> varsOps .)
    ,               reduce using rule 81 (paren -> varsOps .)
    ]               reduce using rule 81 (paren -> varsOps .)
    )               reduce using rule 81 (paren -> varsOps .)
    }               reduce using rule 81 (paren -> varsOps .)

  ! >               [ reduce using rule 107 (tCompare -> varsOps .) ]
  ! <               [ reduce using rule 107 (tCompare -> varsOps .) ]


state 65

    (41) varYVals -> ID .
    (43) vecVal -> ID . m
    (52) sMM -> ID . MASMAS
    (53) sMM -> ID . MENOSMENOS
    (54) sMM -> ID .
    (44) m -> . [ INT ]
    (45) m -> . [ INT ] m

  ! reduce/reduce conflict for ^ resolved using rule 41 (varYVals -> ID .)
  ! reduce/reduce conflict for * resolved using rule 41 (varYVals -> ID .)
  ! reduce/reduce conflict for / resolved using rule 41 (varYVals -> ID .)
  ! reduce/reduce conflict for % resolved using rule 41 (varYVals -> ID .)
  ! reduce/reduce conflict for + resolved using rule 41 (varYVals -> ID .)
  ! reduce/reduce conflict for - resolved using rule 41 (varYVals -> ID .)
  ! reduce/reduce conflict for MULEQ resolved using rule 41 (varYVals -> ID .)
  ! reduce/reduce conflict for DIVEQ resolved using rule 41 (varYVals -> ID .)
  ! reduce/reduce conflict for MASEQ resolved using rule 41 (varYVals -> ID .)
  ! reduce/reduce conflict for MENOSEQ resolved using rule 41 (varYVals -> ID .)
  ! reduce/reduce conflict for ; resolved using rule 41 (varYVals -> ID .)
  ! reduce/reduce conflict for > resolved using rule 41 (varYVals -> ID .)
  ! reduce/reduce conflict for < resolved using rule 41 (varYVals -> ID .)
  ! reduce/reduce conflict for ) resolved using rule 41 (varYVals -> ID .)
  ! reduce/reduce conflict for } resolved using rule 41 (varYVals -> ID .)
  ! reduce/reduce conflict for EQEQ resolved using rule 41 (varYVals -> ID .)
  ! reduce/reduce conflict for DISTINTO resolved using rule 41 (varYVals -> ID .)
  ! reduce/reduce conflict for AND resolved using rule 41 (varYVals -> ID .)
  ! reduce/reduce conflict for ? resolved using rule 41 (varYVals -> ID .)
  ! reduce/reduce conflict for OR resolved using rule 41 (varYVals -> ID .)
  ! reduce/reduce conflict for : resolved using rule 41 (varYVals -> ID .)
  ! reduce/reduce conflict for , resolved using rule 41 (varYVals -> ID .)
  ! reduce/reduce conflict for ] resolved using rule 41 (varYVals -> ID .)
    ^               reduce using rule 41 (varYVals -> ID .)
    *               reduce using rule 41 (varYVals -> ID .)
    /               reduce using rule 41 (varYVals -> ID .)
    %               reduce using rule 41 (varYVals -> ID .)
    +               reduce using rule 41 (varYVals -> ID .)
    -               reduce using rule 41 (varYVals -> ID .)
    MULEQ           reduce using rule 41 (varYVals -> ID .)
    DIVEQ           reduce using rule 41 (varYVals -> ID .)
    MASEQ           reduce using rule 41 (varYVals -> ID .)
    MENOSEQ         reduce using rule 41 (varYVals -> ID .)
    ;               reduce using rule 41 (varYVals -> ID .)
    >               reduce using rule 41 (varYVals -> ID .)
    <               reduce using rule 41 (varYVals -> ID .)
    )               reduce using rule 41 (varYVals -> ID .)
    }               reduce using rule 41 (varYVals -> ID .)
    EQEQ            reduce using rule 41 (varYVals -> ID .)
    DISTINTO        reduce using rule 41 (varYVals -> ID .)
    AND             reduce using rule 41 (varYVals -> ID .)
    ?               reduce using rule 41 (varYVals -> ID .)
    OR              reduce using rule 41 (varYVals -> ID .)
    :               reduce using rule 41 (varYVals -> ID .)
    ,               reduce using rule 41 (varYVals -> ID .)
    ]               reduce using rule 41 (varYVals -> ID .)
    MASMAS          shift and go to state 116
    MENOSMENOS      shift and go to state 119
    [               shift and go to state 117

  ! ^               [ reduce using rule 54 (sMM -> ID .) ]
  ! *               [ reduce using rule 54 (sMM -> ID .) ]
  ! /               [ reduce using rule 54 (sMM -> ID .) ]
  ! %               [ reduce using rule 54 (sMM -> ID .) ]
  ! +               [ reduce using rule 54 (sMM -> ID .) ]
  ! -               [ reduce using rule 54 (sMM -> ID .) ]
  ! MULEQ           [ reduce using rule 54 (sMM -> ID .) ]
  ! DIVEQ           [ reduce using rule 54 (sMM -> ID .) ]
  ! MASEQ           [ reduce using rule 54 (sMM -> ID .) ]
  ! MENOSEQ         [ reduce using rule 54 (sMM -> ID .) ]
  ! ;               [ reduce using rule 54 (sMM -> ID .) ]
  ! >               [ reduce using rule 54 (sMM -> ID .) ]
  ! <               [ reduce using rule 54 (sMM -> ID .) ]
  ! )               [ reduce using rule 54 (sMM -> ID .) ]
  ! }               [ reduce using rule 54 (sMM -> ID .) ]
  ! EQEQ            [ reduce using rule 54 (sMM -> ID .) ]
  ! DISTINTO        [ reduce using rule 54 (sMM -> ID .) ]
  ! AND             [ reduce using rule 54 (sMM -> ID .) ]
  ! ?               [ reduce using rule 54 (sMM -> ID .) ]
  ! OR              [ reduce using rule 54 (sMM -> ID .) ]
  ! :               [ reduce using rule 54 (sMM -> ID .) ]
  ! ,               [ reduce using rule 54 (sMM -> ID .) ]
  ! ]               [ reduce using rule 54 (sMM -> ID .) ]

    m                              shift and go to state 114

state 66

    (79) paren -> varYVals .
    (108) tCompare -> varYVals .
    (104) tBool -> varYVals .

  ! reduce/reduce conflict for > resolved using rule 79 (paren -> varYVals .)
  ! reduce/reduce conflict for < resolved using rule 79 (paren -> varYVals .)
  ! reduce/reduce conflict for ) resolved using rule 79 (paren -> varYVals .)
    ^               reduce using rule 79 (paren -> varYVals .)
    *               reduce using rule 79 (paren -> varYVals .)
    /               reduce using rule 79 (paren -> varYVals .)
    %               reduce using rule 79 (paren -> varYVals .)
    )               reduce using rule 79 (paren -> varYVals .)
    +               reduce using rule 79 (paren -> varYVals .)
    -               reduce using rule 79 (paren -> varYVals .)
    >               reduce using rule 79 (paren -> varYVals .)
    <               reduce using rule 79 (paren -> varYVals .)
    EQEQ            reduce using rule 104 (tBool -> varYVals .)
    DISTINTO        reduce using rule 104 (tBool -> varYVals .)
    AND             reduce using rule 104 (tBool -> varYVals .)
    ?               reduce using rule 104 (tBool -> varYVals .)
    OR              reduce using rule 104 (tBool -> varYVals .)

  ! >               [ reduce using rule 108 (tCompare -> varYVals .) ]
  ! <               [ reduce using rule 108 (tCompare -> varYVals .) ]
  ! )               [ reduce using rule 104 (tBool -> varYVals .) ]


state 67

    (102) tBool -> ( expBool . )

    )               shift and go to state 128


state 68

    (68) p -> p * . exp
    (72) exp -> . exp ^ iSing
    (73) exp -> . iSing
    (74) iSing -> . - paren
    (75) iSing -> . + paren
    (76) iSing -> . paren
    (77) paren -> . ( eMat )
    (78) paren -> . INT
    (79) paren -> . varYVals
    (80) paren -> . FLOAT
    (81) paren -> . varsOps
    (82) paren -> . funcInt
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (49) varsOps -> . MENOSMENOS sMM
    (50) varsOps -> . MASMAS sMM
    (51) varsOps -> . sMM
    (23) funcInt -> . MULTIESCALAR ( vec , eMat , param )
    (24) funcInt -> . LENGTH ( vec )
    (43) vecVal -> . ID m
    (52) sMM -> . ID MASMAS
    (53) sMM -> . ID MENOSMENOS
    (54) sMM -> . ID

    -               shift and go to state 50
    +               shift and go to state 20
    (               shift and go to state 78
    INT             shift and go to state 27
    FLOAT           shift and go to state 56
    ID              shift and go to state 65
    MENOSMENOS      shift and go to state 23
    MASMAS          shift and go to state 28
    MULTIESCALAR    shift and go to state 55
    LENGTH          shift and go to state 11

    funcInt                        shift and go to state 62
    sMM                            shift and go to state 6
    iSing                          shift and go to state 12
    exp                            shift and go to state 129
    paren                          shift and go to state 36
    varYVals                       shift and go to state 81
    vecVal                         shift and go to state 47
    varsOps                        shift and go to state 79

state 69

    (70) p -> p % . exp
    (72) exp -> . exp ^ iSing
    (73) exp -> . iSing
    (74) iSing -> . - paren
    (75) iSing -> . + paren
    (76) iSing -> . paren
    (77) paren -> . ( eMat )
    (78) paren -> . INT
    (79) paren -> . varYVals
    (80) paren -> . FLOAT
    (81) paren -> . varsOps
    (82) paren -> . funcInt
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (49) varsOps -> . MENOSMENOS sMM
    (50) varsOps -> . MASMAS sMM
    (51) varsOps -> . sMM
    (23) funcInt -> . MULTIESCALAR ( vec , eMat , param )
    (24) funcInt -> . LENGTH ( vec )
    (43) vecVal -> . ID m
    (52) sMM -> . ID MASMAS
    (53) sMM -> . ID MENOSMENOS
    (54) sMM -> . ID

    -               shift and go to state 50
    +               shift and go to state 20
    (               shift and go to state 78
    INT             shift and go to state 27
    FLOAT           shift and go to state 56
    ID              shift and go to state 65
    MENOSMENOS      shift and go to state 23
    MASMAS          shift and go to state 28
    MULTIESCALAR    shift and go to state 55
    LENGTH          shift and go to state 11

    funcInt                        shift and go to state 62
    sMM                            shift and go to state 6
    iSing                          shift and go to state 12
    exp                            shift and go to state 130
    paren                          shift and go to state 36
    varYVals                       shift and go to state 81
    vecVal                         shift and go to state 47
    varsOps                        shift and go to state 79

state 70

    (69) p -> p / . exp
    (72) exp -> . exp ^ iSing
    (73) exp -> . iSing
    (74) iSing -> . - paren
    (75) iSing -> . + paren
    (76) iSing -> . paren
    (77) paren -> . ( eMat )
    (78) paren -> . INT
    (79) paren -> . varYVals
    (80) paren -> . FLOAT
    (81) paren -> . varsOps
    (82) paren -> . funcInt
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (49) varsOps -> . MENOSMENOS sMM
    (50) varsOps -> . MASMAS sMM
    (51) varsOps -> . sMM
    (23) funcInt -> . MULTIESCALAR ( vec , eMat , param )
    (24) funcInt -> . LENGTH ( vec )
    (43) vecVal -> . ID m
    (52) sMM -> . ID MASMAS
    (53) sMM -> . ID MENOSMENOS
    (54) sMM -> . ID

    -               shift and go to state 50
    +               shift and go to state 20
    (               shift and go to state 78
    INT             shift and go to state 27
    FLOAT           shift and go to state 56
    ID              shift and go to state 65
    MENOSMENOS      shift and go to state 23
    MASMAS          shift and go to state 28
    MULTIESCALAR    shift and go to state 55
    LENGTH          shift and go to state 11

    funcInt                        shift and go to state 62
    sMM                            shift and go to state 6
    iSing                          shift and go to state 12
    exp                            shift and go to state 131
    paren                          shift and go to state 36
    varYVals                       shift and go to state 81
    vecVal                         shift and go to state 47
    varsOps                        shift and go to state 79

state 71

    (24) funcInt -> LENGTH ( . vec )
    (31) vec -> . ID = [ elem ]

    ID              shift and go to state 126

    vec                            shift and go to state 132

state 72

    (7) sentencia -> RETURN ; .

    RETURN          reduce using rule 7 (sentencia -> RETURN ; .)
    MENOSMENOS      reduce using rule 7 (sentencia -> RETURN ; .)
    MASMAS          reduce using rule 7 (sentencia -> RETURN ; .)
    IF              reduce using rule 7 (sentencia -> RETURN ; .)
    WHILE           reduce using rule 7 (sentencia -> RETURN ; .)
    DO              reduce using rule 7 (sentencia -> RETURN ; .)
    FOR             reduce using rule 7 (sentencia -> RETURN ; .)
    ID              reduce using rule 7 (sentencia -> RETURN ; .)
    PRINT           reduce using rule 7 (sentencia -> RETURN ; .)
    MULTIESCALAR    reduce using rule 7 (sentencia -> RETURN ; .)
    LENGTH          reduce using rule 7 (sentencia -> RETURN ; .)
    CAPITALIZAR     reduce using rule 7 (sentencia -> RETURN ; .)
    COLINEALES      reduce using rule 7 (sentencia -> RETURN ; .)
    STRING          reduce using rule 7 (sentencia -> RETURN ; .)
    {               reduce using rule 7 (sentencia -> RETURN ; .)
    -               reduce using rule 7 (sentencia -> RETURN ; .)
    +               reduce using rule 7 (sentencia -> RETURN ; .)
    (               reduce using rule 7 (sentencia -> RETURN ; .)
    INT             reduce using rule 7 (sentencia -> RETURN ; .)
    FLOAT           reduce using rule 7 (sentencia -> RETURN ; .)
    NOT             reduce using rule 7 (sentencia -> RETURN ; .)
    BOOL            reduce using rule 7 (sentencia -> RETURN ; .)
    $end            reduce using rule 7 (sentencia -> RETURN ; .)
    }               reduce using rule 7 (sentencia -> RETURN ; .)
    ELSE            reduce using rule 7 (sentencia -> RETURN ; .)


state 73

    (27) funcVoid -> PRINT ( . valores )
    (34) valores -> . eMat
    (35) valores -> . expBool
    (36) valores -> . expString
    (37) valores -> . varYVals
    (38) valores -> . funcReturn
    (39) valores -> . reg
    (40) valores -> . ID . ID
    (65) eMat -> . eMat + p
    (66) eMat -> . eMat - p
    (67) eMat -> . p
    (87) expBool -> . or ? expBool : expBool
    (88) expBool -> . or
    (83) expString -> . expString + STRING
    (84) expString -> . STRING
    (85) expString -> . varYVals
    (86) expString -> . funcString
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (20) funcReturn -> . funcInt
    (21) funcReturn -> . funcString
    (22) funcReturn -> . funcBool
    (46) reg -> . { campos }
    (68) p -> . p * exp
    (69) p -> . p / exp
    (70) p -> . p % exp
    (71) p -> . exp
    (89) or -> . or OR and
    (90) or -> . and
    (25) funcString -> . CAPITALIZAR ( expString )
    (43) vecVal -> . ID m
    (23) funcInt -> . MULTIESCALAR ( vec , eMat , param )
    (24) funcInt -> . LENGTH ( vec )
    (26) funcBool -> . COLINEALES ( vec , vec )
    (72) exp -> . exp ^ iSing
    (73) exp -> . iSing
    (91) and -> . and AND eq
    (92) and -> . eq
    (74) iSing -> . - paren
    (75) iSing -> . + paren
    (76) iSing -> . paren
    (93) eq -> . eq EQEQ tBool
    (94) eq -> . eq DISTINTO tBool
    (95) eq -> . mayor
    (77) paren -> . ( eMat )
    (78) paren -> . INT
    (79) paren -> . varYVals
    (80) paren -> . FLOAT
    (81) paren -> . varsOps
    (82) paren -> . funcInt
    (96) mayor -> . tCompare > tCompare
    (97) mayor -> . menor
    (49) varsOps -> . MENOSMENOS sMM
    (50) varsOps -> . MASMAS sMM
    (51) varsOps -> . sMM
    (106) tCompare -> . eMat
    (107) tCompare -> . varsOps
    (108) tCompare -> . varYVals
    (98) menor -> . tCompare < tCompare
    (99) menor -> . not
    (52) sMM -> . ID MASMAS
    (53) sMM -> . ID MENOSMENOS
    (54) sMM -> . ID
    (100) not -> . NOT not
    (101) not -> . tBool
    (102) tBool -> . ( expBool )
    (103) tBool -> . BOOL
    (104) tBool -> . varYVals
    (105) tBool -> . funcBool

    ID              shift and go to state 133
    STRING          shift and go to state 51
    {               shift and go to state 32
    CAPITALIZAR     shift and go to state 57
    MULTIESCALAR    shift and go to state 55
    LENGTH          shift and go to state 11
    COLINEALES      shift and go to state 1
    -               shift and go to state 50
    +               shift and go to state 20
    (               shift and go to state 5
    INT             shift and go to state 27
    FLOAT           shift and go to state 56
    MENOSMENOS      shift and go to state 23
    MASMAS          shift and go to state 28
    NOT             shift and go to state 30
    BOOL            shift and go to state 41

    and                            shift and go to state 44
    funcBool                       shift and go to state 2
    funcInt                        shift and go to state 14
    menor                          shift and go to state 3
    eq                             shift and go to state 16
    vecVal                         shift and go to state 47
    eMat                           shift and go to state 49
    mayor                          shift and go to state 4
    sMM                            shift and go to state 6
    paren                          shift and go to state 36
    reg                            shift and go to state 22
    varsOps                        shift and go to state 64
    expString                      shift and go to state 24
    tCompare                       shift and go to state 37
    not                            shift and go to state 8
    funcString                     shift and go to state 92
    funcReturn                     shift and go to state 93
    valores                        shift and go to state 134
    p                              shift and go to state 10
    iSing                          shift and go to state 12
    exp                            shift and go to state 59
    tBool                          shift and go to state 31
    varYVals                       shift and go to state 33
    or                             shift and go to state 34
    expBool                        shift and go to state 29

state 74

    (93) eq -> eq EQEQ . tBool
    (102) tBool -> . ( expBool )
    (103) tBool -> . BOOL
    (104) tBool -> . varYVals
    (105) tBool -> . funcBool
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (26) funcBool -> . COLINEALES ( vec , vec )
    (43) vecVal -> . ID m

    (               shift and go to state 86
    BOOL            shift and go to state 41
    ID              shift and go to state 89
    COLINEALES      shift and go to state 1

    funcBool                       shift and go to state 61
    varYVals                       shift and go to state 88
    tBool                          shift and go to state 135
    vecVal                         shift and go to state 47

state 75

    (94) eq -> eq DISTINTO . tBool
    (102) tBool -> . ( expBool )
    (103) tBool -> . BOOL
    (104) tBool -> . varYVals
    (105) tBool -> . funcBool
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (26) funcBool -> . COLINEALES ( vec , vec )
    (43) vecVal -> . ID m

    (               shift and go to state 86
    BOOL            shift and go to state 41
    ID              shift and go to state 89
    COLINEALES      shift and go to state 1

    funcBool                       shift and go to state 61
    varYVals                       shift and go to state 88
    tBool                          shift and go to state 136
    vecVal                         shift and go to state 47

state 76

    (1) g -> sentencia g .

    $end            reduce using rule 1 (g -> sentencia g .)
    }               reduce using rule 1 (g -> sentencia g .)


state 77

    (12) loop -> FOR ( . varAsig ; expBool ; varsOps ) bloque
    (55) varAsig -> . valores MULEQ varAsig
    (56) varAsig -> . valores DIVEQ varAsig
    (57) varAsig -> . sIgual
    (34) valores -> . eMat
    (35) valores -> . expBool
    (36) valores -> . expString
    (37) valores -> . varYVals
    (38) valores -> . funcReturn
    (39) valores -> . reg
    (40) valores -> . ID . ID
    (58) sIgual -> . valores MASEQ sIgual
    (59) sIgual -> . valores MENOSEQ sIgual
    (60) sIgual -> . asig
    (65) eMat -> . eMat + p
    (66) eMat -> . eMat - p
    (67) eMat -> . p
    (87) expBool -> . or ? expBool : expBool
    (88) expBool -> . or
    (83) expString -> . expString + STRING
    (84) expString -> . STRING
    (85) expString -> . varYVals
    (86) expString -> . funcString
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (20) funcReturn -> . funcInt
    (21) funcReturn -> . funcString
    (22) funcReturn -> . funcBool
    (46) reg -> . { campos }
    (61) asig -> . ID = asig
    (62) asig -> . ID . ID = asig
    (63) asig -> . vec
    (64) asig -> . valores
    (68) p -> . p * exp
    (69) p -> . p / exp
    (70) p -> . p % exp
    (71) p -> . exp
    (89) or -> . or OR and
    (90) or -> . and
    (25) funcString -> . CAPITALIZAR ( expString )
    (43) vecVal -> . ID m
    (23) funcInt -> . MULTIESCALAR ( vec , eMat , param )
    (24) funcInt -> . LENGTH ( vec )
    (26) funcBool -> . COLINEALES ( vec , vec )
    (31) vec -> . ID = [ elem ]
    (72) exp -> . exp ^ iSing
    (73) exp -> . iSing
    (91) and -> . and AND eq
    (92) and -> . eq
    (74) iSing -> . - paren
    (75) iSing -> . + paren
    (76) iSing -> . paren
    (93) eq -> . eq EQEQ tBool
    (94) eq -> . eq DISTINTO tBool
    (95) eq -> . mayor
    (77) paren -> . ( eMat )
    (78) paren -> . INT
    (79) paren -> . varYVals
    (80) paren -> . FLOAT
    (81) paren -> . varsOps
    (82) paren -> . funcInt
    (96) mayor -> . tCompare > tCompare
    (97) mayor -> . menor
    (49) varsOps -> . MENOSMENOS sMM
    (50) varsOps -> . MASMAS sMM
    (51) varsOps -> . sMM
    (106) tCompare -> . eMat
    (107) tCompare -> . varsOps
    (108) tCompare -> . varYVals
    (98) menor -> . tCompare < tCompare
    (99) menor -> . not
    (52) sMM -> . ID MASMAS
    (53) sMM -> . ID MENOSMENOS
    (54) sMM -> . ID
    (100) not -> . NOT not
    (101) not -> . tBool
    (102) tBool -> . ( expBool )
    (103) tBool -> . BOOL
    (104) tBool -> . varYVals
    (105) tBool -> . funcBool

    ID              shift and go to state 137
    STRING          shift and go to state 51
    {               shift and go to state 32
    CAPITALIZAR     shift and go to state 57
    MULTIESCALAR    shift and go to state 55
    LENGTH          shift and go to state 11
    COLINEALES      shift and go to state 1
    -               shift and go to state 50
    +               shift and go to state 20
    (               shift and go to state 5
    INT             shift and go to state 27
    FLOAT           shift and go to state 56
    MENOSMENOS      shift and go to state 23
    MASMAS          shift and go to state 28
    NOT             shift and go to state 30
    BOOL            shift and go to state 41

    and                            shift and go to state 44
    funcBool                       shift and go to state 2
    funcInt                        shift and go to state 14
    menor                          shift and go to state 3
    eq                             shift and go to state 16
    vecVal                         shift and go to state 47
    eMat                           shift and go to state 49
    asig                           shift and go to state 19
    mayor                          shift and go to state 4
    sMM                            shift and go to state 6
    vec                            shift and go to state 7
    sIgual                         shift and go to state 21
    reg                            shift and go to state 22
    iSing                          shift and go to state 12
    expString                      shift and go to state 24
    tCompare                       shift and go to state 37
    paren                          shift and go to state 36
    not                            shift and go to state 8
    varAsig                        shift and go to state 138
    funcString                     shift and go to state 92
    funcReturn                     shift and go to state 93
    valores                        shift and go to state 40
    p                              shift and go to state 10
    varsOps                        shift and go to state 64
    exp                            shift and go to state 59
    tBool                          shift and go to state 31
    varYVals                       shift and go to state 33
    or                             shift and go to state 34
    expBool                        shift and go to state 29

state 78

    (77) paren -> ( . eMat )
    (65) eMat -> . eMat + p
    (66) eMat -> . eMat - p
    (67) eMat -> . p
    (68) p -> . p * exp
    (69) p -> . p / exp
    (70) p -> . p % exp
    (71) p -> . exp
    (72) exp -> . exp ^ iSing
    (73) exp -> . iSing
    (74) iSing -> . - paren
    (75) iSing -> . + paren
    (76) iSing -> . paren
    (77) paren -> . ( eMat )
    (78) paren -> . INT
    (79) paren -> . varYVals
    (80) paren -> . FLOAT
    (81) paren -> . varsOps
    (82) paren -> . funcInt
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (49) varsOps -> . MENOSMENOS sMM
    (50) varsOps -> . MASMAS sMM
    (51) varsOps -> . sMM
    (23) funcInt -> . MULTIESCALAR ( vec , eMat , param )
    (24) funcInt -> . LENGTH ( vec )
    (43) vecVal -> . ID m
    (52) sMM -> . ID MASMAS
    (53) sMM -> . ID MENOSMENOS
    (54) sMM -> . ID

    -               shift and go to state 50
    +               shift and go to state 20
    (               shift and go to state 78
    INT             shift and go to state 27
    FLOAT           shift and go to state 56
    ID              shift and go to state 65
    MENOSMENOS      shift and go to state 23
    MASMAS          shift and go to state 28
    MULTIESCALAR    shift and go to state 55
    LENGTH          shift and go to state 11

    eMat                           shift and go to state 139
    funcInt                        shift and go to state 62
    p                              shift and go to state 10
    sMM                            shift and go to state 6
    iSing                          shift and go to state 12
    exp                            shift and go to state 59
    paren                          shift and go to state 36
    varYVals                       shift and go to state 81
    vecVal                         shift and go to state 47
    varsOps                        shift and go to state 79

state 79

    (81) paren -> varsOps .

    ^               reduce using rule 81 (paren -> varsOps .)
    *               reduce using rule 81 (paren -> varsOps .)
    /               reduce using rule 81 (paren -> varsOps .)
    %               reduce using rule 81 (paren -> varsOps .)
    )               reduce using rule 81 (paren -> varsOps .)
    +               reduce using rule 81 (paren -> varsOps .)
    -               reduce using rule 81 (paren -> varsOps .)
    ,               reduce using rule 81 (paren -> varsOps .)
    MULEQ           reduce using rule 81 (paren -> varsOps .)
    DIVEQ           reduce using rule 81 (paren -> varsOps .)
    MASEQ           reduce using rule 81 (paren -> varsOps .)
    MENOSEQ         reduce using rule 81 (paren -> varsOps .)
    ;               reduce using rule 81 (paren -> varsOps .)
    >               reduce using rule 81 (paren -> varsOps .)
    <               reduce using rule 81 (paren -> varsOps .)
    }               reduce using rule 81 (paren -> varsOps .)
    EQEQ            reduce using rule 81 (paren -> varsOps .)
    DISTINTO        reduce using rule 81 (paren -> varsOps .)
    AND             reduce using rule 81 (paren -> varsOps .)
    ?               reduce using rule 81 (paren -> varsOps .)
    OR              reduce using rule 81 (paren -> varsOps .)
    :               reduce using rule 81 (paren -> varsOps .)
    ]               reduce using rule 81 (paren -> varsOps .)


state 80

    (75) iSing -> + paren .

    ^               reduce using rule 75 (iSing -> + paren .)
    *               reduce using rule 75 (iSing -> + paren .)
    /               reduce using rule 75 (iSing -> + paren .)
    %               reduce using rule 75 (iSing -> + paren .)
    +               reduce using rule 75 (iSing -> + paren .)
    -               reduce using rule 75 (iSing -> + paren .)
    >               reduce using rule 75 (iSing -> + paren .)
    <               reduce using rule 75 (iSing -> + paren .)
    ;               reduce using rule 75 (iSing -> + paren .)
    ,               reduce using rule 75 (iSing -> + paren .)
    ]               reduce using rule 75 (iSing -> + paren .)
    MULEQ           reduce using rule 75 (iSing -> + paren .)
    DIVEQ           reduce using rule 75 (iSing -> + paren .)
    MASEQ           reduce using rule 75 (iSing -> + paren .)
    MENOSEQ         reduce using rule 75 (iSing -> + paren .)
    EQEQ            reduce using rule 75 (iSing -> + paren .)
    DISTINTO        reduce using rule 75 (iSing -> + paren .)
    AND             reduce using rule 75 (iSing -> + paren .)
    ?               reduce using rule 75 (iSing -> + paren .)
    OR              reduce using rule 75 (iSing -> + paren .)
    )               reduce using rule 75 (iSing -> + paren .)
    }               reduce using rule 75 (iSing -> + paren .)
    :               reduce using rule 75 (iSing -> + paren .)


state 81

    (79) paren -> varYVals .

    ^               reduce using rule 79 (paren -> varYVals .)
    *               reduce using rule 79 (paren -> varYVals .)
    /               reduce using rule 79 (paren -> varYVals .)
    %               reduce using rule 79 (paren -> varYVals .)
    )               reduce using rule 79 (paren -> varYVals .)
    +               reduce using rule 79 (paren -> varYVals .)
    -               reduce using rule 79 (paren -> varYVals .)
    ,               reduce using rule 79 (paren -> varYVals .)
    MULEQ           reduce using rule 79 (paren -> varYVals .)
    DIVEQ           reduce using rule 79 (paren -> varYVals .)
    MASEQ           reduce using rule 79 (paren -> varYVals .)
    MENOSEQ         reduce using rule 79 (paren -> varYVals .)
    ;               reduce using rule 79 (paren -> varYVals .)
    >               reduce using rule 79 (paren -> varYVals .)
    <               reduce using rule 79 (paren -> varYVals .)
    }               reduce using rule 79 (paren -> varYVals .)
    EQEQ            reduce using rule 79 (paren -> varYVals .)
    DISTINTO        reduce using rule 79 (paren -> varYVals .)
    AND             reduce using rule 79 (paren -> varYVals .)
    ?               reduce using rule 79 (paren -> varYVals .)
    OR              reduce using rule 79 (paren -> varYVals .)
    :               reduce using rule 79 (paren -> varYVals .)
    ]               reduce using rule 79 (paren -> varYVals .)


state 82

    (49) varsOps -> MENOSMENOS sMM .

    ^               reduce using rule 49 (varsOps -> MENOSMENOS sMM .)
    *               reduce using rule 49 (varsOps -> MENOSMENOS sMM .)
    /               reduce using rule 49 (varsOps -> MENOSMENOS sMM .)
    %               reduce using rule 49 (varsOps -> MENOSMENOS sMM .)
    ,               reduce using rule 49 (varsOps -> MENOSMENOS sMM .)
    +               reduce using rule 49 (varsOps -> MENOSMENOS sMM .)
    -               reduce using rule 49 (varsOps -> MENOSMENOS sMM .)
    MULEQ           reduce using rule 49 (varsOps -> MENOSMENOS sMM .)
    DIVEQ           reduce using rule 49 (varsOps -> MENOSMENOS sMM .)
    MASEQ           reduce using rule 49 (varsOps -> MENOSMENOS sMM .)
    MENOSEQ         reduce using rule 49 (varsOps -> MENOSMENOS sMM .)
    ;               reduce using rule 49 (varsOps -> MENOSMENOS sMM .)
    >               reduce using rule 49 (varsOps -> MENOSMENOS sMM .)
    <               reduce using rule 49 (varsOps -> MENOSMENOS sMM .)
    EQEQ            reduce using rule 49 (varsOps -> MENOSMENOS sMM .)
    DISTINTO        reduce using rule 49 (varsOps -> MENOSMENOS sMM .)
    AND             reduce using rule 49 (varsOps -> MENOSMENOS sMM .)
    ?               reduce using rule 49 (varsOps -> MENOSMENOS sMM .)
    OR              reduce using rule 49 (varsOps -> MENOSMENOS sMM .)
    )               reduce using rule 49 (varsOps -> MENOSMENOS sMM .)
    }               reduce using rule 49 (varsOps -> MENOSMENOS sMM .)
    :               reduce using rule 49 (varsOps -> MENOSMENOS sMM .)
    ]               reduce using rule 49 (varsOps -> MENOSMENOS sMM .)


state 83

    (52) sMM -> ID . MASMAS
    (53) sMM -> ID . MENOSMENOS
    (54) sMM -> ID .

    MASMAS          shift and go to state 116
    MENOSMENOS      shift and go to state 119
    ;               reduce using rule 54 (sMM -> ID .)
    ^               reduce using rule 54 (sMM -> ID .)
    *               reduce using rule 54 (sMM -> ID .)
    /               reduce using rule 54 (sMM -> ID .)
    %               reduce using rule 54 (sMM -> ID .)
    +               reduce using rule 54 (sMM -> ID .)
    -               reduce using rule 54 (sMM -> ID .)
    MULEQ           reduce using rule 54 (sMM -> ID .)
    DIVEQ           reduce using rule 54 (sMM -> ID .)
    MASEQ           reduce using rule 54 (sMM -> ID .)
    MENOSEQ         reduce using rule 54 (sMM -> ID .)
    >               reduce using rule 54 (sMM -> ID .)
    <               reduce using rule 54 (sMM -> ID .)
    )               reduce using rule 54 (sMM -> ID .)
    }               reduce using rule 54 (sMM -> ID .)
    EQEQ            reduce using rule 54 (sMM -> ID .)
    DISTINTO        reduce using rule 54 (sMM -> ID .)
    AND             reduce using rule 54 (sMM -> ID .)
    ?               reduce using rule 54 (sMM -> ID .)
    OR              reduce using rule 54 (sMM -> ID .)
    :               reduce using rule 54 (sMM -> ID .)
    ,               reduce using rule 54 (sMM -> ID .)
    ]               reduce using rule 54 (sMM -> ID .)


state 84

    (83) expString -> expString + . STRING

    STRING          shift and go to state 140


state 85

    (50) varsOps -> MASMAS sMM .

    ^               reduce using rule 50 (varsOps -> MASMAS sMM .)
    *               reduce using rule 50 (varsOps -> MASMAS sMM .)
    /               reduce using rule 50 (varsOps -> MASMAS sMM .)
    %               reduce using rule 50 (varsOps -> MASMAS sMM .)
    ,               reduce using rule 50 (varsOps -> MASMAS sMM .)
    +               reduce using rule 50 (varsOps -> MASMAS sMM .)
    -               reduce using rule 50 (varsOps -> MASMAS sMM .)
    MULEQ           reduce using rule 50 (varsOps -> MASMAS sMM .)
    DIVEQ           reduce using rule 50 (varsOps -> MASMAS sMM .)
    MASEQ           reduce using rule 50 (varsOps -> MASMAS sMM .)
    MENOSEQ         reduce using rule 50 (varsOps -> MASMAS sMM .)
    ;               reduce using rule 50 (varsOps -> MASMAS sMM .)
    >               reduce using rule 50 (varsOps -> MASMAS sMM .)
    <               reduce using rule 50 (varsOps -> MASMAS sMM .)
    EQEQ            reduce using rule 50 (varsOps -> MASMAS sMM .)
    DISTINTO        reduce using rule 50 (varsOps -> MASMAS sMM .)
    AND             reduce using rule 50 (varsOps -> MASMAS sMM .)
    ?               reduce using rule 50 (varsOps -> MASMAS sMM .)
    OR              reduce using rule 50 (varsOps -> MASMAS sMM .)
    )               reduce using rule 50 (varsOps -> MASMAS sMM .)
    }               reduce using rule 50 (varsOps -> MASMAS sMM .)
    :               reduce using rule 50 (varsOps -> MASMAS sMM .)
    ]               reduce using rule 50 (varsOps -> MASMAS sMM .)


state 86

    (102) tBool -> ( . expBool )
    (87) expBool -> . or ? expBool : expBool
    (88) expBool -> . or
    (89) or -> . or OR and
    (90) or -> . and
    (91) and -> . and AND eq
    (92) and -> . eq
    (93) eq -> . eq EQEQ tBool
    (94) eq -> . eq DISTINTO tBool
    (95) eq -> . mayor
    (96) mayor -> . tCompare > tCompare
    (97) mayor -> . menor
    (106) tCompare -> . eMat
    (107) tCompare -> . varsOps
    (108) tCompare -> . varYVals
    (98) menor -> . tCompare < tCompare
    (99) menor -> . not
    (65) eMat -> . eMat + p
    (66) eMat -> . eMat - p
    (67) eMat -> . p
    (49) varsOps -> . MENOSMENOS sMM
    (50) varsOps -> . MASMAS sMM
    (51) varsOps -> . sMM
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (100) not -> . NOT not
    (101) not -> . tBool
    (68) p -> . p * exp
    (69) p -> . p / exp
    (70) p -> . p % exp
    (71) p -> . exp
    (52) sMM -> . ID MASMAS
    (53) sMM -> . ID MENOSMENOS
    (54) sMM -> . ID
    (43) vecVal -> . ID m
    (102) tBool -> . ( expBool )
    (103) tBool -> . BOOL
    (104) tBool -> . varYVals
    (105) tBool -> . funcBool
    (72) exp -> . exp ^ iSing
    (73) exp -> . iSing
    (26) funcBool -> . COLINEALES ( vec , vec )
    (74) iSing -> . - paren
    (75) iSing -> . + paren
    (76) iSing -> . paren
    (77) paren -> . ( eMat )
    (78) paren -> . INT
    (79) paren -> . varYVals
    (80) paren -> . FLOAT
    (81) paren -> . varsOps
    (82) paren -> . funcInt
    (23) funcInt -> . MULTIESCALAR ( vec , eMat , param )
    (24) funcInt -> . LENGTH ( vec )

    MENOSMENOS      shift and go to state 23
    MASMAS          shift and go to state 28
    ID              shift and go to state 143
    NOT             shift and go to state 30
    (               shift and go to state 142
    BOOL            shift and go to state 41
    COLINEALES      shift and go to state 1
    -               shift and go to state 50
    +               shift and go to state 20
    INT             shift and go to state 27
    FLOAT           shift and go to state 56
    MULTIESCALAR    shift and go to state 55
    LENGTH          shift and go to state 11

    and                            shift and go to state 44
    funcBool                       shift and go to state 61
    funcInt                        shift and go to state 62
    menor                          shift and go to state 3
    eq                             shift and go to state 16
    mayor                          shift and go to state 4
    eMat                           shift and go to state 141
    vecVal                         shift and go to state 47
    sMM                            shift and go to state 6
    paren                          shift and go to state 36
    iSing                          shift and go to state 12
    tCompare                       shift and go to state 37
    not                            shift and go to state 8
    p                              shift and go to state 10
    varsOps                        shift and go to state 144
    exp                            shift and go to state 59
    tBool                          shift and go to state 31
    varYVals                       shift and go to state 145
    or                             shift and go to state 34
    expBool                        shift and go to state 67

state 87

    (100) not -> NOT not .

    EQEQ            reduce using rule 100 (not -> NOT not .)
    DISTINTO        reduce using rule 100 (not -> NOT not .)
    AND             reduce using rule 100 (not -> NOT not .)
    ?               reduce using rule 100 (not -> NOT not .)
    OR              reduce using rule 100 (not -> NOT not .)
    MULEQ           reduce using rule 100 (not -> NOT not .)
    DIVEQ           reduce using rule 100 (not -> NOT not .)
    MASEQ           reduce using rule 100 (not -> NOT not .)
    MENOSEQ         reduce using rule 100 (not -> NOT not .)
    ;               reduce using rule 100 (not -> NOT not .)
    )               reduce using rule 100 (not -> NOT not .)
    :               reduce using rule 100 (not -> NOT not .)
    }               reduce using rule 100 (not -> NOT not .)
    ,               reduce using rule 100 (not -> NOT not .)
    ]               reduce using rule 100 (not -> NOT not .)


state 88

    (104) tBool -> varYVals .

    EQEQ            reduce using rule 104 (tBool -> varYVals .)
    DISTINTO        reduce using rule 104 (tBool -> varYVals .)
    AND             reduce using rule 104 (tBool -> varYVals .)
    ?               reduce using rule 104 (tBool -> varYVals .)
    OR              reduce using rule 104 (tBool -> varYVals .)
    MULEQ           reduce using rule 104 (tBool -> varYVals .)
    DIVEQ           reduce using rule 104 (tBool -> varYVals .)
    MASEQ           reduce using rule 104 (tBool -> varYVals .)
    MENOSEQ         reduce using rule 104 (tBool -> varYVals .)
    ;               reduce using rule 104 (tBool -> varYVals .)
    )               reduce using rule 104 (tBool -> varYVals .)
    }               reduce using rule 104 (tBool -> varYVals .)
    :               reduce using rule 104 (tBool -> varYVals .)
    ,               reduce using rule 104 (tBool -> varYVals .)
    ]               reduce using rule 104 (tBool -> varYVals .)


state 89

    (41) varYVals -> ID .
    (43) vecVal -> ID . m
    (44) m -> . [ INT ]
    (45) m -> . [ INT ] m

    EQEQ            reduce using rule 41 (varYVals -> ID .)
    DISTINTO        reduce using rule 41 (varYVals -> ID .)
    AND             reduce using rule 41 (varYVals -> ID .)
    ?               reduce using rule 41 (varYVals -> ID .)
    OR              reduce using rule 41 (varYVals -> ID .)
    MULEQ           reduce using rule 41 (varYVals -> ID .)
    DIVEQ           reduce using rule 41 (varYVals -> ID .)
    MASEQ           reduce using rule 41 (varYVals -> ID .)
    MENOSEQ         reduce using rule 41 (varYVals -> ID .)
    ;               reduce using rule 41 (varYVals -> ID .)
    )               reduce using rule 41 (varYVals -> ID .)
    }               reduce using rule 41 (varYVals -> ID .)
    :               reduce using rule 41 (varYVals -> ID .)
    ,               reduce using rule 41 (varYVals -> ID .)
    ]               reduce using rule 41 (varYVals -> ID .)
    +               reduce using rule 41 (varYVals -> ID .)
    [               shift and go to state 117

    m                              shift and go to state 114

state 90

    (46) reg -> { campos . }

    }               shift and go to state 146


state 91

    (47) campos -> ID . : valores , campos
    (40) valores -> ID . . ID
    (41) varYVals -> ID .
    (43) vecVal -> ID . m
    (52) sMM -> ID . MASMAS
    (53) sMM -> ID . MENOSMENOS
    (54) sMM -> ID .
    (44) m -> . [ INT ]
    (45) m -> . [ INT ] m

  ! reduce/reduce conflict for ^ resolved using rule 41 (varYVals -> ID .)
  ! reduce/reduce conflict for * resolved using rule 41 (varYVals -> ID .)
  ! reduce/reduce conflict for / resolved using rule 41 (varYVals -> ID .)
  ! reduce/reduce conflict for % resolved using rule 41 (varYVals -> ID .)
  ! reduce/reduce conflict for + resolved using rule 41 (varYVals -> ID .)
  ! reduce/reduce conflict for - resolved using rule 41 (varYVals -> ID .)
  ! reduce/reduce conflict for } resolved using rule 41 (varYVals -> ID .)
  ! reduce/reduce conflict for > resolved using rule 41 (varYVals -> ID .)
  ! reduce/reduce conflict for < resolved using rule 41 (varYVals -> ID .)
    :               shift and go to state 148
    .               shift and go to state 147
    }               reduce using rule 41 (varYVals -> ID .)
    +               reduce using rule 41 (varYVals -> ID .)
    ^               reduce using rule 41 (varYVals -> ID .)
    *               reduce using rule 41 (varYVals -> ID .)
    /               reduce using rule 41 (varYVals -> ID .)
    %               reduce using rule 41 (varYVals -> ID .)
    -               reduce using rule 41 (varYVals -> ID .)
    >               reduce using rule 41 (varYVals -> ID .)
    <               reduce using rule 41 (varYVals -> ID .)
    EQEQ            reduce using rule 41 (varYVals -> ID .)
    DISTINTO        reduce using rule 41 (varYVals -> ID .)
    AND             reduce using rule 41 (varYVals -> ID .)
    ?               reduce using rule 41 (varYVals -> ID .)
    OR              reduce using rule 41 (varYVals -> ID .)
    MASMAS          shift and go to state 116
    MENOSMENOS      shift and go to state 119
    [               shift and go to state 117

  ! ^               [ reduce using rule 54 (sMM -> ID .) ]
  ! *               [ reduce using rule 54 (sMM -> ID .) ]
  ! /               [ reduce using rule 54 (sMM -> ID .) ]
  ! %               [ reduce using rule 54 (sMM -> ID .) ]
  ! +               [ reduce using rule 54 (sMM -> ID .) ]
  ! -               [ reduce using rule 54 (sMM -> ID .) ]
  ! }               [ reduce using rule 54 (sMM -> ID .) ]
  ! >               [ reduce using rule 54 (sMM -> ID .) ]
  ! <               [ reduce using rule 54 (sMM -> ID .) ]

    m                              shift and go to state 114

state 92

    (86) expString -> funcString .
    (21) funcReturn -> funcString .

  ! reduce/reduce conflict for ) resolved using rule 21 (funcReturn -> funcString .)
  ! reduce/reduce conflict for MULEQ resolved using rule 21 (funcReturn -> funcString .)
  ! reduce/reduce conflict for DIVEQ resolved using rule 21 (funcReturn -> funcString .)
  ! reduce/reduce conflict for MASEQ resolved using rule 21 (funcReturn -> funcString .)
  ! reduce/reduce conflict for MENOSEQ resolved using rule 21 (funcReturn -> funcString .)
  ! reduce/reduce conflict for } resolved using rule 21 (funcReturn -> funcString .)
  ! reduce/reduce conflict for ; resolved using rule 21 (funcReturn -> funcString .)
  ! reduce/reduce conflict for , resolved using rule 21 (funcReturn -> funcString .)
  ! reduce/reduce conflict for ] resolved using rule 21 (funcReturn -> funcString .)
    +               reduce using rule 86 (expString -> funcString .)
    )               reduce using rule 21 (funcReturn -> funcString .)
    MULEQ           reduce using rule 21 (funcReturn -> funcString .)
    DIVEQ           reduce using rule 21 (funcReturn -> funcString .)
    MASEQ           reduce using rule 21 (funcReturn -> funcString .)
    MENOSEQ         reduce using rule 21 (funcReturn -> funcString .)
    }               reduce using rule 21 (funcReturn -> funcString .)
    ;               reduce using rule 21 (funcReturn -> funcString .)
    ,               reduce using rule 21 (funcReturn -> funcString .)
    ]               reduce using rule 21 (funcReturn -> funcString .)

  ! MULEQ           [ reduce using rule 86 (expString -> funcString .) ]
  ! DIVEQ           [ reduce using rule 86 (expString -> funcString .) ]
  ! MASEQ           [ reduce using rule 86 (expString -> funcString .) ]
  ! MENOSEQ         [ reduce using rule 86 (expString -> funcString .) ]
  ! ;               [ reduce using rule 86 (expString -> funcString .) ]
  ! )               [ reduce using rule 86 (expString -> funcString .) ]
  ! ,               [ reduce using rule 86 (expString -> funcString .) ]
  ! }               [ reduce using rule 86 (expString -> funcString .) ]
  ! ]               [ reduce using rule 86 (expString -> funcString .) ]


state 93

    (38) valores -> funcReturn .

    ,               reduce using rule 38 (valores -> funcReturn .)
    ]               reduce using rule 38 (valores -> funcReturn .)
    MULEQ           reduce using rule 38 (valores -> funcReturn .)
    DIVEQ           reduce using rule 38 (valores -> funcReturn .)
    MASEQ           reduce using rule 38 (valores -> funcReturn .)
    MENOSEQ         reduce using rule 38 (valores -> funcReturn .)
    ;               reduce using rule 38 (valores -> funcReturn .)
    }               reduce using rule 38 (valores -> funcReturn .)
    )               reduce using rule 38 (valores -> funcReturn .)


state 94

    (48) campos -> valores .

    }               reduce using rule 48 (campos -> valores .)


state 95

    (89) or -> or OR . and
    (91) and -> . and AND eq
    (92) and -> . eq
    (93) eq -> . eq EQEQ tBool
    (94) eq -> . eq DISTINTO tBool
    (95) eq -> . mayor
    (96) mayor -> . tCompare > tCompare
    (97) mayor -> . menor
    (106) tCompare -> . eMat
    (107) tCompare -> . varsOps
    (108) tCompare -> . varYVals
    (98) menor -> . tCompare < tCompare
    (99) menor -> . not
    (65) eMat -> . eMat + p
    (66) eMat -> . eMat - p
    (67) eMat -> . p
    (49) varsOps -> . MENOSMENOS sMM
    (50) varsOps -> . MASMAS sMM
    (51) varsOps -> . sMM
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (100) not -> . NOT not
    (101) not -> . tBool
    (68) p -> . p * exp
    (69) p -> . p / exp
    (70) p -> . p % exp
    (71) p -> . exp
    (52) sMM -> . ID MASMAS
    (53) sMM -> . ID MENOSMENOS
    (54) sMM -> . ID
    (43) vecVal -> . ID m
    (102) tBool -> . ( expBool )
    (103) tBool -> . BOOL
    (104) tBool -> . varYVals
    (105) tBool -> . funcBool
    (72) exp -> . exp ^ iSing
    (73) exp -> . iSing
    (26) funcBool -> . COLINEALES ( vec , vec )
    (74) iSing -> . - paren
    (75) iSing -> . + paren
    (76) iSing -> . paren
    (77) paren -> . ( eMat )
    (78) paren -> . INT
    (79) paren -> . varYVals
    (80) paren -> . FLOAT
    (81) paren -> . varsOps
    (82) paren -> . funcInt
    (23) funcInt -> . MULTIESCALAR ( vec , eMat , param )
    (24) funcInt -> . LENGTH ( vec )

    MENOSMENOS      shift and go to state 23
    MASMAS          shift and go to state 28
    ID              shift and go to state 143
    NOT             shift and go to state 30
    (               shift and go to state 142
    BOOL            shift and go to state 41
    COLINEALES      shift and go to state 1
    -               shift and go to state 50
    +               shift and go to state 20
    INT             shift and go to state 27
    FLOAT           shift and go to state 56
    MULTIESCALAR    shift and go to state 55
    LENGTH          shift and go to state 11

    and                            shift and go to state 149
    funcBool                       shift and go to state 61
    funcInt                        shift and go to state 62
    menor                          shift and go to state 3
    eq                             shift and go to state 16
    mayor                          shift and go to state 4
    eMat                           shift and go to state 141
    vecVal                         shift and go to state 47
    sMM                            shift and go to state 6
    paren                          shift and go to state 36
    iSing                          shift and go to state 12
    tCompare                       shift and go to state 37
    not                            shift and go to state 8
    p                              shift and go to state 10
    varsOps                        shift and go to state 144
    exp                            shift and go to state 59
    tBool                          shift and go to state 31
    varYVals                       shift and go to state 145

state 96

    (87) expBool -> or ? . expBool : expBool
    (87) expBool -> . or ? expBool : expBool
    (88) expBool -> . or
    (89) or -> . or OR and
    (90) or -> . and
    (91) and -> . and AND eq
    (92) and -> . eq
    (93) eq -> . eq EQEQ tBool
    (94) eq -> . eq DISTINTO tBool
    (95) eq -> . mayor
    (96) mayor -> . tCompare > tCompare
    (97) mayor -> . menor
    (106) tCompare -> . eMat
    (107) tCompare -> . varsOps
    (108) tCompare -> . varYVals
    (98) menor -> . tCompare < tCompare
    (99) menor -> . not
    (65) eMat -> . eMat + p
    (66) eMat -> . eMat - p
    (67) eMat -> . p
    (49) varsOps -> . MENOSMENOS sMM
    (50) varsOps -> . MASMAS sMM
    (51) varsOps -> . sMM
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (100) not -> . NOT not
    (101) not -> . tBool
    (68) p -> . p * exp
    (69) p -> . p / exp
    (70) p -> . p % exp
    (71) p -> . exp
    (52) sMM -> . ID MASMAS
    (53) sMM -> . ID MENOSMENOS
    (54) sMM -> . ID
    (43) vecVal -> . ID m
    (102) tBool -> . ( expBool )
    (103) tBool -> . BOOL
    (104) tBool -> . varYVals
    (105) tBool -> . funcBool
    (72) exp -> . exp ^ iSing
    (73) exp -> . iSing
    (26) funcBool -> . COLINEALES ( vec , vec )
    (74) iSing -> . - paren
    (75) iSing -> . + paren
    (76) iSing -> . paren
    (77) paren -> . ( eMat )
    (78) paren -> . INT
    (79) paren -> . varYVals
    (80) paren -> . FLOAT
    (81) paren -> . varsOps
    (82) paren -> . funcInt
    (23) funcInt -> . MULTIESCALAR ( vec , eMat , param )
    (24) funcInt -> . LENGTH ( vec )

    MENOSMENOS      shift and go to state 23
    MASMAS          shift and go to state 28
    ID              shift and go to state 143
    NOT             shift and go to state 30
    (               shift and go to state 142
    BOOL            shift and go to state 41
    COLINEALES      shift and go to state 1
    -               shift and go to state 50
    +               shift and go to state 20
    INT             shift and go to state 27
    FLOAT           shift and go to state 56
    MULTIESCALAR    shift and go to state 55
    LENGTH          shift and go to state 11

    and                            shift and go to state 44
    funcBool                       shift and go to state 61
    funcInt                        shift and go to state 62
    menor                          shift and go to state 3
    eq                             shift and go to state 16
    mayor                          shift and go to state 4
    eMat                           shift and go to state 141
    vecVal                         shift and go to state 47
    sMM                            shift and go to state 6
    paren                          shift and go to state 36
    iSing                          shift and go to state 12
    tCompare                       shift and go to state 37
    not                            shift and go to state 8
    p                              shift and go to state 10
    varsOps                        shift and go to state 144
    exp                            shift and go to state 59
    tBool                          shift and go to state 31
    varYVals                       shift and go to state 145
    or                             shift and go to state 34
    expBool                        shift and go to state 150

state 97

    (10) loop -> WHILE ( . expBool ) bloque
    (87) expBool -> . or ? expBool : expBool
    (88) expBool -> . or
    (89) or -> . or OR and
    (90) or -> . and
    (91) and -> . and AND eq
    (92) and -> . eq
    (93) eq -> . eq EQEQ tBool
    (94) eq -> . eq DISTINTO tBool
    (95) eq -> . mayor
    (96) mayor -> . tCompare > tCompare
    (97) mayor -> . menor
    (106) tCompare -> . eMat
    (107) tCompare -> . varsOps
    (108) tCompare -> . varYVals
    (98) menor -> . tCompare < tCompare
    (99) menor -> . not
    (65) eMat -> . eMat + p
    (66) eMat -> . eMat - p
    (67) eMat -> . p
    (49) varsOps -> . MENOSMENOS sMM
    (50) varsOps -> . MASMAS sMM
    (51) varsOps -> . sMM
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (100) not -> . NOT not
    (101) not -> . tBool
    (68) p -> . p * exp
    (69) p -> . p / exp
    (70) p -> . p % exp
    (71) p -> . exp
    (52) sMM -> . ID MASMAS
    (53) sMM -> . ID MENOSMENOS
    (54) sMM -> . ID
    (43) vecVal -> . ID m
    (102) tBool -> . ( expBool )
    (103) tBool -> . BOOL
    (104) tBool -> . varYVals
    (105) tBool -> . funcBool
    (72) exp -> . exp ^ iSing
    (73) exp -> . iSing
    (26) funcBool -> . COLINEALES ( vec , vec )
    (74) iSing -> . - paren
    (75) iSing -> . + paren
    (76) iSing -> . paren
    (77) paren -> . ( eMat )
    (78) paren -> . INT
    (79) paren -> . varYVals
    (80) paren -> . FLOAT
    (81) paren -> . varsOps
    (82) paren -> . funcInt
    (23) funcInt -> . MULTIESCALAR ( vec , eMat , param )
    (24) funcInt -> . LENGTH ( vec )

    MENOSMENOS      shift and go to state 23
    MASMAS          shift and go to state 28
    ID              shift and go to state 143
    NOT             shift and go to state 30
    (               shift and go to state 142
    BOOL            shift and go to state 41
    COLINEALES      shift and go to state 1
    -               shift and go to state 50
    +               shift and go to state 20
    INT             shift and go to state 27
    FLOAT           shift and go to state 56
    MULTIESCALAR    shift and go to state 55
    LENGTH          shift and go to state 11

    and                            shift and go to state 44
    funcBool                       shift and go to state 61
    funcInt                        shift and go to state 62
    menor                          shift and go to state 3
    eq                             shift and go to state 16
    mayor                          shift and go to state 4
    eMat                           shift and go to state 141
    vecVal                         shift and go to state 47
    sMM                            shift and go to state 6
    paren                          shift and go to state 36
    iSing                          shift and go to state 12
    tCompare                       shift and go to state 37
    not                            shift and go to state 8
    p                              shift and go to state 10
    varsOps                        shift and go to state 144
    exp                            shift and go to state 59
    tBool                          shift and go to state 31
    varYVals                       shift and go to state 145
    or                             shift and go to state 34
    expBool                        shift and go to state 151

state 98

    (98) menor -> tCompare < . tCompare
    (106) tCompare -> . eMat
    (107) tCompare -> . varsOps
    (108) tCompare -> . varYVals
    (65) eMat -> . eMat + p
    (66) eMat -> . eMat - p
    (67) eMat -> . p
    (49) varsOps -> . MENOSMENOS sMM
    (50) varsOps -> . MASMAS sMM
    (51) varsOps -> . sMM
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (68) p -> . p * exp
    (69) p -> . p / exp
    (70) p -> . p % exp
    (71) p -> . exp
    (52) sMM -> . ID MASMAS
    (53) sMM -> . ID MENOSMENOS
    (54) sMM -> . ID
    (43) vecVal -> . ID m
    (72) exp -> . exp ^ iSing
    (73) exp -> . iSing
    (74) iSing -> . - paren
    (75) iSing -> . + paren
    (76) iSing -> . paren
    (77) paren -> . ( eMat )
    (78) paren -> . INT
    (79) paren -> . varYVals
    (80) paren -> . FLOAT
    (81) paren -> . varsOps
    (82) paren -> . funcInt
    (23) funcInt -> . MULTIESCALAR ( vec , eMat , param )
    (24) funcInt -> . LENGTH ( vec )

    MENOSMENOS      shift and go to state 23
    MASMAS          shift and go to state 28
    ID              shift and go to state 143
    -               shift and go to state 50
    +               shift and go to state 20
    (               shift and go to state 78
    INT             shift and go to state 27
    FLOAT           shift and go to state 56
    MULTIESCALAR    shift and go to state 55
    LENGTH          shift and go to state 11

    eMat                           shift and go to state 141
    p                              shift and go to state 10
    funcInt                        shift and go to state 62
    tCompare                       shift and go to state 152
    sMM                            shift and go to state 6
    varsOps                        shift and go to state 144
    exp                            shift and go to state 59
    paren                          shift and go to state 36
    varYVals                       shift and go to state 153
    vecVal                         shift and go to state 47
    iSing                          shift and go to state 12

state 99

    (96) mayor -> tCompare > . tCompare
    (106) tCompare -> . eMat
    (107) tCompare -> . varsOps
    (108) tCompare -> . varYVals
    (65) eMat -> . eMat + p
    (66) eMat -> . eMat - p
    (67) eMat -> . p
    (49) varsOps -> . MENOSMENOS sMM
    (50) varsOps -> . MASMAS sMM
    (51) varsOps -> . sMM
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (68) p -> . p * exp
    (69) p -> . p / exp
    (70) p -> . p % exp
    (71) p -> . exp
    (52) sMM -> . ID MASMAS
    (53) sMM -> . ID MENOSMENOS
    (54) sMM -> . ID
    (43) vecVal -> . ID m
    (72) exp -> . exp ^ iSing
    (73) exp -> . iSing
    (74) iSing -> . - paren
    (75) iSing -> . + paren
    (76) iSing -> . paren
    (77) paren -> . ( eMat )
    (78) paren -> . INT
    (79) paren -> . varYVals
    (80) paren -> . FLOAT
    (81) paren -> . varsOps
    (82) paren -> . funcInt
    (23) funcInt -> . MULTIESCALAR ( vec , eMat , param )
    (24) funcInt -> . LENGTH ( vec )

    MENOSMENOS      shift and go to state 23
    MASMAS          shift and go to state 28
    ID              shift and go to state 143
    -               shift and go to state 50
    +               shift and go to state 20
    (               shift and go to state 78
    INT             shift and go to state 27
    FLOAT           shift and go to state 56
    MULTIESCALAR    shift and go to state 55
    LENGTH          shift and go to state 11

    eMat                           shift and go to state 141
    p                              shift and go to state 10
    funcInt                        shift and go to state 62
    tCompare                       shift and go to state 154
    sMM                            shift and go to state 6
    varsOps                        shift and go to state 144
    exp                            shift and go to state 59
    paren                          shift and go to state 36
    varYVals                       shift and go to state 153
    vecVal                         shift and go to state 47
    iSing                          shift and go to state 12

state 100

    (5) sentencia -> func ; .

    RETURN          reduce using rule 5 (sentencia -> func ; .)
    MENOSMENOS      reduce using rule 5 (sentencia -> func ; .)
    MASMAS          reduce using rule 5 (sentencia -> func ; .)
    IF              reduce using rule 5 (sentencia -> func ; .)
    WHILE           reduce using rule 5 (sentencia -> func ; .)
    DO              reduce using rule 5 (sentencia -> func ; .)
    FOR             reduce using rule 5 (sentencia -> func ; .)
    ID              reduce using rule 5 (sentencia -> func ; .)
    PRINT           reduce using rule 5 (sentencia -> func ; .)
    MULTIESCALAR    reduce using rule 5 (sentencia -> func ; .)
    LENGTH          reduce using rule 5 (sentencia -> func ; .)
    CAPITALIZAR     reduce using rule 5 (sentencia -> func ; .)
    COLINEALES      reduce using rule 5 (sentencia -> func ; .)
    STRING          reduce using rule 5 (sentencia -> func ; .)
    {               reduce using rule 5 (sentencia -> func ; .)
    -               reduce using rule 5 (sentencia -> func ; .)
    +               reduce using rule 5 (sentencia -> func ; .)
    (               reduce using rule 5 (sentencia -> func ; .)
    INT             reduce using rule 5 (sentencia -> func ; .)
    FLOAT           reduce using rule 5 (sentencia -> func ; .)
    NOT             reduce using rule 5 (sentencia -> func ; .)
    BOOL            reduce using rule 5 (sentencia -> func ; .)
    $end            reduce using rule 5 (sentencia -> func ; .)
    }               reduce using rule 5 (sentencia -> func ; .)
    ELSE            reduce using rule 5 (sentencia -> func ; .)


state 101

    (6) sentencia -> varAsig ; .

    RETURN          reduce using rule 6 (sentencia -> varAsig ; .)
    MENOSMENOS      reduce using rule 6 (sentencia -> varAsig ; .)
    MASMAS          reduce using rule 6 (sentencia -> varAsig ; .)
    IF              reduce using rule 6 (sentencia -> varAsig ; .)
    WHILE           reduce using rule 6 (sentencia -> varAsig ; .)
    DO              reduce using rule 6 (sentencia -> varAsig ; .)
    FOR             reduce using rule 6 (sentencia -> varAsig ; .)
    ID              reduce using rule 6 (sentencia -> varAsig ; .)
    PRINT           reduce using rule 6 (sentencia -> varAsig ; .)
    MULTIESCALAR    reduce using rule 6 (sentencia -> varAsig ; .)
    LENGTH          reduce using rule 6 (sentencia -> varAsig ; .)
    CAPITALIZAR     reduce using rule 6 (sentencia -> varAsig ; .)
    COLINEALES      reduce using rule 6 (sentencia -> varAsig ; .)
    STRING          reduce using rule 6 (sentencia -> varAsig ; .)
    {               reduce using rule 6 (sentencia -> varAsig ; .)
    -               reduce using rule 6 (sentencia -> varAsig ; .)
    +               reduce using rule 6 (sentencia -> varAsig ; .)
    (               reduce using rule 6 (sentencia -> varAsig ; .)
    INT             reduce using rule 6 (sentencia -> varAsig ; .)
    FLOAT           reduce using rule 6 (sentencia -> varAsig ; .)
    NOT             reduce using rule 6 (sentencia -> varAsig ; .)
    BOOL            reduce using rule 6 (sentencia -> varAsig ; .)
    $end            reduce using rule 6 (sentencia -> varAsig ; .)
    }               reduce using rule 6 (sentencia -> varAsig ; .)
    ELSE            reduce using rule 6 (sentencia -> varAsig ; .)


state 102

    (59) sIgual -> valores MENOSEQ . sIgual
    (58) sIgual -> . valores MASEQ sIgual
    (59) sIgual -> . valores MENOSEQ sIgual
    (60) sIgual -> . asig
    (34) valores -> . eMat
    (35) valores -> . expBool
    (36) valores -> . expString
    (37) valores -> . varYVals
    (38) valores -> . funcReturn
    (39) valores -> . reg
    (40) valores -> . ID . ID
    (61) asig -> . ID = asig
    (62) asig -> . ID . ID = asig
    (63) asig -> . vec
    (64) asig -> . valores
    (65) eMat -> . eMat + p
    (66) eMat -> . eMat - p
    (67) eMat -> . p
    (87) expBool -> . or ? expBool : expBool
    (88) expBool -> . or
    (83) expString -> . expString + STRING
    (84) expString -> . STRING
    (85) expString -> . varYVals
    (86) expString -> . funcString
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (20) funcReturn -> . funcInt
    (21) funcReturn -> . funcString
    (22) funcReturn -> . funcBool
    (46) reg -> . { campos }
    (31) vec -> . ID = [ elem ]
    (68) p -> . p * exp
    (69) p -> . p / exp
    (70) p -> . p % exp
    (71) p -> . exp
    (89) or -> . or OR and
    (90) or -> . and
    (25) funcString -> . CAPITALIZAR ( expString )
    (43) vecVal -> . ID m
    (23) funcInt -> . MULTIESCALAR ( vec , eMat , param )
    (24) funcInt -> . LENGTH ( vec )
    (26) funcBool -> . COLINEALES ( vec , vec )
    (72) exp -> . exp ^ iSing
    (73) exp -> . iSing
    (91) and -> . and AND eq
    (92) and -> . eq
    (74) iSing -> . - paren
    (75) iSing -> . + paren
    (76) iSing -> . paren
    (93) eq -> . eq EQEQ tBool
    (94) eq -> . eq DISTINTO tBool
    (95) eq -> . mayor
    (77) paren -> . ( eMat )
    (78) paren -> . INT
    (79) paren -> . varYVals
    (80) paren -> . FLOAT
    (81) paren -> . varsOps
    (82) paren -> . funcInt
    (96) mayor -> . tCompare > tCompare
    (97) mayor -> . menor
    (49) varsOps -> . MENOSMENOS sMM
    (50) varsOps -> . MASMAS sMM
    (51) varsOps -> . sMM
    (106) tCompare -> . eMat
    (107) tCompare -> . varsOps
    (108) tCompare -> . varYVals
    (98) menor -> . tCompare < tCompare
    (99) menor -> . not
    (52) sMM -> . ID MASMAS
    (53) sMM -> . ID MENOSMENOS
    (54) sMM -> . ID
    (100) not -> . NOT not
    (101) not -> . tBool
    (102) tBool -> . ( expBool )
    (103) tBool -> . BOOL
    (104) tBool -> . varYVals
    (105) tBool -> . funcBool

    ID              shift and go to state 156
    STRING          shift and go to state 51
    {               shift and go to state 32
    CAPITALIZAR     shift and go to state 57
    MULTIESCALAR    shift and go to state 55
    LENGTH          shift and go to state 11
    COLINEALES      shift and go to state 1
    -               shift and go to state 50
    +               shift and go to state 20
    (               shift and go to state 5
    INT             shift and go to state 27
    FLOAT           shift and go to state 56
    MENOSMENOS      shift and go to state 23
    MASMAS          shift and go to state 28
    NOT             shift and go to state 30
    BOOL            shift and go to state 41

    and                            shift and go to state 44
    funcBool                       shift and go to state 2
    funcInt                        shift and go to state 14
    menor                          shift and go to state 3
    eq                             shift and go to state 16
    vecVal                         shift and go to state 47
    eMat                           shift and go to state 49
    asig                           shift and go to state 19
    mayor                          shift and go to state 4
    sMM                            shift and go to state 6
    vec                            shift and go to state 7
    sIgual                         shift and go to state 155
    reg                            shift and go to state 22
    varsOps                        shift and go to state 64
    expString                      shift and go to state 24
    tCompare                       shift and go to state 37
    paren                          shift and go to state 36
    not                            shift and go to state 8
    funcString                     shift and go to state 92
    funcReturn                     shift and go to state 93
    valores                        shift and go to state 157
    p                              shift and go to state 10
    iSing                          shift and go to state 12
    exp                            shift and go to state 59
    tBool                          shift and go to state 31
    varYVals                       shift and go to state 33
    or                             shift and go to state 34
    expBool                        shift and go to state 29

state 103

    (58) sIgual -> valores MASEQ . sIgual
    (58) sIgual -> . valores MASEQ sIgual
    (59) sIgual -> . valores MENOSEQ sIgual
    (60) sIgual -> . asig
    (34) valores -> . eMat
    (35) valores -> . expBool
    (36) valores -> . expString
    (37) valores -> . varYVals
    (38) valores -> . funcReturn
    (39) valores -> . reg
    (40) valores -> . ID . ID
    (61) asig -> . ID = asig
    (62) asig -> . ID . ID = asig
    (63) asig -> . vec
    (64) asig -> . valores
    (65) eMat -> . eMat + p
    (66) eMat -> . eMat - p
    (67) eMat -> . p
    (87) expBool -> . or ? expBool : expBool
    (88) expBool -> . or
    (83) expString -> . expString + STRING
    (84) expString -> . STRING
    (85) expString -> . varYVals
    (86) expString -> . funcString
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (20) funcReturn -> . funcInt
    (21) funcReturn -> . funcString
    (22) funcReturn -> . funcBool
    (46) reg -> . { campos }
    (31) vec -> . ID = [ elem ]
    (68) p -> . p * exp
    (69) p -> . p / exp
    (70) p -> . p % exp
    (71) p -> . exp
    (89) or -> . or OR and
    (90) or -> . and
    (25) funcString -> . CAPITALIZAR ( expString )
    (43) vecVal -> . ID m
    (23) funcInt -> . MULTIESCALAR ( vec , eMat , param )
    (24) funcInt -> . LENGTH ( vec )
    (26) funcBool -> . COLINEALES ( vec , vec )
    (72) exp -> . exp ^ iSing
    (73) exp -> . iSing
    (91) and -> . and AND eq
    (92) and -> . eq
    (74) iSing -> . - paren
    (75) iSing -> . + paren
    (76) iSing -> . paren
    (93) eq -> . eq EQEQ tBool
    (94) eq -> . eq DISTINTO tBool
    (95) eq -> . mayor
    (77) paren -> . ( eMat )
    (78) paren -> . INT
    (79) paren -> . varYVals
    (80) paren -> . FLOAT
    (81) paren -> . varsOps
    (82) paren -> . funcInt
    (96) mayor -> . tCompare > tCompare
    (97) mayor -> . menor
    (49) varsOps -> . MENOSMENOS sMM
    (50) varsOps -> . MASMAS sMM
    (51) varsOps -> . sMM
    (106) tCompare -> . eMat
    (107) tCompare -> . varsOps
    (108) tCompare -> . varYVals
    (98) menor -> . tCompare < tCompare
    (99) menor -> . not
    (52) sMM -> . ID MASMAS
    (53) sMM -> . ID MENOSMENOS
    (54) sMM -> . ID
    (100) not -> . NOT not
    (101) not -> . tBool
    (102) tBool -> . ( expBool )
    (103) tBool -> . BOOL
    (104) tBool -> . varYVals
    (105) tBool -> . funcBool

    ID              shift and go to state 156
    STRING          shift and go to state 51
    {               shift and go to state 32
    CAPITALIZAR     shift and go to state 57
    MULTIESCALAR    shift and go to state 55
    LENGTH          shift and go to state 11
    COLINEALES      shift and go to state 1
    -               shift and go to state 50
    +               shift and go to state 20
    (               shift and go to state 5
    INT             shift and go to state 27
    FLOAT           shift and go to state 56
    MENOSMENOS      shift and go to state 23
    MASMAS          shift and go to state 28
    NOT             shift and go to state 30
    BOOL            shift and go to state 41

    and                            shift and go to state 44
    funcBool                       shift and go to state 2
    funcInt                        shift and go to state 14
    menor                          shift and go to state 3
    eq                             shift and go to state 16
    vecVal                         shift and go to state 47
    eMat                           shift and go to state 49
    asig                           shift and go to state 19
    mayor                          shift and go to state 4
    sMM                            shift and go to state 6
    vec                            shift and go to state 7
    sIgual                         shift and go to state 158
    reg                            shift and go to state 22
    varsOps                        shift and go to state 64
    expString                      shift and go to state 24
    tCompare                       shift and go to state 37
    paren                          shift and go to state 36
    not                            shift and go to state 8
    funcString                     shift and go to state 92
    funcReturn                     shift and go to state 93
    valores                        shift and go to state 157
    p                              shift and go to state 10
    iSing                          shift and go to state 12
    exp                            shift and go to state 59
    tBool                          shift and go to state 31
    varYVals                       shift and go to state 33
    or                             shift and go to state 34
    expBool                        shift and go to state 29

state 104

    (55) varAsig -> valores MULEQ . varAsig
    (55) varAsig -> . valores MULEQ varAsig
    (56) varAsig -> . valores DIVEQ varAsig
    (57) varAsig -> . sIgual
    (34) valores -> . eMat
    (35) valores -> . expBool
    (36) valores -> . expString
    (37) valores -> . varYVals
    (38) valores -> . funcReturn
    (39) valores -> . reg
    (40) valores -> . ID . ID
    (58) sIgual -> . valores MASEQ sIgual
    (59) sIgual -> . valores MENOSEQ sIgual
    (60) sIgual -> . asig
    (65) eMat -> . eMat + p
    (66) eMat -> . eMat - p
    (67) eMat -> . p
    (87) expBool -> . or ? expBool : expBool
    (88) expBool -> . or
    (83) expString -> . expString + STRING
    (84) expString -> . STRING
    (85) expString -> . varYVals
    (86) expString -> . funcString
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (20) funcReturn -> . funcInt
    (21) funcReturn -> . funcString
    (22) funcReturn -> . funcBool
    (46) reg -> . { campos }
    (61) asig -> . ID = asig
    (62) asig -> . ID . ID = asig
    (63) asig -> . vec
    (64) asig -> . valores
    (68) p -> . p * exp
    (69) p -> . p / exp
    (70) p -> . p % exp
    (71) p -> . exp
    (89) or -> . or OR and
    (90) or -> . and
    (25) funcString -> . CAPITALIZAR ( expString )
    (43) vecVal -> . ID m
    (23) funcInt -> . MULTIESCALAR ( vec , eMat , param )
    (24) funcInt -> . LENGTH ( vec )
    (26) funcBool -> . COLINEALES ( vec , vec )
    (31) vec -> . ID = [ elem ]
    (72) exp -> . exp ^ iSing
    (73) exp -> . iSing
    (91) and -> . and AND eq
    (92) and -> . eq
    (74) iSing -> . - paren
    (75) iSing -> . + paren
    (76) iSing -> . paren
    (93) eq -> . eq EQEQ tBool
    (94) eq -> . eq DISTINTO tBool
    (95) eq -> . mayor
    (77) paren -> . ( eMat )
    (78) paren -> . INT
    (79) paren -> . varYVals
    (80) paren -> . FLOAT
    (81) paren -> . varsOps
    (82) paren -> . funcInt
    (96) mayor -> . tCompare > tCompare
    (97) mayor -> . menor
    (49) varsOps -> . MENOSMENOS sMM
    (50) varsOps -> . MASMAS sMM
    (51) varsOps -> . sMM
    (106) tCompare -> . eMat
    (107) tCompare -> . varsOps
    (108) tCompare -> . varYVals
    (98) menor -> . tCompare < tCompare
    (99) menor -> . not
    (52) sMM -> . ID MASMAS
    (53) sMM -> . ID MENOSMENOS
    (54) sMM -> . ID
    (100) not -> . NOT not
    (101) not -> . tBool
    (102) tBool -> . ( expBool )
    (103) tBool -> . BOOL
    (104) tBool -> . varYVals
    (105) tBool -> . funcBool

    ID              shift and go to state 137
    STRING          shift and go to state 51
    {               shift and go to state 32
    CAPITALIZAR     shift and go to state 57
    MULTIESCALAR    shift and go to state 55
    LENGTH          shift and go to state 11
    COLINEALES      shift and go to state 1
    -               shift and go to state 50
    +               shift and go to state 20
    (               shift and go to state 5
    INT             shift and go to state 27
    FLOAT           shift and go to state 56
    MENOSMENOS      shift and go to state 23
    MASMAS          shift and go to state 28
    NOT             shift and go to state 30
    BOOL            shift and go to state 41

    and                            shift and go to state 44
    funcBool                       shift and go to state 2
    funcInt                        shift and go to state 14
    menor                          shift and go to state 3
    eq                             shift and go to state 16
    vecVal                         shift and go to state 47
    eMat                           shift and go to state 49
    asig                           shift and go to state 19
    mayor                          shift and go to state 4
    sMM                            shift and go to state 6
    vec                            shift and go to state 7
    sIgual                         shift and go to state 21
    reg                            shift and go to state 22
    varsOps                        shift and go to state 64
    expString                      shift and go to state 24
    tCompare                       shift and go to state 37
    paren                          shift and go to state 36
    not                            shift and go to state 8
    varAsig                        shift and go to state 159
    funcString                     shift and go to state 92
    funcReturn                     shift and go to state 93
    valores                        shift and go to state 40
    p                              shift and go to state 10
    iSing                          shift and go to state 12
    exp                            shift and go to state 59
    tBool                          shift and go to state 31
    varYVals                       shift and go to state 33
    or                             shift and go to state 34
    expBool                        shift and go to state 29

state 105

    (56) varAsig -> valores DIVEQ . varAsig
    (55) varAsig -> . valores MULEQ varAsig
    (56) varAsig -> . valores DIVEQ varAsig
    (57) varAsig -> . sIgual
    (34) valores -> . eMat
    (35) valores -> . expBool
    (36) valores -> . expString
    (37) valores -> . varYVals
    (38) valores -> . funcReturn
    (39) valores -> . reg
    (40) valores -> . ID . ID
    (58) sIgual -> . valores MASEQ sIgual
    (59) sIgual -> . valores MENOSEQ sIgual
    (60) sIgual -> . asig
    (65) eMat -> . eMat + p
    (66) eMat -> . eMat - p
    (67) eMat -> . p
    (87) expBool -> . or ? expBool : expBool
    (88) expBool -> . or
    (83) expString -> . expString + STRING
    (84) expString -> . STRING
    (85) expString -> . varYVals
    (86) expString -> . funcString
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (20) funcReturn -> . funcInt
    (21) funcReturn -> . funcString
    (22) funcReturn -> . funcBool
    (46) reg -> . { campos }
    (61) asig -> . ID = asig
    (62) asig -> . ID . ID = asig
    (63) asig -> . vec
    (64) asig -> . valores
    (68) p -> . p * exp
    (69) p -> . p / exp
    (70) p -> . p % exp
    (71) p -> . exp
    (89) or -> . or OR and
    (90) or -> . and
    (25) funcString -> . CAPITALIZAR ( expString )
    (43) vecVal -> . ID m
    (23) funcInt -> . MULTIESCALAR ( vec , eMat , param )
    (24) funcInt -> . LENGTH ( vec )
    (26) funcBool -> . COLINEALES ( vec , vec )
    (31) vec -> . ID = [ elem ]
    (72) exp -> . exp ^ iSing
    (73) exp -> . iSing
    (91) and -> . and AND eq
    (92) and -> . eq
    (74) iSing -> . - paren
    (75) iSing -> . + paren
    (76) iSing -> . paren
    (93) eq -> . eq EQEQ tBool
    (94) eq -> . eq DISTINTO tBool
    (95) eq -> . mayor
    (77) paren -> . ( eMat )
    (78) paren -> . INT
    (79) paren -> . varYVals
    (80) paren -> . FLOAT
    (81) paren -> . varsOps
    (82) paren -> . funcInt
    (96) mayor -> . tCompare > tCompare
    (97) mayor -> . menor
    (49) varsOps -> . MENOSMENOS sMM
    (50) varsOps -> . MASMAS sMM
    (51) varsOps -> . sMM
    (106) tCompare -> . eMat
    (107) tCompare -> . varsOps
    (108) tCompare -> . varYVals
    (98) menor -> . tCompare < tCompare
    (99) menor -> . not
    (52) sMM -> . ID MASMAS
    (53) sMM -> . ID MENOSMENOS
    (54) sMM -> . ID
    (100) not -> . NOT not
    (101) not -> . tBool
    (102) tBool -> . ( expBool )
    (103) tBool -> . BOOL
    (104) tBool -> . varYVals
    (105) tBool -> . funcBool

    ID              shift and go to state 137
    STRING          shift and go to state 51
    {               shift and go to state 32
    CAPITALIZAR     shift and go to state 57
    MULTIESCALAR    shift and go to state 55
    LENGTH          shift and go to state 11
    COLINEALES      shift and go to state 1
    -               shift and go to state 50
    +               shift and go to state 20
    (               shift and go to state 5
    INT             shift and go to state 27
    FLOAT           shift and go to state 56
    MENOSMENOS      shift and go to state 23
    MASMAS          shift and go to state 28
    NOT             shift and go to state 30
    BOOL            shift and go to state 41

    and                            shift and go to state 44
    funcBool                       shift and go to state 2
    funcInt                        shift and go to state 14
    menor                          shift and go to state 3
    eq                             shift and go to state 16
    vecVal                         shift and go to state 47
    eMat                           shift and go to state 49
    asig                           shift and go to state 19
    mayor                          shift and go to state 4
    sMM                            shift and go to state 6
    vec                            shift and go to state 7
    sIgual                         shift and go to state 21
    reg                            shift and go to state 22
    varsOps                        shift and go to state 64
    expString                      shift and go to state 24
    tCompare                       shift and go to state 37
    paren                          shift and go to state 36
    not                            shift and go to state 8
    varAsig                        shift and go to state 160
    funcString                     shift and go to state 92
    funcReturn                     shift and go to state 93
    valores                        shift and go to state 40
    p                              shift and go to state 10
    iSing                          shift and go to state 12
    exp                            shift and go to state 59
    tBool                          shift and go to state 31
    varYVals                       shift and go to state 33
    or                             shift and go to state 34
    expBool                        shift and go to state 29

state 106

    (91) and -> and AND . eq
    (93) eq -> . eq EQEQ tBool
    (94) eq -> . eq DISTINTO tBool
    (95) eq -> . mayor
    (96) mayor -> . tCompare > tCompare
    (97) mayor -> . menor
    (106) tCompare -> . eMat
    (107) tCompare -> . varsOps
    (108) tCompare -> . varYVals
    (98) menor -> . tCompare < tCompare
    (99) menor -> . not
    (65) eMat -> . eMat + p
    (66) eMat -> . eMat - p
    (67) eMat -> . p
    (49) varsOps -> . MENOSMENOS sMM
    (50) varsOps -> . MASMAS sMM
    (51) varsOps -> . sMM
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (100) not -> . NOT not
    (101) not -> . tBool
    (68) p -> . p * exp
    (69) p -> . p / exp
    (70) p -> . p % exp
    (71) p -> . exp
    (52) sMM -> . ID MASMAS
    (53) sMM -> . ID MENOSMENOS
    (54) sMM -> . ID
    (43) vecVal -> . ID m
    (102) tBool -> . ( expBool )
    (103) tBool -> . BOOL
    (104) tBool -> . varYVals
    (105) tBool -> . funcBool
    (72) exp -> . exp ^ iSing
    (73) exp -> . iSing
    (26) funcBool -> . COLINEALES ( vec , vec )
    (74) iSing -> . - paren
    (75) iSing -> . + paren
    (76) iSing -> . paren
    (77) paren -> . ( eMat )
    (78) paren -> . INT
    (79) paren -> . varYVals
    (80) paren -> . FLOAT
    (81) paren -> . varsOps
    (82) paren -> . funcInt
    (23) funcInt -> . MULTIESCALAR ( vec , eMat , param )
    (24) funcInt -> . LENGTH ( vec )

    MENOSMENOS      shift and go to state 23
    MASMAS          shift and go to state 28
    ID              shift and go to state 143
    NOT             shift and go to state 30
    (               shift and go to state 142
    BOOL            shift and go to state 41
    COLINEALES      shift and go to state 1
    -               shift and go to state 50
    +               shift and go to state 20
    INT             shift and go to state 27
    FLOAT           shift and go to state 56
    MULTIESCALAR    shift and go to state 55
    LENGTH          shift and go to state 11

    funcBool                       shift and go to state 61
    funcInt                        shift and go to state 62
    menor                          shift and go to state 3
    eq                             shift and go to state 161
    vecVal                         shift and go to state 47
    eMat                           shift and go to state 141
    mayor                          shift and go to state 4
    sMM                            shift and go to state 6
    paren                          shift and go to state 36
    iSing                          shift and go to state 12
    tCompare                       shift and go to state 37
    not                            shift and go to state 8
    p                              shift and go to state 10
    varsOps                        shift and go to state 144
    exp                            shift and go to state 59
    tBool                          shift and go to state 31
    varYVals                       shift and go to state 145

state 107

    (11) loop -> DO bloque . WHILE ( expBool ) ;

    WHILE           shift and go to state 162


state 108

    (16) bloque -> sentencia .

    RETURN          reduce using rule 16 (bloque -> sentencia .)
    MENOSMENOS      reduce using rule 16 (bloque -> sentencia .)
    MASMAS          reduce using rule 16 (bloque -> sentencia .)
    IF              reduce using rule 16 (bloque -> sentencia .)
    WHILE           reduce using rule 16 (bloque -> sentencia .)
    DO              reduce using rule 16 (bloque -> sentencia .)
    FOR             reduce using rule 16 (bloque -> sentencia .)
    ID              reduce using rule 16 (bloque -> sentencia .)
    PRINT           reduce using rule 16 (bloque -> sentencia .)
    MULTIESCALAR    reduce using rule 16 (bloque -> sentencia .)
    LENGTH          reduce using rule 16 (bloque -> sentencia .)
    CAPITALIZAR     reduce using rule 16 (bloque -> sentencia .)
    COLINEALES      reduce using rule 16 (bloque -> sentencia .)
    STRING          reduce using rule 16 (bloque -> sentencia .)
    {               reduce using rule 16 (bloque -> sentencia .)
    -               reduce using rule 16 (bloque -> sentencia .)
    +               reduce using rule 16 (bloque -> sentencia .)
    (               reduce using rule 16 (bloque -> sentencia .)
    INT             reduce using rule 16 (bloque -> sentencia .)
    FLOAT           reduce using rule 16 (bloque -> sentencia .)
    NOT             reduce using rule 16 (bloque -> sentencia .)
    BOOL            reduce using rule 16 (bloque -> sentencia .)
    $end            reduce using rule 16 (bloque -> sentencia .)
    }               reduce using rule 16 (bloque -> sentencia .)
    ELSE            reduce using rule 16 (bloque -> sentencia .)


state 109

    (17) bloque -> { . g }
    (46) reg -> { . campos }
    (1) g -> . sentencia g
    (2) g -> . ctrl g
    (3) g -> . empty
    (47) campos -> . ID : valores , campos
    (48) campos -> . valores
    (4) sentencia -> . varsOps ;
    (5) sentencia -> . func ;
    (6) sentencia -> . varAsig ;
    (7) sentencia -> . RETURN ;
    (8) ctrl -> . if
    (9) ctrl -> . loop
    (30) empty -> .
    (34) valores -> . eMat
    (35) valores -> . expBool
    (36) valores -> . expString
    (37) valores -> . varYVals
    (38) valores -> . funcReturn
    (39) valores -> . reg
    (40) valores -> . ID . ID
    (49) varsOps -> . MENOSMENOS sMM
    (50) varsOps -> . MASMAS sMM
    (51) varsOps -> . sMM
    (18) func -> . funcReturn
    (19) func -> . funcVoid
    (55) varAsig -> . valores MULEQ varAsig
    (56) varAsig -> . valores DIVEQ varAsig
    (57) varAsig -> . sIgual
    (13) if -> . IF ( expBool ) THEN bloque else
    (10) loop -> . WHILE ( expBool ) bloque
    (11) loop -> . DO bloque WHILE ( expBool ) ;
    (12) loop -> . FOR ( varAsig ; expBool ; varsOps ) bloque
    (65) eMat -> . eMat + p
    (66) eMat -> . eMat - p
    (67) eMat -> . p
    (87) expBool -> . or ? expBool : expBool
    (88) expBool -> . or
    (83) expString -> . expString + STRING
    (84) expString -> . STRING
    (85) expString -> . varYVals
    (86) expString -> . funcString
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (20) funcReturn -> . funcInt
    (21) funcReturn -> . funcString
    (22) funcReturn -> . funcBool
    (46) reg -> . { campos }
    (52) sMM -> . ID MASMAS
    (53) sMM -> . ID MENOSMENOS
    (54) sMM -> . ID
    (27) funcVoid -> . PRINT ( valores )
    (58) sIgual -> . valores MASEQ sIgual
    (59) sIgual -> . valores MENOSEQ sIgual
    (60) sIgual -> . asig
    (68) p -> . p * exp
    (69) p -> . p / exp
    (70) p -> . p % exp
    (71) p -> . exp
    (89) or -> . or OR and
    (90) or -> . and
    (25) funcString -> . CAPITALIZAR ( expString )
    (43) vecVal -> . ID m
    (23) funcInt -> . MULTIESCALAR ( vec , eMat , param )
    (24) funcInt -> . LENGTH ( vec )
    (26) funcBool -> . COLINEALES ( vec , vec )
    (61) asig -> . ID = asig
    (62) asig -> . ID . ID = asig
    (63) asig -> . vec
    (64) asig -> . valores
    (72) exp -> . exp ^ iSing
    (73) exp -> . iSing
    (91) and -> . and AND eq
    (92) and -> . eq
    (31) vec -> . ID = [ elem ]
    (74) iSing -> . - paren
    (75) iSing -> . + paren
    (76) iSing -> . paren
    (93) eq -> . eq EQEQ tBool
    (94) eq -> . eq DISTINTO tBool
    (95) eq -> . mayor
    (77) paren -> . ( eMat )
    (78) paren -> . INT
    (79) paren -> . varYVals
    (80) paren -> . FLOAT
    (81) paren -> . varsOps
    (82) paren -> . funcInt
    (96) mayor -> . tCompare > tCompare
    (97) mayor -> . menor
    (106) tCompare -> . eMat
    (107) tCompare -> . varsOps
    (108) tCompare -> . varYVals
    (98) menor -> . tCompare < tCompare
    (99) menor -> . not
    (100) not -> . NOT not
    (101) not -> . tBool
    (102) tBool -> . ( expBool )
    (103) tBool -> . BOOL
    (104) tBool -> . varYVals
    (105) tBool -> . funcBool

    ID              shift and go to state 166
    RETURN          shift and go to state 13
    }               reduce using rule 30 (empty -> .)
    MENOSMENOS      shift and go to state 23
    MASMAS          shift and go to state 28
    IF              shift and go to state 53
    WHILE           shift and go to state 35
    DO              shift and go to state 45
    FOR             shift and go to state 18
    STRING          shift and go to state 51
    {               shift and go to state 32
    PRINT           shift and go to state 15
    CAPITALIZAR     shift and go to state 57
    MULTIESCALAR    shift and go to state 55
    LENGTH          shift and go to state 11
    COLINEALES      shift and go to state 1
    -               shift and go to state 50
    +               shift and go to state 20
    (               shift and go to state 5
    INT             shift and go to state 27
    FLOAT           shift and go to state 56
    NOT             shift and go to state 30
    BOOL            shift and go to state 41

    and                            shift and go to state 44
    funcBool                       shift and go to state 2
    ctrl                           shift and go to state 46
    funcInt                        shift and go to state 14
    menor                          shift and go to state 3
    loop                           shift and go to state 43
    eq                             shift and go to state 16
    vecVal                         shift and go to state 47
    if                             shift and go to state 48
    sentencia                      shift and go to state 17
    eMat                           shift and go to state 49
    asig                           shift and go to state 19
    mayor                          shift and go to state 4
    sMM                            shift and go to state 6
    vec                            shift and go to state 7
    sIgual                         shift and go to state 21
    reg                            shift and go to state 22
    empty                          shift and go to state 42
    iSing                          shift and go to state 12
    funcVoid                       shift and go to state 54
    expString                      shift and go to state 24
    tCompare                       shift and go to state 37
    campos                         shift and go to state 90
    func                           shift and go to state 38
    paren                          shift and go to state 36
    not                            shift and go to state 8
    varAsig                        shift and go to state 39
    g                              shift and go to state 164
    funcString                     shift and go to state 92
    funcReturn                     shift and go to state 163
    valores                        shift and go to state 165
    p                              shift and go to state 10
    varsOps                        shift and go to state 58
    exp                            shift and go to state 59
    tBool                          shift and go to state 31
    varYVals                       shift and go to state 33
    or                             shift and go to state 34
    expBool                        shift and go to state 29

state 110

    (2) g -> ctrl g .

    $end            reduce using rule 2 (g -> ctrl g .)
    }               reduce using rule 2 (g -> ctrl g .)


state 111

    (65) eMat -> eMat + . p
    (68) p -> . p * exp
    (69) p -> . p / exp
    (70) p -> . p % exp
    (71) p -> . exp
    (72) exp -> . exp ^ iSing
    (73) exp -> . iSing
    (74) iSing -> . - paren
    (75) iSing -> . + paren
    (76) iSing -> . paren
    (77) paren -> . ( eMat )
    (78) paren -> . INT
    (79) paren -> . varYVals
    (80) paren -> . FLOAT
    (81) paren -> . varsOps
    (82) paren -> . funcInt
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (49) varsOps -> . MENOSMENOS sMM
    (50) varsOps -> . MASMAS sMM
    (51) varsOps -> . sMM
    (23) funcInt -> . MULTIESCALAR ( vec , eMat , param )
    (24) funcInt -> . LENGTH ( vec )
    (43) vecVal -> . ID m
    (52) sMM -> . ID MASMAS
    (53) sMM -> . ID MENOSMENOS
    (54) sMM -> . ID

    -               shift and go to state 50
    +               shift and go to state 20
    (               shift and go to state 78
    INT             shift and go to state 27
    FLOAT           shift and go to state 56
    ID              shift and go to state 65
    MENOSMENOS      shift and go to state 23
    MASMAS          shift and go to state 28
    MULTIESCALAR    shift and go to state 55
    LENGTH          shift and go to state 11

    funcInt                        shift and go to state 62
    p                              shift and go to state 167
    sMM                            shift and go to state 6
    iSing                          shift and go to state 12
    exp                            shift and go to state 59
    paren                          shift and go to state 36
    varYVals                       shift and go to state 81
    vecVal                         shift and go to state 47
    varsOps                        shift and go to state 79

state 112

    (66) eMat -> eMat - . p
    (68) p -> . p * exp
    (69) p -> . p / exp
    (70) p -> . p % exp
    (71) p -> . exp
    (72) exp -> . exp ^ iSing
    (73) exp -> . iSing
    (74) iSing -> . - paren
    (75) iSing -> . + paren
    (76) iSing -> . paren
    (77) paren -> . ( eMat )
    (78) paren -> . INT
    (79) paren -> . varYVals
    (80) paren -> . FLOAT
    (81) paren -> . varsOps
    (82) paren -> . funcInt
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (49) varsOps -> . MENOSMENOS sMM
    (50) varsOps -> . MASMAS sMM
    (51) varsOps -> . sMM
    (23) funcInt -> . MULTIESCALAR ( vec , eMat , param )
    (24) funcInt -> . LENGTH ( vec )
    (43) vecVal -> . ID m
    (52) sMM -> . ID MASMAS
    (53) sMM -> . ID MENOSMENOS
    (54) sMM -> . ID

    -               shift and go to state 50
    +               shift and go to state 20
    (               shift and go to state 78
    INT             shift and go to state 27
    FLOAT           shift and go to state 56
    ID              shift and go to state 65
    MENOSMENOS      shift and go to state 23
    MASMAS          shift and go to state 28
    MULTIESCALAR    shift and go to state 55
    LENGTH          shift and go to state 11

    funcInt                        shift and go to state 62
    p                              shift and go to state 168
    sMM                            shift and go to state 6
    iSing                          shift and go to state 12
    exp                            shift and go to state 59
    paren                          shift and go to state 36
    varYVals                       shift and go to state 81
    vecVal                         shift and go to state 47
    varsOps                        shift and go to state 79

state 113

    (74) iSing -> - paren .

    ^               reduce using rule 74 (iSing -> - paren .)
    *               reduce using rule 74 (iSing -> - paren .)
    /               reduce using rule 74 (iSing -> - paren .)
    %               reduce using rule 74 (iSing -> - paren .)
    +               reduce using rule 74 (iSing -> - paren .)
    -               reduce using rule 74 (iSing -> - paren .)
    >               reduce using rule 74 (iSing -> - paren .)
    <               reduce using rule 74 (iSing -> - paren .)
    ;               reduce using rule 74 (iSing -> - paren .)
    ,               reduce using rule 74 (iSing -> - paren .)
    ]               reduce using rule 74 (iSing -> - paren .)
    MULEQ           reduce using rule 74 (iSing -> - paren .)
    DIVEQ           reduce using rule 74 (iSing -> - paren .)
    MASEQ           reduce using rule 74 (iSing -> - paren .)
    MENOSEQ         reduce using rule 74 (iSing -> - paren .)
    EQEQ            reduce using rule 74 (iSing -> - paren .)
    DISTINTO        reduce using rule 74 (iSing -> - paren .)
    AND             reduce using rule 74 (iSing -> - paren .)
    ?               reduce using rule 74 (iSing -> - paren .)
    OR              reduce using rule 74 (iSing -> - paren .)
    )               reduce using rule 74 (iSing -> - paren .)
    }               reduce using rule 74 (iSing -> - paren .)
    :               reduce using rule 74 (iSing -> - paren .)


state 114

    (43) vecVal -> ID m .

    ;               reduce using rule 43 (vecVal -> ID m .)
    +               reduce using rule 43 (vecVal -> ID m .)
    ^               reduce using rule 43 (vecVal -> ID m .)
    *               reduce using rule 43 (vecVal -> ID m .)
    /               reduce using rule 43 (vecVal -> ID m .)
    %               reduce using rule 43 (vecVal -> ID m .)
    -               reduce using rule 43 (vecVal -> ID m .)
    >               reduce using rule 43 (vecVal -> ID m .)
    <               reduce using rule 43 (vecVal -> ID m .)
    EQEQ            reduce using rule 43 (vecVal -> ID m .)
    DISTINTO        reduce using rule 43 (vecVal -> ID m .)
    AND             reduce using rule 43 (vecVal -> ID m .)
    ?               reduce using rule 43 (vecVal -> ID m .)
    OR              reduce using rule 43 (vecVal -> ID m .)
    }               reduce using rule 43 (vecVal -> ID m .)
    )               reduce using rule 43 (vecVal -> ID m .)
    MULEQ           reduce using rule 43 (vecVal -> ID m .)
    DIVEQ           reduce using rule 43 (vecVal -> ID m .)
    MASEQ           reduce using rule 43 (vecVal -> ID m .)
    MENOSEQ         reduce using rule 43 (vecVal -> ID m .)
    :               reduce using rule 43 (vecVal -> ID m .)
    ,               reduce using rule 43 (vecVal -> ID m .)
    ]               reduce using rule 43 (vecVal -> ID m .)


state 115

    (40) valores -> ID . . ID
    (62) asig -> ID . . ID = asig

    ID              shift and go to state 169


state 116

    (52) sMM -> ID MASMAS .

    ^               reduce using rule 52 (sMM -> ID MASMAS .)
    *               reduce using rule 52 (sMM -> ID MASMAS .)
    /               reduce using rule 52 (sMM -> ID MASMAS .)
    %               reduce using rule 52 (sMM -> ID MASMAS .)
    +               reduce using rule 52 (sMM -> ID MASMAS .)
    -               reduce using rule 52 (sMM -> ID MASMAS .)
    MULEQ           reduce using rule 52 (sMM -> ID MASMAS .)
    DIVEQ           reduce using rule 52 (sMM -> ID MASMAS .)
    MASEQ           reduce using rule 52 (sMM -> ID MASMAS .)
    MENOSEQ         reduce using rule 52 (sMM -> ID MASMAS .)
    ;               reduce using rule 52 (sMM -> ID MASMAS .)
    >               reduce using rule 52 (sMM -> ID MASMAS .)
    <               reduce using rule 52 (sMM -> ID MASMAS .)
    )               reduce using rule 52 (sMM -> ID MASMAS .)
    }               reduce using rule 52 (sMM -> ID MASMAS .)
    EQEQ            reduce using rule 52 (sMM -> ID MASMAS .)
    DISTINTO        reduce using rule 52 (sMM -> ID MASMAS .)
    AND             reduce using rule 52 (sMM -> ID MASMAS .)
    ?               reduce using rule 52 (sMM -> ID MASMAS .)
    OR              reduce using rule 52 (sMM -> ID MASMAS .)
    :               reduce using rule 52 (sMM -> ID MASMAS .)
    ,               reduce using rule 52 (sMM -> ID MASMAS .)
    ]               reduce using rule 52 (sMM -> ID MASMAS .)


state 117

    (44) m -> [ . INT ]
    (45) m -> [ . INT ] m

    INT             shift and go to state 170


state 118

    (61) asig -> ID = . asig
    (31) vec -> ID = . [ elem ]
    (61) asig -> . ID = asig
    (62) asig -> . ID . ID = asig
    (63) asig -> . vec
    (64) asig -> . valores
    (31) vec -> . ID = [ elem ]
    (34) valores -> . eMat
    (35) valores -> . expBool
    (36) valores -> . expString
    (37) valores -> . varYVals
    (38) valores -> . funcReturn
    (39) valores -> . reg
    (40) valores -> . ID . ID
    (65) eMat -> . eMat + p
    (66) eMat -> . eMat - p
    (67) eMat -> . p
    (87) expBool -> . or ? expBool : expBool
    (88) expBool -> . or
    (83) expString -> . expString + STRING
    (84) expString -> . STRING
    (85) expString -> . varYVals
    (86) expString -> . funcString
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (20) funcReturn -> . funcInt
    (21) funcReturn -> . funcString
    (22) funcReturn -> . funcBool
    (46) reg -> . { campos }
    (68) p -> . p * exp
    (69) p -> . p / exp
    (70) p -> . p % exp
    (71) p -> . exp
    (89) or -> . or OR and
    (90) or -> . and
    (25) funcString -> . CAPITALIZAR ( expString )
    (43) vecVal -> . ID m
    (23) funcInt -> . MULTIESCALAR ( vec , eMat , param )
    (24) funcInt -> . LENGTH ( vec )
    (26) funcBool -> . COLINEALES ( vec , vec )
    (72) exp -> . exp ^ iSing
    (73) exp -> . iSing
    (91) and -> . and AND eq
    (92) and -> . eq
    (74) iSing -> . - paren
    (75) iSing -> . + paren
    (76) iSing -> . paren
    (93) eq -> . eq EQEQ tBool
    (94) eq -> . eq DISTINTO tBool
    (95) eq -> . mayor
    (77) paren -> . ( eMat )
    (78) paren -> . INT
    (79) paren -> . varYVals
    (80) paren -> . FLOAT
    (81) paren -> . varsOps
    (82) paren -> . funcInt
    (96) mayor -> . tCompare > tCompare
    (97) mayor -> . menor
    (49) varsOps -> . MENOSMENOS sMM
    (50) varsOps -> . MASMAS sMM
    (51) varsOps -> . sMM
    (106) tCompare -> . eMat
    (107) tCompare -> . varsOps
    (108) tCompare -> . varYVals
    (98) menor -> . tCompare < tCompare
    (99) menor -> . not
    (52) sMM -> . ID MASMAS
    (53) sMM -> . ID MENOSMENOS
    (54) sMM -> . ID
    (100) not -> . NOT not
    (101) not -> . tBool
    (102) tBool -> . ( expBool )
    (103) tBool -> . BOOL
    (104) tBool -> . varYVals
    (105) tBool -> . funcBool

    [               shift and go to state 173
    ID              shift and go to state 174
    STRING          shift and go to state 51
    {               shift and go to state 32
    CAPITALIZAR     shift and go to state 57
    MULTIESCALAR    shift and go to state 55
    LENGTH          shift and go to state 11
    COLINEALES      shift and go to state 1
    -               shift and go to state 50
    +               shift and go to state 20
    (               shift and go to state 5
    INT             shift and go to state 27
    FLOAT           shift and go to state 56
    MENOSMENOS      shift and go to state 23
    MASMAS          shift and go to state 28
    NOT             shift and go to state 30
    BOOL            shift and go to state 41

    and                            shift and go to state 44
    funcBool                       shift and go to state 2
    funcInt                        shift and go to state 14
    valores                        shift and go to state 171
    menor                          shift and go to state 3
    eq                             shift and go to state 16
    vecVal                         shift and go to state 47
    eMat                           shift and go to state 49
    asig                           shift and go to state 172
    mayor                          shift and go to state 4
    sMM                            shift and go to state 6
    vec                            shift and go to state 7
    paren                          shift and go to state 36
    reg                            shift and go to state 22
    varsOps                        shift and go to state 64
    expString                      shift and go to state 24
    tCompare                       shift and go to state 37
    not                            shift and go to state 8
    funcString                     shift and go to state 92
    funcReturn                     shift and go to state 93
    p                              shift and go to state 10
    iSing                          shift and go to state 12
    exp                            shift and go to state 59
    tBool                          shift and go to state 31
    varYVals                       shift and go to state 33
    or                             shift and go to state 34
    expBool                        shift and go to state 29

state 119

    (53) sMM -> ID MENOSMENOS .

    ^               reduce using rule 53 (sMM -> ID MENOSMENOS .)
    *               reduce using rule 53 (sMM -> ID MENOSMENOS .)
    /               reduce using rule 53 (sMM -> ID MENOSMENOS .)
    %               reduce using rule 53 (sMM -> ID MENOSMENOS .)
    +               reduce using rule 53 (sMM -> ID MENOSMENOS .)
    -               reduce using rule 53 (sMM -> ID MENOSMENOS .)
    MULEQ           reduce using rule 53 (sMM -> ID MENOSMENOS .)
    DIVEQ           reduce using rule 53 (sMM -> ID MENOSMENOS .)
    MASEQ           reduce using rule 53 (sMM -> ID MENOSMENOS .)
    MENOSEQ         reduce using rule 53 (sMM -> ID MENOSMENOS .)
    ;               reduce using rule 53 (sMM -> ID MENOSMENOS .)
    >               reduce using rule 53 (sMM -> ID MENOSMENOS .)
    <               reduce using rule 53 (sMM -> ID MENOSMENOS .)
    )               reduce using rule 53 (sMM -> ID MENOSMENOS .)
    }               reduce using rule 53 (sMM -> ID MENOSMENOS .)
    EQEQ            reduce using rule 53 (sMM -> ID MENOSMENOS .)
    DISTINTO        reduce using rule 53 (sMM -> ID MENOSMENOS .)
    AND             reduce using rule 53 (sMM -> ID MENOSMENOS .)
    ?               reduce using rule 53 (sMM -> ID MENOSMENOS .)
    OR              reduce using rule 53 (sMM -> ID MENOSMENOS .)
    :               reduce using rule 53 (sMM -> ID MENOSMENOS .)
    ,               reduce using rule 53 (sMM -> ID MENOSMENOS .)
    ]               reduce using rule 53 (sMM -> ID MENOSMENOS .)


state 120

    (13) if -> IF ( . expBool ) THEN bloque else
    (87) expBool -> . or ? expBool : expBool
    (88) expBool -> . or
    (89) or -> . or OR and
    (90) or -> . and
    (91) and -> . and AND eq
    (92) and -> . eq
    (93) eq -> . eq EQEQ tBool
    (94) eq -> . eq DISTINTO tBool
    (95) eq -> . mayor
    (96) mayor -> . tCompare > tCompare
    (97) mayor -> . menor
    (106) tCompare -> . eMat
    (107) tCompare -> . varsOps
    (108) tCompare -> . varYVals
    (98) menor -> . tCompare < tCompare
    (99) menor -> . not
    (65) eMat -> . eMat + p
    (66) eMat -> . eMat - p
    (67) eMat -> . p
    (49) varsOps -> . MENOSMENOS sMM
    (50) varsOps -> . MASMAS sMM
    (51) varsOps -> . sMM
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (100) not -> . NOT not
    (101) not -> . tBool
    (68) p -> . p * exp
    (69) p -> . p / exp
    (70) p -> . p % exp
    (71) p -> . exp
    (52) sMM -> . ID MASMAS
    (53) sMM -> . ID MENOSMENOS
    (54) sMM -> . ID
    (43) vecVal -> . ID m
    (102) tBool -> . ( expBool )
    (103) tBool -> . BOOL
    (104) tBool -> . varYVals
    (105) tBool -> . funcBool
    (72) exp -> . exp ^ iSing
    (73) exp -> . iSing
    (26) funcBool -> . COLINEALES ( vec , vec )
    (74) iSing -> . - paren
    (75) iSing -> . + paren
    (76) iSing -> . paren
    (77) paren -> . ( eMat )
    (78) paren -> . INT
    (79) paren -> . varYVals
    (80) paren -> . FLOAT
    (81) paren -> . varsOps
    (82) paren -> . funcInt
    (23) funcInt -> . MULTIESCALAR ( vec , eMat , param )
    (24) funcInt -> . LENGTH ( vec )

    MENOSMENOS      shift and go to state 23
    MASMAS          shift and go to state 28
    ID              shift and go to state 143
    NOT             shift and go to state 30
    (               shift and go to state 142
    BOOL            shift and go to state 41
    COLINEALES      shift and go to state 1
    -               shift and go to state 50
    +               shift and go to state 20
    INT             shift and go to state 27
    FLOAT           shift and go to state 56
    MULTIESCALAR    shift and go to state 55
    LENGTH          shift and go to state 11

    and                            shift and go to state 44
    funcBool                       shift and go to state 61
    funcInt                        shift and go to state 62
    menor                          shift and go to state 3
    eq                             shift and go to state 16
    mayor                          shift and go to state 4
    eMat                           shift and go to state 141
    vecVal                         shift and go to state 47
    sMM                            shift and go to state 6
    paren                          shift and go to state 36
    varsOps                        shift and go to state 144
    tCompare                       shift and go to state 37
    not                            shift and go to state 8
    p                              shift and go to state 10
    iSing                          shift and go to state 12
    exp                            shift and go to state 59
    tBool                          shift and go to state 31
    varYVals                       shift and go to state 145
    or                             shift and go to state 34
    expBool                        shift and go to state 175

state 121

    (23) funcInt -> MULTIESCALAR ( . vec , eMat , param )
    (31) vec -> . ID = [ elem ]

    ID              shift and go to state 126

    vec                            shift and go to state 176

state 122

    (25) funcString -> CAPITALIZAR ( . expString )
    (83) expString -> . expString + STRING
    (84) expString -> . STRING
    (85) expString -> . varYVals
    (86) expString -> . funcString
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (25) funcString -> . CAPITALIZAR ( expString )
    (43) vecVal -> . ID m

    STRING          shift and go to state 51
    ID              shift and go to state 89
    CAPITALIZAR     shift and go to state 57

    funcString                     shift and go to state 178
    varYVals                       shift and go to state 179
    vecVal                         shift and go to state 47
    expString                      shift and go to state 177

state 123

    (4) sentencia -> varsOps ; .

    RETURN          reduce using rule 4 (sentencia -> varsOps ; .)
    MENOSMENOS      reduce using rule 4 (sentencia -> varsOps ; .)
    MASMAS          reduce using rule 4 (sentencia -> varsOps ; .)
    IF              reduce using rule 4 (sentencia -> varsOps ; .)
    WHILE           reduce using rule 4 (sentencia -> varsOps ; .)
    DO              reduce using rule 4 (sentencia -> varsOps ; .)
    FOR             reduce using rule 4 (sentencia -> varsOps ; .)
    ID              reduce using rule 4 (sentencia -> varsOps ; .)
    PRINT           reduce using rule 4 (sentencia -> varsOps ; .)
    MULTIESCALAR    reduce using rule 4 (sentencia -> varsOps ; .)
    LENGTH          reduce using rule 4 (sentencia -> varsOps ; .)
    CAPITALIZAR     reduce using rule 4 (sentencia -> varsOps ; .)
    COLINEALES      reduce using rule 4 (sentencia -> varsOps ; .)
    STRING          reduce using rule 4 (sentencia -> varsOps ; .)
    {               reduce using rule 4 (sentencia -> varsOps ; .)
    -               reduce using rule 4 (sentencia -> varsOps ; .)
    +               reduce using rule 4 (sentencia -> varsOps ; .)
    (               reduce using rule 4 (sentencia -> varsOps ; .)
    INT             reduce using rule 4 (sentencia -> varsOps ; .)
    FLOAT           reduce using rule 4 (sentencia -> varsOps ; .)
    NOT             reduce using rule 4 (sentencia -> varsOps ; .)
    BOOL            reduce using rule 4 (sentencia -> varsOps ; .)
    $end            reduce using rule 4 (sentencia -> varsOps ; .)
    }               reduce using rule 4 (sentencia -> varsOps ; .)
    ELSE            reduce using rule 4 (sentencia -> varsOps ; .)


state 124

    (72) exp -> exp ^ . iSing
    (74) iSing -> . - paren
    (75) iSing -> . + paren
    (76) iSing -> . paren
    (77) paren -> . ( eMat )
    (78) paren -> . INT
    (79) paren -> . varYVals
    (80) paren -> . FLOAT
    (81) paren -> . varsOps
    (82) paren -> . funcInt
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (49) varsOps -> . MENOSMENOS sMM
    (50) varsOps -> . MASMAS sMM
    (51) varsOps -> . sMM
    (23) funcInt -> . MULTIESCALAR ( vec , eMat , param )
    (24) funcInt -> . LENGTH ( vec )
    (43) vecVal -> . ID m
    (52) sMM -> . ID MASMAS
    (53) sMM -> . ID MENOSMENOS
    (54) sMM -> . ID

    -               shift and go to state 50
    +               shift and go to state 20
    (               shift and go to state 78
    INT             shift and go to state 27
    FLOAT           shift and go to state 56
    ID              shift and go to state 65
    MENOSMENOS      shift and go to state 23
    MASMAS          shift and go to state 28
    MULTIESCALAR    shift and go to state 55
    LENGTH          shift and go to state 11

    funcInt                        shift and go to state 62
    sMM                            shift and go to state 6
    varsOps                        shift and go to state 79
    paren                          shift and go to state 36
    varYVals                       shift and go to state 81
    vecVal                         shift and go to state 47
    iSing                          shift and go to state 180

state 125

    (26) funcBool -> COLINEALES ( vec . , vec )

    ,               shift and go to state 181


state 126

    (31) vec -> ID . = [ elem ]

    =               shift and go to state 182


state 127

    (77) paren -> ( eMat ) .

    ^               reduce using rule 77 (paren -> ( eMat ) .)
    *               reduce using rule 77 (paren -> ( eMat ) .)
    /               reduce using rule 77 (paren -> ( eMat ) .)
    %               reduce using rule 77 (paren -> ( eMat ) .)
    +               reduce using rule 77 (paren -> ( eMat ) .)
    -               reduce using rule 77 (paren -> ( eMat ) .)
    MULEQ           reduce using rule 77 (paren -> ( eMat ) .)
    DIVEQ           reduce using rule 77 (paren -> ( eMat ) .)
    MASEQ           reduce using rule 77 (paren -> ( eMat ) .)
    MENOSEQ         reduce using rule 77 (paren -> ( eMat ) .)
    ;               reduce using rule 77 (paren -> ( eMat ) .)
    >               reduce using rule 77 (paren -> ( eMat ) .)
    <               reduce using rule 77 (paren -> ( eMat ) .)
    )               reduce using rule 77 (paren -> ( eMat ) .)
    EQEQ            reduce using rule 77 (paren -> ( eMat ) .)
    DISTINTO        reduce using rule 77 (paren -> ( eMat ) .)
    AND             reduce using rule 77 (paren -> ( eMat ) .)
    ?               reduce using rule 77 (paren -> ( eMat ) .)
    OR              reduce using rule 77 (paren -> ( eMat ) .)
    }               reduce using rule 77 (paren -> ( eMat ) .)
    :               reduce using rule 77 (paren -> ( eMat ) .)
    ,               reduce using rule 77 (paren -> ( eMat ) .)
    ]               reduce using rule 77 (paren -> ( eMat ) .)


state 128

    (102) tBool -> ( expBool ) .

    EQEQ            reduce using rule 102 (tBool -> ( expBool ) .)
    DISTINTO        reduce using rule 102 (tBool -> ( expBool ) .)
    AND             reduce using rule 102 (tBool -> ( expBool ) .)
    ?               reduce using rule 102 (tBool -> ( expBool ) .)
    OR              reduce using rule 102 (tBool -> ( expBool ) .)
    )               reduce using rule 102 (tBool -> ( expBool ) .)
    MULEQ           reduce using rule 102 (tBool -> ( expBool ) .)
    DIVEQ           reduce using rule 102 (tBool -> ( expBool ) .)
    MASEQ           reduce using rule 102 (tBool -> ( expBool ) .)
    MENOSEQ         reduce using rule 102 (tBool -> ( expBool ) .)
    ;               reduce using rule 102 (tBool -> ( expBool ) .)
    }               reduce using rule 102 (tBool -> ( expBool ) .)
    :               reduce using rule 102 (tBool -> ( expBool ) .)
    ,               reduce using rule 102 (tBool -> ( expBool ) .)
    ]               reduce using rule 102 (tBool -> ( expBool ) .)


state 129

    (68) p -> p * exp .
    (72) exp -> exp . ^ iSing

    *               reduce using rule 68 (p -> p * exp .)
    /               reduce using rule 68 (p -> p * exp .)
    %               reduce using rule 68 (p -> p * exp .)
    +               reduce using rule 68 (p -> p * exp .)
    -               reduce using rule 68 (p -> p * exp .)
    MULEQ           reduce using rule 68 (p -> p * exp .)
    DIVEQ           reduce using rule 68 (p -> p * exp .)
    MASEQ           reduce using rule 68 (p -> p * exp .)
    MENOSEQ         reduce using rule 68 (p -> p * exp .)
    ;               reduce using rule 68 (p -> p * exp .)
    >               reduce using rule 68 (p -> p * exp .)
    <               reduce using rule 68 (p -> p * exp .)
    }               reduce using rule 68 (p -> p * exp .)
    )               reduce using rule 68 (p -> p * exp .)
    ,               reduce using rule 68 (p -> p * exp .)
    EQEQ            reduce using rule 68 (p -> p * exp .)
    DISTINTO        reduce using rule 68 (p -> p * exp .)
    AND             reduce using rule 68 (p -> p * exp .)
    ?               reduce using rule 68 (p -> p * exp .)
    OR              reduce using rule 68 (p -> p * exp .)
    :               reduce using rule 68 (p -> p * exp .)
    ]               reduce using rule 68 (p -> p * exp .)
    ^               shift and go to state 124


state 130

    (70) p -> p % exp .
    (72) exp -> exp . ^ iSing

    *               reduce using rule 70 (p -> p % exp .)
    /               reduce using rule 70 (p -> p % exp .)
    %               reduce using rule 70 (p -> p % exp .)
    +               reduce using rule 70 (p -> p % exp .)
    -               reduce using rule 70 (p -> p % exp .)
    MULEQ           reduce using rule 70 (p -> p % exp .)
    DIVEQ           reduce using rule 70 (p -> p % exp .)
    MASEQ           reduce using rule 70 (p -> p % exp .)
    MENOSEQ         reduce using rule 70 (p -> p % exp .)
    ;               reduce using rule 70 (p -> p % exp .)
    >               reduce using rule 70 (p -> p % exp .)
    <               reduce using rule 70 (p -> p % exp .)
    }               reduce using rule 70 (p -> p % exp .)
    )               reduce using rule 70 (p -> p % exp .)
    ,               reduce using rule 70 (p -> p % exp .)
    EQEQ            reduce using rule 70 (p -> p % exp .)
    DISTINTO        reduce using rule 70 (p -> p % exp .)
    AND             reduce using rule 70 (p -> p % exp .)
    ?               reduce using rule 70 (p -> p % exp .)
    OR              reduce using rule 70 (p -> p % exp .)
    :               reduce using rule 70 (p -> p % exp .)
    ]               reduce using rule 70 (p -> p % exp .)
    ^               shift and go to state 124


state 131

    (69) p -> p / exp .
    (72) exp -> exp . ^ iSing

    *               reduce using rule 69 (p -> p / exp .)
    /               reduce using rule 69 (p -> p / exp .)
    %               reduce using rule 69 (p -> p / exp .)
    +               reduce using rule 69 (p -> p / exp .)
    -               reduce using rule 69 (p -> p / exp .)
    MULEQ           reduce using rule 69 (p -> p / exp .)
    DIVEQ           reduce using rule 69 (p -> p / exp .)
    MASEQ           reduce using rule 69 (p -> p / exp .)
    MENOSEQ         reduce using rule 69 (p -> p / exp .)
    ;               reduce using rule 69 (p -> p / exp .)
    >               reduce using rule 69 (p -> p / exp .)
    <               reduce using rule 69 (p -> p / exp .)
    }               reduce using rule 69 (p -> p / exp .)
    )               reduce using rule 69 (p -> p / exp .)
    ,               reduce using rule 69 (p -> p / exp .)
    EQEQ            reduce using rule 69 (p -> p / exp .)
    DISTINTO        reduce using rule 69 (p -> p / exp .)
    AND             reduce using rule 69 (p -> p / exp .)
    ?               reduce using rule 69 (p -> p / exp .)
    OR              reduce using rule 69 (p -> p / exp .)
    :               reduce using rule 69 (p -> p / exp .)
    ]               reduce using rule 69 (p -> p / exp .)
    ^               shift and go to state 124


state 132

    (24) funcInt -> LENGTH ( vec . )

    )               shift and go to state 183


state 133

    (40) valores -> ID . . ID
    (41) varYVals -> ID .
    (43) vecVal -> ID . m
    (52) sMM -> ID . MASMAS
    (53) sMM -> ID . MENOSMENOS
    (54) sMM -> ID .
    (44) m -> . [ INT ]
    (45) m -> . [ INT ] m

  ! reduce/reduce conflict for ^ resolved using rule 41 (varYVals -> ID .)
  ! reduce/reduce conflict for * resolved using rule 41 (varYVals -> ID .)
  ! reduce/reduce conflict for / resolved using rule 41 (varYVals -> ID .)
  ! reduce/reduce conflict for % resolved using rule 41 (varYVals -> ID .)
  ! reduce/reduce conflict for + resolved using rule 41 (varYVals -> ID .)
  ! reduce/reduce conflict for - resolved using rule 41 (varYVals -> ID .)
  ! reduce/reduce conflict for , resolved using rule 41 (varYVals -> ID .)
  ! reduce/reduce conflict for ] resolved using rule 41 (varYVals -> ID .)
  ! reduce/reduce conflict for > resolved using rule 41 (varYVals -> ID .)
  ! reduce/reduce conflict for < resolved using rule 41 (varYVals -> ID .)
  ! reduce/reduce conflict for ) resolved using rule 41 (varYVals -> ID .)
    .               shift and go to state 147
    )               reduce using rule 41 (varYVals -> ID .)
    +               reduce using rule 41 (varYVals -> ID .)
    ^               reduce using rule 41 (varYVals -> ID .)
    *               reduce using rule 41 (varYVals -> ID .)
    /               reduce using rule 41 (varYVals -> ID .)
    %               reduce using rule 41 (varYVals -> ID .)
    -               reduce using rule 41 (varYVals -> ID .)
    >               reduce using rule 41 (varYVals -> ID .)
    <               reduce using rule 41 (varYVals -> ID .)
    EQEQ            reduce using rule 41 (varYVals -> ID .)
    DISTINTO        reduce using rule 41 (varYVals -> ID .)
    AND             reduce using rule 41 (varYVals -> ID .)
    ?               reduce using rule 41 (varYVals -> ID .)
    OR              reduce using rule 41 (varYVals -> ID .)
    ,               reduce using rule 41 (varYVals -> ID .)
    ]               reduce using rule 41 (varYVals -> ID .)
    MASMAS          shift and go to state 116
    MENOSMENOS      shift and go to state 119
    [               shift and go to state 117

  ! ^               [ reduce using rule 54 (sMM -> ID .) ]
  ! *               [ reduce using rule 54 (sMM -> ID .) ]
  ! /               [ reduce using rule 54 (sMM -> ID .) ]
  ! %               [ reduce using rule 54 (sMM -> ID .) ]
  ! +               [ reduce using rule 54 (sMM -> ID .) ]
  ! -               [ reduce using rule 54 (sMM -> ID .) ]
  ! ,               [ reduce using rule 54 (sMM -> ID .) ]
  ! ]               [ reduce using rule 54 (sMM -> ID .) ]
  ! >               [ reduce using rule 54 (sMM -> ID .) ]
  ! <               [ reduce using rule 54 (sMM -> ID .) ]
  ! )               [ reduce using rule 54 (sMM -> ID .) ]

    m                              shift and go to state 114

state 134

    (27) funcVoid -> PRINT ( valores . )

    )               shift and go to state 184


state 135

    (93) eq -> eq EQEQ tBool .

    EQEQ            reduce using rule 93 (eq -> eq EQEQ tBool .)
    DISTINTO        reduce using rule 93 (eq -> eq EQEQ tBool .)
    AND             reduce using rule 93 (eq -> eq EQEQ tBool .)
    ?               reduce using rule 93 (eq -> eq EQEQ tBool .)
    OR              reduce using rule 93 (eq -> eq EQEQ tBool .)
    MULEQ           reduce using rule 93 (eq -> eq EQEQ tBool .)
    DIVEQ           reduce using rule 93 (eq -> eq EQEQ tBool .)
    MASEQ           reduce using rule 93 (eq -> eq EQEQ tBool .)
    MENOSEQ         reduce using rule 93 (eq -> eq EQEQ tBool .)
    ;               reduce using rule 93 (eq -> eq EQEQ tBool .)
    )               reduce using rule 93 (eq -> eq EQEQ tBool .)
    }               reduce using rule 93 (eq -> eq EQEQ tBool .)
    :               reduce using rule 93 (eq -> eq EQEQ tBool .)
    ,               reduce using rule 93 (eq -> eq EQEQ tBool .)
    ]               reduce using rule 93 (eq -> eq EQEQ tBool .)


state 136

    (94) eq -> eq DISTINTO tBool .

    EQEQ            reduce using rule 94 (eq -> eq DISTINTO tBool .)
    DISTINTO        reduce using rule 94 (eq -> eq DISTINTO tBool .)
    AND             reduce using rule 94 (eq -> eq DISTINTO tBool .)
    ?               reduce using rule 94 (eq -> eq DISTINTO tBool .)
    OR              reduce using rule 94 (eq -> eq DISTINTO tBool .)
    MULEQ           reduce using rule 94 (eq -> eq DISTINTO tBool .)
    DIVEQ           reduce using rule 94 (eq -> eq DISTINTO tBool .)
    MASEQ           reduce using rule 94 (eq -> eq DISTINTO tBool .)
    MENOSEQ         reduce using rule 94 (eq -> eq DISTINTO tBool .)
    ;               reduce using rule 94 (eq -> eq DISTINTO tBool .)
    )               reduce using rule 94 (eq -> eq DISTINTO tBool .)
    }               reduce using rule 94 (eq -> eq DISTINTO tBool .)
    :               reduce using rule 94 (eq -> eq DISTINTO tBool .)
    ,               reduce using rule 94 (eq -> eq DISTINTO tBool .)
    ]               reduce using rule 94 (eq -> eq DISTINTO tBool .)


state 137

    (40) valores -> ID . . ID
    (41) varYVals -> ID .
    (61) asig -> ID . = asig
    (62) asig -> ID . . ID = asig
    (43) vecVal -> ID . m
    (31) vec -> ID . = [ elem ]
    (52) sMM -> ID . MASMAS
    (53) sMM -> ID . MENOSMENOS
    (54) sMM -> ID .
    (44) m -> . [ INT ]
    (45) m -> . [ INT ] m

  ! reduce/reduce conflict for ^ resolved using rule 41 (varYVals -> ID .)
  ! reduce/reduce conflict for * resolved using rule 41 (varYVals -> ID .)
  ! reduce/reduce conflict for / resolved using rule 41 (varYVals -> ID .)
  ! reduce/reduce conflict for % resolved using rule 41 (varYVals -> ID .)
  ! reduce/reduce conflict for + resolved using rule 41 (varYVals -> ID .)
  ! reduce/reduce conflict for - resolved using rule 41 (varYVals -> ID .)
  ! reduce/reduce conflict for MULEQ resolved using rule 41 (varYVals -> ID .)
  ! reduce/reduce conflict for DIVEQ resolved using rule 41 (varYVals -> ID .)
  ! reduce/reduce conflict for MASEQ resolved using rule 41 (varYVals -> ID .)
  ! reduce/reduce conflict for MENOSEQ resolved using rule 41 (varYVals -> ID .)
  ! reduce/reduce conflict for ; resolved using rule 41 (varYVals -> ID .)
  ! reduce/reduce conflict for > resolved using rule 41 (varYVals -> ID .)
  ! reduce/reduce conflict for < resolved using rule 41 (varYVals -> ID .)
    .               shift and go to state 115
    MULEQ           reduce using rule 41 (varYVals -> ID .)
    DIVEQ           reduce using rule 41 (varYVals -> ID .)
    MASEQ           reduce using rule 41 (varYVals -> ID .)
    MENOSEQ         reduce using rule 41 (varYVals -> ID .)
    ;               reduce using rule 41 (varYVals -> ID .)
    +               reduce using rule 41 (varYVals -> ID .)
    ^               reduce using rule 41 (varYVals -> ID .)
    *               reduce using rule 41 (varYVals -> ID .)
    /               reduce using rule 41 (varYVals -> ID .)
    %               reduce using rule 41 (varYVals -> ID .)
    -               reduce using rule 41 (varYVals -> ID .)
    >               reduce using rule 41 (varYVals -> ID .)
    <               reduce using rule 41 (varYVals -> ID .)
    EQEQ            reduce using rule 41 (varYVals -> ID .)
    DISTINTO        reduce using rule 41 (varYVals -> ID .)
    AND             reduce using rule 41 (varYVals -> ID .)
    ?               reduce using rule 41 (varYVals -> ID .)
    OR              reduce using rule 41 (varYVals -> ID .)
    =               shift and go to state 118
    MASMAS          shift and go to state 116
    MENOSMENOS      shift and go to state 119
    [               shift and go to state 117

  ! ^               [ reduce using rule 54 (sMM -> ID .) ]
  ! *               [ reduce using rule 54 (sMM -> ID .) ]
  ! /               [ reduce using rule 54 (sMM -> ID .) ]
  ! %               [ reduce using rule 54 (sMM -> ID .) ]
  ! +               [ reduce using rule 54 (sMM -> ID .) ]
  ! -               [ reduce using rule 54 (sMM -> ID .) ]
  ! MULEQ           [ reduce using rule 54 (sMM -> ID .) ]
  ! DIVEQ           [ reduce using rule 54 (sMM -> ID .) ]
  ! MASEQ           [ reduce using rule 54 (sMM -> ID .) ]
  ! MENOSEQ         [ reduce using rule 54 (sMM -> ID .) ]
  ! ;               [ reduce using rule 54 (sMM -> ID .) ]
  ! >               [ reduce using rule 54 (sMM -> ID .) ]
  ! <               [ reduce using rule 54 (sMM -> ID .) ]

    m                              shift and go to state 114

state 138

    (12) loop -> FOR ( varAsig . ; expBool ; varsOps ) bloque

    ;               shift and go to state 185


state 139

    (77) paren -> ( eMat . )
    (65) eMat -> eMat . + p
    (66) eMat -> eMat . - p

    )               shift and go to state 127
    +               shift and go to state 111
    -               shift and go to state 112


state 140

    (83) expString -> expString + STRING .

    +               reduce using rule 83 (expString -> expString + STRING .)
    MULEQ           reduce using rule 83 (expString -> expString + STRING .)
    DIVEQ           reduce using rule 83 (expString -> expString + STRING .)
    MASEQ           reduce using rule 83 (expString -> expString + STRING .)
    MENOSEQ         reduce using rule 83 (expString -> expString + STRING .)
    ;               reduce using rule 83 (expString -> expString + STRING .)
    )               reduce using rule 83 (expString -> expString + STRING .)
    ,               reduce using rule 83 (expString -> expString + STRING .)
    }               reduce using rule 83 (expString -> expString + STRING .)
    ]               reduce using rule 83 (expString -> expString + STRING .)


state 141

    (106) tCompare -> eMat .
    (65) eMat -> eMat . + p
    (66) eMat -> eMat . - p

    >               reduce using rule 106 (tCompare -> eMat .)
    <               reduce using rule 106 (tCompare -> eMat .)
    EQEQ            reduce using rule 106 (tCompare -> eMat .)
    DISTINTO        reduce using rule 106 (tCompare -> eMat .)
    AND             reduce using rule 106 (tCompare -> eMat .)
    ?               reduce using rule 106 (tCompare -> eMat .)
    OR              reduce using rule 106 (tCompare -> eMat .)
    MULEQ           reduce using rule 106 (tCompare -> eMat .)
    DIVEQ           reduce using rule 106 (tCompare -> eMat .)
    MASEQ           reduce using rule 106 (tCompare -> eMat .)
    MENOSEQ         reduce using rule 106 (tCompare -> eMat .)
    ;               reduce using rule 106 (tCompare -> eMat .)
    )               reduce using rule 106 (tCompare -> eMat .)
    }               reduce using rule 106 (tCompare -> eMat .)
    :               reduce using rule 106 (tCompare -> eMat .)
    ,               reduce using rule 106 (tCompare -> eMat .)
    ]               reduce using rule 106 (tCompare -> eMat .)
    +               shift and go to state 111
    -               shift and go to state 112


state 142

    (102) tBool -> ( . expBool )
    (77) paren -> ( . eMat )
    (87) expBool -> . or ? expBool : expBool
    (88) expBool -> . or
    (65) eMat -> . eMat + p
    (66) eMat -> . eMat - p
    (67) eMat -> . p
    (89) or -> . or OR and
    (90) or -> . and
    (68) p -> . p * exp
    (69) p -> . p / exp
    (70) p -> . p % exp
    (71) p -> . exp
    (91) and -> . and AND eq
    (92) and -> . eq
    (72) exp -> . exp ^ iSing
    (73) exp -> . iSing
    (93) eq -> . eq EQEQ tBool
    (94) eq -> . eq DISTINTO tBool
    (95) eq -> . mayor
    (74) iSing -> . - paren
    (75) iSing -> . + paren
    (76) iSing -> . paren
    (96) mayor -> . tCompare > tCompare
    (97) mayor -> . menor
    (77) paren -> . ( eMat )
    (78) paren -> . INT
    (79) paren -> . varYVals
    (80) paren -> . FLOAT
    (81) paren -> . varsOps
    (82) paren -> . funcInt
    (106) tCompare -> . eMat
    (107) tCompare -> . varsOps
    (108) tCompare -> . varYVals
    (98) menor -> . tCompare < tCompare
    (99) menor -> . not
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (49) varsOps -> . MENOSMENOS sMM
    (50) varsOps -> . MASMAS sMM
    (51) varsOps -> . sMM
    (23) funcInt -> . MULTIESCALAR ( vec , eMat , param )
    (24) funcInt -> . LENGTH ( vec )
    (100) not -> . NOT not
    (101) not -> . tBool
    (43) vecVal -> . ID m
    (52) sMM -> . ID MASMAS
    (53) sMM -> . ID MENOSMENOS
    (54) sMM -> . ID
    (102) tBool -> . ( expBool )
    (103) tBool -> . BOOL
    (104) tBool -> . varYVals
    (105) tBool -> . funcBool
    (26) funcBool -> . COLINEALES ( vec , vec )

    -               shift and go to state 50
    +               shift and go to state 20
    (               shift and go to state 5
    INT             shift and go to state 27
    FLOAT           shift and go to state 56
    ID              shift and go to state 65
    MENOSMENOS      shift and go to state 23
    MASMAS          shift and go to state 28
    MULTIESCALAR    shift and go to state 55
    LENGTH          shift and go to state 11
    NOT             shift and go to state 30
    BOOL            shift and go to state 41
    COLINEALES      shift and go to state 1

    and                            shift and go to state 44
    funcBool                       shift and go to state 61
    funcInt                        shift and go to state 62
    menor                          shift and go to state 3
    eq                             shift and go to state 16
    mayor                          shift and go to state 4
    eMat                           shift and go to state 63
    vecVal                         shift and go to state 47
    sMM                            shift and go to state 6
    paren                          shift and go to state 36
    varsOps                        shift and go to state 64
    tCompare                       shift and go to state 37
    not                            shift and go to state 8
    p                              shift and go to state 10
    iSing                          shift and go to state 12
    exp                            shift and go to state 59
    tBool                          shift and go to state 31
    varYVals                       shift and go to state 66
    or                             shift and go to state 34
    expBool                        shift and go to state 67

state 143

    (41) varYVals -> ID .
    (52) sMM -> ID . MASMAS
    (53) sMM -> ID . MENOSMENOS
    (54) sMM -> ID .
    (43) vecVal -> ID . m
    (44) m -> . [ INT ]
    (45) m -> . [ INT ] m

  ! reduce/reduce conflict for > resolved using rule 41 (varYVals -> ID .)
  ! reduce/reduce conflict for < resolved using rule 41 (varYVals -> ID .)
  ! reduce/reduce conflict for ^ resolved using rule 41 (varYVals -> ID .)
  ! reduce/reduce conflict for * resolved using rule 41 (varYVals -> ID .)
  ! reduce/reduce conflict for / resolved using rule 41 (varYVals -> ID .)
  ! reduce/reduce conflict for % resolved using rule 41 (varYVals -> ID .)
  ! reduce/reduce conflict for + resolved using rule 41 (varYVals -> ID .)
  ! reduce/reduce conflict for - resolved using rule 41 (varYVals -> ID .)
  ! reduce/reduce conflict for EQEQ resolved using rule 41 (varYVals -> ID .)
  ! reduce/reduce conflict for DISTINTO resolved using rule 41 (varYVals -> ID .)
  ! reduce/reduce conflict for AND resolved using rule 41 (varYVals -> ID .)
  ! reduce/reduce conflict for ? resolved using rule 41 (varYVals -> ID .)
  ! reduce/reduce conflict for OR resolved using rule 41 (varYVals -> ID .)
  ! reduce/reduce conflict for MULEQ resolved using rule 41 (varYVals -> ID .)
  ! reduce/reduce conflict for DIVEQ resolved using rule 41 (varYVals -> ID .)
  ! reduce/reduce conflict for MASEQ resolved using rule 41 (varYVals -> ID .)
  ! reduce/reduce conflict for MENOSEQ resolved using rule 41 (varYVals -> ID .)
  ! reduce/reduce conflict for ; resolved using rule 41 (varYVals -> ID .)
  ! reduce/reduce conflict for ) resolved using rule 41 (varYVals -> ID .)
  ! reduce/reduce conflict for } resolved using rule 41 (varYVals -> ID .)
  ! reduce/reduce conflict for : resolved using rule 41 (varYVals -> ID .)
  ! reduce/reduce conflict for , resolved using rule 41 (varYVals -> ID .)
  ! reduce/reduce conflict for ] resolved using rule 41 (varYVals -> ID .)
    >               reduce using rule 41 (varYVals -> ID .)
    <               reduce using rule 41 (varYVals -> ID .)
    EQEQ            reduce using rule 41 (varYVals -> ID .)
    DISTINTO        reduce using rule 41 (varYVals -> ID .)
    AND             reduce using rule 41 (varYVals -> ID .)
    ?               reduce using rule 41 (varYVals -> ID .)
    OR              reduce using rule 41 (varYVals -> ID .)
    MULEQ           reduce using rule 41 (varYVals -> ID .)
    DIVEQ           reduce using rule 41 (varYVals -> ID .)
    MASEQ           reduce using rule 41 (varYVals -> ID .)
    MENOSEQ         reduce using rule 41 (varYVals -> ID .)
    ;               reduce using rule 41 (varYVals -> ID .)
    )               reduce using rule 41 (varYVals -> ID .)
    }               reduce using rule 41 (varYVals -> ID .)
    :               reduce using rule 41 (varYVals -> ID .)
    ,               reduce using rule 41 (varYVals -> ID .)
    ]               reduce using rule 41 (varYVals -> ID .)
    ^               reduce using rule 41 (varYVals -> ID .)
    *               reduce using rule 41 (varYVals -> ID .)
    /               reduce using rule 41 (varYVals -> ID .)
    %               reduce using rule 41 (varYVals -> ID .)
    +               reduce using rule 41 (varYVals -> ID .)
    -               reduce using rule 41 (varYVals -> ID .)
    MASMAS          shift and go to state 116
    MENOSMENOS      shift and go to state 119
    [               shift and go to state 117

  ! >               [ reduce using rule 54 (sMM -> ID .) ]
  ! <               [ reduce using rule 54 (sMM -> ID .) ]
  ! ^               [ reduce using rule 54 (sMM -> ID .) ]
  ! *               [ reduce using rule 54 (sMM -> ID .) ]
  ! /               [ reduce using rule 54 (sMM -> ID .) ]
  ! %               [ reduce using rule 54 (sMM -> ID .) ]
  ! +               [ reduce using rule 54 (sMM -> ID .) ]
  ! -               [ reduce using rule 54 (sMM -> ID .) ]
  ! EQEQ            [ reduce using rule 54 (sMM -> ID .) ]
  ! DISTINTO        [ reduce using rule 54 (sMM -> ID .) ]
  ! AND             [ reduce using rule 54 (sMM -> ID .) ]
  ! ?               [ reduce using rule 54 (sMM -> ID .) ]
  ! OR              [ reduce using rule 54 (sMM -> ID .) ]
  ! MULEQ           [ reduce using rule 54 (sMM -> ID .) ]
  ! DIVEQ           [ reduce using rule 54 (sMM -> ID .) ]
  ! MASEQ           [ reduce using rule 54 (sMM -> ID .) ]
  ! MENOSEQ         [ reduce using rule 54 (sMM -> ID .) ]
  ! ;               [ reduce using rule 54 (sMM -> ID .) ]
  ! )               [ reduce using rule 54 (sMM -> ID .) ]
  ! }               [ reduce using rule 54 (sMM -> ID .) ]
  ! :               [ reduce using rule 54 (sMM -> ID .) ]
  ! ,               [ reduce using rule 54 (sMM -> ID .) ]
  ! ]               [ reduce using rule 54 (sMM -> ID .) ]

    m                              shift and go to state 114

state 144

    (107) tCompare -> varsOps .
    (81) paren -> varsOps .

  ! reduce/reduce conflict for EQEQ resolved using rule 81 (paren -> varsOps .)
  ! reduce/reduce conflict for DISTINTO resolved using rule 81 (paren -> varsOps .)
  ! reduce/reduce conflict for AND resolved using rule 81 (paren -> varsOps .)
  ! reduce/reduce conflict for ? resolved using rule 81 (paren -> varsOps .)
  ! reduce/reduce conflict for OR resolved using rule 81 (paren -> varsOps .)
  ! reduce/reduce conflict for MULEQ resolved using rule 81 (paren -> varsOps .)
  ! reduce/reduce conflict for DIVEQ resolved using rule 81 (paren -> varsOps .)
  ! reduce/reduce conflict for MASEQ resolved using rule 81 (paren -> varsOps .)
  ! reduce/reduce conflict for MENOSEQ resolved using rule 81 (paren -> varsOps .)
  ! reduce/reduce conflict for ; resolved using rule 81 (paren -> varsOps .)
  ! reduce/reduce conflict for ) resolved using rule 81 (paren -> varsOps .)
  ! reduce/reduce conflict for } resolved using rule 81 (paren -> varsOps .)
  ! reduce/reduce conflict for : resolved using rule 81 (paren -> varsOps .)
  ! reduce/reduce conflict for , resolved using rule 81 (paren -> varsOps .)
  ! reduce/reduce conflict for ] resolved using rule 81 (paren -> varsOps .)
  ! reduce/reduce conflict for > resolved using rule 81 (paren -> varsOps .)
  ! reduce/reduce conflict for < resolved using rule 81 (paren -> varsOps .)
    ^               reduce using rule 81 (paren -> varsOps .)
    *               reduce using rule 81 (paren -> varsOps .)
    /               reduce using rule 81 (paren -> varsOps .)
    %               reduce using rule 81 (paren -> varsOps .)
    +               reduce using rule 81 (paren -> varsOps .)
    -               reduce using rule 81 (paren -> varsOps .)
    EQEQ            reduce using rule 81 (paren -> varsOps .)
    DISTINTO        reduce using rule 81 (paren -> varsOps .)
    AND             reduce using rule 81 (paren -> varsOps .)
    ?               reduce using rule 81 (paren -> varsOps .)
    OR              reduce using rule 81 (paren -> varsOps .)
    MULEQ           reduce using rule 81 (paren -> varsOps .)
    DIVEQ           reduce using rule 81 (paren -> varsOps .)
    MASEQ           reduce using rule 81 (paren -> varsOps .)
    MENOSEQ         reduce using rule 81 (paren -> varsOps .)
    ;               reduce using rule 81 (paren -> varsOps .)
    )               reduce using rule 81 (paren -> varsOps .)
    }               reduce using rule 81 (paren -> varsOps .)
    :               reduce using rule 81 (paren -> varsOps .)
    ,               reduce using rule 81 (paren -> varsOps .)
    ]               reduce using rule 81 (paren -> varsOps .)
    >               reduce using rule 81 (paren -> varsOps .)
    <               reduce using rule 81 (paren -> varsOps .)

  ! >               [ reduce using rule 107 (tCompare -> varsOps .) ]
  ! <               [ reduce using rule 107 (tCompare -> varsOps .) ]
  ! EQEQ            [ reduce using rule 107 (tCompare -> varsOps .) ]
  ! DISTINTO        [ reduce using rule 107 (tCompare -> varsOps .) ]
  ! AND             [ reduce using rule 107 (tCompare -> varsOps .) ]
  ! ?               [ reduce using rule 107 (tCompare -> varsOps .) ]
  ! OR              [ reduce using rule 107 (tCompare -> varsOps .) ]
  ! MULEQ           [ reduce using rule 107 (tCompare -> varsOps .) ]
  ! DIVEQ           [ reduce using rule 107 (tCompare -> varsOps .) ]
  ! MASEQ           [ reduce using rule 107 (tCompare -> varsOps .) ]
  ! MENOSEQ         [ reduce using rule 107 (tCompare -> varsOps .) ]
  ! ;               [ reduce using rule 107 (tCompare -> varsOps .) ]
  ! )               [ reduce using rule 107 (tCompare -> varsOps .) ]
  ! }               [ reduce using rule 107 (tCompare -> varsOps .) ]
  ! :               [ reduce using rule 107 (tCompare -> varsOps .) ]
  ! ,               [ reduce using rule 107 (tCompare -> varsOps .) ]
  ! ]               [ reduce using rule 107 (tCompare -> varsOps .) ]


state 145

    (108) tCompare -> varYVals .
    (104) tBool -> varYVals .
    (79) paren -> varYVals .

  ! reduce/reduce conflict for > resolved using rule 79 (paren -> varYVals .)
  ! reduce/reduce conflict for < resolved using rule 79 (paren -> varYVals .)
    EQEQ            reduce using rule 104 (tBool -> varYVals .)
    DISTINTO        reduce using rule 104 (tBool -> varYVals .)
    AND             reduce using rule 104 (tBool -> varYVals .)
    ?               reduce using rule 104 (tBool -> varYVals .)
    OR              reduce using rule 104 (tBool -> varYVals .)
    MULEQ           reduce using rule 104 (tBool -> varYVals .)
    DIVEQ           reduce using rule 104 (tBool -> varYVals .)
    MASEQ           reduce using rule 104 (tBool -> varYVals .)
    MENOSEQ         reduce using rule 104 (tBool -> varYVals .)
    ;               reduce using rule 104 (tBool -> varYVals .)
    )               reduce using rule 104 (tBool -> varYVals .)
    }               reduce using rule 104 (tBool -> varYVals .)
    :               reduce using rule 104 (tBool -> varYVals .)
    ,               reduce using rule 104 (tBool -> varYVals .)
    ]               reduce using rule 104 (tBool -> varYVals .)
    ^               reduce using rule 79 (paren -> varYVals .)
    *               reduce using rule 79 (paren -> varYVals .)
    /               reduce using rule 79 (paren -> varYVals .)
    %               reduce using rule 79 (paren -> varYVals .)
    +               reduce using rule 79 (paren -> varYVals .)
    -               reduce using rule 79 (paren -> varYVals .)
    >               reduce using rule 79 (paren -> varYVals .)
    <               reduce using rule 79 (paren -> varYVals .)

  ! >               [ reduce using rule 108 (tCompare -> varYVals .) ]
  ! <               [ reduce using rule 108 (tCompare -> varYVals .) ]


state 146

    (46) reg -> { campos } .

    MULEQ           reduce using rule 46 (reg -> { campos } .)
    DIVEQ           reduce using rule 46 (reg -> { campos } .)
    MASEQ           reduce using rule 46 (reg -> { campos } .)
    MENOSEQ         reduce using rule 46 (reg -> { campos } .)
    ;               reduce using rule 46 (reg -> { campos } .)
    }               reduce using rule 46 (reg -> { campos } .)
    ,               reduce using rule 46 (reg -> { campos } .)
    ]               reduce using rule 46 (reg -> { campos } .)
    )               reduce using rule 46 (reg -> { campos } .)


state 147

    (40) valores -> ID . . ID

    ID              shift and go to state 186


state 148

    (47) campos -> ID : . valores , campos
    (34) valores -> . eMat
    (35) valores -> . expBool
    (36) valores -> . expString
    (37) valores -> . varYVals
    (38) valores -> . funcReturn
    (39) valores -> . reg
    (40) valores -> . ID . ID
    (65) eMat -> . eMat + p
    (66) eMat -> . eMat - p
    (67) eMat -> . p
    (87) expBool -> . or ? expBool : expBool
    (88) expBool -> . or
    (83) expString -> . expString + STRING
    (84) expString -> . STRING
    (85) expString -> . varYVals
    (86) expString -> . funcString
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (20) funcReturn -> . funcInt
    (21) funcReturn -> . funcString
    (22) funcReturn -> . funcBool
    (46) reg -> . { campos }
    (68) p -> . p * exp
    (69) p -> . p / exp
    (70) p -> . p % exp
    (71) p -> . exp
    (89) or -> . or OR and
    (90) or -> . and
    (25) funcString -> . CAPITALIZAR ( expString )
    (43) vecVal -> . ID m
    (23) funcInt -> . MULTIESCALAR ( vec , eMat , param )
    (24) funcInt -> . LENGTH ( vec )
    (26) funcBool -> . COLINEALES ( vec , vec )
    (72) exp -> . exp ^ iSing
    (73) exp -> . iSing
    (91) and -> . and AND eq
    (92) and -> . eq
    (74) iSing -> . - paren
    (75) iSing -> . + paren
    (76) iSing -> . paren
    (93) eq -> . eq EQEQ tBool
    (94) eq -> . eq DISTINTO tBool
    (95) eq -> . mayor
    (77) paren -> . ( eMat )
    (78) paren -> . INT
    (79) paren -> . varYVals
    (80) paren -> . FLOAT
    (81) paren -> . varsOps
    (82) paren -> . funcInt
    (96) mayor -> . tCompare > tCompare
    (97) mayor -> . menor
    (49) varsOps -> . MENOSMENOS sMM
    (50) varsOps -> . MASMAS sMM
    (51) varsOps -> . sMM
    (106) tCompare -> . eMat
    (107) tCompare -> . varsOps
    (108) tCompare -> . varYVals
    (98) menor -> . tCompare < tCompare
    (99) menor -> . not
    (52) sMM -> . ID MASMAS
    (53) sMM -> . ID MENOSMENOS
    (54) sMM -> . ID
    (100) not -> . NOT not
    (101) not -> . tBool
    (102) tBool -> . ( expBool )
    (103) tBool -> . BOOL
    (104) tBool -> . varYVals
    (105) tBool -> . funcBool

    ID              shift and go to state 133
    STRING          shift and go to state 51
    {               shift and go to state 32
    CAPITALIZAR     shift and go to state 57
    MULTIESCALAR    shift and go to state 55
    LENGTH          shift and go to state 11
    COLINEALES      shift and go to state 1
    -               shift and go to state 50
    +               shift and go to state 20
    (               shift and go to state 5
    INT             shift and go to state 27
    FLOAT           shift and go to state 56
    MENOSMENOS      shift and go to state 23
    MASMAS          shift and go to state 28
    NOT             shift and go to state 30
    BOOL            shift and go to state 41

    and                            shift and go to state 44
    funcBool                       shift and go to state 2
    funcInt                        shift and go to state 14
    menor                          shift and go to state 3
    eq                             shift and go to state 16
    vecVal                         shift and go to state 47
    eMat                           shift and go to state 49
    mayor                          shift and go to state 4
    sMM                            shift and go to state 6
    paren                          shift and go to state 36
    reg                            shift and go to state 22
    varsOps                        shift and go to state 64
    expString                      shift and go to state 24
    tCompare                       shift and go to state 37
    not                            shift and go to state 8
    funcString                     shift and go to state 92
    funcReturn                     shift and go to state 93
    valores                        shift and go to state 187
    p                              shift and go to state 10
    iSing                          shift and go to state 12
    exp                            shift and go to state 59
    tBool                          shift and go to state 31
    varYVals                       shift and go to state 33
    or                             shift and go to state 34
    expBool                        shift and go to state 29

state 149

    (89) or -> or OR and .
    (91) and -> and . AND eq

    ?               reduce using rule 89 (or -> or OR and .)
    OR              reduce using rule 89 (or -> or OR and .)
    )               reduce using rule 89 (or -> or OR and .)
    MULEQ           reduce using rule 89 (or -> or OR and .)
    DIVEQ           reduce using rule 89 (or -> or OR and .)
    MASEQ           reduce using rule 89 (or -> or OR and .)
    MENOSEQ         reduce using rule 89 (or -> or OR and .)
    ;               reduce using rule 89 (or -> or OR and .)
    ,               reduce using rule 89 (or -> or OR and .)
    ]               reduce using rule 89 (or -> or OR and .)
    }               reduce using rule 89 (or -> or OR and .)
    :               reduce using rule 89 (or -> or OR and .)
    AND             shift and go to state 106


state 150

    (87) expBool -> or ? expBool . : expBool

    :               shift and go to state 188


state 151

    (10) loop -> WHILE ( expBool . ) bloque

    )               shift and go to state 189


state 152

    (98) menor -> tCompare < tCompare .

    EQEQ            reduce using rule 98 (menor -> tCompare < tCompare .)
    DISTINTO        reduce using rule 98 (menor -> tCompare < tCompare .)
    AND             reduce using rule 98 (menor -> tCompare < tCompare .)
    ?               reduce using rule 98 (menor -> tCompare < tCompare .)
    OR              reduce using rule 98 (menor -> tCompare < tCompare .)
    MULEQ           reduce using rule 98 (menor -> tCompare < tCompare .)
    DIVEQ           reduce using rule 98 (menor -> tCompare < tCompare .)
    MASEQ           reduce using rule 98 (menor -> tCompare < tCompare .)
    MENOSEQ         reduce using rule 98 (menor -> tCompare < tCompare .)
    ;               reduce using rule 98 (menor -> tCompare < tCompare .)
    )               reduce using rule 98 (menor -> tCompare < tCompare .)
    }               reduce using rule 98 (menor -> tCompare < tCompare .)
    ,               reduce using rule 98 (menor -> tCompare < tCompare .)
    ]               reduce using rule 98 (menor -> tCompare < tCompare .)
    :               reduce using rule 98 (menor -> tCompare < tCompare .)


state 153

    (108) tCompare -> varYVals .
    (79) paren -> varYVals .

  ! reduce/reduce conflict for EQEQ resolved using rule 79 (paren -> varYVals .)
  ! reduce/reduce conflict for DISTINTO resolved using rule 79 (paren -> varYVals .)
  ! reduce/reduce conflict for AND resolved using rule 79 (paren -> varYVals .)
  ! reduce/reduce conflict for ? resolved using rule 79 (paren -> varYVals .)
  ! reduce/reduce conflict for OR resolved using rule 79 (paren -> varYVals .)
  ! reduce/reduce conflict for MULEQ resolved using rule 79 (paren -> varYVals .)
  ! reduce/reduce conflict for DIVEQ resolved using rule 79 (paren -> varYVals .)
  ! reduce/reduce conflict for MASEQ resolved using rule 79 (paren -> varYVals .)
  ! reduce/reduce conflict for MENOSEQ resolved using rule 79 (paren -> varYVals .)
  ! reduce/reduce conflict for ; resolved using rule 79 (paren -> varYVals .)
  ! reduce/reduce conflict for ) resolved using rule 79 (paren -> varYVals .)
  ! reduce/reduce conflict for } resolved using rule 79 (paren -> varYVals .)
  ! reduce/reduce conflict for : resolved using rule 79 (paren -> varYVals .)
  ! reduce/reduce conflict for , resolved using rule 79 (paren -> varYVals .)
  ! reduce/reduce conflict for ] resolved using rule 79 (paren -> varYVals .)
    ^               reduce using rule 79 (paren -> varYVals .)
    *               reduce using rule 79 (paren -> varYVals .)
    /               reduce using rule 79 (paren -> varYVals .)
    %               reduce using rule 79 (paren -> varYVals .)
    +               reduce using rule 79 (paren -> varYVals .)
    -               reduce using rule 79 (paren -> varYVals .)
    EQEQ            reduce using rule 79 (paren -> varYVals .)
    DISTINTO        reduce using rule 79 (paren -> varYVals .)
    AND             reduce using rule 79 (paren -> varYVals .)
    ?               reduce using rule 79 (paren -> varYVals .)
    OR              reduce using rule 79 (paren -> varYVals .)
    MULEQ           reduce using rule 79 (paren -> varYVals .)
    DIVEQ           reduce using rule 79 (paren -> varYVals .)
    MASEQ           reduce using rule 79 (paren -> varYVals .)
    MENOSEQ         reduce using rule 79 (paren -> varYVals .)
    ;               reduce using rule 79 (paren -> varYVals .)
    )               reduce using rule 79 (paren -> varYVals .)
    }               reduce using rule 79 (paren -> varYVals .)
    :               reduce using rule 79 (paren -> varYVals .)
    ,               reduce using rule 79 (paren -> varYVals .)
    ]               reduce using rule 79 (paren -> varYVals .)

  ! EQEQ            [ reduce using rule 108 (tCompare -> varYVals .) ]
  ! DISTINTO        [ reduce using rule 108 (tCompare -> varYVals .) ]
  ! AND             [ reduce using rule 108 (tCompare -> varYVals .) ]
  ! ?               [ reduce using rule 108 (tCompare -> varYVals .) ]
  ! OR              [ reduce using rule 108 (tCompare -> varYVals .) ]
  ! MULEQ           [ reduce using rule 108 (tCompare -> varYVals .) ]
  ! DIVEQ           [ reduce using rule 108 (tCompare -> varYVals .) ]
  ! MASEQ           [ reduce using rule 108 (tCompare -> varYVals .) ]
  ! MENOSEQ         [ reduce using rule 108 (tCompare -> varYVals .) ]
  ! ;               [ reduce using rule 108 (tCompare -> varYVals .) ]
  ! )               [ reduce using rule 108 (tCompare -> varYVals .) ]
  ! }               [ reduce using rule 108 (tCompare -> varYVals .) ]
  ! :               [ reduce using rule 108 (tCompare -> varYVals .) ]
  ! ,               [ reduce using rule 108 (tCompare -> varYVals .) ]
  ! ]               [ reduce using rule 108 (tCompare -> varYVals .) ]


state 154

    (96) mayor -> tCompare > tCompare .

    EQEQ            reduce using rule 96 (mayor -> tCompare > tCompare .)
    DISTINTO        reduce using rule 96 (mayor -> tCompare > tCompare .)
    AND             reduce using rule 96 (mayor -> tCompare > tCompare .)
    ?               reduce using rule 96 (mayor -> tCompare > tCompare .)
    OR              reduce using rule 96 (mayor -> tCompare > tCompare .)
    ;               reduce using rule 96 (mayor -> tCompare > tCompare .)
    MULEQ           reduce using rule 96 (mayor -> tCompare > tCompare .)
    DIVEQ           reduce using rule 96 (mayor -> tCompare > tCompare .)
    MASEQ           reduce using rule 96 (mayor -> tCompare > tCompare .)
    MENOSEQ         reduce using rule 96 (mayor -> tCompare > tCompare .)
    }               reduce using rule 96 (mayor -> tCompare > tCompare .)
    )               reduce using rule 96 (mayor -> tCompare > tCompare .)
    :               reduce using rule 96 (mayor -> tCompare > tCompare .)
    ,               reduce using rule 96 (mayor -> tCompare > tCompare .)
    ]               reduce using rule 96 (mayor -> tCompare > tCompare .)


state 155

    (59) sIgual -> valores MENOSEQ sIgual .

    ;               reduce using rule 59 (sIgual -> valores MENOSEQ sIgual .)


state 156

    (40) valores -> ID . . ID
    (61) asig -> ID . = asig
    (62) asig -> ID . . ID = asig
    (41) varYVals -> ID .
    (31) vec -> ID . = [ elem ]
    (43) vecVal -> ID . m
    (52) sMM -> ID . MASMAS
    (53) sMM -> ID . MENOSMENOS
    (54) sMM -> ID .
    (44) m -> . [ INT ]
    (45) m -> . [ INT ] m

  ! reduce/reduce conflict for ^ resolved using rule 41 (varYVals -> ID .)
  ! reduce/reduce conflict for * resolved using rule 41 (varYVals -> ID .)
  ! reduce/reduce conflict for / resolved using rule 41 (varYVals -> ID .)
  ! reduce/reduce conflict for % resolved using rule 41 (varYVals -> ID .)
  ! reduce/reduce conflict for + resolved using rule 41 (varYVals -> ID .)
  ! reduce/reduce conflict for - resolved using rule 41 (varYVals -> ID .)
  ! reduce/reduce conflict for MASEQ resolved using rule 41 (varYVals -> ID .)
  ! reduce/reduce conflict for MENOSEQ resolved using rule 41 (varYVals -> ID .)
  ! reduce/reduce conflict for ; resolved using rule 41 (varYVals -> ID .)
  ! reduce/reduce conflict for > resolved using rule 41 (varYVals -> ID .)
  ! reduce/reduce conflict for < resolved using rule 41 (varYVals -> ID .)
    .               shift and go to state 115
    =               shift and go to state 118
    MASEQ           reduce using rule 41 (varYVals -> ID .)
    MENOSEQ         reduce using rule 41 (varYVals -> ID .)
    ;               reduce using rule 41 (varYVals -> ID .)
    +               reduce using rule 41 (varYVals -> ID .)
    ^               reduce using rule 41 (varYVals -> ID .)
    *               reduce using rule 41 (varYVals -> ID .)
    /               reduce using rule 41 (varYVals -> ID .)
    %               reduce using rule 41 (varYVals -> ID .)
    -               reduce using rule 41 (varYVals -> ID .)
    >               reduce using rule 41 (varYVals -> ID .)
    <               reduce using rule 41 (varYVals -> ID .)
    EQEQ            reduce using rule 41 (varYVals -> ID .)
    DISTINTO        reduce using rule 41 (varYVals -> ID .)
    AND             reduce using rule 41 (varYVals -> ID .)
    ?               reduce using rule 41 (varYVals -> ID .)
    OR              reduce using rule 41 (varYVals -> ID .)
    MASMAS          shift and go to state 116
    MENOSMENOS      shift and go to state 119
    [               shift and go to state 117

  ! ^               [ reduce using rule 54 (sMM -> ID .) ]
  ! *               [ reduce using rule 54 (sMM -> ID .) ]
  ! /               [ reduce using rule 54 (sMM -> ID .) ]
  ! %               [ reduce using rule 54 (sMM -> ID .) ]
  ! +               [ reduce using rule 54 (sMM -> ID .) ]
  ! -               [ reduce using rule 54 (sMM -> ID .) ]
  ! MASEQ           [ reduce using rule 54 (sMM -> ID .) ]
  ! MENOSEQ         [ reduce using rule 54 (sMM -> ID .) ]
  ! ;               [ reduce using rule 54 (sMM -> ID .) ]
  ! >               [ reduce using rule 54 (sMM -> ID .) ]
  ! <               [ reduce using rule 54 (sMM -> ID .) ]

    m                              shift and go to state 114

state 157

    (58) sIgual -> valores . MASEQ sIgual
    (59) sIgual -> valores . MENOSEQ sIgual
    (64) asig -> valores .

    MASEQ           shift and go to state 103
    MENOSEQ         shift and go to state 102
    ;               reduce using rule 64 (asig -> valores .)


state 158

    (58) sIgual -> valores MASEQ sIgual .

    ;               reduce using rule 58 (sIgual -> valores MASEQ sIgual .)


state 159

    (55) varAsig -> valores MULEQ varAsig .

    ;               reduce using rule 55 (varAsig -> valores MULEQ varAsig .)


state 160

    (56) varAsig -> valores DIVEQ varAsig .

    ;               reduce using rule 56 (varAsig -> valores DIVEQ varAsig .)


state 161

    (91) and -> and AND eq .
    (93) eq -> eq . EQEQ tBool
    (94) eq -> eq . DISTINTO tBool

    AND             reduce using rule 91 (and -> and AND eq .)
    ?               reduce using rule 91 (and -> and AND eq .)
    OR              reduce using rule 91 (and -> and AND eq .)
    MASEQ           reduce using rule 91 (and -> and AND eq .)
    MENOSEQ         reduce using rule 91 (and -> and AND eq .)
    ;               reduce using rule 91 (and -> and AND eq .)
    )               reduce using rule 91 (and -> and AND eq .)
    MULEQ           reduce using rule 91 (and -> and AND eq .)
    DIVEQ           reduce using rule 91 (and -> and AND eq .)
    }               reduce using rule 91 (and -> and AND eq .)
    :               reduce using rule 91 (and -> and AND eq .)
    ,               reduce using rule 91 (and -> and AND eq .)
    ]               reduce using rule 91 (and -> and AND eq .)
    EQEQ            shift and go to state 74
    DISTINTO        shift and go to state 75


state 162

    (11) loop -> DO bloque WHILE . ( expBool ) ;

    (               shift and go to state 190


state 163

    (38) valores -> funcReturn .
    (18) func -> funcReturn .

  ! reduce/reduce conflict for ; resolved using rule 18 (func -> funcReturn .)
    MULEQ           reduce using rule 38 (valores -> funcReturn .)
    DIVEQ           reduce using rule 38 (valores -> funcReturn .)
    MASEQ           reduce using rule 38 (valores -> funcReturn .)
    MENOSEQ         reduce using rule 38 (valores -> funcReturn .)
    }               reduce using rule 38 (valores -> funcReturn .)
    ;               reduce using rule 18 (func -> funcReturn .)

  ! ;               [ reduce using rule 38 (valores -> funcReturn .) ]


state 164

    (17) bloque -> { g . }

    }               shift and go to state 191


state 165

    (48) campos -> valores .
    (55) varAsig -> valores . MULEQ varAsig
    (56) varAsig -> valores . DIVEQ varAsig
    (58) sIgual -> valores . MASEQ sIgual
    (59) sIgual -> valores . MENOSEQ sIgual
    (64) asig -> valores .

    }               reduce using rule 48 (campos -> valores .)
    MULEQ           shift and go to state 104
    DIVEQ           shift and go to state 105
    MASEQ           shift and go to state 103
    MENOSEQ         shift and go to state 102
    ;               reduce using rule 64 (asig -> valores .)


state 166

    (47) campos -> ID . : valores , campos
    (40) valores -> ID . . ID
    (41) varYVals -> ID .
    (52) sMM -> ID . MASMAS
    (53) sMM -> ID . MENOSMENOS
    (54) sMM -> ID .
    (43) vecVal -> ID . m
    (61) asig -> ID . = asig
    (62) asig -> ID . . ID = asig
    (31) vec -> ID . = [ elem ]
    (44) m -> . [ INT ]
    (45) m -> . [ INT ] m

  ! reduce/reduce conflict for ; resolved using rule 41 (varYVals -> ID .)
  ! reduce/reduce conflict for ^ resolved using rule 41 (varYVals -> ID .)
  ! reduce/reduce conflict for * resolved using rule 41 (varYVals -> ID .)
  ! reduce/reduce conflict for / resolved using rule 41 (varYVals -> ID .)
  ! reduce/reduce conflict for % resolved using rule 41 (varYVals -> ID .)
  ! reduce/reduce conflict for + resolved using rule 41 (varYVals -> ID .)
  ! reduce/reduce conflict for - resolved using rule 41 (varYVals -> ID .)
  ! reduce/reduce conflict for MULEQ resolved using rule 41 (varYVals -> ID .)
  ! reduce/reduce conflict for DIVEQ resolved using rule 41 (varYVals -> ID .)
  ! reduce/reduce conflict for MASEQ resolved using rule 41 (varYVals -> ID .)
  ! reduce/reduce conflict for MENOSEQ resolved using rule 41 (varYVals -> ID .)
  ! reduce/reduce conflict for } resolved using rule 41 (varYVals -> ID .)
  ! reduce/reduce conflict for > resolved using rule 41 (varYVals -> ID .)
  ! reduce/reduce conflict for < resolved using rule 41 (varYVals -> ID .)
    :               shift and go to state 148
    .               shift and go to state 115
    MULEQ           reduce using rule 41 (varYVals -> ID .)
    DIVEQ           reduce using rule 41 (varYVals -> ID .)
    MASEQ           reduce using rule 41 (varYVals -> ID .)
    MENOSEQ         reduce using rule 41 (varYVals -> ID .)
    }               reduce using rule 41 (varYVals -> ID .)
    ;               reduce using rule 41 (varYVals -> ID .)
    +               reduce using rule 41 (varYVals -> ID .)
    ^               reduce using rule 41 (varYVals -> ID .)
    *               reduce using rule 41 (varYVals -> ID .)
    /               reduce using rule 41 (varYVals -> ID .)
    %               reduce using rule 41 (varYVals -> ID .)
    -               reduce using rule 41 (varYVals -> ID .)
    >               reduce using rule 41 (varYVals -> ID .)
    <               reduce using rule 41 (varYVals -> ID .)
    EQEQ            reduce using rule 41 (varYVals -> ID .)
    DISTINTO        reduce using rule 41 (varYVals -> ID .)
    AND             reduce using rule 41 (varYVals -> ID .)
    ?               reduce using rule 41 (varYVals -> ID .)
    OR              reduce using rule 41 (varYVals -> ID .)
    MASMAS          shift and go to state 116
    MENOSMENOS      shift and go to state 119
    =               shift and go to state 118
    [               shift and go to state 117

  ! ;               [ reduce using rule 54 (sMM -> ID .) ]
  ! ^               [ reduce using rule 54 (sMM -> ID .) ]
  ! *               [ reduce using rule 54 (sMM -> ID .) ]
  ! /               [ reduce using rule 54 (sMM -> ID .) ]
  ! %               [ reduce using rule 54 (sMM -> ID .) ]
  ! +               [ reduce using rule 54 (sMM -> ID .) ]
  ! -               [ reduce using rule 54 (sMM -> ID .) ]
  ! MULEQ           [ reduce using rule 54 (sMM -> ID .) ]
  ! DIVEQ           [ reduce using rule 54 (sMM -> ID .) ]
  ! MASEQ           [ reduce using rule 54 (sMM -> ID .) ]
  ! MENOSEQ         [ reduce using rule 54 (sMM -> ID .) ]
  ! }               [ reduce using rule 54 (sMM -> ID .) ]
  ! >               [ reduce using rule 54 (sMM -> ID .) ]
  ! <               [ reduce using rule 54 (sMM -> ID .) ]

    m                              shift and go to state 114

state 167

    (65) eMat -> eMat + p .
    (68) p -> p . * exp
    (69) p -> p . / exp
    (70) p -> p . % exp

    +               reduce using rule 65 (eMat -> eMat + p .)
    -               reduce using rule 65 (eMat -> eMat + p .)
    MULEQ           reduce using rule 65 (eMat -> eMat + p .)
    DIVEQ           reduce using rule 65 (eMat -> eMat + p .)
    MASEQ           reduce using rule 65 (eMat -> eMat + p .)
    MENOSEQ         reduce using rule 65 (eMat -> eMat + p .)
    ;               reduce using rule 65 (eMat -> eMat + p .)
    >               reduce using rule 65 (eMat -> eMat + p .)
    <               reduce using rule 65 (eMat -> eMat + p .)
    ,               reduce using rule 65 (eMat -> eMat + p .)
    )               reduce using rule 65 (eMat -> eMat + p .)
    }               reduce using rule 65 (eMat -> eMat + p .)
    ]               reduce using rule 65 (eMat -> eMat + p .)
    EQEQ            reduce using rule 65 (eMat -> eMat + p .)
    DISTINTO        reduce using rule 65 (eMat -> eMat + p .)
    AND             reduce using rule 65 (eMat -> eMat + p .)
    ?               reduce using rule 65 (eMat -> eMat + p .)
    OR              reduce using rule 65 (eMat -> eMat + p .)
    :               reduce using rule 65 (eMat -> eMat + p .)
    *               shift and go to state 68
    /               shift and go to state 70
    %               shift and go to state 69


state 168

    (66) eMat -> eMat - p .
    (68) p -> p . * exp
    (69) p -> p . / exp
    (70) p -> p . % exp

    +               reduce using rule 66 (eMat -> eMat - p .)
    -               reduce using rule 66 (eMat -> eMat - p .)
    MULEQ           reduce using rule 66 (eMat -> eMat - p .)
    DIVEQ           reduce using rule 66 (eMat -> eMat - p .)
    MASEQ           reduce using rule 66 (eMat -> eMat - p .)
    MENOSEQ         reduce using rule 66 (eMat -> eMat - p .)
    ;               reduce using rule 66 (eMat -> eMat - p .)
    >               reduce using rule 66 (eMat -> eMat - p .)
    <               reduce using rule 66 (eMat -> eMat - p .)
    ,               reduce using rule 66 (eMat -> eMat - p .)
    )               reduce using rule 66 (eMat -> eMat - p .)
    }               reduce using rule 66 (eMat -> eMat - p .)
    ]               reduce using rule 66 (eMat -> eMat - p .)
    EQEQ            reduce using rule 66 (eMat -> eMat - p .)
    DISTINTO        reduce using rule 66 (eMat -> eMat - p .)
    AND             reduce using rule 66 (eMat -> eMat - p .)
    ?               reduce using rule 66 (eMat -> eMat - p .)
    OR              reduce using rule 66 (eMat -> eMat - p .)
    :               reduce using rule 66 (eMat -> eMat - p .)
    *               shift and go to state 68
    /               shift and go to state 70
    %               shift and go to state 69


state 169

    (40) valores -> ID . ID .
    (62) asig -> ID . ID . = asig

    MULEQ           reduce using rule 40 (valores -> ID . ID .)
    DIVEQ           reduce using rule 40 (valores -> ID . ID .)
    MASEQ           reduce using rule 40 (valores -> ID . ID .)
    MENOSEQ         reduce using rule 40 (valores -> ID . ID .)
    }               reduce using rule 40 (valores -> ID . ID .)
    ;               reduce using rule 40 (valores -> ID . ID .)
    =               shift and go to state 192


state 170

    (44) m -> [ INT . ]
    (45) m -> [ INT . ] m

    ]               shift and go to state 193


state 171

    (64) asig -> valores .

    ;               reduce using rule 64 (asig -> valores .)


state 172

    (61) asig -> ID = asig .

    ;               reduce using rule 61 (asig -> ID = asig .)


state 173

    (31) vec -> ID = [ . elem ]
    (32) elem -> . valores , elem
    (33) elem -> . valores
    (34) valores -> . eMat
    (35) valores -> . expBool
    (36) valores -> . expString
    (37) valores -> . varYVals
    (38) valores -> . funcReturn
    (39) valores -> . reg
    (40) valores -> . ID . ID
    (65) eMat -> . eMat + p
    (66) eMat -> . eMat - p
    (67) eMat -> . p
    (87) expBool -> . or ? expBool : expBool
    (88) expBool -> . or
    (83) expString -> . expString + STRING
    (84) expString -> . STRING
    (85) expString -> . varYVals
    (86) expString -> . funcString
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (20) funcReturn -> . funcInt
    (21) funcReturn -> . funcString
    (22) funcReturn -> . funcBool
    (46) reg -> . { campos }
    (68) p -> . p * exp
    (69) p -> . p / exp
    (70) p -> . p % exp
    (71) p -> . exp
    (89) or -> . or OR and
    (90) or -> . and
    (25) funcString -> . CAPITALIZAR ( expString )
    (43) vecVal -> . ID m
    (23) funcInt -> . MULTIESCALAR ( vec , eMat , param )
    (24) funcInt -> . LENGTH ( vec )
    (26) funcBool -> . COLINEALES ( vec , vec )
    (72) exp -> . exp ^ iSing
    (73) exp -> . iSing
    (91) and -> . and AND eq
    (92) and -> . eq
    (74) iSing -> . - paren
    (75) iSing -> . + paren
    (76) iSing -> . paren
    (93) eq -> . eq EQEQ tBool
    (94) eq -> . eq DISTINTO tBool
    (95) eq -> . mayor
    (77) paren -> . ( eMat )
    (78) paren -> . INT
    (79) paren -> . varYVals
    (80) paren -> . FLOAT
    (81) paren -> . varsOps
    (82) paren -> . funcInt
    (96) mayor -> . tCompare > tCompare
    (97) mayor -> . menor
    (49) varsOps -> . MENOSMENOS sMM
    (50) varsOps -> . MASMAS sMM
    (51) varsOps -> . sMM
    (106) tCompare -> . eMat
    (107) tCompare -> . varsOps
    (108) tCompare -> . varYVals
    (98) menor -> . tCompare < tCompare
    (99) menor -> . not
    (52) sMM -> . ID MASMAS
    (53) sMM -> . ID MENOSMENOS
    (54) sMM -> . ID
    (100) not -> . NOT not
    (101) not -> . tBool
    (102) tBool -> . ( expBool )
    (103) tBool -> . BOOL
    (104) tBool -> . varYVals
    (105) tBool -> . funcBool

    ID              shift and go to state 133
    STRING          shift and go to state 51
    {               shift and go to state 32
    CAPITALIZAR     shift and go to state 57
    MULTIESCALAR    shift and go to state 55
    LENGTH          shift and go to state 11
    COLINEALES      shift and go to state 1
    -               shift and go to state 50
    +               shift and go to state 20
    (               shift and go to state 5
    INT             shift and go to state 27
    FLOAT           shift and go to state 56
    MENOSMENOS      shift and go to state 23
    MASMAS          shift and go to state 28
    NOT             shift and go to state 30
    BOOL            shift and go to state 41

    and                            shift and go to state 44
    funcBool                       shift and go to state 2
    funcInt                        shift and go to state 14
    valores                        shift and go to state 195
    menor                          shift and go to state 3
    eq                             shift and go to state 16
    vecVal                         shift and go to state 47
    eMat                           shift and go to state 49
    mayor                          shift and go to state 4
    sMM                            shift and go to state 6
    paren                          shift and go to state 36
    reg                            shift and go to state 22
    varsOps                        shift and go to state 64
    expString                      shift and go to state 24
    tCompare                       shift and go to state 37
    not                            shift and go to state 8
    funcString                     shift and go to state 92
    funcReturn                     shift and go to state 93
    elem                           shift and go to state 194
    p                              shift and go to state 10
    iSing                          shift and go to state 12
    exp                            shift and go to state 59
    tBool                          shift and go to state 31
    varYVals                       shift and go to state 33
    or                             shift and go to state 34
    expBool                        shift and go to state 29

state 174

    (61) asig -> ID . = asig
    (62) asig -> ID . . ID = asig
    (31) vec -> ID . = [ elem ]
    (40) valores -> ID . . ID
    (41) varYVals -> ID .
    (43) vecVal -> ID . m
    (52) sMM -> ID . MASMAS
    (53) sMM -> ID . MENOSMENOS
    (54) sMM -> ID .
    (44) m -> . [ INT ]
    (45) m -> . [ INT ] m

  ! reduce/reduce conflict for ^ resolved using rule 41 (varYVals -> ID .)
  ! reduce/reduce conflict for * resolved using rule 41 (varYVals -> ID .)
  ! reduce/reduce conflict for / resolved using rule 41 (varYVals -> ID .)
  ! reduce/reduce conflict for % resolved using rule 41 (varYVals -> ID .)
  ! reduce/reduce conflict for + resolved using rule 41 (varYVals -> ID .)
  ! reduce/reduce conflict for - resolved using rule 41 (varYVals -> ID .)
  ! reduce/reduce conflict for ; resolved using rule 41 (varYVals -> ID .)
  ! reduce/reduce conflict for > resolved using rule 41 (varYVals -> ID .)
  ! reduce/reduce conflict for < resolved using rule 41 (varYVals -> ID .)
    =               shift and go to state 118
    .               shift and go to state 196
    ;               reduce using rule 41 (varYVals -> ID .)
    +               reduce using rule 41 (varYVals -> ID .)
    ^               reduce using rule 41 (varYVals -> ID .)
    *               reduce using rule 41 (varYVals -> ID .)
    /               reduce using rule 41 (varYVals -> ID .)
    %               reduce using rule 41 (varYVals -> ID .)
    -               reduce using rule 41 (varYVals -> ID .)
    >               reduce using rule 41 (varYVals -> ID .)
    <               reduce using rule 41 (varYVals -> ID .)
    EQEQ            reduce using rule 41 (varYVals -> ID .)
    DISTINTO        reduce using rule 41 (varYVals -> ID .)
    AND             reduce using rule 41 (varYVals -> ID .)
    ?               reduce using rule 41 (varYVals -> ID .)
    OR              reduce using rule 41 (varYVals -> ID .)
    MASMAS          shift and go to state 116
    MENOSMENOS      shift and go to state 119
    [               shift and go to state 117

  ! ^               [ reduce using rule 54 (sMM -> ID .) ]
  ! *               [ reduce using rule 54 (sMM -> ID .) ]
  ! /               [ reduce using rule 54 (sMM -> ID .) ]
  ! %               [ reduce using rule 54 (sMM -> ID .) ]
  ! +               [ reduce using rule 54 (sMM -> ID .) ]
  ! -               [ reduce using rule 54 (sMM -> ID .) ]
  ! ;               [ reduce using rule 54 (sMM -> ID .) ]
  ! >               [ reduce using rule 54 (sMM -> ID .) ]
  ! <               [ reduce using rule 54 (sMM -> ID .) ]

    m                              shift and go to state 114

state 175

    (13) if -> IF ( expBool . ) THEN bloque else

    )               shift and go to state 197


state 176

    (23) funcInt -> MULTIESCALAR ( vec . , eMat , param )

    ,               shift and go to state 198


state 177

    (25) funcString -> CAPITALIZAR ( expString . )
    (83) expString -> expString . + STRING

    )               shift and go to state 199
    +               shift and go to state 84


state 178

    (86) expString -> funcString .

    )               reduce using rule 86 (expString -> funcString .)
    +               reduce using rule 86 (expString -> funcString .)


state 179

    (85) expString -> varYVals .

    )               reduce using rule 85 (expString -> varYVals .)
    +               reduce using rule 85 (expString -> varYVals .)


state 180

    (72) exp -> exp ^ iSing .

    ^               reduce using rule 72 (exp -> exp ^ iSing .)
    *               reduce using rule 72 (exp -> exp ^ iSing .)
    /               reduce using rule 72 (exp -> exp ^ iSing .)
    %               reduce using rule 72 (exp -> exp ^ iSing .)
    +               reduce using rule 72 (exp -> exp ^ iSing .)
    -               reduce using rule 72 (exp -> exp ^ iSing .)
    MASEQ           reduce using rule 72 (exp -> exp ^ iSing .)
    MENOSEQ         reduce using rule 72 (exp -> exp ^ iSing .)
    ;               reduce using rule 72 (exp -> exp ^ iSing .)
    >               reduce using rule 72 (exp -> exp ^ iSing .)
    <               reduce using rule 72 (exp -> exp ^ iSing .)
    MULEQ           reduce using rule 72 (exp -> exp ^ iSing .)
    DIVEQ           reduce using rule 72 (exp -> exp ^ iSing .)
    )               reduce using rule 72 (exp -> exp ^ iSing .)
    }               reduce using rule 72 (exp -> exp ^ iSing .)
    EQEQ            reduce using rule 72 (exp -> exp ^ iSing .)
    DISTINTO        reduce using rule 72 (exp -> exp ^ iSing .)
    AND             reduce using rule 72 (exp -> exp ^ iSing .)
    ?               reduce using rule 72 (exp -> exp ^ iSing .)
    OR              reduce using rule 72 (exp -> exp ^ iSing .)
    :               reduce using rule 72 (exp -> exp ^ iSing .)
    ,               reduce using rule 72 (exp -> exp ^ iSing .)
    ]               reduce using rule 72 (exp -> exp ^ iSing .)


state 181

    (26) funcBool -> COLINEALES ( vec , . vec )
    (31) vec -> . ID = [ elem ]

    ID              shift and go to state 126

    vec                            shift and go to state 200

state 182

    (31) vec -> ID = . [ elem ]

    [               shift and go to state 173


state 183

    (24) funcInt -> LENGTH ( vec ) .

    ^               reduce using rule 24 (funcInt -> LENGTH ( vec ) .)
    *               reduce using rule 24 (funcInt -> LENGTH ( vec ) .)
    /               reduce using rule 24 (funcInt -> LENGTH ( vec ) .)
    %               reduce using rule 24 (funcInt -> LENGTH ( vec ) .)
    +               reduce using rule 24 (funcInt -> LENGTH ( vec ) .)
    -               reduce using rule 24 (funcInt -> LENGTH ( vec ) .)
    >               reduce using rule 24 (funcInt -> LENGTH ( vec ) .)
    <               reduce using rule 24 (funcInt -> LENGTH ( vec ) .)
    ,               reduce using rule 24 (funcInt -> LENGTH ( vec ) .)
    ;               reduce using rule 24 (funcInt -> LENGTH ( vec ) .)
    MULEQ           reduce using rule 24 (funcInt -> LENGTH ( vec ) .)
    DIVEQ           reduce using rule 24 (funcInt -> LENGTH ( vec ) .)
    MASEQ           reduce using rule 24 (funcInt -> LENGTH ( vec ) .)
    MENOSEQ         reduce using rule 24 (funcInt -> LENGTH ( vec ) .)
    }               reduce using rule 24 (funcInt -> LENGTH ( vec ) .)
    )               reduce using rule 24 (funcInt -> LENGTH ( vec ) .)
    EQEQ            reduce using rule 24 (funcInt -> LENGTH ( vec ) .)
    DISTINTO        reduce using rule 24 (funcInt -> LENGTH ( vec ) .)
    AND             reduce using rule 24 (funcInt -> LENGTH ( vec ) .)
    ?               reduce using rule 24 (funcInt -> LENGTH ( vec ) .)
    OR              reduce using rule 24 (funcInt -> LENGTH ( vec ) .)
    :               reduce using rule 24 (funcInt -> LENGTH ( vec ) .)
    ]               reduce using rule 24 (funcInt -> LENGTH ( vec ) .)


state 184

    (27) funcVoid -> PRINT ( valores ) .

    ;               reduce using rule 27 (funcVoid -> PRINT ( valores ) .)


state 185

    (12) loop -> FOR ( varAsig ; . expBool ; varsOps ) bloque
    (87) expBool -> . or ? expBool : expBool
    (88) expBool -> . or
    (89) or -> . or OR and
    (90) or -> . and
    (91) and -> . and AND eq
    (92) and -> . eq
    (93) eq -> . eq EQEQ tBool
    (94) eq -> . eq DISTINTO tBool
    (95) eq -> . mayor
    (96) mayor -> . tCompare > tCompare
    (97) mayor -> . menor
    (106) tCompare -> . eMat
    (107) tCompare -> . varsOps
    (108) tCompare -> . varYVals
    (98) menor -> . tCompare < tCompare
    (99) menor -> . not
    (65) eMat -> . eMat + p
    (66) eMat -> . eMat - p
    (67) eMat -> . p
    (49) varsOps -> . MENOSMENOS sMM
    (50) varsOps -> . MASMAS sMM
    (51) varsOps -> . sMM
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (100) not -> . NOT not
    (101) not -> . tBool
    (68) p -> . p * exp
    (69) p -> . p / exp
    (70) p -> . p % exp
    (71) p -> . exp
    (52) sMM -> . ID MASMAS
    (53) sMM -> . ID MENOSMENOS
    (54) sMM -> . ID
    (43) vecVal -> . ID m
    (102) tBool -> . ( expBool )
    (103) tBool -> . BOOL
    (104) tBool -> . varYVals
    (105) tBool -> . funcBool
    (72) exp -> . exp ^ iSing
    (73) exp -> . iSing
    (26) funcBool -> . COLINEALES ( vec , vec )
    (74) iSing -> . - paren
    (75) iSing -> . + paren
    (76) iSing -> . paren
    (77) paren -> . ( eMat )
    (78) paren -> . INT
    (79) paren -> . varYVals
    (80) paren -> . FLOAT
    (81) paren -> . varsOps
    (82) paren -> . funcInt
    (23) funcInt -> . MULTIESCALAR ( vec , eMat , param )
    (24) funcInt -> . LENGTH ( vec )

    MENOSMENOS      shift and go to state 23
    MASMAS          shift and go to state 28
    ID              shift and go to state 143
    NOT             shift and go to state 30
    (               shift and go to state 142
    BOOL            shift and go to state 41
    COLINEALES      shift and go to state 1
    -               shift and go to state 50
    +               shift and go to state 20
    INT             shift and go to state 27
    FLOAT           shift and go to state 56
    MULTIESCALAR    shift and go to state 55
    LENGTH          shift and go to state 11

    and                            shift and go to state 44
    funcBool                       shift and go to state 61
    funcInt                        shift and go to state 62
    menor                          shift and go to state 3
    eq                             shift and go to state 16
    mayor                          shift and go to state 4
    eMat                           shift and go to state 141
    vecVal                         shift and go to state 47
    sMM                            shift and go to state 6
    paren                          shift and go to state 36
    iSing                          shift and go to state 12
    tCompare                       shift and go to state 37
    not                            shift and go to state 8
    p                              shift and go to state 10
    varsOps                        shift and go to state 144
    exp                            shift and go to state 59
    tBool                          shift and go to state 31
    varYVals                       shift and go to state 145
    or                             shift and go to state 34
    expBool                        shift and go to state 201

state 186

    (40) valores -> ID . ID .

    ,               reduce using rule 40 (valores -> ID . ID .)
    ]               reduce using rule 40 (valores -> ID . ID .)
    }               reduce using rule 40 (valores -> ID . ID .)
    )               reduce using rule 40 (valores -> ID . ID .)


state 187

    (47) campos -> ID : valores . , campos

    ,               shift and go to state 202


state 188

    (87) expBool -> or ? expBool : . expBool
    (87) expBool -> . or ? expBool : expBool
    (88) expBool -> . or
    (89) or -> . or OR and
    (90) or -> . and
    (91) and -> . and AND eq
    (92) and -> . eq
    (93) eq -> . eq EQEQ tBool
    (94) eq -> . eq DISTINTO tBool
    (95) eq -> . mayor
    (96) mayor -> . tCompare > tCompare
    (97) mayor -> . menor
    (106) tCompare -> . eMat
    (107) tCompare -> . varsOps
    (108) tCompare -> . varYVals
    (98) menor -> . tCompare < tCompare
    (99) menor -> . not
    (65) eMat -> . eMat + p
    (66) eMat -> . eMat - p
    (67) eMat -> . p
    (49) varsOps -> . MENOSMENOS sMM
    (50) varsOps -> . MASMAS sMM
    (51) varsOps -> . sMM
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (100) not -> . NOT not
    (101) not -> . tBool
    (68) p -> . p * exp
    (69) p -> . p / exp
    (70) p -> . p % exp
    (71) p -> . exp
    (52) sMM -> . ID MASMAS
    (53) sMM -> . ID MENOSMENOS
    (54) sMM -> . ID
    (43) vecVal -> . ID m
    (102) tBool -> . ( expBool )
    (103) tBool -> . BOOL
    (104) tBool -> . varYVals
    (105) tBool -> . funcBool
    (72) exp -> . exp ^ iSing
    (73) exp -> . iSing
    (26) funcBool -> . COLINEALES ( vec , vec )
    (74) iSing -> . - paren
    (75) iSing -> . + paren
    (76) iSing -> . paren
    (77) paren -> . ( eMat )
    (78) paren -> . INT
    (79) paren -> . varYVals
    (80) paren -> . FLOAT
    (81) paren -> . varsOps
    (82) paren -> . funcInt
    (23) funcInt -> . MULTIESCALAR ( vec , eMat , param )
    (24) funcInt -> . LENGTH ( vec )

    MENOSMENOS      shift and go to state 23
    MASMAS          shift and go to state 28
    ID              shift and go to state 143
    NOT             shift and go to state 30
    (               shift and go to state 142
    BOOL            shift and go to state 41
    COLINEALES      shift and go to state 1
    -               shift and go to state 50
    +               shift and go to state 20
    INT             shift and go to state 27
    FLOAT           shift and go to state 56
    MULTIESCALAR    shift and go to state 55
    LENGTH          shift and go to state 11

    and                            shift and go to state 44
    funcBool                       shift and go to state 61
    funcInt                        shift and go to state 62
    menor                          shift and go to state 3
    eq                             shift and go to state 16
    mayor                          shift and go to state 4
    eMat                           shift and go to state 141
    vecVal                         shift and go to state 47
    sMM                            shift and go to state 6
    paren                          shift and go to state 36
    iSing                          shift and go to state 12
    tCompare                       shift and go to state 37
    not                            shift and go to state 8
    p                              shift and go to state 10
    varsOps                        shift and go to state 144
    exp                            shift and go to state 59
    tBool                          shift and go to state 31
    varYVals                       shift and go to state 145
    or                             shift and go to state 34
    expBool                        shift and go to state 203

state 189

    (10) loop -> WHILE ( expBool ) . bloque
    (16) bloque -> . sentencia
    (17) bloque -> . { g }
    (4) sentencia -> . varsOps ;
    (5) sentencia -> . func ;
    (6) sentencia -> . varAsig ;
    (7) sentencia -> . RETURN ;
    (49) varsOps -> . MENOSMENOS sMM
    (50) varsOps -> . MASMAS sMM
    (51) varsOps -> . sMM
    (18) func -> . funcReturn
    (19) func -> . funcVoid
    (55) varAsig -> . valores MULEQ varAsig
    (56) varAsig -> . valores DIVEQ varAsig
    (57) varAsig -> . sIgual
    (52) sMM -> . ID MASMAS
    (53) sMM -> . ID MENOSMENOS
    (54) sMM -> . ID
    (20) funcReturn -> . funcInt
    (21) funcReturn -> . funcString
    (22) funcReturn -> . funcBool
    (27) funcVoid -> . PRINT ( valores )
    (34) valores -> . eMat
    (35) valores -> . expBool
    (36) valores -> . expString
    (37) valores -> . varYVals
    (38) valores -> . funcReturn
    (39) valores -> . reg
    (40) valores -> . ID . ID
    (58) sIgual -> . valores MASEQ sIgual
    (59) sIgual -> . valores MENOSEQ sIgual
    (60) sIgual -> . asig
    (23) funcInt -> . MULTIESCALAR ( vec , eMat , param )
    (24) funcInt -> . LENGTH ( vec )
    (25) funcString -> . CAPITALIZAR ( expString )
    (26) funcBool -> . COLINEALES ( vec , vec )
    (65) eMat -> . eMat + p
    (66) eMat -> . eMat - p
    (67) eMat -> . p
    (87) expBool -> . or ? expBool : expBool
    (88) expBool -> . or
    (83) expString -> . expString + STRING
    (84) expString -> . STRING
    (85) expString -> . varYVals
    (86) expString -> . funcString
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (46) reg -> . { campos }
    (61) asig -> . ID = asig
    (62) asig -> . ID . ID = asig
    (63) asig -> . vec
    (64) asig -> . valores
    (68) p -> . p * exp
    (69) p -> . p / exp
    (70) p -> . p % exp
    (71) p -> . exp
    (89) or -> . or OR and
    (90) or -> . and
    (43) vecVal -> . ID m
    (31) vec -> . ID = [ elem ]
    (72) exp -> . exp ^ iSing
    (73) exp -> . iSing
    (91) and -> . and AND eq
    (92) and -> . eq
    (74) iSing -> . - paren
    (75) iSing -> . + paren
    (76) iSing -> . paren
    (93) eq -> . eq EQEQ tBool
    (94) eq -> . eq DISTINTO tBool
    (95) eq -> . mayor
    (77) paren -> . ( eMat )
    (78) paren -> . INT
    (79) paren -> . varYVals
    (80) paren -> . FLOAT
    (81) paren -> . varsOps
    (82) paren -> . funcInt
    (96) mayor -> . tCompare > tCompare
    (97) mayor -> . menor
    (106) tCompare -> . eMat
    (107) tCompare -> . varsOps
    (108) tCompare -> . varYVals
    (98) menor -> . tCompare < tCompare
    (99) menor -> . not
    (100) not -> . NOT not
    (101) not -> . tBool
    (102) tBool -> . ( expBool )
    (103) tBool -> . BOOL
    (104) tBool -> . varYVals
    (105) tBool -> . funcBool

    {               shift and go to state 109
    RETURN          shift and go to state 13
    MENOSMENOS      shift and go to state 23
    MASMAS          shift and go to state 28
    ID              shift and go to state 52
    PRINT           shift and go to state 15
    MULTIESCALAR    shift and go to state 55
    LENGTH          shift and go to state 11
    CAPITALIZAR     shift and go to state 57
    COLINEALES      shift and go to state 1
    STRING          shift and go to state 51
    -               shift and go to state 50
    +               shift and go to state 20
    (               shift and go to state 5
    INT             shift and go to state 27
    FLOAT           shift and go to state 56
    NOT             shift and go to state 30
    BOOL            shift and go to state 41

    and                            shift and go to state 44
    funcBool                       shift and go to state 2
    funcInt                        shift and go to state 14
    menor                          shift and go to state 3
    bloque                         shift and go to state 204
    eq                             shift and go to state 16
    vecVal                         shift and go to state 47
    sentencia                      shift and go to state 108
    eMat                           shift and go to state 49
    asig                           shift and go to state 19
    mayor                          shift and go to state 4
    sMM                            shift and go to state 6
    vec                            shift and go to state 7
    sIgual                         shift and go to state 21
    reg                            shift and go to state 22
    iSing                          shift and go to state 12
    funcVoid                       shift and go to state 54
    expString                      shift and go to state 24
    tCompare                       shift and go to state 37
    func                           shift and go to state 38
    paren                          shift and go to state 36
    not                            shift and go to state 8
    varAsig                        shift and go to state 39
    funcString                     shift and go to state 26
    funcReturn                     shift and go to state 9
    valores                        shift and go to state 40
    p                              shift and go to state 10
    varsOps                        shift and go to state 58
    exp                            shift and go to state 59
    tBool                          shift and go to state 31
    varYVals                       shift and go to state 33
    or                             shift and go to state 34
    expBool                        shift and go to state 29

state 190

    (11) loop -> DO bloque WHILE ( . expBool ) ;
    (87) expBool -> . or ? expBool : expBool
    (88) expBool -> . or
    (89) or -> . or OR and
    (90) or -> . and
    (91) and -> . and AND eq
    (92) and -> . eq
    (93) eq -> . eq EQEQ tBool
    (94) eq -> . eq DISTINTO tBool
    (95) eq -> . mayor
    (96) mayor -> . tCompare > tCompare
    (97) mayor -> . menor
    (106) tCompare -> . eMat
    (107) tCompare -> . varsOps
    (108) tCompare -> . varYVals
    (98) menor -> . tCompare < tCompare
    (99) menor -> . not
    (65) eMat -> . eMat + p
    (66) eMat -> . eMat - p
    (67) eMat -> . p
    (49) varsOps -> . MENOSMENOS sMM
    (50) varsOps -> . MASMAS sMM
    (51) varsOps -> . sMM
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (100) not -> . NOT not
    (101) not -> . tBool
    (68) p -> . p * exp
    (69) p -> . p / exp
    (70) p -> . p % exp
    (71) p -> . exp
    (52) sMM -> . ID MASMAS
    (53) sMM -> . ID MENOSMENOS
    (54) sMM -> . ID
    (43) vecVal -> . ID m
    (102) tBool -> . ( expBool )
    (103) tBool -> . BOOL
    (104) tBool -> . varYVals
    (105) tBool -> . funcBool
    (72) exp -> . exp ^ iSing
    (73) exp -> . iSing
    (26) funcBool -> . COLINEALES ( vec , vec )
    (74) iSing -> . - paren
    (75) iSing -> . + paren
    (76) iSing -> . paren
    (77) paren -> . ( eMat )
    (78) paren -> . INT
    (79) paren -> . varYVals
    (80) paren -> . FLOAT
    (81) paren -> . varsOps
    (82) paren -> . funcInt
    (23) funcInt -> . MULTIESCALAR ( vec , eMat , param )
    (24) funcInt -> . LENGTH ( vec )

    MENOSMENOS      shift and go to state 23
    MASMAS          shift and go to state 28
    ID              shift and go to state 143
    NOT             shift and go to state 30
    (               shift and go to state 142
    BOOL            shift and go to state 41
    COLINEALES      shift and go to state 1
    -               shift and go to state 50
    +               shift and go to state 20
    INT             shift and go to state 27
    FLOAT           shift and go to state 56
    MULTIESCALAR    shift and go to state 55
    LENGTH          shift and go to state 11

    and                            shift and go to state 44
    funcBool                       shift and go to state 61
    funcInt                        shift and go to state 62
    menor                          shift and go to state 3
    eq                             shift and go to state 16
    mayor                          shift and go to state 4
    eMat                           shift and go to state 141
    vecVal                         shift and go to state 47
    sMM                            shift and go to state 6
    paren                          shift and go to state 36
    iSing                          shift and go to state 12
    tCompare                       shift and go to state 37
    not                            shift and go to state 8
    p                              shift and go to state 10
    varsOps                        shift and go to state 144
    exp                            shift and go to state 59
    tBool                          shift and go to state 31
    varYVals                       shift and go to state 145
    or                             shift and go to state 34
    expBool                        shift and go to state 205

state 191

    (17) bloque -> { g } .

    RETURN          reduce using rule 17 (bloque -> { g } .)
    MENOSMENOS      reduce using rule 17 (bloque -> { g } .)
    MASMAS          reduce using rule 17 (bloque -> { g } .)
    IF              reduce using rule 17 (bloque -> { g } .)
    WHILE           reduce using rule 17 (bloque -> { g } .)
    DO              reduce using rule 17 (bloque -> { g } .)
    FOR             reduce using rule 17 (bloque -> { g } .)
    ID              reduce using rule 17 (bloque -> { g } .)
    PRINT           reduce using rule 17 (bloque -> { g } .)
    MULTIESCALAR    reduce using rule 17 (bloque -> { g } .)
    LENGTH          reduce using rule 17 (bloque -> { g } .)
    CAPITALIZAR     reduce using rule 17 (bloque -> { g } .)
    COLINEALES      reduce using rule 17 (bloque -> { g } .)
    STRING          reduce using rule 17 (bloque -> { g } .)
    {               reduce using rule 17 (bloque -> { g } .)
    -               reduce using rule 17 (bloque -> { g } .)
    +               reduce using rule 17 (bloque -> { g } .)
    (               reduce using rule 17 (bloque -> { g } .)
    INT             reduce using rule 17 (bloque -> { g } .)
    FLOAT           reduce using rule 17 (bloque -> { g } .)
    NOT             reduce using rule 17 (bloque -> { g } .)
    BOOL            reduce using rule 17 (bloque -> { g } .)
    $end            reduce using rule 17 (bloque -> { g } .)
    }               reduce using rule 17 (bloque -> { g } .)
    ELSE            reduce using rule 17 (bloque -> { g } .)


state 192

    (62) asig -> ID . ID = . asig
    (61) asig -> . ID = asig
    (62) asig -> . ID . ID = asig
    (63) asig -> . vec
    (64) asig -> . valores
    (31) vec -> . ID = [ elem ]
    (34) valores -> . eMat
    (35) valores -> . expBool
    (36) valores -> . expString
    (37) valores -> . varYVals
    (38) valores -> . funcReturn
    (39) valores -> . reg
    (40) valores -> . ID . ID
    (65) eMat -> . eMat + p
    (66) eMat -> . eMat - p
    (67) eMat -> . p
    (87) expBool -> . or ? expBool : expBool
    (88) expBool -> . or
    (83) expString -> . expString + STRING
    (84) expString -> . STRING
    (85) expString -> . varYVals
    (86) expString -> . funcString
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (20) funcReturn -> . funcInt
    (21) funcReturn -> . funcString
    (22) funcReturn -> . funcBool
    (46) reg -> . { campos }
    (68) p -> . p * exp
    (69) p -> . p / exp
    (70) p -> . p % exp
    (71) p -> . exp
    (89) or -> . or OR and
    (90) or -> . and
    (25) funcString -> . CAPITALIZAR ( expString )
    (43) vecVal -> . ID m
    (23) funcInt -> . MULTIESCALAR ( vec , eMat , param )
    (24) funcInt -> . LENGTH ( vec )
    (26) funcBool -> . COLINEALES ( vec , vec )
    (72) exp -> . exp ^ iSing
    (73) exp -> . iSing
    (91) and -> . and AND eq
    (92) and -> . eq
    (74) iSing -> . - paren
    (75) iSing -> . + paren
    (76) iSing -> . paren
    (93) eq -> . eq EQEQ tBool
    (94) eq -> . eq DISTINTO tBool
    (95) eq -> . mayor
    (77) paren -> . ( eMat )
    (78) paren -> . INT
    (79) paren -> . varYVals
    (80) paren -> . FLOAT
    (81) paren -> . varsOps
    (82) paren -> . funcInt
    (96) mayor -> . tCompare > tCompare
    (97) mayor -> . menor
    (49) varsOps -> . MENOSMENOS sMM
    (50) varsOps -> . MASMAS sMM
    (51) varsOps -> . sMM
    (106) tCompare -> . eMat
    (107) tCompare -> . varsOps
    (108) tCompare -> . varYVals
    (98) menor -> . tCompare < tCompare
    (99) menor -> . not
    (52) sMM -> . ID MASMAS
    (53) sMM -> . ID MENOSMENOS
    (54) sMM -> . ID
    (100) not -> . NOT not
    (101) not -> . tBool
    (102) tBool -> . ( expBool )
    (103) tBool -> . BOOL
    (104) tBool -> . varYVals
    (105) tBool -> . funcBool

    ID              shift and go to state 174
    STRING          shift and go to state 51
    {               shift and go to state 32
    CAPITALIZAR     shift and go to state 57
    MULTIESCALAR    shift and go to state 55
    LENGTH          shift and go to state 11
    COLINEALES      shift and go to state 1
    -               shift and go to state 50
    +               shift and go to state 20
    (               shift and go to state 5
    INT             shift and go to state 27
    FLOAT           shift and go to state 56
    MENOSMENOS      shift and go to state 23
    MASMAS          shift and go to state 28
    NOT             shift and go to state 30
    BOOL            shift and go to state 41

    and                            shift and go to state 44
    funcBool                       shift and go to state 2
    funcInt                        shift and go to state 14
    valores                        shift and go to state 171
    menor                          shift and go to state 3
    eq                             shift and go to state 16
    vecVal                         shift and go to state 47
    eMat                           shift and go to state 49
    asig                           shift and go to state 206
    mayor                          shift and go to state 4
    sMM                            shift and go to state 6
    vec                            shift and go to state 7
    paren                          shift and go to state 36
    reg                            shift and go to state 22
    varsOps                        shift and go to state 64
    expString                      shift and go to state 24
    tCompare                       shift and go to state 37
    not                            shift and go to state 8
    funcString                     shift and go to state 92
    funcReturn                     shift and go to state 93
    p                              shift and go to state 10
    iSing                          shift and go to state 12
    exp                            shift and go to state 59
    tBool                          shift and go to state 31
    varYVals                       shift and go to state 33
    or                             shift and go to state 34
    expBool                        shift and go to state 29

state 193

    (44) m -> [ INT ] .
    (45) m -> [ INT ] . m
    (44) m -> . [ INT ]
    (45) m -> . [ INT ] m

    )               reduce using rule 44 (m -> [ INT ] .)
    +               reduce using rule 44 (m -> [ INT ] .)
    ^               reduce using rule 44 (m -> [ INT ] .)
    *               reduce using rule 44 (m -> [ INT ] .)
    /               reduce using rule 44 (m -> [ INT ] .)
    %               reduce using rule 44 (m -> [ INT ] .)
    -               reduce using rule 44 (m -> [ INT ] .)
    >               reduce using rule 44 (m -> [ INT ] .)
    <               reduce using rule 44 (m -> [ INT ] .)
    EQEQ            reduce using rule 44 (m -> [ INT ] .)
    DISTINTO        reduce using rule 44 (m -> [ INT ] .)
    AND             reduce using rule 44 (m -> [ INT ] .)
    ?               reduce using rule 44 (m -> [ INT ] .)
    OR              reduce using rule 44 (m -> [ INT ] .)
    ,               reduce using rule 44 (m -> [ INT ] .)
    ]               reduce using rule 44 (m -> [ INT ] .)
    MULEQ           reduce using rule 44 (m -> [ INT ] .)
    DIVEQ           reduce using rule 44 (m -> [ INT ] .)
    MASEQ           reduce using rule 44 (m -> [ INT ] .)
    MENOSEQ         reduce using rule 44 (m -> [ INT ] .)
    ;               reduce using rule 44 (m -> [ INT ] .)
    }               reduce using rule 44 (m -> [ INT ] .)
    :               reduce using rule 44 (m -> [ INT ] .)
    [               shift and go to state 117

    m                              shift and go to state 207

state 194

    (31) vec -> ID = [ elem . ]

    ]               shift and go to state 208


state 195

    (32) elem -> valores . , elem
    (33) elem -> valores .

    ,               shift and go to state 209
    ]               reduce using rule 33 (elem -> valores .)


state 196

    (62) asig -> ID . . ID = asig
    (40) valores -> ID . . ID

    ID              shift and go to state 210


state 197

    (13) if -> IF ( expBool ) . THEN bloque else

    THEN            shift and go to state 211


state 198

    (23) funcInt -> MULTIESCALAR ( vec , . eMat , param )
    (65) eMat -> . eMat + p
    (66) eMat -> . eMat - p
    (67) eMat -> . p
    (68) p -> . p * exp
    (69) p -> . p / exp
    (70) p -> . p % exp
    (71) p -> . exp
    (72) exp -> . exp ^ iSing
    (73) exp -> . iSing
    (74) iSing -> . - paren
    (75) iSing -> . + paren
    (76) iSing -> . paren
    (77) paren -> . ( eMat )
    (78) paren -> . INT
    (79) paren -> . varYVals
    (80) paren -> . FLOAT
    (81) paren -> . varsOps
    (82) paren -> . funcInt
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (49) varsOps -> . MENOSMENOS sMM
    (50) varsOps -> . MASMAS sMM
    (51) varsOps -> . sMM
    (23) funcInt -> . MULTIESCALAR ( vec , eMat , param )
    (24) funcInt -> . LENGTH ( vec )
    (43) vecVal -> . ID m
    (52) sMM -> . ID MASMAS
    (53) sMM -> . ID MENOSMENOS
    (54) sMM -> . ID

    -               shift and go to state 50
    +               shift and go to state 20
    (               shift and go to state 78
    INT             shift and go to state 27
    FLOAT           shift and go to state 56
    ID              shift and go to state 65
    MENOSMENOS      shift and go to state 23
    MASMAS          shift and go to state 28
    MULTIESCALAR    shift and go to state 55
    LENGTH          shift and go to state 11

    eMat                           shift and go to state 212
    funcInt                        shift and go to state 62
    p                              shift and go to state 10
    sMM                            shift and go to state 6
    iSing                          shift and go to state 12
    exp                            shift and go to state 59
    paren                          shift and go to state 36
    varsOps                        shift and go to state 79
    varYVals                       shift and go to state 81
    vecVal                         shift and go to state 47

state 199

    (25) funcString -> CAPITALIZAR ( expString ) .

    +               reduce using rule 25 (funcString -> CAPITALIZAR ( expString ) .)
    ,               reduce using rule 25 (funcString -> CAPITALIZAR ( expString ) .)
    }               reduce using rule 25 (funcString -> CAPITALIZAR ( expString ) .)
    ;               reduce using rule 25 (funcString -> CAPITALIZAR ( expString ) .)
    MULEQ           reduce using rule 25 (funcString -> CAPITALIZAR ( expString ) .)
    DIVEQ           reduce using rule 25 (funcString -> CAPITALIZAR ( expString ) .)
    MASEQ           reduce using rule 25 (funcString -> CAPITALIZAR ( expString ) .)
    MENOSEQ         reduce using rule 25 (funcString -> CAPITALIZAR ( expString ) .)
    ]               reduce using rule 25 (funcString -> CAPITALIZAR ( expString ) .)
    )               reduce using rule 25 (funcString -> CAPITALIZAR ( expString ) .)


state 200

    (26) funcBool -> COLINEALES ( vec , vec . )

    )               shift and go to state 213


state 201

    (12) loop -> FOR ( varAsig ; expBool . ; varsOps ) bloque

    ;               shift and go to state 214


state 202

    (47) campos -> ID : valores , . campos
    (47) campos -> . ID : valores , campos
    (48) campos -> . valores
    (34) valores -> . eMat
    (35) valores -> . expBool
    (36) valores -> . expString
    (37) valores -> . varYVals
    (38) valores -> . funcReturn
    (39) valores -> . reg
    (40) valores -> . ID . ID
    (65) eMat -> . eMat + p
    (66) eMat -> . eMat - p
    (67) eMat -> . p
    (87) expBool -> . or ? expBool : expBool
    (88) expBool -> . or
    (83) expString -> . expString + STRING
    (84) expString -> . STRING
    (85) expString -> . varYVals
    (86) expString -> . funcString
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (20) funcReturn -> . funcInt
    (21) funcReturn -> . funcString
    (22) funcReturn -> . funcBool
    (46) reg -> . { campos }
    (68) p -> . p * exp
    (69) p -> . p / exp
    (70) p -> . p % exp
    (71) p -> . exp
    (89) or -> . or OR and
    (90) or -> . and
    (25) funcString -> . CAPITALIZAR ( expString )
    (43) vecVal -> . ID m
    (23) funcInt -> . MULTIESCALAR ( vec , eMat , param )
    (24) funcInt -> . LENGTH ( vec )
    (26) funcBool -> . COLINEALES ( vec , vec )
    (72) exp -> . exp ^ iSing
    (73) exp -> . iSing
    (91) and -> . and AND eq
    (92) and -> . eq
    (74) iSing -> . - paren
    (75) iSing -> . + paren
    (76) iSing -> . paren
    (93) eq -> . eq EQEQ tBool
    (94) eq -> . eq DISTINTO tBool
    (95) eq -> . mayor
    (77) paren -> . ( eMat )
    (78) paren -> . INT
    (79) paren -> . varYVals
    (80) paren -> . FLOAT
    (81) paren -> . varsOps
    (82) paren -> . funcInt
    (96) mayor -> . tCompare > tCompare
    (97) mayor -> . menor
    (49) varsOps -> . MENOSMENOS sMM
    (50) varsOps -> . MASMAS sMM
    (51) varsOps -> . sMM
    (106) tCompare -> . eMat
    (107) tCompare -> . varsOps
    (108) tCompare -> . varYVals
    (98) menor -> . tCompare < tCompare
    (99) menor -> . not
    (52) sMM -> . ID MASMAS
    (53) sMM -> . ID MENOSMENOS
    (54) sMM -> . ID
    (100) not -> . NOT not
    (101) not -> . tBool
    (102) tBool -> . ( expBool )
    (103) tBool -> . BOOL
    (104) tBool -> . varYVals
    (105) tBool -> . funcBool

    ID              shift and go to state 91
    STRING          shift and go to state 51
    {               shift and go to state 32
    CAPITALIZAR     shift and go to state 57
    MULTIESCALAR    shift and go to state 55
    LENGTH          shift and go to state 11
    COLINEALES      shift and go to state 1
    -               shift and go to state 50
    +               shift and go to state 20
    (               shift and go to state 5
    INT             shift and go to state 27
    FLOAT           shift and go to state 56
    MENOSMENOS      shift and go to state 23
    MASMAS          shift and go to state 28
    NOT             shift and go to state 30
    BOOL            shift and go to state 41

    and                            shift and go to state 44
    funcBool                       shift and go to state 2
    funcInt                        shift and go to state 14
    menor                          shift and go to state 3
    eq                             shift and go to state 16
    vecVal                         shift and go to state 47
    eMat                           shift and go to state 49
    mayor                          shift and go to state 4
    sMM                            shift and go to state 6
    paren                          shift and go to state 36
    reg                            shift and go to state 22
    varsOps                        shift and go to state 64
    expString                      shift and go to state 24
    tCompare                       shift and go to state 37
    campos                         shift and go to state 215
    not                            shift and go to state 8
    funcString                     shift and go to state 92
    funcReturn                     shift and go to state 93
    valores                        shift and go to state 94
    p                              shift and go to state 10
    iSing                          shift and go to state 12
    exp                            shift and go to state 59
    tBool                          shift and go to state 31
    varYVals                       shift and go to state 33
    or                             shift and go to state 34
    expBool                        shift and go to state 29

state 203

    (87) expBool -> or ? expBool : expBool .

    )               reduce using rule 87 (expBool -> or ? expBool : expBool .)
    MULEQ           reduce using rule 87 (expBool -> or ? expBool : expBool .)
    DIVEQ           reduce using rule 87 (expBool -> or ? expBool : expBool .)
    MASEQ           reduce using rule 87 (expBool -> or ? expBool : expBool .)
    MENOSEQ         reduce using rule 87 (expBool -> or ? expBool : expBool .)
    ;               reduce using rule 87 (expBool -> or ? expBool : expBool .)
    :               reduce using rule 87 (expBool -> or ? expBool : expBool .)
    }               reduce using rule 87 (expBool -> or ? expBool : expBool .)
    ,               reduce using rule 87 (expBool -> or ? expBool : expBool .)
    ]               reduce using rule 87 (expBool -> or ? expBool : expBool .)


state 204

    (10) loop -> WHILE ( expBool ) bloque .

    RETURN          reduce using rule 10 (loop -> WHILE ( expBool ) bloque .)
    MENOSMENOS      reduce using rule 10 (loop -> WHILE ( expBool ) bloque .)
    MASMAS          reduce using rule 10 (loop -> WHILE ( expBool ) bloque .)
    IF              reduce using rule 10 (loop -> WHILE ( expBool ) bloque .)
    WHILE           reduce using rule 10 (loop -> WHILE ( expBool ) bloque .)
    DO              reduce using rule 10 (loop -> WHILE ( expBool ) bloque .)
    FOR             reduce using rule 10 (loop -> WHILE ( expBool ) bloque .)
    ID              reduce using rule 10 (loop -> WHILE ( expBool ) bloque .)
    PRINT           reduce using rule 10 (loop -> WHILE ( expBool ) bloque .)
    MULTIESCALAR    reduce using rule 10 (loop -> WHILE ( expBool ) bloque .)
    LENGTH          reduce using rule 10 (loop -> WHILE ( expBool ) bloque .)
    CAPITALIZAR     reduce using rule 10 (loop -> WHILE ( expBool ) bloque .)
    COLINEALES      reduce using rule 10 (loop -> WHILE ( expBool ) bloque .)
    STRING          reduce using rule 10 (loop -> WHILE ( expBool ) bloque .)
    {               reduce using rule 10 (loop -> WHILE ( expBool ) bloque .)
    -               reduce using rule 10 (loop -> WHILE ( expBool ) bloque .)
    +               reduce using rule 10 (loop -> WHILE ( expBool ) bloque .)
    (               reduce using rule 10 (loop -> WHILE ( expBool ) bloque .)
    INT             reduce using rule 10 (loop -> WHILE ( expBool ) bloque .)
    FLOAT           reduce using rule 10 (loop -> WHILE ( expBool ) bloque .)
    NOT             reduce using rule 10 (loop -> WHILE ( expBool ) bloque .)
    BOOL            reduce using rule 10 (loop -> WHILE ( expBool ) bloque .)
    $end            reduce using rule 10 (loop -> WHILE ( expBool ) bloque .)
    }               reduce using rule 10 (loop -> WHILE ( expBool ) bloque .)


state 205

    (11) loop -> DO bloque WHILE ( expBool . ) ;

    )               shift and go to state 216


state 206

    (62) asig -> ID . ID = asig .

    ;               reduce using rule 62 (asig -> ID . ID = asig .)


state 207

    (45) m -> [ INT ] m .

    )               reduce using rule 45 (m -> [ INT ] m .)
    +               reduce using rule 45 (m -> [ INT ] m .)
    ^               reduce using rule 45 (m -> [ INT ] m .)
    *               reduce using rule 45 (m -> [ INT ] m .)
    /               reduce using rule 45 (m -> [ INT ] m .)
    %               reduce using rule 45 (m -> [ INT ] m .)
    -               reduce using rule 45 (m -> [ INT ] m .)
    >               reduce using rule 45 (m -> [ INT ] m .)
    <               reduce using rule 45 (m -> [ INT ] m .)
    EQEQ            reduce using rule 45 (m -> [ INT ] m .)
    DISTINTO        reduce using rule 45 (m -> [ INT ] m .)
    AND             reduce using rule 45 (m -> [ INT ] m .)
    ?               reduce using rule 45 (m -> [ INT ] m .)
    OR              reduce using rule 45 (m -> [ INT ] m .)
    ,               reduce using rule 45 (m -> [ INT ] m .)
    ]               reduce using rule 45 (m -> [ INT ] m .)
    MULEQ           reduce using rule 45 (m -> [ INT ] m .)
    DIVEQ           reduce using rule 45 (m -> [ INT ] m .)
    MASEQ           reduce using rule 45 (m -> [ INT ] m .)
    MENOSEQ         reduce using rule 45 (m -> [ INT ] m .)
    ;               reduce using rule 45 (m -> [ INT ] m .)
    }               reduce using rule 45 (m -> [ INT ] m .)
    :               reduce using rule 45 (m -> [ INT ] m .)


state 208

    (31) vec -> ID = [ elem ] .

    ;               reduce using rule 31 (vec -> ID = [ elem ] .)
    ,               reduce using rule 31 (vec -> ID = [ elem ] .)
    )               reduce using rule 31 (vec -> ID = [ elem ] .)


state 209

    (32) elem -> valores , . elem
    (32) elem -> . valores , elem
    (33) elem -> . valores
    (34) valores -> . eMat
    (35) valores -> . expBool
    (36) valores -> . expString
    (37) valores -> . varYVals
    (38) valores -> . funcReturn
    (39) valores -> . reg
    (40) valores -> . ID . ID
    (65) eMat -> . eMat + p
    (66) eMat -> . eMat - p
    (67) eMat -> . p
    (87) expBool -> . or ? expBool : expBool
    (88) expBool -> . or
    (83) expString -> . expString + STRING
    (84) expString -> . STRING
    (85) expString -> . varYVals
    (86) expString -> . funcString
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (20) funcReturn -> . funcInt
    (21) funcReturn -> . funcString
    (22) funcReturn -> . funcBool
    (46) reg -> . { campos }
    (68) p -> . p * exp
    (69) p -> . p / exp
    (70) p -> . p % exp
    (71) p -> . exp
    (89) or -> . or OR and
    (90) or -> . and
    (25) funcString -> . CAPITALIZAR ( expString )
    (43) vecVal -> . ID m
    (23) funcInt -> . MULTIESCALAR ( vec , eMat , param )
    (24) funcInt -> . LENGTH ( vec )
    (26) funcBool -> . COLINEALES ( vec , vec )
    (72) exp -> . exp ^ iSing
    (73) exp -> . iSing
    (91) and -> . and AND eq
    (92) and -> . eq
    (74) iSing -> . - paren
    (75) iSing -> . + paren
    (76) iSing -> . paren
    (93) eq -> . eq EQEQ tBool
    (94) eq -> . eq DISTINTO tBool
    (95) eq -> . mayor
    (77) paren -> . ( eMat )
    (78) paren -> . INT
    (79) paren -> . varYVals
    (80) paren -> . FLOAT
    (81) paren -> . varsOps
    (82) paren -> . funcInt
    (96) mayor -> . tCompare > tCompare
    (97) mayor -> . menor
    (49) varsOps -> . MENOSMENOS sMM
    (50) varsOps -> . MASMAS sMM
    (51) varsOps -> . sMM
    (106) tCompare -> . eMat
    (107) tCompare -> . varsOps
    (108) tCompare -> . varYVals
    (98) menor -> . tCompare < tCompare
    (99) menor -> . not
    (52) sMM -> . ID MASMAS
    (53) sMM -> . ID MENOSMENOS
    (54) sMM -> . ID
    (100) not -> . NOT not
    (101) not -> . tBool
    (102) tBool -> . ( expBool )
    (103) tBool -> . BOOL
    (104) tBool -> . varYVals
    (105) tBool -> . funcBool

    ID              shift and go to state 133
    STRING          shift and go to state 51
    {               shift and go to state 32
    CAPITALIZAR     shift and go to state 57
    MULTIESCALAR    shift and go to state 55
    LENGTH          shift and go to state 11
    COLINEALES      shift and go to state 1
    -               shift and go to state 50
    +               shift and go to state 20
    (               shift and go to state 5
    INT             shift and go to state 27
    FLOAT           shift and go to state 56
    MENOSMENOS      shift and go to state 23
    MASMAS          shift and go to state 28
    NOT             shift and go to state 30
    BOOL            shift and go to state 41

    and                            shift and go to state 44
    funcBool                       shift and go to state 2
    funcInt                        shift and go to state 14
    elem                           shift and go to state 217
    menor                          shift and go to state 3
    eq                             shift and go to state 16
    vecVal                         shift and go to state 47
    eMat                           shift and go to state 49
    mayor                          shift and go to state 4
    sMM                            shift and go to state 6
    paren                          shift and go to state 36
    reg                            shift and go to state 22
    varsOps                        shift and go to state 64
    expString                      shift and go to state 24
    tCompare                       shift and go to state 37
    not                            shift and go to state 8
    funcString                     shift and go to state 92
    funcReturn                     shift and go to state 93
    valores                        shift and go to state 195
    p                              shift and go to state 10
    iSing                          shift and go to state 12
    exp                            shift and go to state 59
    tBool                          shift and go to state 31
    varYVals                       shift and go to state 33
    or                             shift and go to state 34
    expBool                        shift and go to state 29

state 210

    (62) asig -> ID . ID . = asig
    (40) valores -> ID . ID .

    =               shift and go to state 192
    ;               reduce using rule 40 (valores -> ID . ID .)


state 211

    (13) if -> IF ( expBool ) THEN . bloque else
    (16) bloque -> . sentencia
    (17) bloque -> . { g }
    (4) sentencia -> . varsOps ;
    (5) sentencia -> . func ;
    (6) sentencia -> . varAsig ;
    (7) sentencia -> . RETURN ;
    (49) varsOps -> . MENOSMENOS sMM
    (50) varsOps -> . MASMAS sMM
    (51) varsOps -> . sMM
    (18) func -> . funcReturn
    (19) func -> . funcVoid
    (55) varAsig -> . valores MULEQ varAsig
    (56) varAsig -> . valores DIVEQ varAsig
    (57) varAsig -> . sIgual
    (52) sMM -> . ID MASMAS
    (53) sMM -> . ID MENOSMENOS
    (54) sMM -> . ID
    (20) funcReturn -> . funcInt
    (21) funcReturn -> . funcString
    (22) funcReturn -> . funcBool
    (27) funcVoid -> . PRINT ( valores )
    (34) valores -> . eMat
    (35) valores -> . expBool
    (36) valores -> . expString
    (37) valores -> . varYVals
    (38) valores -> . funcReturn
    (39) valores -> . reg
    (40) valores -> . ID . ID
    (58) sIgual -> . valores MASEQ sIgual
    (59) sIgual -> . valores MENOSEQ sIgual
    (60) sIgual -> . asig
    (23) funcInt -> . MULTIESCALAR ( vec , eMat , param )
    (24) funcInt -> . LENGTH ( vec )
    (25) funcString -> . CAPITALIZAR ( expString )
    (26) funcBool -> . COLINEALES ( vec , vec )
    (65) eMat -> . eMat + p
    (66) eMat -> . eMat - p
    (67) eMat -> . p
    (87) expBool -> . or ? expBool : expBool
    (88) expBool -> . or
    (83) expString -> . expString + STRING
    (84) expString -> . STRING
    (85) expString -> . varYVals
    (86) expString -> . funcString
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (46) reg -> . { campos }
    (61) asig -> . ID = asig
    (62) asig -> . ID . ID = asig
    (63) asig -> . vec
    (64) asig -> . valores
    (68) p -> . p * exp
    (69) p -> . p / exp
    (70) p -> . p % exp
    (71) p -> . exp
    (89) or -> . or OR and
    (90) or -> . and
    (43) vecVal -> . ID m
    (31) vec -> . ID = [ elem ]
    (72) exp -> . exp ^ iSing
    (73) exp -> . iSing
    (91) and -> . and AND eq
    (92) and -> . eq
    (74) iSing -> . - paren
    (75) iSing -> . + paren
    (76) iSing -> . paren
    (93) eq -> . eq EQEQ tBool
    (94) eq -> . eq DISTINTO tBool
    (95) eq -> . mayor
    (77) paren -> . ( eMat )
    (78) paren -> . INT
    (79) paren -> . varYVals
    (80) paren -> . FLOAT
    (81) paren -> . varsOps
    (82) paren -> . funcInt
    (96) mayor -> . tCompare > tCompare
    (97) mayor -> . menor
    (106) tCompare -> . eMat
    (107) tCompare -> . varsOps
    (108) tCompare -> . varYVals
    (98) menor -> . tCompare < tCompare
    (99) menor -> . not
    (100) not -> . NOT not
    (101) not -> . tBool
    (102) tBool -> . ( expBool )
    (103) tBool -> . BOOL
    (104) tBool -> . varYVals
    (105) tBool -> . funcBool

    {               shift and go to state 109
    RETURN          shift and go to state 13
    MENOSMENOS      shift and go to state 23
    MASMAS          shift and go to state 28
    ID              shift and go to state 52
    PRINT           shift and go to state 15
    MULTIESCALAR    shift and go to state 55
    LENGTH          shift and go to state 11
    CAPITALIZAR     shift and go to state 57
    COLINEALES      shift and go to state 1
    STRING          shift and go to state 51
    -               shift and go to state 50
    +               shift and go to state 20
    (               shift and go to state 5
    INT             shift and go to state 27
    FLOAT           shift and go to state 56
    NOT             shift and go to state 30
    BOOL            shift and go to state 41

    and                            shift and go to state 44
    funcBool                       shift and go to state 2
    funcInt                        shift and go to state 14
    menor                          shift and go to state 3
    bloque                         shift and go to state 218
    eq                             shift and go to state 16
    vecVal                         shift and go to state 47
    sentencia                      shift and go to state 108
    eMat                           shift and go to state 49
    asig                           shift and go to state 19
    mayor                          shift and go to state 4
    sMM                            shift and go to state 6
    vec                            shift and go to state 7
    sIgual                         shift and go to state 21
    reg                            shift and go to state 22
    iSing                          shift and go to state 12
    funcVoid                       shift and go to state 54
    expString                      shift and go to state 24
    tCompare                       shift and go to state 37
    func                           shift and go to state 38
    paren                          shift and go to state 36
    not                            shift and go to state 8
    varAsig                        shift and go to state 39
    funcString                     shift and go to state 26
    funcReturn                     shift and go to state 9
    valores                        shift and go to state 40
    p                              shift and go to state 10
    varsOps                        shift and go to state 58
    exp                            shift and go to state 59
    tBool                          shift and go to state 31
    varYVals                       shift and go to state 33
    or                             shift and go to state 34
    expBool                        shift and go to state 29

state 212

    (23) funcInt -> MULTIESCALAR ( vec , eMat . , param )
    (65) eMat -> eMat . + p
    (66) eMat -> eMat . - p

    ,               shift and go to state 219
    +               shift and go to state 111
    -               shift and go to state 112


state 213

    (26) funcBool -> COLINEALES ( vec , vec ) .

    ;               reduce using rule 26 (funcBool -> COLINEALES ( vec , vec ) .)
    MULEQ           reduce using rule 26 (funcBool -> COLINEALES ( vec , vec ) .)
    DIVEQ           reduce using rule 26 (funcBool -> COLINEALES ( vec , vec ) .)
    MASEQ           reduce using rule 26 (funcBool -> COLINEALES ( vec , vec ) .)
    MENOSEQ         reduce using rule 26 (funcBool -> COLINEALES ( vec , vec ) .)
    EQEQ            reduce using rule 26 (funcBool -> COLINEALES ( vec , vec ) .)
    DISTINTO        reduce using rule 26 (funcBool -> COLINEALES ( vec , vec ) .)
    AND             reduce using rule 26 (funcBool -> COLINEALES ( vec , vec ) .)
    ?               reduce using rule 26 (funcBool -> COLINEALES ( vec , vec ) .)
    OR              reduce using rule 26 (funcBool -> COLINEALES ( vec , vec ) .)
    }               reduce using rule 26 (funcBool -> COLINEALES ( vec , vec ) .)
    ,               reduce using rule 26 (funcBool -> COLINEALES ( vec , vec ) .)
    ]               reduce using rule 26 (funcBool -> COLINEALES ( vec , vec ) .)
    )               reduce using rule 26 (funcBool -> COLINEALES ( vec , vec ) .)
    :               reduce using rule 26 (funcBool -> COLINEALES ( vec , vec ) .)


state 214

    (12) loop -> FOR ( varAsig ; expBool ; . varsOps ) bloque
    (49) varsOps -> . MENOSMENOS sMM
    (50) varsOps -> . MASMAS sMM
    (51) varsOps -> . sMM
    (52) sMM -> . ID MASMAS
    (53) sMM -> . ID MENOSMENOS
    (54) sMM -> . ID

    MENOSMENOS      shift and go to state 23
    MASMAS          shift and go to state 28
    ID              shift and go to state 83

    sMM                            shift and go to state 6
    varsOps                        shift and go to state 220

state 215

    (47) campos -> ID : valores , campos .

    }               reduce using rule 47 (campos -> ID : valores , campos .)


state 216

    (11) loop -> DO bloque WHILE ( expBool ) . ;

    ;               shift and go to state 221


state 217

    (32) elem -> valores , elem .

    ]               reduce using rule 32 (elem -> valores , elem .)


state 218

    (13) if -> IF ( expBool ) THEN bloque . else
    (14) else -> . ELSE bloque
    (15) else -> . empty
    (30) empty -> .

    ELSE            shift and go to state 224
    RETURN          reduce using rule 30 (empty -> .)
    MENOSMENOS      reduce using rule 30 (empty -> .)
    MASMAS          reduce using rule 30 (empty -> .)
    IF              reduce using rule 30 (empty -> .)
    WHILE           reduce using rule 30 (empty -> .)
    DO              reduce using rule 30 (empty -> .)
    FOR             reduce using rule 30 (empty -> .)
    ID              reduce using rule 30 (empty -> .)
    PRINT           reduce using rule 30 (empty -> .)
    MULTIESCALAR    reduce using rule 30 (empty -> .)
    LENGTH          reduce using rule 30 (empty -> .)
    CAPITALIZAR     reduce using rule 30 (empty -> .)
    COLINEALES      reduce using rule 30 (empty -> .)
    STRING          reduce using rule 30 (empty -> .)
    {               reduce using rule 30 (empty -> .)
    -               reduce using rule 30 (empty -> .)
    +               reduce using rule 30 (empty -> .)
    (               reduce using rule 30 (empty -> .)
    INT             reduce using rule 30 (empty -> .)
    FLOAT           reduce using rule 30 (empty -> .)
    NOT             reduce using rule 30 (empty -> .)
    BOOL            reduce using rule 30 (empty -> .)
    $end            reduce using rule 30 (empty -> .)
    }               reduce using rule 30 (empty -> .)

    empty                          shift and go to state 223
    else                           shift and go to state 222

state 219

    (23) funcInt -> MULTIESCALAR ( vec , eMat , . param )
    (28) param -> . expBool
    (29) param -> . empty
    (87) expBool -> . or ? expBool : expBool
    (88) expBool -> . or
    (30) empty -> .
    (89) or -> . or OR and
    (90) or -> . and
    (91) and -> . and AND eq
    (92) and -> . eq
    (93) eq -> . eq EQEQ tBool
    (94) eq -> . eq DISTINTO tBool
    (95) eq -> . mayor
    (96) mayor -> . tCompare > tCompare
    (97) mayor -> . menor
    (106) tCompare -> . eMat
    (107) tCompare -> . varsOps
    (108) tCompare -> . varYVals
    (98) menor -> . tCompare < tCompare
    (99) menor -> . not
    (65) eMat -> . eMat + p
    (66) eMat -> . eMat - p
    (67) eMat -> . p
    (49) varsOps -> . MENOSMENOS sMM
    (50) varsOps -> . MASMAS sMM
    (51) varsOps -> . sMM
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (100) not -> . NOT not
    (101) not -> . tBool
    (68) p -> . p * exp
    (69) p -> . p / exp
    (70) p -> . p % exp
    (71) p -> . exp
    (52) sMM -> . ID MASMAS
    (53) sMM -> . ID MENOSMENOS
    (54) sMM -> . ID
    (43) vecVal -> . ID m
    (102) tBool -> . ( expBool )
    (103) tBool -> . BOOL
    (104) tBool -> . varYVals
    (105) tBool -> . funcBool
    (72) exp -> . exp ^ iSing
    (73) exp -> . iSing
    (26) funcBool -> . COLINEALES ( vec , vec )
    (74) iSing -> . - paren
    (75) iSing -> . + paren
    (76) iSing -> . paren
    (77) paren -> . ( eMat )
    (78) paren -> . INT
    (79) paren -> . varYVals
    (80) paren -> . FLOAT
    (81) paren -> . varsOps
    (82) paren -> . funcInt
    (23) funcInt -> . MULTIESCALAR ( vec , eMat , param )
    (24) funcInt -> . LENGTH ( vec )

    )               reduce using rule 30 (empty -> .)
    MENOSMENOS      shift and go to state 23
    MASMAS          shift and go to state 28
    ID              shift and go to state 143
    NOT             shift and go to state 30
    (               shift and go to state 142
    BOOL            shift and go to state 41
    COLINEALES      shift and go to state 1
    -               shift and go to state 50
    +               shift and go to state 20
    INT             shift and go to state 27
    FLOAT           shift and go to state 56
    MULTIESCALAR    shift and go to state 55
    LENGTH          shift and go to state 11

    and                            shift and go to state 44
    funcBool                       shift and go to state 61
    funcInt                        shift and go to state 62
    menor                          shift and go to state 3
    eq                             shift and go to state 16
    mayor                          shift and go to state 4
    eMat                           shift and go to state 141
    param                          shift and go to state 225
    vecVal                         shift and go to state 47
    sMM                            shift and go to state 6
    paren                          shift and go to state 36
    empty                          shift and go to state 226
    varsOps                        shift and go to state 144
    tCompare                       shift and go to state 37
    not                            shift and go to state 8
    p                              shift and go to state 10
    iSing                          shift and go to state 12
    exp                            shift and go to state 59
    tBool                          shift and go to state 31
    varYVals                       shift and go to state 145
    or                             shift and go to state 34
    expBool                        shift and go to state 227

state 220

    (12) loop -> FOR ( varAsig ; expBool ; varsOps . ) bloque

    )               shift and go to state 228


state 221

    (11) loop -> DO bloque WHILE ( expBool ) ; .

    RETURN          reduce using rule 11 (loop -> DO bloque WHILE ( expBool ) ; .)
    MENOSMENOS      reduce using rule 11 (loop -> DO bloque WHILE ( expBool ) ; .)
    MASMAS          reduce using rule 11 (loop -> DO bloque WHILE ( expBool ) ; .)
    IF              reduce using rule 11 (loop -> DO bloque WHILE ( expBool ) ; .)
    WHILE           reduce using rule 11 (loop -> DO bloque WHILE ( expBool ) ; .)
    DO              reduce using rule 11 (loop -> DO bloque WHILE ( expBool ) ; .)
    FOR             reduce using rule 11 (loop -> DO bloque WHILE ( expBool ) ; .)
    ID              reduce using rule 11 (loop -> DO bloque WHILE ( expBool ) ; .)
    PRINT           reduce using rule 11 (loop -> DO bloque WHILE ( expBool ) ; .)
    MULTIESCALAR    reduce using rule 11 (loop -> DO bloque WHILE ( expBool ) ; .)
    LENGTH          reduce using rule 11 (loop -> DO bloque WHILE ( expBool ) ; .)
    CAPITALIZAR     reduce using rule 11 (loop -> DO bloque WHILE ( expBool ) ; .)
    COLINEALES      reduce using rule 11 (loop -> DO bloque WHILE ( expBool ) ; .)
    STRING          reduce using rule 11 (loop -> DO bloque WHILE ( expBool ) ; .)
    {               reduce using rule 11 (loop -> DO bloque WHILE ( expBool ) ; .)
    -               reduce using rule 11 (loop -> DO bloque WHILE ( expBool ) ; .)
    +               reduce using rule 11 (loop -> DO bloque WHILE ( expBool ) ; .)
    (               reduce using rule 11 (loop -> DO bloque WHILE ( expBool ) ; .)
    INT             reduce using rule 11 (loop -> DO bloque WHILE ( expBool ) ; .)
    FLOAT           reduce using rule 11 (loop -> DO bloque WHILE ( expBool ) ; .)
    NOT             reduce using rule 11 (loop -> DO bloque WHILE ( expBool ) ; .)
    BOOL            reduce using rule 11 (loop -> DO bloque WHILE ( expBool ) ; .)
    $end            reduce using rule 11 (loop -> DO bloque WHILE ( expBool ) ; .)
    }               reduce using rule 11 (loop -> DO bloque WHILE ( expBool ) ; .)


state 222

    (13) if -> IF ( expBool ) THEN bloque else .

    RETURN          reduce using rule 13 (if -> IF ( expBool ) THEN bloque else .)
    MENOSMENOS      reduce using rule 13 (if -> IF ( expBool ) THEN bloque else .)
    MASMAS          reduce using rule 13 (if -> IF ( expBool ) THEN bloque else .)
    IF              reduce using rule 13 (if -> IF ( expBool ) THEN bloque else .)
    WHILE           reduce using rule 13 (if -> IF ( expBool ) THEN bloque else .)
    DO              reduce using rule 13 (if -> IF ( expBool ) THEN bloque else .)
    FOR             reduce using rule 13 (if -> IF ( expBool ) THEN bloque else .)
    ID              reduce using rule 13 (if -> IF ( expBool ) THEN bloque else .)
    PRINT           reduce using rule 13 (if -> IF ( expBool ) THEN bloque else .)
    MULTIESCALAR    reduce using rule 13 (if -> IF ( expBool ) THEN bloque else .)
    LENGTH          reduce using rule 13 (if -> IF ( expBool ) THEN bloque else .)
    CAPITALIZAR     reduce using rule 13 (if -> IF ( expBool ) THEN bloque else .)
    COLINEALES      reduce using rule 13 (if -> IF ( expBool ) THEN bloque else .)
    STRING          reduce using rule 13 (if -> IF ( expBool ) THEN bloque else .)
    {               reduce using rule 13 (if -> IF ( expBool ) THEN bloque else .)
    -               reduce using rule 13 (if -> IF ( expBool ) THEN bloque else .)
    +               reduce using rule 13 (if -> IF ( expBool ) THEN bloque else .)
    (               reduce using rule 13 (if -> IF ( expBool ) THEN bloque else .)
    INT             reduce using rule 13 (if -> IF ( expBool ) THEN bloque else .)
    FLOAT           reduce using rule 13 (if -> IF ( expBool ) THEN bloque else .)
    NOT             reduce using rule 13 (if -> IF ( expBool ) THEN bloque else .)
    BOOL            reduce using rule 13 (if -> IF ( expBool ) THEN bloque else .)
    }               reduce using rule 13 (if -> IF ( expBool ) THEN bloque else .)
    $end            reduce using rule 13 (if -> IF ( expBool ) THEN bloque else .)


state 223

    (15) else -> empty .

    RETURN          reduce using rule 15 (else -> empty .)
    MENOSMENOS      reduce using rule 15 (else -> empty .)
    MASMAS          reduce using rule 15 (else -> empty .)
    IF              reduce using rule 15 (else -> empty .)
    WHILE           reduce using rule 15 (else -> empty .)
    DO              reduce using rule 15 (else -> empty .)
    FOR             reduce using rule 15 (else -> empty .)
    ID              reduce using rule 15 (else -> empty .)
    PRINT           reduce using rule 15 (else -> empty .)
    MULTIESCALAR    reduce using rule 15 (else -> empty .)
    LENGTH          reduce using rule 15 (else -> empty .)
    CAPITALIZAR     reduce using rule 15 (else -> empty .)
    COLINEALES      reduce using rule 15 (else -> empty .)
    STRING          reduce using rule 15 (else -> empty .)
    {               reduce using rule 15 (else -> empty .)
    -               reduce using rule 15 (else -> empty .)
    +               reduce using rule 15 (else -> empty .)
    (               reduce using rule 15 (else -> empty .)
    INT             reduce using rule 15 (else -> empty .)
    FLOAT           reduce using rule 15 (else -> empty .)
    NOT             reduce using rule 15 (else -> empty .)
    BOOL            reduce using rule 15 (else -> empty .)
    $end            reduce using rule 15 (else -> empty .)
    }               reduce using rule 15 (else -> empty .)


state 224

    (14) else -> ELSE . bloque
    (16) bloque -> . sentencia
    (17) bloque -> . { g }
    (4) sentencia -> . varsOps ;
    (5) sentencia -> . func ;
    (6) sentencia -> . varAsig ;
    (7) sentencia -> . RETURN ;
    (49) varsOps -> . MENOSMENOS sMM
    (50) varsOps -> . MASMAS sMM
    (51) varsOps -> . sMM
    (18) func -> . funcReturn
    (19) func -> . funcVoid
    (55) varAsig -> . valores MULEQ varAsig
    (56) varAsig -> . valores DIVEQ varAsig
    (57) varAsig -> . sIgual
    (52) sMM -> . ID MASMAS
    (53) sMM -> . ID MENOSMENOS
    (54) sMM -> . ID
    (20) funcReturn -> . funcInt
    (21) funcReturn -> . funcString
    (22) funcReturn -> . funcBool
    (27) funcVoid -> . PRINT ( valores )
    (34) valores -> . eMat
    (35) valores -> . expBool
    (36) valores -> . expString
    (37) valores -> . varYVals
    (38) valores -> . funcReturn
    (39) valores -> . reg
    (40) valores -> . ID . ID
    (58) sIgual -> . valores MASEQ sIgual
    (59) sIgual -> . valores MENOSEQ sIgual
    (60) sIgual -> . asig
    (23) funcInt -> . MULTIESCALAR ( vec , eMat , param )
    (24) funcInt -> . LENGTH ( vec )
    (25) funcString -> . CAPITALIZAR ( expString )
    (26) funcBool -> . COLINEALES ( vec , vec )
    (65) eMat -> . eMat + p
    (66) eMat -> . eMat - p
    (67) eMat -> . p
    (87) expBool -> . or ? expBool : expBool
    (88) expBool -> . or
    (83) expString -> . expString + STRING
    (84) expString -> . STRING
    (85) expString -> . varYVals
    (86) expString -> . funcString
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (46) reg -> . { campos }
    (61) asig -> . ID = asig
    (62) asig -> . ID . ID = asig
    (63) asig -> . vec
    (64) asig -> . valores
    (68) p -> . p * exp
    (69) p -> . p / exp
    (70) p -> . p % exp
    (71) p -> . exp
    (89) or -> . or OR and
    (90) or -> . and
    (43) vecVal -> . ID m
    (31) vec -> . ID = [ elem ]
    (72) exp -> . exp ^ iSing
    (73) exp -> . iSing
    (91) and -> . and AND eq
    (92) and -> . eq
    (74) iSing -> . - paren
    (75) iSing -> . + paren
    (76) iSing -> . paren
    (93) eq -> . eq EQEQ tBool
    (94) eq -> . eq DISTINTO tBool
    (95) eq -> . mayor
    (77) paren -> . ( eMat )
    (78) paren -> . INT
    (79) paren -> . varYVals
    (80) paren -> . FLOAT
    (81) paren -> . varsOps
    (82) paren -> . funcInt
    (96) mayor -> . tCompare > tCompare
    (97) mayor -> . menor
    (106) tCompare -> . eMat
    (107) tCompare -> . varsOps
    (108) tCompare -> . varYVals
    (98) menor -> . tCompare < tCompare
    (99) menor -> . not
    (100) not -> . NOT not
    (101) not -> . tBool
    (102) tBool -> . ( expBool )
    (103) tBool -> . BOOL
    (104) tBool -> . varYVals
    (105) tBool -> . funcBool

    {               shift and go to state 109
    RETURN          shift and go to state 13
    MENOSMENOS      shift and go to state 23
    MASMAS          shift and go to state 28
    ID              shift and go to state 52
    PRINT           shift and go to state 15
    MULTIESCALAR    shift and go to state 55
    LENGTH          shift and go to state 11
    CAPITALIZAR     shift and go to state 57
    COLINEALES      shift and go to state 1
    STRING          shift and go to state 51
    -               shift and go to state 50
    +               shift and go to state 20
    (               shift and go to state 5
    INT             shift and go to state 27
    FLOAT           shift and go to state 56
    NOT             shift and go to state 30
    BOOL            shift and go to state 41

    and                            shift and go to state 44
    funcBool                       shift and go to state 2
    funcInt                        shift and go to state 14
    menor                          shift and go to state 3
    bloque                         shift and go to state 229
    eq                             shift and go to state 16
    vecVal                         shift and go to state 47
    sentencia                      shift and go to state 108
    eMat                           shift and go to state 49
    asig                           shift and go to state 19
    mayor                          shift and go to state 4
    sMM                            shift and go to state 6
    vec                            shift and go to state 7
    sIgual                         shift and go to state 21
    reg                            shift and go to state 22
    iSing                          shift and go to state 12
    funcVoid                       shift and go to state 54
    expString                      shift and go to state 24
    tCompare                       shift and go to state 37
    func                           shift and go to state 38
    paren                          shift and go to state 36
    not                            shift and go to state 8
    varAsig                        shift and go to state 39
    funcString                     shift and go to state 26
    funcReturn                     shift and go to state 9
    valores                        shift and go to state 40
    p                              shift and go to state 10
    varsOps                        shift and go to state 58
    exp                            shift and go to state 59
    tBool                          shift and go to state 31
    varYVals                       shift and go to state 33
    or                             shift and go to state 34
    expBool                        shift and go to state 29

state 225

    (23) funcInt -> MULTIESCALAR ( vec , eMat , param . )

    )               shift and go to state 230


state 226

    (29) param -> empty .

    )               reduce using rule 29 (param -> empty .)


state 227

    (28) param -> expBool .

    )               reduce using rule 28 (param -> expBool .)


state 228

    (12) loop -> FOR ( varAsig ; expBool ; varsOps ) . bloque
    (16) bloque -> . sentencia
    (17) bloque -> . { g }
    (4) sentencia -> . varsOps ;
    (5) sentencia -> . func ;
    (6) sentencia -> . varAsig ;
    (7) sentencia -> . RETURN ;
    (49) varsOps -> . MENOSMENOS sMM
    (50) varsOps -> . MASMAS sMM
    (51) varsOps -> . sMM
    (18) func -> . funcReturn
    (19) func -> . funcVoid
    (55) varAsig -> . valores MULEQ varAsig
    (56) varAsig -> . valores DIVEQ varAsig
    (57) varAsig -> . sIgual
    (52) sMM -> . ID MASMAS
    (53) sMM -> . ID MENOSMENOS
    (54) sMM -> . ID
    (20) funcReturn -> . funcInt
    (21) funcReturn -> . funcString
    (22) funcReturn -> . funcBool
    (27) funcVoid -> . PRINT ( valores )
    (34) valores -> . eMat
    (35) valores -> . expBool
    (36) valores -> . expString
    (37) valores -> . varYVals
    (38) valores -> . funcReturn
    (39) valores -> . reg
    (40) valores -> . ID . ID
    (58) sIgual -> . valores MASEQ sIgual
    (59) sIgual -> . valores MENOSEQ sIgual
    (60) sIgual -> . asig
    (23) funcInt -> . MULTIESCALAR ( vec , eMat , param )
    (24) funcInt -> . LENGTH ( vec )
    (25) funcString -> . CAPITALIZAR ( expString )
    (26) funcBool -> . COLINEALES ( vec , vec )
    (65) eMat -> . eMat + p
    (66) eMat -> . eMat - p
    (67) eMat -> . p
    (87) expBool -> . or ? expBool : expBool
    (88) expBool -> . or
    (83) expString -> . expString + STRING
    (84) expString -> . STRING
    (85) expString -> . varYVals
    (86) expString -> . funcString
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (46) reg -> . { campos }
    (61) asig -> . ID = asig
    (62) asig -> . ID . ID = asig
    (63) asig -> . vec
    (64) asig -> . valores
    (68) p -> . p * exp
    (69) p -> . p / exp
    (70) p -> . p % exp
    (71) p -> . exp
    (89) or -> . or OR and
    (90) or -> . and
    (43) vecVal -> . ID m
    (31) vec -> . ID = [ elem ]
    (72) exp -> . exp ^ iSing
    (73) exp -> . iSing
    (91) and -> . and AND eq
    (92) and -> . eq
    (74) iSing -> . - paren
    (75) iSing -> . + paren
    (76) iSing -> . paren
    (93) eq -> . eq EQEQ tBool
    (94) eq -> . eq DISTINTO tBool
    (95) eq -> . mayor
    (77) paren -> . ( eMat )
    (78) paren -> . INT
    (79) paren -> . varYVals
    (80) paren -> . FLOAT
    (81) paren -> . varsOps
    (82) paren -> . funcInt
    (96) mayor -> . tCompare > tCompare
    (97) mayor -> . menor
    (106) tCompare -> . eMat
    (107) tCompare -> . varsOps
    (108) tCompare -> . varYVals
    (98) menor -> . tCompare < tCompare
    (99) menor -> . not
    (100) not -> . NOT not
    (101) not -> . tBool
    (102) tBool -> . ( expBool )
    (103) tBool -> . BOOL
    (104) tBool -> . varYVals
    (105) tBool -> . funcBool

    {               shift and go to state 109
    RETURN          shift and go to state 13
    MENOSMENOS      shift and go to state 23
    MASMAS          shift and go to state 28
    ID              shift and go to state 52
    PRINT           shift and go to state 15
    MULTIESCALAR    shift and go to state 55
    LENGTH          shift and go to state 11
    CAPITALIZAR     shift and go to state 57
    COLINEALES      shift and go to state 1
    STRING          shift and go to state 51
    -               shift and go to state 50
    +               shift and go to state 20
    (               shift and go to state 5
    INT             shift and go to state 27
    FLOAT           shift and go to state 56
    NOT             shift and go to state 30
    BOOL            shift and go to state 41

    and                            shift and go to state 44
    funcBool                       shift and go to state 2
    funcInt                        shift and go to state 14
    menor                          shift and go to state 3
    bloque                         shift and go to state 231
    eq                             shift and go to state 16
    vecVal                         shift and go to state 47
    sentencia                      shift and go to state 108
    eMat                           shift and go to state 49
    asig                           shift and go to state 19
    mayor                          shift and go to state 4
    sMM                            shift and go to state 6
    vec                            shift and go to state 7
    sIgual                         shift and go to state 21
    reg                            shift and go to state 22
    iSing                          shift and go to state 12
    funcVoid                       shift and go to state 54
    expString                      shift and go to state 24
    tCompare                       shift and go to state 37
    func                           shift and go to state 38
    paren                          shift and go to state 36
    not                            shift and go to state 8
    varAsig                        shift and go to state 39
    funcString                     shift and go to state 26
    funcReturn                     shift and go to state 9
    valores                        shift and go to state 40
    p                              shift and go to state 10
    varsOps                        shift and go to state 58
    exp                            shift and go to state 59
    tBool                          shift and go to state 31
    varYVals                       shift and go to state 33
    or                             shift and go to state 34
    expBool                        shift and go to state 29

state 229

    (14) else -> ELSE bloque .

    RETURN          reduce using rule 14 (else -> ELSE bloque .)
    MENOSMENOS      reduce using rule 14 (else -> ELSE bloque .)
    MASMAS          reduce using rule 14 (else -> ELSE bloque .)
    IF              reduce using rule 14 (else -> ELSE bloque .)
    WHILE           reduce using rule 14 (else -> ELSE bloque .)
    DO              reduce using rule 14 (else -> ELSE bloque .)
    FOR             reduce using rule 14 (else -> ELSE bloque .)
    ID              reduce using rule 14 (else -> ELSE bloque .)
    PRINT           reduce using rule 14 (else -> ELSE bloque .)
    MULTIESCALAR    reduce using rule 14 (else -> ELSE bloque .)
    LENGTH          reduce using rule 14 (else -> ELSE bloque .)
    CAPITALIZAR     reduce using rule 14 (else -> ELSE bloque .)
    COLINEALES      reduce using rule 14 (else -> ELSE bloque .)
    STRING          reduce using rule 14 (else -> ELSE bloque .)
    {               reduce using rule 14 (else -> ELSE bloque .)
    -               reduce using rule 14 (else -> ELSE bloque .)
    +               reduce using rule 14 (else -> ELSE bloque .)
    (               reduce using rule 14 (else -> ELSE bloque .)
    INT             reduce using rule 14 (else -> ELSE bloque .)
    FLOAT           reduce using rule 14 (else -> ELSE bloque .)
    NOT             reduce using rule 14 (else -> ELSE bloque .)
    BOOL            reduce using rule 14 (else -> ELSE bloque .)
    $end            reduce using rule 14 (else -> ELSE bloque .)
    }               reduce using rule 14 (else -> ELSE bloque .)


state 230

    (23) funcInt -> MULTIESCALAR ( vec , eMat , param ) .

    ^               reduce using rule 23 (funcInt -> MULTIESCALAR ( vec , eMat , param ) .)
    *               reduce using rule 23 (funcInt -> MULTIESCALAR ( vec , eMat , param ) .)
    /               reduce using rule 23 (funcInt -> MULTIESCALAR ( vec , eMat , param ) .)
    %               reduce using rule 23 (funcInt -> MULTIESCALAR ( vec , eMat , param ) .)
    +               reduce using rule 23 (funcInt -> MULTIESCALAR ( vec , eMat , param ) .)
    -               reduce using rule 23 (funcInt -> MULTIESCALAR ( vec , eMat , param ) .)
    >               reduce using rule 23 (funcInt -> MULTIESCALAR ( vec , eMat , param ) .)
    <               reduce using rule 23 (funcInt -> MULTIESCALAR ( vec , eMat , param ) .)
    ,               reduce using rule 23 (funcInt -> MULTIESCALAR ( vec , eMat , param ) .)
    ;               reduce using rule 23 (funcInt -> MULTIESCALAR ( vec , eMat , param ) .)
    MULEQ           reduce using rule 23 (funcInt -> MULTIESCALAR ( vec , eMat , param ) .)
    DIVEQ           reduce using rule 23 (funcInt -> MULTIESCALAR ( vec , eMat , param ) .)
    MASEQ           reduce using rule 23 (funcInt -> MULTIESCALAR ( vec , eMat , param ) .)
    MENOSEQ         reduce using rule 23 (funcInt -> MULTIESCALAR ( vec , eMat , param ) .)
    }               reduce using rule 23 (funcInt -> MULTIESCALAR ( vec , eMat , param ) .)
    )               reduce using rule 23 (funcInt -> MULTIESCALAR ( vec , eMat , param ) .)
    EQEQ            reduce using rule 23 (funcInt -> MULTIESCALAR ( vec , eMat , param ) .)
    DISTINTO        reduce using rule 23 (funcInt -> MULTIESCALAR ( vec , eMat , param ) .)
    AND             reduce using rule 23 (funcInt -> MULTIESCALAR ( vec , eMat , param ) .)
    ?               reduce using rule 23 (funcInt -> MULTIESCALAR ( vec , eMat , param ) .)
    OR              reduce using rule 23 (funcInt -> MULTIESCALAR ( vec , eMat , param ) .)
    :               reduce using rule 23 (funcInt -> MULTIESCALAR ( vec , eMat , param ) .)
    ]               reduce using rule 23 (funcInt -> MULTIESCALAR ( vec , eMat , param ) .)


state 231

    (12) loop -> FOR ( varAsig ; expBool ; varsOps ) bloque .

    RETURN          reduce using rule 12 (loop -> FOR ( varAsig ; expBool ; varsOps ) bloque .)
    MENOSMENOS      reduce using rule 12 (loop -> FOR ( varAsig ; expBool ; varsOps ) bloque .)
    MASMAS          reduce using rule 12 (loop -> FOR ( varAsig ; expBool ; varsOps ) bloque .)
    IF              reduce using rule 12 (loop -> FOR ( varAsig ; expBool ; varsOps ) bloque .)
    WHILE           reduce using rule 12 (loop -> FOR ( varAsig ; expBool ; varsOps ) bloque .)
    DO              reduce using rule 12 (loop -> FOR ( varAsig ; expBool ; varsOps ) bloque .)
    FOR             reduce using rule 12 (loop -> FOR ( varAsig ; expBool ; varsOps ) bloque .)
    ID              reduce using rule 12 (loop -> FOR ( varAsig ; expBool ; varsOps ) bloque .)
    PRINT           reduce using rule 12 (loop -> FOR ( varAsig ; expBool ; varsOps ) bloque .)
    MULTIESCALAR    reduce using rule 12 (loop -> FOR ( varAsig ; expBool ; varsOps ) bloque .)
    LENGTH          reduce using rule 12 (loop -> FOR ( varAsig ; expBool ; varsOps ) bloque .)
    CAPITALIZAR     reduce using rule 12 (loop -> FOR ( varAsig ; expBool ; varsOps ) bloque .)
    COLINEALES      reduce using rule 12 (loop -> FOR ( varAsig ; expBool ; varsOps ) bloque .)
    STRING          reduce using rule 12 (loop -> FOR ( varAsig ; expBool ; varsOps ) bloque .)
    {               reduce using rule 12 (loop -> FOR ( varAsig ; expBool ; varsOps ) bloque .)
    -               reduce using rule 12 (loop -> FOR ( varAsig ; expBool ; varsOps ) bloque .)
    +               reduce using rule 12 (loop -> FOR ( varAsig ; expBool ; varsOps ) bloque .)
    (               reduce using rule 12 (loop -> FOR ( varAsig ; expBool ; varsOps ) bloque .)
    INT             reduce using rule 12 (loop -> FOR ( varAsig ; expBool ; varsOps ) bloque .)
    FLOAT           reduce using rule 12 (loop -> FOR ( varAsig ; expBool ; varsOps ) bloque .)
    NOT             reduce using rule 12 (loop -> FOR ( varAsig ; expBool ; varsOps ) bloque .)
    BOOL            reduce using rule 12 (loop -> FOR ( varAsig ; expBool ; varsOps ) bloque .)
    $end            reduce using rule 12 (loop -> FOR ( varAsig ; expBool ; varsOps ) bloque .)
    }               reduce using rule 12 (loop -> FOR ( varAsig ; expBool ; varsOps ) bloque .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for ; in state 58 resolved as shift
WARNING: reduce/reduce conflict in state 2 resolved using rule (funcReturn -> funcBool)
WARNING: rejected rule (tBool -> funcBool) in state 2
WARNING: reduce/reduce conflict in state 9 resolved using rule (func -> funcReturn)
WARNING: rejected rule (valores -> funcReturn) in state 9
WARNING: reduce/reduce conflict in state 14 resolved using rule (funcReturn -> funcInt)
WARNING: rejected rule (paren -> funcInt) in state 14
WARNING: reduce/reduce conflict in state 26 resolved using rule (funcReturn -> funcString)
WARNING: rejected rule (expString -> funcString) in state 26
WARNING: reduce/reduce conflict in state 33 resolved using rule (valores -> varYVals)
WARNING: rejected rule (expString -> varYVals) in state 33
WARNING: reduce/reduce conflict in state 33 resolved using rule (paren -> varYVals)
WARNING: rejected rule (expString -> varYVals) in state 33
WARNING: reduce/reduce conflict in state 33 resolved using rule (valores -> varYVals)
WARNING: rejected rule (paren -> varYVals) in state 33
WARNING: reduce/reduce conflict in state 33 resolved using rule (paren -> varYVals)
WARNING: rejected rule (tCompare -> varYVals) in state 33
WARNING: reduce/reduce conflict in state 33 resolved using rule (valores -> varYVals)
WARNING: rejected rule (tBool -> varYVals) in state 33
WARNING: reduce/reduce conflict in state 52 resolved using rule (varYVals -> ID)
WARNING: rejected rule (sMM -> ID) in state 52
WARNING: reduce/reduce conflict in state 58 resolved using rule (paren -> varsOps)
WARNING: rejected rule (tCompare -> varsOps) in state 58
WARNING: reduce/reduce conflict in state 64 resolved using rule (paren -> varsOps)
WARNING: rejected rule (tCompare -> varsOps) in state 64
WARNING: reduce/reduce conflict in state 65 resolved using rule (varYVals -> ID)
WARNING: rejected rule (sMM -> ID) in state 65
WARNING: reduce/reduce conflict in state 66 resolved using rule (paren -> varYVals)
WARNING: rejected rule (tCompare -> varYVals) in state 66
WARNING: reduce/reduce conflict in state 66 resolved using rule (paren -> varYVals)
WARNING: rejected rule (tBool -> varYVals) in state 66
WARNING: reduce/reduce conflict in state 91 resolved using rule (varYVals -> ID)
WARNING: rejected rule (sMM -> ID) in state 91
WARNING: reduce/reduce conflict in state 92 resolved using rule (funcReturn -> funcString)
WARNING: rejected rule (expString -> funcString) in state 92
WARNING: reduce/reduce conflict in state 133 resolved using rule (varYVals -> ID)
WARNING: rejected rule (sMM -> ID) in state 133
WARNING: reduce/reduce conflict in state 137 resolved using rule (varYVals -> ID)
WARNING: rejected rule (sMM -> ID) in state 137
WARNING: reduce/reduce conflict in state 143 resolved using rule (varYVals -> ID)
WARNING: rejected rule (sMM -> ID) in state 143
WARNING: reduce/reduce conflict in state 144 resolved using rule (paren -> varsOps)
WARNING: rejected rule (tCompare -> varsOps) in state 144
WARNING: reduce/reduce conflict in state 145 resolved using rule (paren -> varYVals)
WARNING: rejected rule (tCompare -> varYVals) in state 145
WARNING: reduce/reduce conflict in state 153 resolved using rule (paren -> varYVals)
WARNING: rejected rule (tCompare -> varYVals) in state 153
WARNING: reduce/reduce conflict in state 156 resolved using rule (varYVals -> ID)
WARNING: rejected rule (sMM -> ID) in state 156
WARNING: reduce/reduce conflict in state 163 resolved using rule (func -> funcReturn)
WARNING: rejected rule (valores -> funcReturn) in state 163
WARNING: reduce/reduce conflict in state 166 resolved using rule (varYVals -> ID)
WARNING: rejected rule (sMM -> ID) in state 166
WARNING: reduce/reduce conflict in state 174 resolved using rule (varYVals -> ID)
WARNING: rejected rule (sMM -> ID) in state 174
WARNING: Rule (tCompare -> varYVals) is never reduced
WARNING: Rule (tCompare -> varsOps) is never reduced
