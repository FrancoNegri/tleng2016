Created by PLY version 3.8 (http://www.dabeaz.com/ply)

Unused terminals:

    RES
    COMMENT
    BEGIN
    END

Grammar

Rule 0     S' -> g
Rule 1     g -> sentencia g
Rule 2     g -> ctrl g
Rule 3     g -> empty
Rule 4     sentencia -> varsOps ;
Rule 5     sentencia -> func ;
Rule 6     sentencia -> varAsig ;
Rule 7     sentencia -> RETURN ;
Rule 8     ctrl -> if
Rule 9     ctrl -> loop
Rule 10    loop -> WHILE ( expBool ) bloque
Rule 11    loop -> DO bloque WHILE ( expBool ) ;
Rule 12    loop -> FOR ( varAsig ; expBool ; varsOps ) bloque
Rule 13    if -> IF ( expBool ) THEN bloque else
Rule 14    else -> ELSE bloque
Rule 15    else -> empty
Rule 16    bloque -> sentencia
Rule 17    bloque -> { g }
Rule 18    func -> funcReturn
Rule 19    func -> funcVoid
Rule 20    funcReturn -> funcInt
Rule 21    funcReturn -> funcString
Rule 22    funcReturn -> funcBool
Rule 23    funcInt -> MULTIESCALAR ( vec , eMat , param )
Rule 24    funcInt -> LENGTH ( vec )
Rule 25    funcString -> CAPITALIZAR ( expString )
Rule 26    funcBool -> COLINEALES ( vec , vec )
Rule 27    funcVoid -> PRINT ( valores )
Rule 28    param -> expBool
Rule 29    param -> empty
Rule 30    empty -> <empty>
Rule 31    vec -> ID = [ elem ]
Rule 32    elem -> valores , elem
Rule 33    elem -> valores
Rule 34    valores -> eMat
Rule 35    valores -> expBool
Rule 36    valores -> expString
Rule 37    valores -> varYVals
Rule 38    valores -> funcReturn
Rule 39    valores -> reg
Rule 40    valores -> ID . ID
Rule 41    varYVals -> ID
Rule 42    varYVals -> vecVal
Rule 43    vecVal -> ID m
Rule 44    m -> [ INT ]
Rule 45    m -> [ INT ] m
Rule 46    reg -> { campos }
Rule 47    campos -> ID : valores , campos
Rule 48    campos -> valores
Rule 49    varsOps -> MENOSMENOS sMM
Rule 50    varsOps -> MASMAS sMM
Rule 51    varsOps -> sMM
Rule 52    varsOps -> MENOSMENOS varYVals
Rule 53    varsOps -> MASMAS varYVals
Rule 54    sMM -> varYVals MASMAS
Rule 55    sMM -> varYVals MENOSMENOS
Rule 56    varAsig -> ID MENOSEQ varAsig
Rule 57    varAsig -> ID MASEQ varAsig
Rule 58    varAsig -> ID MULEQ varAsig
Rule 59    varAsig -> ID DIVEQ varAsig
Rule 60    varAsig -> ID = varAsig
Rule 61    varAsig -> ID MASEQ valores
Rule 62    varAsig -> ID MENOSEQ valores
Rule 63    varAsig -> ID MULEQ valores
Rule 64    varAsig -> ID DIVEQ valores
Rule 65    varAsig -> ID = valores
Rule 66    eMat -> eMat + p
Rule 67    eMat -> eMat - p
Rule 68    eMat -> p
Rule 69    p -> p * exp
Rule 70    p -> p / exp
Rule 71    p -> p % exp
Rule 72    p -> exp
Rule 73    exp -> exp ^ iSing
Rule 74    exp -> iSing
Rule 75    iSing -> - paren
Rule 76    iSing -> + paren
Rule 77    iSing -> paren
Rule 78    paren -> ( eMat )
Rule 79    paren -> INT
Rule 80    paren -> varYVals
Rule 81    paren -> FLOAT
Rule 82    paren -> varsOps
Rule 83    paren -> funcInt
Rule 84    expString -> expString + STRING
Rule 85    expString -> STRING
Rule 86    expString -> varYVals
Rule 87    expString -> funcString
Rule 88    expBool -> or ? expBool : expBool
Rule 89    expBool -> or
Rule 90    or -> or OR and
Rule 91    or -> and
Rule 92    and -> and AND eq
Rule 93    and -> eq
Rule 94    eq -> eq EQEQ tBool
Rule 95    eq -> eq DISTINTO tBool
Rule 96    eq -> mayor
Rule 97    mayor -> tCompare > tCompare
Rule 98    mayor -> menor
Rule 99    menor -> tCompare < tCompare
Rule 100   menor -> not
Rule 101   not -> NOT not
Rule 102   not -> tBool
Rule 103   tBool -> ( expBool )
Rule 104   tBool -> BOOL
Rule 105   tBool -> varYVals
Rule 106   tBool -> funcBool
Rule 107   tCompare -> eMat
Rule 108   tCompare -> varsOps
Rule 109   tCompare -> varYVals

Terminals, with rules where they appear

%                    : 71
(                    : 10 11 12 13 23 24 25 26 27 78 103
)                    : 10 11 12 13 23 24 25 26 27 78 103
*                    : 69
+                    : 66 76 84
,                    : 23 23 26 32 47
-                    : 67 75
.                    : 40
/                    : 70
:                    : 47 88
;                    : 4 5 6 7 11 12 12
<                    : 99
=                    : 31 60 65
>                    : 97
?                    : 88
AND                  : 92
BEGIN                : 
BOOL                 : 104
CAPITALIZAR          : 25
COLINEALES           : 26
COMMENT              : 
DISTINTO             : 95
DIVEQ                : 59 64
DO                   : 11
ELSE                 : 14
END                  : 
EQEQ                 : 94
FLOAT                : 81
FOR                  : 12
ID                   : 31 40 40 41 43 47 56 57 58 59 60 61 62 63 64 65
IF                   : 13
INT                  : 44 45 79
LENGTH               : 24
MASEQ                : 57 61
MASMAS               : 50 53 54
MENOSEQ              : 56 62
MENOSMENOS           : 49 52 55
MULEQ                : 58 63
MULTIESCALAR         : 23
NOT                  : 101
OR                   : 90
PRINT                : 27
RES                  : 
RETURN               : 7
STRING               : 84 85
THEN                 : 13
WHILE                : 10 11
[                    : 31 44 45
]                    : 31 44 45
^                    : 73
error                : 
{                    : 17 46
}                    : 17 46

Nonterminals, with rules where they appear

and                  : 90 91 92
bloque               : 10 11 12 13 14
campos               : 46 47
ctrl                 : 2
eMat                 : 23 34 66 67 78 107
elem                 : 31 32
else                 : 13
empty                : 3 15 29
eq                   : 92 93 94 95
exp                  : 69 70 71 72 73
expBool              : 10 11 12 13 28 35 88 88 103
expString            : 25 36 84
func                 : 5
funcBool             : 22 106
funcInt              : 20 83
funcReturn           : 18 38
funcString           : 21 87
funcVoid             : 19
g                    : 1 2 17 0
iSing                : 73 74
if                   : 8
loop                 : 9
m                    : 43 45
mayor                : 96
menor                : 98
not                  : 100 101
or                   : 88 89 90
p                    : 66 67 68 69 70 71
param                : 23
paren                : 75 76 77
reg                  : 39
sMM                  : 49 50 51
sentencia            : 1 16
tBool                : 94 95 102
tCompare             : 97 97 99 99
valores              : 27 32 33 47 48 61 62 63 64 65
varAsig              : 6 12 56 57 58 59 60
varYVals             : 37 52 53 54 55 80 86 105 109
varsOps              : 4 12 82 108
vec                  : 23 24 26 26
vecVal               : 42

Parsing method: LALR

state 0

    (0) S' -> . g
    (1) g -> . sentencia g
    (2) g -> . ctrl g
    (3) g -> . empty
    (4) sentencia -> . varsOps ;
    (5) sentencia -> . func ;
    (6) sentencia -> . varAsig ;
    (7) sentencia -> . RETURN ;
    (8) ctrl -> . if
    (9) ctrl -> . loop
    (30) empty -> .
    (49) varsOps -> . MENOSMENOS sMM
    (50) varsOps -> . MASMAS sMM
    (51) varsOps -> . sMM
    (52) varsOps -> . MENOSMENOS varYVals
    (53) varsOps -> . MASMAS varYVals
    (18) func -> . funcReturn
    (19) func -> . funcVoid
    (56) varAsig -> . ID MENOSEQ varAsig
    (57) varAsig -> . ID MASEQ varAsig
    (58) varAsig -> . ID MULEQ varAsig
    (59) varAsig -> . ID DIVEQ varAsig
    (60) varAsig -> . ID = varAsig
    (61) varAsig -> . ID MASEQ valores
    (62) varAsig -> . ID MENOSEQ valores
    (63) varAsig -> . ID MULEQ valores
    (64) varAsig -> . ID DIVEQ valores
    (65) varAsig -> . ID = valores
    (13) if -> . IF ( expBool ) THEN bloque else
    (10) loop -> . WHILE ( expBool ) bloque
    (11) loop -> . DO bloque WHILE ( expBool ) ;
    (12) loop -> . FOR ( varAsig ; expBool ; varsOps ) bloque
    (54) sMM -> . varYVals MASMAS
    (55) sMM -> . varYVals MENOSMENOS
    (20) funcReturn -> . funcInt
    (21) funcReturn -> . funcString
    (22) funcReturn -> . funcBool
    (27) funcVoid -> . PRINT ( valores )
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (23) funcInt -> . MULTIESCALAR ( vec , eMat , param )
    (24) funcInt -> . LENGTH ( vec )
    (25) funcString -> . CAPITALIZAR ( expString )
    (26) funcBool -> . COLINEALES ( vec , vec )
    (43) vecVal -> . ID m

    RETURN          shift and go to state 2
    $end            reduce using rule 30 (empty -> .)
    MENOSMENOS      shift and go to state 30
    MASMAS          shift and go to state 27
    ID              shift and go to state 17
    IF              shift and go to state 18
    WHILE           shift and go to state 6
    DO              shift and go to state 1
    FOR             shift and go to state 15
    PRINT           shift and go to state 8
    MULTIESCALAR    shift and go to state 22
    LENGTH          shift and go to state 25
    CAPITALIZAR     shift and go to state 24
    COLINEALES      shift and go to state 14

    funcBool                       shift and go to state 3
    ctrl                           shift and go to state 4
    funcInt                        shift and go to state 5
    loop                           shift and go to state 7
    vecVal                         shift and go to state 9
    if                             shift and go to state 10
    sentencia                      shift and go to state 11
    sMM                            shift and go to state 12
    empty                          shift and go to state 26
    funcVoid                       shift and go to state 13
    func                           shift and go to state 16
    varAsig                        shift and go to state 19
    g                              shift and go to state 20
    funcString                     shift and go to state 21
    funcReturn                     shift and go to state 23
    varsOps                        shift and go to state 28
    varYVals                       shift and go to state 29

state 1

    (11) loop -> DO . bloque WHILE ( expBool ) ;
    (16) bloque -> . sentencia
    (17) bloque -> . { g }
    (4) sentencia -> . varsOps ;
    (5) sentencia -> . func ;
    (6) sentencia -> . varAsig ;
    (7) sentencia -> . RETURN ;
    (49) varsOps -> . MENOSMENOS sMM
    (50) varsOps -> . MASMAS sMM
    (51) varsOps -> . sMM
    (52) varsOps -> . MENOSMENOS varYVals
    (53) varsOps -> . MASMAS varYVals
    (18) func -> . funcReturn
    (19) func -> . funcVoid
    (56) varAsig -> . ID MENOSEQ varAsig
    (57) varAsig -> . ID MASEQ varAsig
    (58) varAsig -> . ID MULEQ varAsig
    (59) varAsig -> . ID DIVEQ varAsig
    (60) varAsig -> . ID = varAsig
    (61) varAsig -> . ID MASEQ valores
    (62) varAsig -> . ID MENOSEQ valores
    (63) varAsig -> . ID MULEQ valores
    (64) varAsig -> . ID DIVEQ valores
    (65) varAsig -> . ID = valores
    (54) sMM -> . varYVals MASMAS
    (55) sMM -> . varYVals MENOSMENOS
    (20) funcReturn -> . funcInt
    (21) funcReturn -> . funcString
    (22) funcReturn -> . funcBool
    (27) funcVoid -> . PRINT ( valores )
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (23) funcInt -> . MULTIESCALAR ( vec , eMat , param )
    (24) funcInt -> . LENGTH ( vec )
    (25) funcString -> . CAPITALIZAR ( expString )
    (26) funcBool -> . COLINEALES ( vec , vec )
    (43) vecVal -> . ID m

    {               shift and go to state 33
    RETURN          shift and go to state 2
    MENOSMENOS      shift and go to state 30
    MASMAS          shift and go to state 27
    ID              shift and go to state 17
    PRINT           shift and go to state 8
    MULTIESCALAR    shift and go to state 22
    LENGTH          shift and go to state 25
    CAPITALIZAR     shift and go to state 24
    COLINEALES      shift and go to state 14

    varAsig                        shift and go to state 19
    sentencia                      shift and go to state 32
    funcBool                       shift and go to state 3
    funcString                     shift and go to state 21
    funcVoid                       shift and go to state 13
    funcReturn                     shift and go to state 23
    vecVal                         shift and go to state 9
    sMM                            shift and go to state 12
    varsOps                        shift and go to state 28
    func                           shift and go to state 16
    bloque                         shift and go to state 31
    varYVals                       shift and go to state 29
    funcInt                        shift and go to state 5

state 2

    (7) sentencia -> RETURN . ;

    ;               shift and go to state 34


state 3

    (22) funcReturn -> funcBool .

    ;               reduce using rule 22 (funcReturn -> funcBool .)


state 4

    (2) g -> ctrl . g
    (1) g -> . sentencia g
    (2) g -> . ctrl g
    (3) g -> . empty
    (4) sentencia -> . varsOps ;
    (5) sentencia -> . func ;
    (6) sentencia -> . varAsig ;
    (7) sentencia -> . RETURN ;
    (8) ctrl -> . if
    (9) ctrl -> . loop
    (30) empty -> .
    (49) varsOps -> . MENOSMENOS sMM
    (50) varsOps -> . MASMAS sMM
    (51) varsOps -> . sMM
    (52) varsOps -> . MENOSMENOS varYVals
    (53) varsOps -> . MASMAS varYVals
    (18) func -> . funcReturn
    (19) func -> . funcVoid
    (56) varAsig -> . ID MENOSEQ varAsig
    (57) varAsig -> . ID MASEQ varAsig
    (58) varAsig -> . ID MULEQ varAsig
    (59) varAsig -> . ID DIVEQ varAsig
    (60) varAsig -> . ID = varAsig
    (61) varAsig -> . ID MASEQ valores
    (62) varAsig -> . ID MENOSEQ valores
    (63) varAsig -> . ID MULEQ valores
    (64) varAsig -> . ID DIVEQ valores
    (65) varAsig -> . ID = valores
    (13) if -> . IF ( expBool ) THEN bloque else
    (10) loop -> . WHILE ( expBool ) bloque
    (11) loop -> . DO bloque WHILE ( expBool ) ;
    (12) loop -> . FOR ( varAsig ; expBool ; varsOps ) bloque
    (54) sMM -> . varYVals MASMAS
    (55) sMM -> . varYVals MENOSMENOS
    (20) funcReturn -> . funcInt
    (21) funcReturn -> . funcString
    (22) funcReturn -> . funcBool
    (27) funcVoid -> . PRINT ( valores )
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (23) funcInt -> . MULTIESCALAR ( vec , eMat , param )
    (24) funcInt -> . LENGTH ( vec )
    (25) funcString -> . CAPITALIZAR ( expString )
    (26) funcBool -> . COLINEALES ( vec , vec )
    (43) vecVal -> . ID m

    RETURN          shift and go to state 2
    $end            reduce using rule 30 (empty -> .)
    }               reduce using rule 30 (empty -> .)
    MENOSMENOS      shift and go to state 30
    MASMAS          shift and go to state 27
    ID              shift and go to state 17
    IF              shift and go to state 18
    WHILE           shift and go to state 6
    DO              shift and go to state 1
    FOR             shift and go to state 15
    PRINT           shift and go to state 8
    MULTIESCALAR    shift and go to state 22
    LENGTH          shift and go to state 25
    CAPITALIZAR     shift and go to state 24
    COLINEALES      shift and go to state 14

    funcBool                       shift and go to state 3
    ctrl                           shift and go to state 4
    funcInt                        shift and go to state 5
    loop                           shift and go to state 7
    vecVal                         shift and go to state 9
    if                             shift and go to state 10
    sentencia                      shift and go to state 11
    sMM                            shift and go to state 12
    empty                          shift and go to state 26
    funcVoid                       shift and go to state 13
    func                           shift and go to state 16
    varAsig                        shift and go to state 19
    g                              shift and go to state 35
    funcString                     shift and go to state 21
    funcReturn                     shift and go to state 23
    varsOps                        shift and go to state 28
    varYVals                       shift and go to state 29

state 5

    (20) funcReturn -> funcInt .

    ;               reduce using rule 20 (funcReturn -> funcInt .)


state 6

    (10) loop -> WHILE . ( expBool ) bloque

    (               shift and go to state 36


state 7

    (9) ctrl -> loop .

    RETURN          reduce using rule 9 (ctrl -> loop .)
    MENOSMENOS      reduce using rule 9 (ctrl -> loop .)
    MASMAS          reduce using rule 9 (ctrl -> loop .)
    ID              reduce using rule 9 (ctrl -> loop .)
    IF              reduce using rule 9 (ctrl -> loop .)
    WHILE           reduce using rule 9 (ctrl -> loop .)
    DO              reduce using rule 9 (ctrl -> loop .)
    FOR             reduce using rule 9 (ctrl -> loop .)
    PRINT           reduce using rule 9 (ctrl -> loop .)
    MULTIESCALAR    reduce using rule 9 (ctrl -> loop .)
    LENGTH          reduce using rule 9 (ctrl -> loop .)
    CAPITALIZAR     reduce using rule 9 (ctrl -> loop .)
    COLINEALES      reduce using rule 9 (ctrl -> loop .)
    }               reduce using rule 9 (ctrl -> loop .)
    $end            reduce using rule 9 (ctrl -> loop .)


state 8

    (27) funcVoid -> PRINT . ( valores )

    (               shift and go to state 37


state 9

    (42) varYVals -> vecVal .

    MASMAS          reduce using rule 42 (varYVals -> vecVal .)
    MENOSMENOS      reduce using rule 42 (varYVals -> vecVal .)
    ^               reduce using rule 42 (varYVals -> vecVal .)
    *               reduce using rule 42 (varYVals -> vecVal .)
    /               reduce using rule 42 (varYVals -> vecVal .)
    %               reduce using rule 42 (varYVals -> vecVal .)
    )               reduce using rule 42 (varYVals -> vecVal .)
    +               reduce using rule 42 (varYVals -> vecVal .)
    -               reduce using rule 42 (varYVals -> vecVal .)
    >               reduce using rule 42 (varYVals -> vecVal .)
    <               reduce using rule 42 (varYVals -> vecVal .)
    EQEQ            reduce using rule 42 (varYVals -> vecVal .)
    DISTINTO        reduce using rule 42 (varYVals -> vecVal .)
    AND             reduce using rule 42 (varYVals -> vecVal .)
    ?               reduce using rule 42 (varYVals -> vecVal .)
    OR              reduce using rule 42 (varYVals -> vecVal .)
    :               reduce using rule 42 (varYVals -> vecVal .)
    ;               reduce using rule 42 (varYVals -> vecVal .)
    }               reduce using rule 42 (varYVals -> vecVal .)
    ,               reduce using rule 42 (varYVals -> vecVal .)
    ]               reduce using rule 42 (varYVals -> vecVal .)


state 10

    (8) ctrl -> if .

    RETURN          reduce using rule 8 (ctrl -> if .)
    MENOSMENOS      reduce using rule 8 (ctrl -> if .)
    MASMAS          reduce using rule 8 (ctrl -> if .)
    ID              reduce using rule 8 (ctrl -> if .)
    IF              reduce using rule 8 (ctrl -> if .)
    WHILE           reduce using rule 8 (ctrl -> if .)
    DO              reduce using rule 8 (ctrl -> if .)
    FOR             reduce using rule 8 (ctrl -> if .)
    PRINT           reduce using rule 8 (ctrl -> if .)
    MULTIESCALAR    reduce using rule 8 (ctrl -> if .)
    LENGTH          reduce using rule 8 (ctrl -> if .)
    CAPITALIZAR     reduce using rule 8 (ctrl -> if .)
    COLINEALES      reduce using rule 8 (ctrl -> if .)
    }               reduce using rule 8 (ctrl -> if .)
    $end            reduce using rule 8 (ctrl -> if .)


state 11

    (1) g -> sentencia . g
    (1) g -> . sentencia g
    (2) g -> . ctrl g
    (3) g -> . empty
    (4) sentencia -> . varsOps ;
    (5) sentencia -> . func ;
    (6) sentencia -> . varAsig ;
    (7) sentencia -> . RETURN ;
    (8) ctrl -> . if
    (9) ctrl -> . loop
    (30) empty -> .
    (49) varsOps -> . MENOSMENOS sMM
    (50) varsOps -> . MASMAS sMM
    (51) varsOps -> . sMM
    (52) varsOps -> . MENOSMENOS varYVals
    (53) varsOps -> . MASMAS varYVals
    (18) func -> . funcReturn
    (19) func -> . funcVoid
    (56) varAsig -> . ID MENOSEQ varAsig
    (57) varAsig -> . ID MASEQ varAsig
    (58) varAsig -> . ID MULEQ varAsig
    (59) varAsig -> . ID DIVEQ varAsig
    (60) varAsig -> . ID = varAsig
    (61) varAsig -> . ID MASEQ valores
    (62) varAsig -> . ID MENOSEQ valores
    (63) varAsig -> . ID MULEQ valores
    (64) varAsig -> . ID DIVEQ valores
    (65) varAsig -> . ID = valores
    (13) if -> . IF ( expBool ) THEN bloque else
    (10) loop -> . WHILE ( expBool ) bloque
    (11) loop -> . DO bloque WHILE ( expBool ) ;
    (12) loop -> . FOR ( varAsig ; expBool ; varsOps ) bloque
    (54) sMM -> . varYVals MASMAS
    (55) sMM -> . varYVals MENOSMENOS
    (20) funcReturn -> . funcInt
    (21) funcReturn -> . funcString
    (22) funcReturn -> . funcBool
    (27) funcVoid -> . PRINT ( valores )
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (23) funcInt -> . MULTIESCALAR ( vec , eMat , param )
    (24) funcInt -> . LENGTH ( vec )
    (25) funcString -> . CAPITALIZAR ( expString )
    (26) funcBool -> . COLINEALES ( vec , vec )
    (43) vecVal -> . ID m

    RETURN          shift and go to state 2
    $end            reduce using rule 30 (empty -> .)
    }               reduce using rule 30 (empty -> .)
    MENOSMENOS      shift and go to state 30
    MASMAS          shift and go to state 27
    ID              shift and go to state 17
    IF              shift and go to state 18
    WHILE           shift and go to state 6
    DO              shift and go to state 1
    FOR             shift and go to state 15
    PRINT           shift and go to state 8
    MULTIESCALAR    shift and go to state 22
    LENGTH          shift and go to state 25
    CAPITALIZAR     shift and go to state 24
    COLINEALES      shift and go to state 14

    funcBool                       shift and go to state 3
    ctrl                           shift and go to state 4
    funcInt                        shift and go to state 5
    loop                           shift and go to state 7
    vecVal                         shift and go to state 9
    if                             shift and go to state 10
    sentencia                      shift and go to state 11
    sMM                            shift and go to state 12
    empty                          shift and go to state 26
    funcVoid                       shift and go to state 13
    func                           shift and go to state 16
    varAsig                        shift and go to state 19
    g                              shift and go to state 38
    funcString                     shift and go to state 21
    funcReturn                     shift and go to state 23
    varsOps                        shift and go to state 28
    varYVals                       shift and go to state 29

state 12

    (51) varsOps -> sMM .

    ^               reduce using rule 51 (varsOps -> sMM .)
    *               reduce using rule 51 (varsOps -> sMM .)
    /               reduce using rule 51 (varsOps -> sMM .)
    %               reduce using rule 51 (varsOps -> sMM .)
    )               reduce using rule 51 (varsOps -> sMM .)
    +               reduce using rule 51 (varsOps -> sMM .)
    -               reduce using rule 51 (varsOps -> sMM .)
    ,               reduce using rule 51 (varsOps -> sMM .)
    ]               reduce using rule 51 (varsOps -> sMM .)
    >               reduce using rule 51 (varsOps -> sMM .)
    <               reduce using rule 51 (varsOps -> sMM .)
    ;               reduce using rule 51 (varsOps -> sMM .)
    }               reduce using rule 51 (varsOps -> sMM .)
    EQEQ            reduce using rule 51 (varsOps -> sMM .)
    DISTINTO        reduce using rule 51 (varsOps -> sMM .)
    AND             reduce using rule 51 (varsOps -> sMM .)
    ?               reduce using rule 51 (varsOps -> sMM .)
    OR              reduce using rule 51 (varsOps -> sMM .)
    :               reduce using rule 51 (varsOps -> sMM .)


state 13

    (19) func -> funcVoid .

    ;               reduce using rule 19 (func -> funcVoid .)


state 14

    (26) funcBool -> COLINEALES . ( vec , vec )

    (               shift and go to state 39


state 15

    (12) loop -> FOR . ( varAsig ; expBool ; varsOps ) bloque

    (               shift and go to state 40


state 16

    (5) sentencia -> func . ;

    ;               shift and go to state 41


state 17

    (56) varAsig -> ID . MENOSEQ varAsig
    (57) varAsig -> ID . MASEQ varAsig
    (58) varAsig -> ID . MULEQ varAsig
    (59) varAsig -> ID . DIVEQ varAsig
    (60) varAsig -> ID . = varAsig
    (61) varAsig -> ID . MASEQ valores
    (62) varAsig -> ID . MENOSEQ valores
    (63) varAsig -> ID . MULEQ valores
    (64) varAsig -> ID . DIVEQ valores
    (65) varAsig -> ID . = valores
    (41) varYVals -> ID .
    (43) vecVal -> ID . m
    (44) m -> . [ INT ]
    (45) m -> . [ INT ] m

    MENOSEQ         shift and go to state 42
    MASEQ           shift and go to state 43
    MULEQ           shift and go to state 45
    DIVEQ           shift and go to state 48
    =               shift and go to state 47
    MASMAS          reduce using rule 41 (varYVals -> ID .)
    MENOSMENOS      reduce using rule 41 (varYVals -> ID .)
    [               shift and go to state 46

    m                              shift and go to state 44

state 18

    (13) if -> IF . ( expBool ) THEN bloque else

    (               shift and go to state 49


state 19

    (6) sentencia -> varAsig . ;

    ;               shift and go to state 50


state 20

    (0) S' -> g .



state 21

    (21) funcReturn -> funcString .

    ;               reduce using rule 21 (funcReturn -> funcString .)


state 22

    (23) funcInt -> MULTIESCALAR . ( vec , eMat , param )

    (               shift and go to state 51


state 23

    (18) func -> funcReturn .

    ;               reduce using rule 18 (func -> funcReturn .)


state 24

    (25) funcString -> CAPITALIZAR . ( expString )

    (               shift and go to state 52


state 25

    (24) funcInt -> LENGTH . ( vec )

    (               shift and go to state 53


state 26

    (3) g -> empty .

    }               reduce using rule 3 (g -> empty .)
    $end            reduce using rule 3 (g -> empty .)


state 27

    (50) varsOps -> MASMAS . sMM
    (53) varsOps -> MASMAS . varYVals
    (54) sMM -> . varYVals MASMAS
    (55) sMM -> . varYVals MENOSMENOS
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (43) vecVal -> . ID m

    ID              shift and go to state 56

    sMM                            shift and go to state 54
    varYVals                       shift and go to state 55
    vecVal                         shift and go to state 9

state 28

    (4) sentencia -> varsOps . ;

    ;               shift and go to state 57


state 29

    (54) sMM -> varYVals . MASMAS
    (55) sMM -> varYVals . MENOSMENOS

    MASMAS          shift and go to state 58
    MENOSMENOS      shift and go to state 59


state 30

    (49) varsOps -> MENOSMENOS . sMM
    (52) varsOps -> MENOSMENOS . varYVals
    (54) sMM -> . varYVals MASMAS
    (55) sMM -> . varYVals MENOSMENOS
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (43) vecVal -> . ID m

    ID              shift and go to state 56

    sMM                            shift and go to state 60
    varYVals                       shift and go to state 61
    vecVal                         shift and go to state 9

state 31

    (11) loop -> DO bloque . WHILE ( expBool ) ;

    WHILE           shift and go to state 62


state 32

    (16) bloque -> sentencia .

    RETURN          reduce using rule 16 (bloque -> sentencia .)
    MENOSMENOS      reduce using rule 16 (bloque -> sentencia .)
    MASMAS          reduce using rule 16 (bloque -> sentencia .)
    ID              reduce using rule 16 (bloque -> sentencia .)
    IF              reduce using rule 16 (bloque -> sentencia .)
    WHILE           reduce using rule 16 (bloque -> sentencia .)
    DO              reduce using rule 16 (bloque -> sentencia .)
    FOR             reduce using rule 16 (bloque -> sentencia .)
    PRINT           reduce using rule 16 (bloque -> sentencia .)
    MULTIESCALAR    reduce using rule 16 (bloque -> sentencia .)
    LENGTH          reduce using rule 16 (bloque -> sentencia .)
    CAPITALIZAR     reduce using rule 16 (bloque -> sentencia .)
    COLINEALES      reduce using rule 16 (bloque -> sentencia .)
    $end            reduce using rule 16 (bloque -> sentencia .)
    }               reduce using rule 16 (bloque -> sentencia .)
    ELSE            reduce using rule 16 (bloque -> sentencia .)


state 33

    (17) bloque -> { . g }
    (1) g -> . sentencia g
    (2) g -> . ctrl g
    (3) g -> . empty
    (4) sentencia -> . varsOps ;
    (5) sentencia -> . func ;
    (6) sentencia -> . varAsig ;
    (7) sentencia -> . RETURN ;
    (8) ctrl -> . if
    (9) ctrl -> . loop
    (30) empty -> .
    (49) varsOps -> . MENOSMENOS sMM
    (50) varsOps -> . MASMAS sMM
    (51) varsOps -> . sMM
    (52) varsOps -> . MENOSMENOS varYVals
    (53) varsOps -> . MASMAS varYVals
    (18) func -> . funcReturn
    (19) func -> . funcVoid
    (56) varAsig -> . ID MENOSEQ varAsig
    (57) varAsig -> . ID MASEQ varAsig
    (58) varAsig -> . ID MULEQ varAsig
    (59) varAsig -> . ID DIVEQ varAsig
    (60) varAsig -> . ID = varAsig
    (61) varAsig -> . ID MASEQ valores
    (62) varAsig -> . ID MENOSEQ valores
    (63) varAsig -> . ID MULEQ valores
    (64) varAsig -> . ID DIVEQ valores
    (65) varAsig -> . ID = valores
    (13) if -> . IF ( expBool ) THEN bloque else
    (10) loop -> . WHILE ( expBool ) bloque
    (11) loop -> . DO bloque WHILE ( expBool ) ;
    (12) loop -> . FOR ( varAsig ; expBool ; varsOps ) bloque
    (54) sMM -> . varYVals MASMAS
    (55) sMM -> . varYVals MENOSMENOS
    (20) funcReturn -> . funcInt
    (21) funcReturn -> . funcString
    (22) funcReturn -> . funcBool
    (27) funcVoid -> . PRINT ( valores )
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (23) funcInt -> . MULTIESCALAR ( vec , eMat , param )
    (24) funcInt -> . LENGTH ( vec )
    (25) funcString -> . CAPITALIZAR ( expString )
    (26) funcBool -> . COLINEALES ( vec , vec )
    (43) vecVal -> . ID m

    RETURN          shift and go to state 2
    }               reduce using rule 30 (empty -> .)
    MENOSMENOS      shift and go to state 30
    MASMAS          shift and go to state 27
    ID              shift and go to state 17
    IF              shift and go to state 18
    WHILE           shift and go to state 6
    DO              shift and go to state 1
    FOR             shift and go to state 15
    PRINT           shift and go to state 8
    MULTIESCALAR    shift and go to state 22
    LENGTH          shift and go to state 25
    CAPITALIZAR     shift and go to state 24
    COLINEALES      shift and go to state 14

    funcBool                       shift and go to state 3
    ctrl                           shift and go to state 4
    funcInt                        shift and go to state 5
    loop                           shift and go to state 7
    vecVal                         shift and go to state 9
    if                             shift and go to state 10
    sentencia                      shift and go to state 11
    sMM                            shift and go to state 12
    empty                          shift and go to state 26
    funcVoid                       shift and go to state 13
    func                           shift and go to state 16
    varAsig                        shift and go to state 19
    g                              shift and go to state 63
    funcString                     shift and go to state 21
    funcReturn                     shift and go to state 23
    varsOps                        shift and go to state 28
    varYVals                       shift and go to state 29

state 34

    (7) sentencia -> RETURN ; .

    RETURN          reduce using rule 7 (sentencia -> RETURN ; .)
    MENOSMENOS      reduce using rule 7 (sentencia -> RETURN ; .)
    MASMAS          reduce using rule 7 (sentencia -> RETURN ; .)
    ID              reduce using rule 7 (sentencia -> RETURN ; .)
    IF              reduce using rule 7 (sentencia -> RETURN ; .)
    WHILE           reduce using rule 7 (sentencia -> RETURN ; .)
    DO              reduce using rule 7 (sentencia -> RETURN ; .)
    FOR             reduce using rule 7 (sentencia -> RETURN ; .)
    PRINT           reduce using rule 7 (sentencia -> RETURN ; .)
    MULTIESCALAR    reduce using rule 7 (sentencia -> RETURN ; .)
    LENGTH          reduce using rule 7 (sentencia -> RETURN ; .)
    CAPITALIZAR     reduce using rule 7 (sentencia -> RETURN ; .)
    COLINEALES      reduce using rule 7 (sentencia -> RETURN ; .)
    $end            reduce using rule 7 (sentencia -> RETURN ; .)
    }               reduce using rule 7 (sentencia -> RETURN ; .)
    ELSE            reduce using rule 7 (sentencia -> RETURN ; .)


state 35

    (2) g -> ctrl g .

    }               reduce using rule 2 (g -> ctrl g .)
    $end            reduce using rule 2 (g -> ctrl g .)


state 36

    (10) loop -> WHILE ( . expBool ) bloque
    (88) expBool -> . or ? expBool : expBool
    (89) expBool -> . or
    (90) or -> . or OR and
    (91) or -> . and
    (92) and -> . and AND eq
    (93) and -> . eq
    (94) eq -> . eq EQEQ tBool
    (95) eq -> . eq DISTINTO tBool
    (96) eq -> . mayor
    (97) mayor -> . tCompare > tCompare
    (98) mayor -> . menor
    (107) tCompare -> . eMat
    (108) tCompare -> . varsOps
    (109) tCompare -> . varYVals
    (99) menor -> . tCompare < tCompare
    (100) menor -> . not
    (66) eMat -> . eMat + p
    (67) eMat -> . eMat - p
    (68) eMat -> . p
    (49) varsOps -> . MENOSMENOS sMM
    (50) varsOps -> . MASMAS sMM
    (51) varsOps -> . sMM
    (52) varsOps -> . MENOSMENOS varYVals
    (53) varsOps -> . MASMAS varYVals
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (101) not -> . NOT not
    (102) not -> . tBool
    (69) p -> . p * exp
    (70) p -> . p / exp
    (71) p -> . p % exp
    (72) p -> . exp
    (54) sMM -> . varYVals MASMAS
    (55) sMM -> . varYVals MENOSMENOS
    (43) vecVal -> . ID m
    (103) tBool -> . ( expBool )
    (104) tBool -> . BOOL
    (105) tBool -> . varYVals
    (106) tBool -> . funcBool
    (73) exp -> . exp ^ iSing
    (74) exp -> . iSing
    (26) funcBool -> . COLINEALES ( vec , vec )
    (75) iSing -> . - paren
    (76) iSing -> . + paren
    (77) iSing -> . paren
    (78) paren -> . ( eMat )
    (79) paren -> . INT
    (80) paren -> . varYVals
    (81) paren -> . FLOAT
    (82) paren -> . varsOps
    (83) paren -> . funcInt
    (23) funcInt -> . MULTIESCALAR ( vec , eMat , param )
    (24) funcInt -> . LENGTH ( vec )

    MENOSMENOS      shift and go to state 30
    MASMAS          shift and go to state 27
    ID              shift and go to state 56
    NOT             shift and go to state 85
    (               shift and go to state 71
    BOOL            shift and go to state 74
    COLINEALES      shift and go to state 14
    -               shift and go to state 73
    +               shift and go to state 72
    INT             shift and go to state 79
    FLOAT           shift and go to state 80
    MULTIESCALAR    shift and go to state 22
    LENGTH          shift and go to state 25

    and                            shift and go to state 64
    funcBool                       shift and go to state 65
    funcInt                        shift and go to state 66
    menor                          shift and go to state 67
    eq                             shift and go to state 68
    mayor                          shift and go to state 69
    eMat                           shift and go to state 70
    vecVal                         shift and go to state 9
    sMM                            shift and go to state 12
    paren                          shift and go to state 77
    iSing                          shift and go to state 75
    tCompare                       shift and go to state 76
    not                            shift and go to state 78
    p                              shift and go to state 82
    varsOps                        shift and go to state 83
    exp                            shift and go to state 84
    tBool                          shift and go to state 86
    varYVals                       shift and go to state 87
    or                             shift and go to state 81
    expBool                        shift and go to state 88

state 37

    (27) funcVoid -> PRINT ( . valores )
    (34) valores -> . eMat
    (35) valores -> . expBool
    (36) valores -> . expString
    (37) valores -> . varYVals
    (38) valores -> . funcReturn
    (39) valores -> . reg
    (40) valores -> . ID . ID
    (66) eMat -> . eMat + p
    (67) eMat -> . eMat - p
    (68) eMat -> . p
    (88) expBool -> . or ? expBool : expBool
    (89) expBool -> . or
    (84) expString -> . expString + STRING
    (85) expString -> . STRING
    (86) expString -> . varYVals
    (87) expString -> . funcString
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (20) funcReturn -> . funcInt
    (21) funcReturn -> . funcString
    (22) funcReturn -> . funcBool
    (46) reg -> . { campos }
    (69) p -> . p * exp
    (70) p -> . p / exp
    (71) p -> . p % exp
    (72) p -> . exp
    (90) or -> . or OR and
    (91) or -> . and
    (25) funcString -> . CAPITALIZAR ( expString )
    (43) vecVal -> . ID m
    (23) funcInt -> . MULTIESCALAR ( vec , eMat , param )
    (24) funcInt -> . LENGTH ( vec )
    (26) funcBool -> . COLINEALES ( vec , vec )
    (73) exp -> . exp ^ iSing
    (74) exp -> . iSing
    (92) and -> . and AND eq
    (93) and -> . eq
    (75) iSing -> . - paren
    (76) iSing -> . + paren
    (77) iSing -> . paren
    (94) eq -> . eq EQEQ tBool
    (95) eq -> . eq DISTINTO tBool
    (96) eq -> . mayor
    (78) paren -> . ( eMat )
    (79) paren -> . INT
    (80) paren -> . varYVals
    (81) paren -> . FLOAT
    (82) paren -> . varsOps
    (83) paren -> . funcInt
    (97) mayor -> . tCompare > tCompare
    (98) mayor -> . menor
    (49) varsOps -> . MENOSMENOS sMM
    (50) varsOps -> . MASMAS sMM
    (51) varsOps -> . sMM
    (52) varsOps -> . MENOSMENOS varYVals
    (53) varsOps -> . MASMAS varYVals
    (107) tCompare -> . eMat
    (108) tCompare -> . varsOps
    (109) tCompare -> . varYVals
    (99) menor -> . tCompare < tCompare
    (100) menor -> . not
    (54) sMM -> . varYVals MASMAS
    (55) sMM -> . varYVals MENOSMENOS
    (101) not -> . NOT not
    (102) not -> . tBool
    (103) tBool -> . ( expBool )
    (104) tBool -> . BOOL
    (105) tBool -> . varYVals
    (106) tBool -> . funcBool

    ID              shift and go to state 97
    STRING          shift and go to state 95
    {               shift and go to state 101
    CAPITALIZAR     shift and go to state 24
    MULTIESCALAR    shift and go to state 22
    LENGTH          shift and go to state 25
    COLINEALES      shift and go to state 14
    -               shift and go to state 73
    +               shift and go to state 72
    (               shift and go to state 92
    INT             shift and go to state 79
    FLOAT           shift and go to state 80
    MENOSMENOS      shift and go to state 30
    MASMAS          shift and go to state 27
    NOT             shift and go to state 85
    BOOL            shift and go to state 74

    and                            shift and go to state 64
    funcBool                       shift and go to state 89
    funcInt                        shift and go to state 90
    menor                          shift and go to state 67
    eq                             shift and go to state 68
    vecVal                         shift and go to state 9
    eMat                           shift and go to state 91
    mayor                          shift and go to state 69
    sMM                            shift and go to state 12
    paren                          shift and go to state 77
    reg                            shift and go to state 93
    varsOps                        shift and go to state 94
    expString                      shift and go to state 96
    tCompare                       shift and go to state 76
    not                            shift and go to state 78
    funcString                     shift and go to state 98
    funcReturn                     shift and go to state 99
    valores                        shift and go to state 100
    p                              shift and go to state 82
    iSing                          shift and go to state 75
    exp                            shift and go to state 84
    tBool                          shift and go to state 86
    varYVals                       shift and go to state 102
    or                             shift and go to state 81
    expBool                        shift and go to state 103

state 38

    (1) g -> sentencia g .

    }               reduce using rule 1 (g -> sentencia g .)
    $end            reduce using rule 1 (g -> sentencia g .)


state 39

    (26) funcBool -> COLINEALES ( . vec , vec )
    (31) vec -> . ID = [ elem ]

    ID              shift and go to state 105

    vec                            shift and go to state 104

state 40

    (12) loop -> FOR ( . varAsig ; expBool ; varsOps ) bloque
    (56) varAsig -> . ID MENOSEQ varAsig
    (57) varAsig -> . ID MASEQ varAsig
    (58) varAsig -> . ID MULEQ varAsig
    (59) varAsig -> . ID DIVEQ varAsig
    (60) varAsig -> . ID = varAsig
    (61) varAsig -> . ID MASEQ valores
    (62) varAsig -> . ID MENOSEQ valores
    (63) varAsig -> . ID MULEQ valores
    (64) varAsig -> . ID DIVEQ valores
    (65) varAsig -> . ID = valores

    ID              shift and go to state 107

    varAsig                        shift and go to state 106

state 41

    (5) sentencia -> func ; .

    RETURN          reduce using rule 5 (sentencia -> func ; .)
    MENOSMENOS      reduce using rule 5 (sentencia -> func ; .)
    MASMAS          reduce using rule 5 (sentencia -> func ; .)
    ID              reduce using rule 5 (sentencia -> func ; .)
    IF              reduce using rule 5 (sentencia -> func ; .)
    WHILE           reduce using rule 5 (sentencia -> func ; .)
    DO              reduce using rule 5 (sentencia -> func ; .)
    FOR             reduce using rule 5 (sentencia -> func ; .)
    PRINT           reduce using rule 5 (sentencia -> func ; .)
    MULTIESCALAR    reduce using rule 5 (sentencia -> func ; .)
    LENGTH          reduce using rule 5 (sentencia -> func ; .)
    CAPITALIZAR     reduce using rule 5 (sentencia -> func ; .)
    COLINEALES      reduce using rule 5 (sentencia -> func ; .)
    $end            reduce using rule 5 (sentencia -> func ; .)
    }               reduce using rule 5 (sentencia -> func ; .)
    ELSE            reduce using rule 5 (sentencia -> func ; .)


state 42

    (56) varAsig -> ID MENOSEQ . varAsig
    (62) varAsig -> ID MENOSEQ . valores
    (56) varAsig -> . ID MENOSEQ varAsig
    (57) varAsig -> . ID MASEQ varAsig
    (58) varAsig -> . ID MULEQ varAsig
    (59) varAsig -> . ID DIVEQ varAsig
    (60) varAsig -> . ID = varAsig
    (61) varAsig -> . ID MASEQ valores
    (62) varAsig -> . ID MENOSEQ valores
    (63) varAsig -> . ID MULEQ valores
    (64) varAsig -> . ID DIVEQ valores
    (65) varAsig -> . ID = valores
    (34) valores -> . eMat
    (35) valores -> . expBool
    (36) valores -> . expString
    (37) valores -> . varYVals
    (38) valores -> . funcReturn
    (39) valores -> . reg
    (40) valores -> . ID . ID
    (66) eMat -> . eMat + p
    (67) eMat -> . eMat - p
    (68) eMat -> . p
    (88) expBool -> . or ? expBool : expBool
    (89) expBool -> . or
    (84) expString -> . expString + STRING
    (85) expString -> . STRING
    (86) expString -> . varYVals
    (87) expString -> . funcString
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (20) funcReturn -> . funcInt
    (21) funcReturn -> . funcString
    (22) funcReturn -> . funcBool
    (46) reg -> . { campos }
    (69) p -> . p * exp
    (70) p -> . p / exp
    (71) p -> . p % exp
    (72) p -> . exp
    (90) or -> . or OR and
    (91) or -> . and
    (25) funcString -> . CAPITALIZAR ( expString )
    (43) vecVal -> . ID m
    (23) funcInt -> . MULTIESCALAR ( vec , eMat , param )
    (24) funcInt -> . LENGTH ( vec )
    (26) funcBool -> . COLINEALES ( vec , vec )
    (73) exp -> . exp ^ iSing
    (74) exp -> . iSing
    (92) and -> . and AND eq
    (93) and -> . eq
    (75) iSing -> . - paren
    (76) iSing -> . + paren
    (77) iSing -> . paren
    (94) eq -> . eq EQEQ tBool
    (95) eq -> . eq DISTINTO tBool
    (96) eq -> . mayor
    (78) paren -> . ( eMat )
    (79) paren -> . INT
    (80) paren -> . varYVals
    (81) paren -> . FLOAT
    (82) paren -> . varsOps
    (83) paren -> . funcInt
    (97) mayor -> . tCompare > tCompare
    (98) mayor -> . menor
    (49) varsOps -> . MENOSMENOS sMM
    (50) varsOps -> . MASMAS sMM
    (51) varsOps -> . sMM
    (52) varsOps -> . MENOSMENOS varYVals
    (53) varsOps -> . MASMAS varYVals
    (107) tCompare -> . eMat
    (108) tCompare -> . varsOps
    (109) tCompare -> . varYVals
    (99) menor -> . tCompare < tCompare
    (100) menor -> . not
    (54) sMM -> . varYVals MASMAS
    (55) sMM -> . varYVals MENOSMENOS
    (101) not -> . NOT not
    (102) not -> . tBool
    (103) tBool -> . ( expBool )
    (104) tBool -> . BOOL
    (105) tBool -> . varYVals
    (106) tBool -> . funcBool

    ID              shift and go to state 108
    STRING          shift and go to state 95
    {               shift and go to state 101
    CAPITALIZAR     shift and go to state 24
    MULTIESCALAR    shift and go to state 22
    LENGTH          shift and go to state 25
    COLINEALES      shift and go to state 14
    -               shift and go to state 73
    +               shift and go to state 72
    (               shift and go to state 92
    INT             shift and go to state 79
    FLOAT           shift and go to state 80
    MENOSMENOS      shift and go to state 30
    MASMAS          shift and go to state 27
    NOT             shift and go to state 85
    BOOL            shift and go to state 74

    and                            shift and go to state 64
    funcBool                       shift and go to state 89
    funcInt                        shift and go to state 90
    menor                          shift and go to state 67
    eq                             shift and go to state 68
    vecVal                         shift and go to state 9
    eMat                           shift and go to state 91
    mayor                          shift and go to state 69
    sMM                            shift and go to state 12
    paren                          shift and go to state 77
    reg                            shift and go to state 93
    varsOps                        shift and go to state 94
    expString                      shift and go to state 96
    tCompare                       shift and go to state 76
    not                            shift and go to state 78
    varAsig                        shift and go to state 109
    funcString                     shift and go to state 98
    funcReturn                     shift and go to state 99
    valores                        shift and go to state 110
    p                              shift and go to state 82
    iSing                          shift and go to state 75
    exp                            shift and go to state 84
    tBool                          shift and go to state 86
    varYVals                       shift and go to state 102
    or                             shift and go to state 81
    expBool                        shift and go to state 103

state 43

    (57) varAsig -> ID MASEQ . varAsig
    (61) varAsig -> ID MASEQ . valores
    (56) varAsig -> . ID MENOSEQ varAsig
    (57) varAsig -> . ID MASEQ varAsig
    (58) varAsig -> . ID MULEQ varAsig
    (59) varAsig -> . ID DIVEQ varAsig
    (60) varAsig -> . ID = varAsig
    (61) varAsig -> . ID MASEQ valores
    (62) varAsig -> . ID MENOSEQ valores
    (63) varAsig -> . ID MULEQ valores
    (64) varAsig -> . ID DIVEQ valores
    (65) varAsig -> . ID = valores
    (34) valores -> . eMat
    (35) valores -> . expBool
    (36) valores -> . expString
    (37) valores -> . varYVals
    (38) valores -> . funcReturn
    (39) valores -> . reg
    (40) valores -> . ID . ID
    (66) eMat -> . eMat + p
    (67) eMat -> . eMat - p
    (68) eMat -> . p
    (88) expBool -> . or ? expBool : expBool
    (89) expBool -> . or
    (84) expString -> . expString + STRING
    (85) expString -> . STRING
    (86) expString -> . varYVals
    (87) expString -> . funcString
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (20) funcReturn -> . funcInt
    (21) funcReturn -> . funcString
    (22) funcReturn -> . funcBool
    (46) reg -> . { campos }
    (69) p -> . p * exp
    (70) p -> . p / exp
    (71) p -> . p % exp
    (72) p -> . exp
    (90) or -> . or OR and
    (91) or -> . and
    (25) funcString -> . CAPITALIZAR ( expString )
    (43) vecVal -> . ID m
    (23) funcInt -> . MULTIESCALAR ( vec , eMat , param )
    (24) funcInt -> . LENGTH ( vec )
    (26) funcBool -> . COLINEALES ( vec , vec )
    (73) exp -> . exp ^ iSing
    (74) exp -> . iSing
    (92) and -> . and AND eq
    (93) and -> . eq
    (75) iSing -> . - paren
    (76) iSing -> . + paren
    (77) iSing -> . paren
    (94) eq -> . eq EQEQ tBool
    (95) eq -> . eq DISTINTO tBool
    (96) eq -> . mayor
    (78) paren -> . ( eMat )
    (79) paren -> . INT
    (80) paren -> . varYVals
    (81) paren -> . FLOAT
    (82) paren -> . varsOps
    (83) paren -> . funcInt
    (97) mayor -> . tCompare > tCompare
    (98) mayor -> . menor
    (49) varsOps -> . MENOSMENOS sMM
    (50) varsOps -> . MASMAS sMM
    (51) varsOps -> . sMM
    (52) varsOps -> . MENOSMENOS varYVals
    (53) varsOps -> . MASMAS varYVals
    (107) tCompare -> . eMat
    (108) tCompare -> . varsOps
    (109) tCompare -> . varYVals
    (99) menor -> . tCompare < tCompare
    (100) menor -> . not
    (54) sMM -> . varYVals MASMAS
    (55) sMM -> . varYVals MENOSMENOS
    (101) not -> . NOT not
    (102) not -> . tBool
    (103) tBool -> . ( expBool )
    (104) tBool -> . BOOL
    (105) tBool -> . varYVals
    (106) tBool -> . funcBool

    ID              shift and go to state 108
    STRING          shift and go to state 95
    {               shift and go to state 101
    CAPITALIZAR     shift and go to state 24
    MULTIESCALAR    shift and go to state 22
    LENGTH          shift and go to state 25
    COLINEALES      shift and go to state 14
    -               shift and go to state 73
    +               shift and go to state 72
    (               shift and go to state 92
    INT             shift and go to state 79
    FLOAT           shift and go to state 80
    MENOSMENOS      shift and go to state 30
    MASMAS          shift and go to state 27
    NOT             shift and go to state 85
    BOOL            shift and go to state 74

    and                            shift and go to state 64
    funcBool                       shift and go to state 89
    funcInt                        shift and go to state 90
    menor                          shift and go to state 67
    eq                             shift and go to state 68
    vecVal                         shift and go to state 9
    eMat                           shift and go to state 91
    mayor                          shift and go to state 69
    sMM                            shift and go to state 12
    paren                          shift and go to state 77
    reg                            shift and go to state 93
    varsOps                        shift and go to state 94
    expString                      shift and go to state 96
    tCompare                       shift and go to state 76
    not                            shift and go to state 78
    varAsig                        shift and go to state 111
    funcString                     shift and go to state 98
    funcReturn                     shift and go to state 99
    valores                        shift and go to state 112
    p                              shift and go to state 82
    iSing                          shift and go to state 75
    exp                            shift and go to state 84
    tBool                          shift and go to state 86
    varYVals                       shift and go to state 102
    or                             shift and go to state 81
    expBool                        shift and go to state 103

state 44

    (43) vecVal -> ID m .

    MASMAS          reduce using rule 43 (vecVal -> ID m .)
    MENOSMENOS      reduce using rule 43 (vecVal -> ID m .)
    >               reduce using rule 43 (vecVal -> ID m .)
    <               reduce using rule 43 (vecVal -> ID m .)
    EQEQ            reduce using rule 43 (vecVal -> ID m .)
    DISTINTO        reduce using rule 43 (vecVal -> ID m .)
    AND             reduce using rule 43 (vecVal -> ID m .)
    ?               reduce using rule 43 (vecVal -> ID m .)
    OR              reduce using rule 43 (vecVal -> ID m .)
    )               reduce using rule 43 (vecVal -> ID m .)
    ^               reduce using rule 43 (vecVal -> ID m .)
    *               reduce using rule 43 (vecVal -> ID m .)
    /               reduce using rule 43 (vecVal -> ID m .)
    %               reduce using rule 43 (vecVal -> ID m .)
    +               reduce using rule 43 (vecVal -> ID m .)
    -               reduce using rule 43 (vecVal -> ID m .)
    ;               reduce using rule 43 (vecVal -> ID m .)
    }               reduce using rule 43 (vecVal -> ID m .)
    :               reduce using rule 43 (vecVal -> ID m .)
    ,               reduce using rule 43 (vecVal -> ID m .)
    ]               reduce using rule 43 (vecVal -> ID m .)


state 45

    (58) varAsig -> ID MULEQ . varAsig
    (63) varAsig -> ID MULEQ . valores
    (56) varAsig -> . ID MENOSEQ varAsig
    (57) varAsig -> . ID MASEQ varAsig
    (58) varAsig -> . ID MULEQ varAsig
    (59) varAsig -> . ID DIVEQ varAsig
    (60) varAsig -> . ID = varAsig
    (61) varAsig -> . ID MASEQ valores
    (62) varAsig -> . ID MENOSEQ valores
    (63) varAsig -> . ID MULEQ valores
    (64) varAsig -> . ID DIVEQ valores
    (65) varAsig -> . ID = valores
    (34) valores -> . eMat
    (35) valores -> . expBool
    (36) valores -> . expString
    (37) valores -> . varYVals
    (38) valores -> . funcReturn
    (39) valores -> . reg
    (40) valores -> . ID . ID
    (66) eMat -> . eMat + p
    (67) eMat -> . eMat - p
    (68) eMat -> . p
    (88) expBool -> . or ? expBool : expBool
    (89) expBool -> . or
    (84) expString -> . expString + STRING
    (85) expString -> . STRING
    (86) expString -> . varYVals
    (87) expString -> . funcString
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (20) funcReturn -> . funcInt
    (21) funcReturn -> . funcString
    (22) funcReturn -> . funcBool
    (46) reg -> . { campos }
    (69) p -> . p * exp
    (70) p -> . p / exp
    (71) p -> . p % exp
    (72) p -> . exp
    (90) or -> . or OR and
    (91) or -> . and
    (25) funcString -> . CAPITALIZAR ( expString )
    (43) vecVal -> . ID m
    (23) funcInt -> . MULTIESCALAR ( vec , eMat , param )
    (24) funcInt -> . LENGTH ( vec )
    (26) funcBool -> . COLINEALES ( vec , vec )
    (73) exp -> . exp ^ iSing
    (74) exp -> . iSing
    (92) and -> . and AND eq
    (93) and -> . eq
    (75) iSing -> . - paren
    (76) iSing -> . + paren
    (77) iSing -> . paren
    (94) eq -> . eq EQEQ tBool
    (95) eq -> . eq DISTINTO tBool
    (96) eq -> . mayor
    (78) paren -> . ( eMat )
    (79) paren -> . INT
    (80) paren -> . varYVals
    (81) paren -> . FLOAT
    (82) paren -> . varsOps
    (83) paren -> . funcInt
    (97) mayor -> . tCompare > tCompare
    (98) mayor -> . menor
    (49) varsOps -> . MENOSMENOS sMM
    (50) varsOps -> . MASMAS sMM
    (51) varsOps -> . sMM
    (52) varsOps -> . MENOSMENOS varYVals
    (53) varsOps -> . MASMAS varYVals
    (107) tCompare -> . eMat
    (108) tCompare -> . varsOps
    (109) tCompare -> . varYVals
    (99) menor -> . tCompare < tCompare
    (100) menor -> . not
    (54) sMM -> . varYVals MASMAS
    (55) sMM -> . varYVals MENOSMENOS
    (101) not -> . NOT not
    (102) not -> . tBool
    (103) tBool -> . ( expBool )
    (104) tBool -> . BOOL
    (105) tBool -> . varYVals
    (106) tBool -> . funcBool

    ID              shift and go to state 108
    STRING          shift and go to state 95
    {               shift and go to state 101
    CAPITALIZAR     shift and go to state 24
    MULTIESCALAR    shift and go to state 22
    LENGTH          shift and go to state 25
    COLINEALES      shift and go to state 14
    -               shift and go to state 73
    +               shift and go to state 72
    (               shift and go to state 92
    INT             shift and go to state 79
    FLOAT           shift and go to state 80
    MENOSMENOS      shift and go to state 30
    MASMAS          shift and go to state 27
    NOT             shift and go to state 85
    BOOL            shift and go to state 74

    and                            shift and go to state 64
    funcBool                       shift and go to state 89
    funcInt                        shift and go to state 90
    menor                          shift and go to state 67
    eq                             shift and go to state 68
    vecVal                         shift and go to state 9
    eMat                           shift and go to state 91
    mayor                          shift and go to state 69
    sMM                            shift and go to state 12
    paren                          shift and go to state 77
    reg                            shift and go to state 93
    varsOps                        shift and go to state 94
    expString                      shift and go to state 96
    tCompare                       shift and go to state 76
    not                            shift and go to state 78
    varAsig                        shift and go to state 113
    funcString                     shift and go to state 98
    funcReturn                     shift and go to state 99
    valores                        shift and go to state 114
    p                              shift and go to state 82
    iSing                          shift and go to state 75
    exp                            shift and go to state 84
    tBool                          shift and go to state 86
    varYVals                       shift and go to state 102
    or                             shift and go to state 81
    expBool                        shift and go to state 103

state 46

    (44) m -> [ . INT ]
    (45) m -> [ . INT ] m

    INT             shift and go to state 115


state 47

    (60) varAsig -> ID = . varAsig
    (65) varAsig -> ID = . valores
    (56) varAsig -> . ID MENOSEQ varAsig
    (57) varAsig -> . ID MASEQ varAsig
    (58) varAsig -> . ID MULEQ varAsig
    (59) varAsig -> . ID DIVEQ varAsig
    (60) varAsig -> . ID = varAsig
    (61) varAsig -> . ID MASEQ valores
    (62) varAsig -> . ID MENOSEQ valores
    (63) varAsig -> . ID MULEQ valores
    (64) varAsig -> . ID DIVEQ valores
    (65) varAsig -> . ID = valores
    (34) valores -> . eMat
    (35) valores -> . expBool
    (36) valores -> . expString
    (37) valores -> . varYVals
    (38) valores -> . funcReturn
    (39) valores -> . reg
    (40) valores -> . ID . ID
    (66) eMat -> . eMat + p
    (67) eMat -> . eMat - p
    (68) eMat -> . p
    (88) expBool -> . or ? expBool : expBool
    (89) expBool -> . or
    (84) expString -> . expString + STRING
    (85) expString -> . STRING
    (86) expString -> . varYVals
    (87) expString -> . funcString
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (20) funcReturn -> . funcInt
    (21) funcReturn -> . funcString
    (22) funcReturn -> . funcBool
    (46) reg -> . { campos }
    (69) p -> . p * exp
    (70) p -> . p / exp
    (71) p -> . p % exp
    (72) p -> . exp
    (90) or -> . or OR and
    (91) or -> . and
    (25) funcString -> . CAPITALIZAR ( expString )
    (43) vecVal -> . ID m
    (23) funcInt -> . MULTIESCALAR ( vec , eMat , param )
    (24) funcInt -> . LENGTH ( vec )
    (26) funcBool -> . COLINEALES ( vec , vec )
    (73) exp -> . exp ^ iSing
    (74) exp -> . iSing
    (92) and -> . and AND eq
    (93) and -> . eq
    (75) iSing -> . - paren
    (76) iSing -> . + paren
    (77) iSing -> . paren
    (94) eq -> . eq EQEQ tBool
    (95) eq -> . eq DISTINTO tBool
    (96) eq -> . mayor
    (78) paren -> . ( eMat )
    (79) paren -> . INT
    (80) paren -> . varYVals
    (81) paren -> . FLOAT
    (82) paren -> . varsOps
    (83) paren -> . funcInt
    (97) mayor -> . tCompare > tCompare
    (98) mayor -> . menor
    (49) varsOps -> . MENOSMENOS sMM
    (50) varsOps -> . MASMAS sMM
    (51) varsOps -> . sMM
    (52) varsOps -> . MENOSMENOS varYVals
    (53) varsOps -> . MASMAS varYVals
    (107) tCompare -> . eMat
    (108) tCompare -> . varsOps
    (109) tCompare -> . varYVals
    (99) menor -> . tCompare < tCompare
    (100) menor -> . not
    (54) sMM -> . varYVals MASMAS
    (55) sMM -> . varYVals MENOSMENOS
    (101) not -> . NOT not
    (102) not -> . tBool
    (103) tBool -> . ( expBool )
    (104) tBool -> . BOOL
    (105) tBool -> . varYVals
    (106) tBool -> . funcBool

    ID              shift and go to state 108
    STRING          shift and go to state 95
    {               shift and go to state 101
    CAPITALIZAR     shift and go to state 24
    MULTIESCALAR    shift and go to state 22
    LENGTH          shift and go to state 25
    COLINEALES      shift and go to state 14
    -               shift and go to state 73
    +               shift and go to state 72
    (               shift and go to state 92
    INT             shift and go to state 79
    FLOAT           shift and go to state 80
    MENOSMENOS      shift and go to state 30
    MASMAS          shift and go to state 27
    NOT             shift and go to state 85
    BOOL            shift and go to state 74

    and                            shift and go to state 64
    funcBool                       shift and go to state 89
    funcInt                        shift and go to state 90
    menor                          shift and go to state 67
    eq                             shift and go to state 68
    vecVal                         shift and go to state 9
    eMat                           shift and go to state 91
    mayor                          shift and go to state 69
    sMM                            shift and go to state 12
    paren                          shift and go to state 77
    reg                            shift and go to state 93
    varsOps                        shift and go to state 94
    expString                      shift and go to state 96
    tCompare                       shift and go to state 76
    not                            shift and go to state 78
    varAsig                        shift and go to state 116
    funcString                     shift and go to state 98
    funcReturn                     shift and go to state 99
    valores                        shift and go to state 117
    p                              shift and go to state 82
    iSing                          shift and go to state 75
    exp                            shift and go to state 84
    tBool                          shift and go to state 86
    varYVals                       shift and go to state 102
    or                             shift and go to state 81
    expBool                        shift and go to state 103

state 48

    (59) varAsig -> ID DIVEQ . varAsig
    (64) varAsig -> ID DIVEQ . valores
    (56) varAsig -> . ID MENOSEQ varAsig
    (57) varAsig -> . ID MASEQ varAsig
    (58) varAsig -> . ID MULEQ varAsig
    (59) varAsig -> . ID DIVEQ varAsig
    (60) varAsig -> . ID = varAsig
    (61) varAsig -> . ID MASEQ valores
    (62) varAsig -> . ID MENOSEQ valores
    (63) varAsig -> . ID MULEQ valores
    (64) varAsig -> . ID DIVEQ valores
    (65) varAsig -> . ID = valores
    (34) valores -> . eMat
    (35) valores -> . expBool
    (36) valores -> . expString
    (37) valores -> . varYVals
    (38) valores -> . funcReturn
    (39) valores -> . reg
    (40) valores -> . ID . ID
    (66) eMat -> . eMat + p
    (67) eMat -> . eMat - p
    (68) eMat -> . p
    (88) expBool -> . or ? expBool : expBool
    (89) expBool -> . or
    (84) expString -> . expString + STRING
    (85) expString -> . STRING
    (86) expString -> . varYVals
    (87) expString -> . funcString
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (20) funcReturn -> . funcInt
    (21) funcReturn -> . funcString
    (22) funcReturn -> . funcBool
    (46) reg -> . { campos }
    (69) p -> . p * exp
    (70) p -> . p / exp
    (71) p -> . p % exp
    (72) p -> . exp
    (90) or -> . or OR and
    (91) or -> . and
    (25) funcString -> . CAPITALIZAR ( expString )
    (43) vecVal -> . ID m
    (23) funcInt -> . MULTIESCALAR ( vec , eMat , param )
    (24) funcInt -> . LENGTH ( vec )
    (26) funcBool -> . COLINEALES ( vec , vec )
    (73) exp -> . exp ^ iSing
    (74) exp -> . iSing
    (92) and -> . and AND eq
    (93) and -> . eq
    (75) iSing -> . - paren
    (76) iSing -> . + paren
    (77) iSing -> . paren
    (94) eq -> . eq EQEQ tBool
    (95) eq -> . eq DISTINTO tBool
    (96) eq -> . mayor
    (78) paren -> . ( eMat )
    (79) paren -> . INT
    (80) paren -> . varYVals
    (81) paren -> . FLOAT
    (82) paren -> . varsOps
    (83) paren -> . funcInt
    (97) mayor -> . tCompare > tCompare
    (98) mayor -> . menor
    (49) varsOps -> . MENOSMENOS sMM
    (50) varsOps -> . MASMAS sMM
    (51) varsOps -> . sMM
    (52) varsOps -> . MENOSMENOS varYVals
    (53) varsOps -> . MASMAS varYVals
    (107) tCompare -> . eMat
    (108) tCompare -> . varsOps
    (109) tCompare -> . varYVals
    (99) menor -> . tCompare < tCompare
    (100) menor -> . not
    (54) sMM -> . varYVals MASMAS
    (55) sMM -> . varYVals MENOSMENOS
    (101) not -> . NOT not
    (102) not -> . tBool
    (103) tBool -> . ( expBool )
    (104) tBool -> . BOOL
    (105) tBool -> . varYVals
    (106) tBool -> . funcBool

    ID              shift and go to state 108
    STRING          shift and go to state 95
    {               shift and go to state 101
    CAPITALIZAR     shift and go to state 24
    MULTIESCALAR    shift and go to state 22
    LENGTH          shift and go to state 25
    COLINEALES      shift and go to state 14
    -               shift and go to state 73
    +               shift and go to state 72
    (               shift and go to state 92
    INT             shift and go to state 79
    FLOAT           shift and go to state 80
    MENOSMENOS      shift and go to state 30
    MASMAS          shift and go to state 27
    NOT             shift and go to state 85
    BOOL            shift and go to state 74

    and                            shift and go to state 64
    funcBool                       shift and go to state 89
    funcInt                        shift and go to state 90
    menor                          shift and go to state 67
    eq                             shift and go to state 68
    vecVal                         shift and go to state 9
    eMat                           shift and go to state 91
    mayor                          shift and go to state 69
    sMM                            shift and go to state 12
    paren                          shift and go to state 77
    reg                            shift and go to state 93
    varsOps                        shift and go to state 94
    expString                      shift and go to state 96
    tCompare                       shift and go to state 76
    not                            shift and go to state 78
    varAsig                        shift and go to state 118
    funcString                     shift and go to state 98
    funcReturn                     shift and go to state 99
    valores                        shift and go to state 119
    p                              shift and go to state 82
    iSing                          shift and go to state 75
    exp                            shift and go to state 84
    tBool                          shift and go to state 86
    varYVals                       shift and go to state 102
    or                             shift and go to state 81
    expBool                        shift and go to state 103

state 49

    (13) if -> IF ( . expBool ) THEN bloque else
    (88) expBool -> . or ? expBool : expBool
    (89) expBool -> . or
    (90) or -> . or OR and
    (91) or -> . and
    (92) and -> . and AND eq
    (93) and -> . eq
    (94) eq -> . eq EQEQ tBool
    (95) eq -> . eq DISTINTO tBool
    (96) eq -> . mayor
    (97) mayor -> . tCompare > tCompare
    (98) mayor -> . menor
    (107) tCompare -> . eMat
    (108) tCompare -> . varsOps
    (109) tCompare -> . varYVals
    (99) menor -> . tCompare < tCompare
    (100) menor -> . not
    (66) eMat -> . eMat + p
    (67) eMat -> . eMat - p
    (68) eMat -> . p
    (49) varsOps -> . MENOSMENOS sMM
    (50) varsOps -> . MASMAS sMM
    (51) varsOps -> . sMM
    (52) varsOps -> . MENOSMENOS varYVals
    (53) varsOps -> . MASMAS varYVals
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (101) not -> . NOT not
    (102) not -> . tBool
    (69) p -> . p * exp
    (70) p -> . p / exp
    (71) p -> . p % exp
    (72) p -> . exp
    (54) sMM -> . varYVals MASMAS
    (55) sMM -> . varYVals MENOSMENOS
    (43) vecVal -> . ID m
    (103) tBool -> . ( expBool )
    (104) tBool -> . BOOL
    (105) tBool -> . varYVals
    (106) tBool -> . funcBool
    (73) exp -> . exp ^ iSing
    (74) exp -> . iSing
    (26) funcBool -> . COLINEALES ( vec , vec )
    (75) iSing -> . - paren
    (76) iSing -> . + paren
    (77) iSing -> . paren
    (78) paren -> . ( eMat )
    (79) paren -> . INT
    (80) paren -> . varYVals
    (81) paren -> . FLOAT
    (82) paren -> . varsOps
    (83) paren -> . funcInt
    (23) funcInt -> . MULTIESCALAR ( vec , eMat , param )
    (24) funcInt -> . LENGTH ( vec )

    MENOSMENOS      shift and go to state 30
    MASMAS          shift and go to state 27
    ID              shift and go to state 56
    NOT             shift and go to state 85
    (               shift and go to state 71
    BOOL            shift and go to state 74
    COLINEALES      shift and go to state 14
    -               shift and go to state 73
    +               shift and go to state 72
    INT             shift and go to state 79
    FLOAT           shift and go to state 80
    MULTIESCALAR    shift and go to state 22
    LENGTH          shift and go to state 25

    and                            shift and go to state 64
    funcBool                       shift and go to state 65
    funcInt                        shift and go to state 66
    menor                          shift and go to state 67
    eq                             shift and go to state 68
    mayor                          shift and go to state 69
    eMat                           shift and go to state 70
    vecVal                         shift and go to state 9
    sMM                            shift and go to state 12
    paren                          shift and go to state 77
    varsOps                        shift and go to state 83
    tCompare                       shift and go to state 76
    not                            shift and go to state 78
    p                              shift and go to state 82
    iSing                          shift and go to state 75
    exp                            shift and go to state 84
    tBool                          shift and go to state 86
    varYVals                       shift and go to state 87
    or                             shift and go to state 81
    expBool                        shift and go to state 120

state 50

    (6) sentencia -> varAsig ; .

    RETURN          reduce using rule 6 (sentencia -> varAsig ; .)
    MENOSMENOS      reduce using rule 6 (sentencia -> varAsig ; .)
    MASMAS          reduce using rule 6 (sentencia -> varAsig ; .)
    ID              reduce using rule 6 (sentencia -> varAsig ; .)
    IF              reduce using rule 6 (sentencia -> varAsig ; .)
    WHILE           reduce using rule 6 (sentencia -> varAsig ; .)
    DO              reduce using rule 6 (sentencia -> varAsig ; .)
    FOR             reduce using rule 6 (sentencia -> varAsig ; .)
    PRINT           reduce using rule 6 (sentencia -> varAsig ; .)
    MULTIESCALAR    reduce using rule 6 (sentencia -> varAsig ; .)
    LENGTH          reduce using rule 6 (sentencia -> varAsig ; .)
    CAPITALIZAR     reduce using rule 6 (sentencia -> varAsig ; .)
    COLINEALES      reduce using rule 6 (sentencia -> varAsig ; .)
    $end            reduce using rule 6 (sentencia -> varAsig ; .)
    }               reduce using rule 6 (sentencia -> varAsig ; .)
    ELSE            reduce using rule 6 (sentencia -> varAsig ; .)


state 51

    (23) funcInt -> MULTIESCALAR ( . vec , eMat , param )
    (31) vec -> . ID = [ elem ]

    ID              shift and go to state 105

    vec                            shift and go to state 121

state 52

    (25) funcString -> CAPITALIZAR ( . expString )
    (84) expString -> . expString + STRING
    (85) expString -> . STRING
    (86) expString -> . varYVals
    (87) expString -> . funcString
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (25) funcString -> . CAPITALIZAR ( expString )
    (43) vecVal -> . ID m

    STRING          shift and go to state 95
    ID              shift and go to state 56
    CAPITALIZAR     shift and go to state 24

    funcString                     shift and go to state 123
    varYVals                       shift and go to state 124
    vecVal                         shift and go to state 9
    expString                      shift and go to state 122

state 53

    (24) funcInt -> LENGTH ( . vec )
    (31) vec -> . ID = [ elem ]

    ID              shift and go to state 105

    vec                            shift and go to state 125

state 54

    (50) varsOps -> MASMAS sMM .

    ^               reduce using rule 50 (varsOps -> MASMAS sMM .)
    *               reduce using rule 50 (varsOps -> MASMAS sMM .)
    /               reduce using rule 50 (varsOps -> MASMAS sMM .)
    %               reduce using rule 50 (varsOps -> MASMAS sMM .)
    )               reduce using rule 50 (varsOps -> MASMAS sMM .)
    +               reduce using rule 50 (varsOps -> MASMAS sMM .)
    -               reduce using rule 50 (varsOps -> MASMAS sMM .)
    ,               reduce using rule 50 (varsOps -> MASMAS sMM .)
    ]               reduce using rule 50 (varsOps -> MASMAS sMM .)
    >               reduce using rule 50 (varsOps -> MASMAS sMM .)
    <               reduce using rule 50 (varsOps -> MASMAS sMM .)
    ;               reduce using rule 50 (varsOps -> MASMAS sMM .)
    }               reduce using rule 50 (varsOps -> MASMAS sMM .)
    EQEQ            reduce using rule 50 (varsOps -> MASMAS sMM .)
    DISTINTO        reduce using rule 50 (varsOps -> MASMAS sMM .)
    AND             reduce using rule 50 (varsOps -> MASMAS sMM .)
    ?               reduce using rule 50 (varsOps -> MASMAS sMM .)
    OR              reduce using rule 50 (varsOps -> MASMAS sMM .)
    :               reduce using rule 50 (varsOps -> MASMAS sMM .)


state 55

    (53) varsOps -> MASMAS varYVals .
    (54) sMM -> varYVals . MASMAS
    (55) sMM -> varYVals . MENOSMENOS

    ^               reduce using rule 53 (varsOps -> MASMAS varYVals .)
    *               reduce using rule 53 (varsOps -> MASMAS varYVals .)
    /               reduce using rule 53 (varsOps -> MASMAS varYVals .)
    %               reduce using rule 53 (varsOps -> MASMAS varYVals .)
    )               reduce using rule 53 (varsOps -> MASMAS varYVals .)
    +               reduce using rule 53 (varsOps -> MASMAS varYVals .)
    -               reduce using rule 53 (varsOps -> MASMAS varYVals .)
    ,               reduce using rule 53 (varsOps -> MASMAS varYVals .)
    ]               reduce using rule 53 (varsOps -> MASMAS varYVals .)
    >               reduce using rule 53 (varsOps -> MASMAS varYVals .)
    <               reduce using rule 53 (varsOps -> MASMAS varYVals .)
    ;               reduce using rule 53 (varsOps -> MASMAS varYVals .)
    }               reduce using rule 53 (varsOps -> MASMAS varYVals .)
    EQEQ            reduce using rule 53 (varsOps -> MASMAS varYVals .)
    DISTINTO        reduce using rule 53 (varsOps -> MASMAS varYVals .)
    AND             reduce using rule 53 (varsOps -> MASMAS varYVals .)
    ?               reduce using rule 53 (varsOps -> MASMAS varYVals .)
    OR              reduce using rule 53 (varsOps -> MASMAS varYVals .)
    :               reduce using rule 53 (varsOps -> MASMAS varYVals .)
    MASMAS          shift and go to state 58
    MENOSMENOS      shift and go to state 59


state 56

    (41) varYVals -> ID .
    (43) vecVal -> ID . m
    (44) m -> . [ INT ]
    (45) m -> . [ INT ] m

    MASMAS          reduce using rule 41 (varYVals -> ID .)
    MENOSMENOS      reduce using rule 41 (varYVals -> ID .)
    ^               reduce using rule 41 (varYVals -> ID .)
    *               reduce using rule 41 (varYVals -> ID .)
    /               reduce using rule 41 (varYVals -> ID .)
    %               reduce using rule 41 (varYVals -> ID .)
    )               reduce using rule 41 (varYVals -> ID .)
    +               reduce using rule 41 (varYVals -> ID .)
    -               reduce using rule 41 (varYVals -> ID .)
    >               reduce using rule 41 (varYVals -> ID .)
    <               reduce using rule 41 (varYVals -> ID .)
    EQEQ            reduce using rule 41 (varYVals -> ID .)
    DISTINTO        reduce using rule 41 (varYVals -> ID .)
    AND             reduce using rule 41 (varYVals -> ID .)
    ?               reduce using rule 41 (varYVals -> ID .)
    OR              reduce using rule 41 (varYVals -> ID .)
    :               reduce using rule 41 (varYVals -> ID .)
    ;               reduce using rule 41 (varYVals -> ID .)
    }               reduce using rule 41 (varYVals -> ID .)
    ,               reduce using rule 41 (varYVals -> ID .)
    ]               reduce using rule 41 (varYVals -> ID .)
    [               shift and go to state 46

    m                              shift and go to state 44

state 57

    (4) sentencia -> varsOps ; .

    RETURN          reduce using rule 4 (sentencia -> varsOps ; .)
    MENOSMENOS      reduce using rule 4 (sentencia -> varsOps ; .)
    MASMAS          reduce using rule 4 (sentencia -> varsOps ; .)
    ID              reduce using rule 4 (sentencia -> varsOps ; .)
    IF              reduce using rule 4 (sentencia -> varsOps ; .)
    WHILE           reduce using rule 4 (sentencia -> varsOps ; .)
    DO              reduce using rule 4 (sentencia -> varsOps ; .)
    FOR             reduce using rule 4 (sentencia -> varsOps ; .)
    PRINT           reduce using rule 4 (sentencia -> varsOps ; .)
    MULTIESCALAR    reduce using rule 4 (sentencia -> varsOps ; .)
    LENGTH          reduce using rule 4 (sentencia -> varsOps ; .)
    CAPITALIZAR     reduce using rule 4 (sentencia -> varsOps ; .)
    COLINEALES      reduce using rule 4 (sentencia -> varsOps ; .)
    $end            reduce using rule 4 (sentencia -> varsOps ; .)
    }               reduce using rule 4 (sentencia -> varsOps ; .)
    ELSE            reduce using rule 4 (sentencia -> varsOps ; .)


state 58

    (54) sMM -> varYVals MASMAS .

    >               reduce using rule 54 (sMM -> varYVals MASMAS .)
    <               reduce using rule 54 (sMM -> varYVals MASMAS .)
    ^               reduce using rule 54 (sMM -> varYVals MASMAS .)
    *               reduce using rule 54 (sMM -> varYVals MASMAS .)
    /               reduce using rule 54 (sMM -> varYVals MASMAS .)
    %               reduce using rule 54 (sMM -> varYVals MASMAS .)
    +               reduce using rule 54 (sMM -> varYVals MASMAS .)
    -               reduce using rule 54 (sMM -> varYVals MASMAS .)
    ;               reduce using rule 54 (sMM -> varYVals MASMAS .)
    )               reduce using rule 54 (sMM -> varYVals MASMAS .)
    }               reduce using rule 54 (sMM -> varYVals MASMAS .)
    EQEQ            reduce using rule 54 (sMM -> varYVals MASMAS .)
    DISTINTO        reduce using rule 54 (sMM -> varYVals MASMAS .)
    AND             reduce using rule 54 (sMM -> varYVals MASMAS .)
    ?               reduce using rule 54 (sMM -> varYVals MASMAS .)
    OR              reduce using rule 54 (sMM -> varYVals MASMAS .)
    :               reduce using rule 54 (sMM -> varYVals MASMAS .)
    ,               reduce using rule 54 (sMM -> varYVals MASMAS .)
    ]               reduce using rule 54 (sMM -> varYVals MASMAS .)


state 59

    (55) sMM -> varYVals MENOSMENOS .

    >               reduce using rule 55 (sMM -> varYVals MENOSMENOS .)
    <               reduce using rule 55 (sMM -> varYVals MENOSMENOS .)
    ^               reduce using rule 55 (sMM -> varYVals MENOSMENOS .)
    *               reduce using rule 55 (sMM -> varYVals MENOSMENOS .)
    /               reduce using rule 55 (sMM -> varYVals MENOSMENOS .)
    %               reduce using rule 55 (sMM -> varYVals MENOSMENOS .)
    +               reduce using rule 55 (sMM -> varYVals MENOSMENOS .)
    -               reduce using rule 55 (sMM -> varYVals MENOSMENOS .)
    ;               reduce using rule 55 (sMM -> varYVals MENOSMENOS .)
    )               reduce using rule 55 (sMM -> varYVals MENOSMENOS .)
    }               reduce using rule 55 (sMM -> varYVals MENOSMENOS .)
    EQEQ            reduce using rule 55 (sMM -> varYVals MENOSMENOS .)
    DISTINTO        reduce using rule 55 (sMM -> varYVals MENOSMENOS .)
    AND             reduce using rule 55 (sMM -> varYVals MENOSMENOS .)
    ?               reduce using rule 55 (sMM -> varYVals MENOSMENOS .)
    OR              reduce using rule 55 (sMM -> varYVals MENOSMENOS .)
    :               reduce using rule 55 (sMM -> varYVals MENOSMENOS .)
    ,               reduce using rule 55 (sMM -> varYVals MENOSMENOS .)
    ]               reduce using rule 55 (sMM -> varYVals MENOSMENOS .)


state 60

    (49) varsOps -> MENOSMENOS sMM .

    ^               reduce using rule 49 (varsOps -> MENOSMENOS sMM .)
    *               reduce using rule 49 (varsOps -> MENOSMENOS sMM .)
    /               reduce using rule 49 (varsOps -> MENOSMENOS sMM .)
    %               reduce using rule 49 (varsOps -> MENOSMENOS sMM .)
    )               reduce using rule 49 (varsOps -> MENOSMENOS sMM .)
    +               reduce using rule 49 (varsOps -> MENOSMENOS sMM .)
    -               reduce using rule 49 (varsOps -> MENOSMENOS sMM .)
    ,               reduce using rule 49 (varsOps -> MENOSMENOS sMM .)
    ]               reduce using rule 49 (varsOps -> MENOSMENOS sMM .)
    >               reduce using rule 49 (varsOps -> MENOSMENOS sMM .)
    <               reduce using rule 49 (varsOps -> MENOSMENOS sMM .)
    ;               reduce using rule 49 (varsOps -> MENOSMENOS sMM .)
    }               reduce using rule 49 (varsOps -> MENOSMENOS sMM .)
    EQEQ            reduce using rule 49 (varsOps -> MENOSMENOS sMM .)
    DISTINTO        reduce using rule 49 (varsOps -> MENOSMENOS sMM .)
    AND             reduce using rule 49 (varsOps -> MENOSMENOS sMM .)
    ?               reduce using rule 49 (varsOps -> MENOSMENOS sMM .)
    OR              reduce using rule 49 (varsOps -> MENOSMENOS sMM .)
    :               reduce using rule 49 (varsOps -> MENOSMENOS sMM .)


state 61

    (52) varsOps -> MENOSMENOS varYVals .
    (54) sMM -> varYVals . MASMAS
    (55) sMM -> varYVals . MENOSMENOS

    ^               reduce using rule 52 (varsOps -> MENOSMENOS varYVals .)
    *               reduce using rule 52 (varsOps -> MENOSMENOS varYVals .)
    /               reduce using rule 52 (varsOps -> MENOSMENOS varYVals .)
    %               reduce using rule 52 (varsOps -> MENOSMENOS varYVals .)
    )               reduce using rule 52 (varsOps -> MENOSMENOS varYVals .)
    +               reduce using rule 52 (varsOps -> MENOSMENOS varYVals .)
    -               reduce using rule 52 (varsOps -> MENOSMENOS varYVals .)
    ,               reduce using rule 52 (varsOps -> MENOSMENOS varYVals .)
    ]               reduce using rule 52 (varsOps -> MENOSMENOS varYVals .)
    >               reduce using rule 52 (varsOps -> MENOSMENOS varYVals .)
    <               reduce using rule 52 (varsOps -> MENOSMENOS varYVals .)
    ;               reduce using rule 52 (varsOps -> MENOSMENOS varYVals .)
    }               reduce using rule 52 (varsOps -> MENOSMENOS varYVals .)
    EQEQ            reduce using rule 52 (varsOps -> MENOSMENOS varYVals .)
    DISTINTO        reduce using rule 52 (varsOps -> MENOSMENOS varYVals .)
    AND             reduce using rule 52 (varsOps -> MENOSMENOS varYVals .)
    ?               reduce using rule 52 (varsOps -> MENOSMENOS varYVals .)
    OR              reduce using rule 52 (varsOps -> MENOSMENOS varYVals .)
    :               reduce using rule 52 (varsOps -> MENOSMENOS varYVals .)
    MASMAS          shift and go to state 58
    MENOSMENOS      shift and go to state 59


state 62

    (11) loop -> DO bloque WHILE . ( expBool ) ;

    (               shift and go to state 126


state 63

    (17) bloque -> { g . }

    }               shift and go to state 127


state 64

    (91) or -> and .
    (92) and -> and . AND eq

    ?               reduce using rule 91 (or -> and .)
    OR              reduce using rule 91 (or -> and .)
    ;               reduce using rule 91 (or -> and .)
    )               reduce using rule 91 (or -> and .)
    }               reduce using rule 91 (or -> and .)
    :               reduce using rule 91 (or -> and .)
    ,               reduce using rule 91 (or -> and .)
    ]               reduce using rule 91 (or -> and .)
    AND             shift and go to state 128


state 65

    (106) tBool -> funcBool .

    EQEQ            reduce using rule 106 (tBool -> funcBool .)
    DISTINTO        reduce using rule 106 (tBool -> funcBool .)
    AND             reduce using rule 106 (tBool -> funcBool .)
    ?               reduce using rule 106 (tBool -> funcBool .)
    OR              reduce using rule 106 (tBool -> funcBool .)
    )               reduce using rule 106 (tBool -> funcBool .)
    ;               reduce using rule 106 (tBool -> funcBool .)
    }               reduce using rule 106 (tBool -> funcBool .)
    :               reduce using rule 106 (tBool -> funcBool .)
    ,               reduce using rule 106 (tBool -> funcBool .)
    ]               reduce using rule 106 (tBool -> funcBool .)


state 66

    (83) paren -> funcInt .

    ^               reduce using rule 83 (paren -> funcInt .)
    *               reduce using rule 83 (paren -> funcInt .)
    /               reduce using rule 83 (paren -> funcInt .)
    %               reduce using rule 83 (paren -> funcInt .)
    +               reduce using rule 83 (paren -> funcInt .)
    -               reduce using rule 83 (paren -> funcInt .)
    >               reduce using rule 83 (paren -> funcInt .)
    <               reduce using rule 83 (paren -> funcInt .)
    )               reduce using rule 83 (paren -> funcInt .)
    ;               reduce using rule 83 (paren -> funcInt .)
    }               reduce using rule 83 (paren -> funcInt .)
    EQEQ            reduce using rule 83 (paren -> funcInt .)
    DISTINTO        reduce using rule 83 (paren -> funcInt .)
    AND             reduce using rule 83 (paren -> funcInt .)
    ?               reduce using rule 83 (paren -> funcInt .)
    OR              reduce using rule 83 (paren -> funcInt .)
    :               reduce using rule 83 (paren -> funcInt .)
    ,               reduce using rule 83 (paren -> funcInt .)
    ]               reduce using rule 83 (paren -> funcInt .)


state 67

    (98) mayor -> menor .

    EQEQ            reduce using rule 98 (mayor -> menor .)
    DISTINTO        reduce using rule 98 (mayor -> menor .)
    AND             reduce using rule 98 (mayor -> menor .)
    ?               reduce using rule 98 (mayor -> menor .)
    OR              reduce using rule 98 (mayor -> menor .)
    )               reduce using rule 98 (mayor -> menor .)
    ;               reduce using rule 98 (mayor -> menor .)
    }               reduce using rule 98 (mayor -> menor .)
    :               reduce using rule 98 (mayor -> menor .)
    ,               reduce using rule 98 (mayor -> menor .)
    ]               reduce using rule 98 (mayor -> menor .)


state 68

    (93) and -> eq .
    (94) eq -> eq . EQEQ tBool
    (95) eq -> eq . DISTINTO tBool

    AND             reduce using rule 93 (and -> eq .)
    ?               reduce using rule 93 (and -> eq .)
    OR              reduce using rule 93 (and -> eq .)
    )               reduce using rule 93 (and -> eq .)
    ,               reduce using rule 93 (and -> eq .)
    ]               reduce using rule 93 (and -> eq .)
    }               reduce using rule 93 (and -> eq .)
    ;               reduce using rule 93 (and -> eq .)
    :               reduce using rule 93 (and -> eq .)
    EQEQ            shift and go to state 129
    DISTINTO        shift and go to state 130


state 69

    (96) eq -> mayor .

    EQEQ            reduce using rule 96 (eq -> mayor .)
    DISTINTO        reduce using rule 96 (eq -> mayor .)
    AND             reduce using rule 96 (eq -> mayor .)
    ?               reduce using rule 96 (eq -> mayor .)
    OR              reduce using rule 96 (eq -> mayor .)
    )               reduce using rule 96 (eq -> mayor .)
    ,               reduce using rule 96 (eq -> mayor .)
    ]               reduce using rule 96 (eq -> mayor .)
    ;               reduce using rule 96 (eq -> mayor .)
    }               reduce using rule 96 (eq -> mayor .)
    :               reduce using rule 96 (eq -> mayor .)


state 70

    (107) tCompare -> eMat .
    (66) eMat -> eMat . + p
    (67) eMat -> eMat . - p

    >               reduce using rule 107 (tCompare -> eMat .)
    <               reduce using rule 107 (tCompare -> eMat .)
    EQEQ            reduce using rule 107 (tCompare -> eMat .)
    DISTINTO        reduce using rule 107 (tCompare -> eMat .)
    AND             reduce using rule 107 (tCompare -> eMat .)
    ?               reduce using rule 107 (tCompare -> eMat .)
    OR              reduce using rule 107 (tCompare -> eMat .)
    )               reduce using rule 107 (tCompare -> eMat .)
    ;               reduce using rule 107 (tCompare -> eMat .)
    }               reduce using rule 107 (tCompare -> eMat .)
    :               reduce using rule 107 (tCompare -> eMat .)
    ,               reduce using rule 107 (tCompare -> eMat .)
    ]               reduce using rule 107 (tCompare -> eMat .)
    +               shift and go to state 131
    -               shift and go to state 132


state 71

    (103) tBool -> ( . expBool )
    (78) paren -> ( . eMat )
    (88) expBool -> . or ? expBool : expBool
    (89) expBool -> . or
    (66) eMat -> . eMat + p
    (67) eMat -> . eMat - p
    (68) eMat -> . p
    (90) or -> . or OR and
    (91) or -> . and
    (69) p -> . p * exp
    (70) p -> . p / exp
    (71) p -> . p % exp
    (72) p -> . exp
    (92) and -> . and AND eq
    (93) and -> . eq
    (73) exp -> . exp ^ iSing
    (74) exp -> . iSing
    (94) eq -> . eq EQEQ tBool
    (95) eq -> . eq DISTINTO tBool
    (96) eq -> . mayor
    (75) iSing -> . - paren
    (76) iSing -> . + paren
    (77) iSing -> . paren
    (97) mayor -> . tCompare > tCompare
    (98) mayor -> . menor
    (78) paren -> . ( eMat )
    (79) paren -> . INT
    (80) paren -> . varYVals
    (81) paren -> . FLOAT
    (82) paren -> . varsOps
    (83) paren -> . funcInt
    (107) tCompare -> . eMat
    (108) tCompare -> . varsOps
    (109) tCompare -> . varYVals
    (99) menor -> . tCompare < tCompare
    (100) menor -> . not
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (49) varsOps -> . MENOSMENOS sMM
    (50) varsOps -> . MASMAS sMM
    (51) varsOps -> . sMM
    (52) varsOps -> . MENOSMENOS varYVals
    (53) varsOps -> . MASMAS varYVals
    (23) funcInt -> . MULTIESCALAR ( vec , eMat , param )
    (24) funcInt -> . LENGTH ( vec )
    (101) not -> . NOT not
    (102) not -> . tBool
    (43) vecVal -> . ID m
    (54) sMM -> . varYVals MASMAS
    (55) sMM -> . varYVals MENOSMENOS
    (103) tBool -> . ( expBool )
    (104) tBool -> . BOOL
    (105) tBool -> . varYVals
    (106) tBool -> . funcBool
    (26) funcBool -> . COLINEALES ( vec , vec )

    -               shift and go to state 73
    +               shift and go to state 72
    (               shift and go to state 92
    INT             shift and go to state 79
    FLOAT           shift and go to state 80
    ID              shift and go to state 56
    MENOSMENOS      shift and go to state 30
    MASMAS          shift and go to state 27
    MULTIESCALAR    shift and go to state 22
    LENGTH          shift and go to state 25
    NOT             shift and go to state 85
    BOOL            shift and go to state 74
    COLINEALES      shift and go to state 14

    and                            shift and go to state 64
    funcBool                       shift and go to state 65
    funcInt                        shift and go to state 66
    menor                          shift and go to state 67
    eq                             shift and go to state 68
    mayor                          shift and go to state 69
    eMat                           shift and go to state 133
    vecVal                         shift and go to state 9
    sMM                            shift and go to state 12
    paren                          shift and go to state 77
    varsOps                        shift and go to state 94
    tCompare                       shift and go to state 76
    not                            shift and go to state 78
    p                              shift and go to state 82
    iSing                          shift and go to state 75
    exp                            shift and go to state 84
    tBool                          shift and go to state 86
    varYVals                       shift and go to state 134
    or                             shift and go to state 81
    expBool                        shift and go to state 135

state 72

    (76) iSing -> + . paren
    (78) paren -> . ( eMat )
    (79) paren -> . INT
    (80) paren -> . varYVals
    (81) paren -> . FLOAT
    (82) paren -> . varsOps
    (83) paren -> . funcInt
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (49) varsOps -> . MENOSMENOS sMM
    (50) varsOps -> . MASMAS sMM
    (51) varsOps -> . sMM
    (52) varsOps -> . MENOSMENOS varYVals
    (53) varsOps -> . MASMAS varYVals
    (23) funcInt -> . MULTIESCALAR ( vec , eMat , param )
    (24) funcInt -> . LENGTH ( vec )
    (43) vecVal -> . ID m
    (54) sMM -> . varYVals MASMAS
    (55) sMM -> . varYVals MENOSMENOS

    (               shift and go to state 136
    INT             shift and go to state 79
    FLOAT           shift and go to state 80
    ID              shift and go to state 56
    MENOSMENOS      shift and go to state 30
    MASMAS          shift and go to state 27
    MULTIESCALAR    shift and go to state 22
    LENGTH          shift and go to state 25

    funcInt                        shift and go to state 66
    sMM                            shift and go to state 12
    varsOps                        shift and go to state 137
    paren                          shift and go to state 138
    varYVals                       shift and go to state 139
    vecVal                         shift and go to state 9

state 73

    (75) iSing -> - . paren
    (78) paren -> . ( eMat )
    (79) paren -> . INT
    (80) paren -> . varYVals
    (81) paren -> . FLOAT
    (82) paren -> . varsOps
    (83) paren -> . funcInt
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (49) varsOps -> . MENOSMENOS sMM
    (50) varsOps -> . MASMAS sMM
    (51) varsOps -> . sMM
    (52) varsOps -> . MENOSMENOS varYVals
    (53) varsOps -> . MASMAS varYVals
    (23) funcInt -> . MULTIESCALAR ( vec , eMat , param )
    (24) funcInt -> . LENGTH ( vec )
    (43) vecVal -> . ID m
    (54) sMM -> . varYVals MASMAS
    (55) sMM -> . varYVals MENOSMENOS

    (               shift and go to state 136
    INT             shift and go to state 79
    FLOAT           shift and go to state 80
    ID              shift and go to state 56
    MENOSMENOS      shift and go to state 30
    MASMAS          shift and go to state 27
    MULTIESCALAR    shift and go to state 22
    LENGTH          shift and go to state 25

    funcInt                        shift and go to state 66
    sMM                            shift and go to state 12
    varsOps                        shift and go to state 137
    paren                          shift and go to state 140
    varYVals                       shift and go to state 139
    vecVal                         shift and go to state 9

state 74

    (104) tBool -> BOOL .

    EQEQ            reduce using rule 104 (tBool -> BOOL .)
    DISTINTO        reduce using rule 104 (tBool -> BOOL .)
    AND             reduce using rule 104 (tBool -> BOOL .)
    ?               reduce using rule 104 (tBool -> BOOL .)
    OR              reduce using rule 104 (tBool -> BOOL .)
    )               reduce using rule 104 (tBool -> BOOL .)
    ;               reduce using rule 104 (tBool -> BOOL .)
    }               reduce using rule 104 (tBool -> BOOL .)
    :               reduce using rule 104 (tBool -> BOOL .)
    ,               reduce using rule 104 (tBool -> BOOL .)
    ]               reduce using rule 104 (tBool -> BOOL .)


state 75

    (74) exp -> iSing .

    ^               reduce using rule 74 (exp -> iSing .)
    *               reduce using rule 74 (exp -> iSing .)
    /               reduce using rule 74 (exp -> iSing .)
    %               reduce using rule 74 (exp -> iSing .)
    +               reduce using rule 74 (exp -> iSing .)
    -               reduce using rule 74 (exp -> iSing .)
    >               reduce using rule 74 (exp -> iSing .)
    <               reduce using rule 74 (exp -> iSing .)
    ,               reduce using rule 74 (exp -> iSing .)
    ;               reduce using rule 74 (exp -> iSing .)
    }               reduce using rule 74 (exp -> iSing .)
    EQEQ            reduce using rule 74 (exp -> iSing .)
    DISTINTO        reduce using rule 74 (exp -> iSing .)
    AND             reduce using rule 74 (exp -> iSing .)
    ?               reduce using rule 74 (exp -> iSing .)
    OR              reduce using rule 74 (exp -> iSing .)
    )               reduce using rule 74 (exp -> iSing .)
    :               reduce using rule 74 (exp -> iSing .)
    ]               reduce using rule 74 (exp -> iSing .)


state 76

    (97) mayor -> tCompare . > tCompare
    (99) menor -> tCompare . < tCompare

    >               shift and go to state 142
    <               shift and go to state 141


state 77

    (77) iSing -> paren .

    ^               reduce using rule 77 (iSing -> paren .)
    *               reduce using rule 77 (iSing -> paren .)
    /               reduce using rule 77 (iSing -> paren .)
    %               reduce using rule 77 (iSing -> paren .)
    )               reduce using rule 77 (iSing -> paren .)
    +               reduce using rule 77 (iSing -> paren .)
    -               reduce using rule 77 (iSing -> paren .)
    >               reduce using rule 77 (iSing -> paren .)
    <               reduce using rule 77 (iSing -> paren .)
    ;               reduce using rule 77 (iSing -> paren .)
    }               reduce using rule 77 (iSing -> paren .)
    EQEQ            reduce using rule 77 (iSing -> paren .)
    DISTINTO        reduce using rule 77 (iSing -> paren .)
    AND             reduce using rule 77 (iSing -> paren .)
    ?               reduce using rule 77 (iSing -> paren .)
    OR              reduce using rule 77 (iSing -> paren .)
    :               reduce using rule 77 (iSing -> paren .)
    ,               reduce using rule 77 (iSing -> paren .)
    ]               reduce using rule 77 (iSing -> paren .)


state 78

    (100) menor -> not .

    EQEQ            reduce using rule 100 (menor -> not .)
    DISTINTO        reduce using rule 100 (menor -> not .)
    AND             reduce using rule 100 (menor -> not .)
    ?               reduce using rule 100 (menor -> not .)
    OR              reduce using rule 100 (menor -> not .)
    ,               reduce using rule 100 (menor -> not .)
    ]               reduce using rule 100 (menor -> not .)
    )               reduce using rule 100 (menor -> not .)
    ;               reduce using rule 100 (menor -> not .)
    }               reduce using rule 100 (menor -> not .)
    :               reduce using rule 100 (menor -> not .)


state 79

    (79) paren -> INT .

    ^               reduce using rule 79 (paren -> INT .)
    *               reduce using rule 79 (paren -> INT .)
    /               reduce using rule 79 (paren -> INT .)
    %               reduce using rule 79 (paren -> INT .)
    +               reduce using rule 79 (paren -> INT .)
    -               reduce using rule 79 (paren -> INT .)
    >               reduce using rule 79 (paren -> INT .)
    <               reduce using rule 79 (paren -> INT .)
    )               reduce using rule 79 (paren -> INT .)
    ;               reduce using rule 79 (paren -> INT .)
    }               reduce using rule 79 (paren -> INT .)
    EQEQ            reduce using rule 79 (paren -> INT .)
    DISTINTO        reduce using rule 79 (paren -> INT .)
    AND             reduce using rule 79 (paren -> INT .)
    ?               reduce using rule 79 (paren -> INT .)
    OR              reduce using rule 79 (paren -> INT .)
    :               reduce using rule 79 (paren -> INT .)
    ,               reduce using rule 79 (paren -> INT .)
    ]               reduce using rule 79 (paren -> INT .)


state 80

    (81) paren -> FLOAT .

    ^               reduce using rule 81 (paren -> FLOAT .)
    *               reduce using rule 81 (paren -> FLOAT .)
    /               reduce using rule 81 (paren -> FLOAT .)
    %               reduce using rule 81 (paren -> FLOAT .)
    +               reduce using rule 81 (paren -> FLOAT .)
    -               reduce using rule 81 (paren -> FLOAT .)
    >               reduce using rule 81 (paren -> FLOAT .)
    <               reduce using rule 81 (paren -> FLOAT .)
    )               reduce using rule 81 (paren -> FLOAT .)
    ;               reduce using rule 81 (paren -> FLOAT .)
    }               reduce using rule 81 (paren -> FLOAT .)
    EQEQ            reduce using rule 81 (paren -> FLOAT .)
    DISTINTO        reduce using rule 81 (paren -> FLOAT .)
    AND             reduce using rule 81 (paren -> FLOAT .)
    ?               reduce using rule 81 (paren -> FLOAT .)
    OR              reduce using rule 81 (paren -> FLOAT .)
    :               reduce using rule 81 (paren -> FLOAT .)
    ,               reduce using rule 81 (paren -> FLOAT .)
    ]               reduce using rule 81 (paren -> FLOAT .)


state 81

    (88) expBool -> or . ? expBool : expBool
    (89) expBool -> or .
    (90) or -> or . OR and

    ?               shift and go to state 144
    }               reduce using rule 89 (expBool -> or .)
    )               reduce using rule 89 (expBool -> or .)
    ;               reduce using rule 89 (expBool -> or .)
    :               reduce using rule 89 (expBool -> or .)
    ,               reduce using rule 89 (expBool -> or .)
    ]               reduce using rule 89 (expBool -> or .)
    OR              shift and go to state 143


state 82

    (68) eMat -> p .
    (69) p -> p . * exp
    (70) p -> p . / exp
    (71) p -> p . % exp

    +               reduce using rule 68 (eMat -> p .)
    -               reduce using rule 68 (eMat -> p .)
    ;               reduce using rule 68 (eMat -> p .)
    >               reduce using rule 68 (eMat -> p .)
    <               reduce using rule 68 (eMat -> p .)
    )               reduce using rule 68 (eMat -> p .)
    }               reduce using rule 68 (eMat -> p .)
    EQEQ            reduce using rule 68 (eMat -> p .)
    DISTINTO        reduce using rule 68 (eMat -> p .)
    AND             reduce using rule 68 (eMat -> p .)
    ?               reduce using rule 68 (eMat -> p .)
    OR              reduce using rule 68 (eMat -> p .)
    :               reduce using rule 68 (eMat -> p .)
    ,               reduce using rule 68 (eMat -> p .)
    ]               reduce using rule 68 (eMat -> p .)
    *               shift and go to state 145
    /               shift and go to state 147
    %               shift and go to state 146


state 83

    (108) tCompare -> varsOps .
    (82) paren -> varsOps .

  ! reduce/reduce conflict for > resolved using rule 82 (paren -> varsOps .)
  ! reduce/reduce conflict for < resolved using rule 82 (paren -> varsOps .)
  ! reduce/reduce conflict for EQEQ resolved using rule 82 (paren -> varsOps .)
  ! reduce/reduce conflict for DISTINTO resolved using rule 82 (paren -> varsOps .)
  ! reduce/reduce conflict for AND resolved using rule 82 (paren -> varsOps .)
  ! reduce/reduce conflict for ? resolved using rule 82 (paren -> varsOps .)
  ! reduce/reduce conflict for OR resolved using rule 82 (paren -> varsOps .)
  ! reduce/reduce conflict for ) resolved using rule 82 (paren -> varsOps .)
  ! reduce/reduce conflict for ; resolved using rule 82 (paren -> varsOps .)
  ! reduce/reduce conflict for } resolved using rule 82 (paren -> varsOps .)
  ! reduce/reduce conflict for : resolved using rule 82 (paren -> varsOps .)
  ! reduce/reduce conflict for , resolved using rule 82 (paren -> varsOps .)
  ! reduce/reduce conflict for ] resolved using rule 82 (paren -> varsOps .)
    ^               reduce using rule 82 (paren -> varsOps .)
    *               reduce using rule 82 (paren -> varsOps .)
    /               reduce using rule 82 (paren -> varsOps .)
    %               reduce using rule 82 (paren -> varsOps .)
    +               reduce using rule 82 (paren -> varsOps .)
    -               reduce using rule 82 (paren -> varsOps .)
    >               reduce using rule 82 (paren -> varsOps .)
    <               reduce using rule 82 (paren -> varsOps .)
    EQEQ            reduce using rule 82 (paren -> varsOps .)
    DISTINTO        reduce using rule 82 (paren -> varsOps .)
    AND             reduce using rule 82 (paren -> varsOps .)
    ?               reduce using rule 82 (paren -> varsOps .)
    OR              reduce using rule 82 (paren -> varsOps .)
    )               reduce using rule 82 (paren -> varsOps .)
    ;               reduce using rule 82 (paren -> varsOps .)
    }               reduce using rule 82 (paren -> varsOps .)
    :               reduce using rule 82 (paren -> varsOps .)
    ,               reduce using rule 82 (paren -> varsOps .)
    ]               reduce using rule 82 (paren -> varsOps .)

  ! >               [ reduce using rule 108 (tCompare -> varsOps .) ]
  ! <               [ reduce using rule 108 (tCompare -> varsOps .) ]
  ! EQEQ            [ reduce using rule 108 (tCompare -> varsOps .) ]
  ! DISTINTO        [ reduce using rule 108 (tCompare -> varsOps .) ]
  ! AND             [ reduce using rule 108 (tCompare -> varsOps .) ]
  ! ?               [ reduce using rule 108 (tCompare -> varsOps .) ]
  ! OR              [ reduce using rule 108 (tCompare -> varsOps .) ]
  ! )               [ reduce using rule 108 (tCompare -> varsOps .) ]
  ! ;               [ reduce using rule 108 (tCompare -> varsOps .) ]
  ! }               [ reduce using rule 108 (tCompare -> varsOps .) ]
  ! :               [ reduce using rule 108 (tCompare -> varsOps .) ]
  ! ,               [ reduce using rule 108 (tCompare -> varsOps .) ]
  ! ]               [ reduce using rule 108 (tCompare -> varsOps .) ]


state 84

    (72) p -> exp .
    (73) exp -> exp . ^ iSing

    *               reduce using rule 72 (p -> exp .)
    /               reduce using rule 72 (p -> exp .)
    %               reduce using rule 72 (p -> exp .)
    +               reduce using rule 72 (p -> exp .)
    -               reduce using rule 72 (p -> exp .)
    )               reduce using rule 72 (p -> exp .)
    >               reduce using rule 72 (p -> exp .)
    <               reduce using rule 72 (p -> exp .)
    ;               reduce using rule 72 (p -> exp .)
    }               reduce using rule 72 (p -> exp .)
    EQEQ            reduce using rule 72 (p -> exp .)
    DISTINTO        reduce using rule 72 (p -> exp .)
    AND             reduce using rule 72 (p -> exp .)
    ?               reduce using rule 72 (p -> exp .)
    OR              reduce using rule 72 (p -> exp .)
    :               reduce using rule 72 (p -> exp .)
    ,               reduce using rule 72 (p -> exp .)
    ]               reduce using rule 72 (p -> exp .)
    ^               shift and go to state 148


state 85

    (101) not -> NOT . not
    (101) not -> . NOT not
    (102) not -> . tBool
    (103) tBool -> . ( expBool )
    (104) tBool -> . BOOL
    (105) tBool -> . varYVals
    (106) tBool -> . funcBool
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (26) funcBool -> . COLINEALES ( vec , vec )
    (43) vecVal -> . ID m

    NOT             shift and go to state 85
    (               shift and go to state 149
    BOOL            shift and go to state 74
    ID              shift and go to state 56
    COLINEALES      shift and go to state 14

    funcBool                       shift and go to state 65
    not                            shift and go to state 150
    tBool                          shift and go to state 86
    varYVals                       shift and go to state 151
    vecVal                         shift and go to state 9

state 86

    (102) not -> tBool .

    EQEQ            reduce using rule 102 (not -> tBool .)
    DISTINTO        reduce using rule 102 (not -> tBool .)
    AND             reduce using rule 102 (not -> tBool .)
    ?               reduce using rule 102 (not -> tBool .)
    OR              reduce using rule 102 (not -> tBool .)
    ;               reduce using rule 102 (not -> tBool .)
    )               reduce using rule 102 (not -> tBool .)
    }               reduce using rule 102 (not -> tBool .)
    :               reduce using rule 102 (not -> tBool .)
    ,               reduce using rule 102 (not -> tBool .)
    ]               reduce using rule 102 (not -> tBool .)


state 87

    (109) tCompare -> varYVals .
    (54) sMM -> varYVals . MASMAS
    (55) sMM -> varYVals . MENOSMENOS
    (105) tBool -> varYVals .
    (80) paren -> varYVals .

  ! reduce/reduce conflict for > resolved using rule 80 (paren -> varYVals .)
  ! reduce/reduce conflict for < resolved using rule 80 (paren -> varYVals .)
    MASMAS          shift and go to state 58
    MENOSMENOS      shift and go to state 59
    EQEQ            reduce using rule 105 (tBool -> varYVals .)
    DISTINTO        reduce using rule 105 (tBool -> varYVals .)
    AND             reduce using rule 105 (tBool -> varYVals .)
    ?               reduce using rule 105 (tBool -> varYVals .)
    OR              reduce using rule 105 (tBool -> varYVals .)
    )               reduce using rule 105 (tBool -> varYVals .)
    ;               reduce using rule 105 (tBool -> varYVals .)
    }               reduce using rule 105 (tBool -> varYVals .)
    :               reduce using rule 105 (tBool -> varYVals .)
    ,               reduce using rule 105 (tBool -> varYVals .)
    ]               reduce using rule 105 (tBool -> varYVals .)
    ^               reduce using rule 80 (paren -> varYVals .)
    *               reduce using rule 80 (paren -> varYVals .)
    /               reduce using rule 80 (paren -> varYVals .)
    %               reduce using rule 80 (paren -> varYVals .)
    +               reduce using rule 80 (paren -> varYVals .)
    -               reduce using rule 80 (paren -> varYVals .)
    >               reduce using rule 80 (paren -> varYVals .)
    <               reduce using rule 80 (paren -> varYVals .)

  ! >               [ reduce using rule 109 (tCompare -> varYVals .) ]
  ! <               [ reduce using rule 109 (tCompare -> varYVals .) ]


state 88

    (10) loop -> WHILE ( expBool . ) bloque

    )               shift and go to state 152


state 89

    (22) funcReturn -> funcBool .
    (106) tBool -> funcBool .

  ! reduce/reduce conflict for } resolved using rule 22 (funcReturn -> funcBool .)
  ! reduce/reduce conflict for ; resolved using rule 22 (funcReturn -> funcBool .)
  ! reduce/reduce conflict for ) resolved using rule 22 (funcReturn -> funcBool .)
  ! reduce/reduce conflict for , resolved using rule 22 (funcReturn -> funcBool .)
  ! reduce/reduce conflict for ] resolved using rule 22 (funcReturn -> funcBool .)
    )               reduce using rule 22 (funcReturn -> funcBool .)
    ,               reduce using rule 22 (funcReturn -> funcBool .)
    ]               reduce using rule 22 (funcReturn -> funcBool .)
    }               reduce using rule 22 (funcReturn -> funcBool .)
    ;               reduce using rule 22 (funcReturn -> funcBool .)
    EQEQ            reduce using rule 106 (tBool -> funcBool .)
    DISTINTO        reduce using rule 106 (tBool -> funcBool .)
    AND             reduce using rule 106 (tBool -> funcBool .)
    ?               reduce using rule 106 (tBool -> funcBool .)
    OR              reduce using rule 106 (tBool -> funcBool .)

  ! }               [ reduce using rule 106 (tBool -> funcBool .) ]
  ! ;               [ reduce using rule 106 (tBool -> funcBool .) ]
  ! )               [ reduce using rule 106 (tBool -> funcBool .) ]
  ! ,               [ reduce using rule 106 (tBool -> funcBool .) ]
  ! ]               [ reduce using rule 106 (tBool -> funcBool .) ]


state 90

    (20) funcReturn -> funcInt .
    (83) paren -> funcInt .

  ! reduce/reduce conflict for ; resolved using rule 20 (funcReturn -> funcInt .)
  ! reduce/reduce conflict for } resolved using rule 20 (funcReturn -> funcInt .)
  ! reduce/reduce conflict for , resolved using rule 20 (funcReturn -> funcInt .)
  ! reduce/reduce conflict for ] resolved using rule 20 (funcReturn -> funcInt .)
  ! reduce/reduce conflict for ) resolved using rule 20 (funcReturn -> funcInt .)
    )               reduce using rule 20 (funcReturn -> funcInt .)
    ,               reduce using rule 20 (funcReturn -> funcInt .)
    ]               reduce using rule 20 (funcReturn -> funcInt .)
    }               reduce using rule 20 (funcReturn -> funcInt .)
    ;               reduce using rule 20 (funcReturn -> funcInt .)
    ^               reduce using rule 83 (paren -> funcInt .)
    *               reduce using rule 83 (paren -> funcInt .)
    /               reduce using rule 83 (paren -> funcInt .)
    %               reduce using rule 83 (paren -> funcInt .)
    +               reduce using rule 83 (paren -> funcInt .)
    -               reduce using rule 83 (paren -> funcInt .)
    >               reduce using rule 83 (paren -> funcInt .)
    <               reduce using rule 83 (paren -> funcInt .)

  ! ;               [ reduce using rule 83 (paren -> funcInt .) ]
  ! }               [ reduce using rule 83 (paren -> funcInt .) ]
  ! ,               [ reduce using rule 83 (paren -> funcInt .) ]
  ! ]               [ reduce using rule 83 (paren -> funcInt .) ]
  ! )               [ reduce using rule 83 (paren -> funcInt .) ]


state 91

    (34) valores -> eMat .
    (66) eMat -> eMat . + p
    (67) eMat -> eMat . - p
    (107) tCompare -> eMat .

    ,               reduce using rule 34 (valores -> eMat .)
    ]               reduce using rule 34 (valores -> eMat .)
    }               reduce using rule 34 (valores -> eMat .)
    ;               reduce using rule 34 (valores -> eMat .)
    )               reduce using rule 34 (valores -> eMat .)
    +               shift and go to state 131
    -               shift and go to state 132
    >               reduce using rule 107 (tCompare -> eMat .)
    <               reduce using rule 107 (tCompare -> eMat .)


state 92

    (78) paren -> ( . eMat )
    (103) tBool -> ( . expBool )
    (66) eMat -> . eMat + p
    (67) eMat -> . eMat - p
    (68) eMat -> . p
    (88) expBool -> . or ? expBool : expBool
    (89) expBool -> . or
    (69) p -> . p * exp
    (70) p -> . p / exp
    (71) p -> . p % exp
    (72) p -> . exp
    (90) or -> . or OR and
    (91) or -> . and
    (73) exp -> . exp ^ iSing
    (74) exp -> . iSing
    (92) and -> . and AND eq
    (93) and -> . eq
    (75) iSing -> . - paren
    (76) iSing -> . + paren
    (77) iSing -> . paren
    (94) eq -> . eq EQEQ tBool
    (95) eq -> . eq DISTINTO tBool
    (96) eq -> . mayor
    (78) paren -> . ( eMat )
    (79) paren -> . INT
    (80) paren -> . varYVals
    (81) paren -> . FLOAT
    (82) paren -> . varsOps
    (83) paren -> . funcInt
    (97) mayor -> . tCompare > tCompare
    (98) mayor -> . menor
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (49) varsOps -> . MENOSMENOS sMM
    (50) varsOps -> . MASMAS sMM
    (51) varsOps -> . sMM
    (52) varsOps -> . MENOSMENOS varYVals
    (53) varsOps -> . MASMAS varYVals
    (23) funcInt -> . MULTIESCALAR ( vec , eMat , param )
    (24) funcInt -> . LENGTH ( vec )
    (107) tCompare -> . eMat
    (108) tCompare -> . varsOps
    (109) tCompare -> . varYVals
    (99) menor -> . tCompare < tCompare
    (100) menor -> . not
    (43) vecVal -> . ID m
    (54) sMM -> . varYVals MASMAS
    (55) sMM -> . varYVals MENOSMENOS
    (101) not -> . NOT not
    (102) not -> . tBool
    (103) tBool -> . ( expBool )
    (104) tBool -> . BOOL
    (105) tBool -> . varYVals
    (106) tBool -> . funcBool
    (26) funcBool -> . COLINEALES ( vec , vec )

    -               shift and go to state 73
    +               shift and go to state 72
    (               shift and go to state 92
    INT             shift and go to state 79
    FLOAT           shift and go to state 80
    ID              shift and go to state 56
    MENOSMENOS      shift and go to state 30
    MASMAS          shift and go to state 27
    MULTIESCALAR    shift and go to state 22
    LENGTH          shift and go to state 25
    NOT             shift and go to state 85
    BOOL            shift and go to state 74
    COLINEALES      shift and go to state 14

    and                            shift and go to state 64
    funcBool                       shift and go to state 65
    funcInt                        shift and go to state 66
    menor                          shift and go to state 67
    eq                             shift and go to state 68
    mayor                          shift and go to state 69
    eMat                           shift and go to state 133
    vecVal                         shift and go to state 9
    sMM                            shift and go to state 12
    paren                          shift and go to state 77
    varsOps                        shift and go to state 94
    tCompare                       shift and go to state 76
    not                            shift and go to state 78
    p                              shift and go to state 82
    iSing                          shift and go to state 75
    exp                            shift and go to state 84
    tBool                          shift and go to state 86
    varYVals                       shift and go to state 134
    or                             shift and go to state 81
    expBool                        shift and go to state 135

state 93

    (39) valores -> reg .

    ,               reduce using rule 39 (valores -> reg .)
    ]               reduce using rule 39 (valores -> reg .)
    }               reduce using rule 39 (valores -> reg .)
    ;               reduce using rule 39 (valores -> reg .)
    )               reduce using rule 39 (valores -> reg .)


state 94

    (82) paren -> varsOps .
    (108) tCompare -> varsOps .

  ! reduce/reduce conflict for > resolved using rule 82 (paren -> varsOps .)
  ! reduce/reduce conflict for < resolved using rule 82 (paren -> varsOps .)
    ^               reduce using rule 82 (paren -> varsOps .)
    *               reduce using rule 82 (paren -> varsOps .)
    /               reduce using rule 82 (paren -> varsOps .)
    %               reduce using rule 82 (paren -> varsOps .)
    )               reduce using rule 82 (paren -> varsOps .)
    +               reduce using rule 82 (paren -> varsOps .)
    -               reduce using rule 82 (paren -> varsOps .)
    >               reduce using rule 82 (paren -> varsOps .)
    <               reduce using rule 82 (paren -> varsOps .)
    ;               reduce using rule 82 (paren -> varsOps .)
    }               reduce using rule 82 (paren -> varsOps .)
    ,               reduce using rule 82 (paren -> varsOps .)
    ]               reduce using rule 82 (paren -> varsOps .)

  ! >               [ reduce using rule 108 (tCompare -> varsOps .) ]
  ! <               [ reduce using rule 108 (tCompare -> varsOps .) ]


state 95

    (85) expString -> STRING .

    +               reduce using rule 85 (expString -> STRING .)
    }               reduce using rule 85 (expString -> STRING .)
    ,               reduce using rule 85 (expString -> STRING .)
    ]               reduce using rule 85 (expString -> STRING .)
    )               reduce using rule 85 (expString -> STRING .)
    ;               reduce using rule 85 (expString -> STRING .)


state 96

    (36) valores -> expString .
    (84) expString -> expString . + STRING

    ,               reduce using rule 36 (valores -> expString .)
    ]               reduce using rule 36 (valores -> expString .)
    }               reduce using rule 36 (valores -> expString .)
    ;               reduce using rule 36 (valores -> expString .)
    )               reduce using rule 36 (valores -> expString .)
    +               shift and go to state 153


state 97

    (40) valores -> ID . . ID
    (41) varYVals -> ID .
    (43) vecVal -> ID . m
    (44) m -> . [ INT ]
    (45) m -> . [ INT ] m

    .               shift and go to state 154
    MASMAS          reduce using rule 41 (varYVals -> ID .)
    MENOSMENOS      reduce using rule 41 (varYVals -> ID .)
    )               reduce using rule 41 (varYVals -> ID .)
    +               reduce using rule 41 (varYVals -> ID .)
    ^               reduce using rule 41 (varYVals -> ID .)
    *               reduce using rule 41 (varYVals -> ID .)
    /               reduce using rule 41 (varYVals -> ID .)
    %               reduce using rule 41 (varYVals -> ID .)
    -               reduce using rule 41 (varYVals -> ID .)
    >               reduce using rule 41 (varYVals -> ID .)
    <               reduce using rule 41 (varYVals -> ID .)
    EQEQ            reduce using rule 41 (varYVals -> ID .)
    DISTINTO        reduce using rule 41 (varYVals -> ID .)
    AND             reduce using rule 41 (varYVals -> ID .)
    ?               reduce using rule 41 (varYVals -> ID .)
    OR              reduce using rule 41 (varYVals -> ID .)
    ,               reduce using rule 41 (varYVals -> ID .)
    ]               reduce using rule 41 (varYVals -> ID .)
    [               shift and go to state 46

    m                              shift and go to state 44

state 98

    (87) expString -> funcString .
    (21) funcReturn -> funcString .

  ! reduce/reduce conflict for ) resolved using rule 21 (funcReturn -> funcString .)
  ! reduce/reduce conflict for , resolved using rule 21 (funcReturn -> funcString .)
  ! reduce/reduce conflict for ] resolved using rule 21 (funcReturn -> funcString .)
  ! reduce/reduce conflict for } resolved using rule 21 (funcReturn -> funcString .)
  ! reduce/reduce conflict for ; resolved using rule 21 (funcReturn -> funcString .)
    +               reduce using rule 87 (expString -> funcString .)
    )               reduce using rule 21 (funcReturn -> funcString .)
    ,               reduce using rule 21 (funcReturn -> funcString .)
    ]               reduce using rule 21 (funcReturn -> funcString .)
    }               reduce using rule 21 (funcReturn -> funcString .)
    ;               reduce using rule 21 (funcReturn -> funcString .)

  ! }               [ reduce using rule 87 (expString -> funcString .) ]
  ! ,               [ reduce using rule 87 (expString -> funcString .) ]
  ! ]               [ reduce using rule 87 (expString -> funcString .) ]
  ! ;               [ reduce using rule 87 (expString -> funcString .) ]
  ! )               [ reduce using rule 87 (expString -> funcString .) ]


state 99

    (38) valores -> funcReturn .

    ,               reduce using rule 38 (valores -> funcReturn .)
    ]               reduce using rule 38 (valores -> funcReturn .)
    }               reduce using rule 38 (valores -> funcReturn .)
    ;               reduce using rule 38 (valores -> funcReturn .)
    )               reduce using rule 38 (valores -> funcReturn .)


state 100

    (27) funcVoid -> PRINT ( valores . )

    )               shift and go to state 155


state 101

    (46) reg -> { . campos }
    (47) campos -> . ID : valores , campos
    (48) campos -> . valores
    (34) valores -> . eMat
    (35) valores -> . expBool
    (36) valores -> . expString
    (37) valores -> . varYVals
    (38) valores -> . funcReturn
    (39) valores -> . reg
    (40) valores -> . ID . ID
    (66) eMat -> . eMat + p
    (67) eMat -> . eMat - p
    (68) eMat -> . p
    (88) expBool -> . or ? expBool : expBool
    (89) expBool -> . or
    (84) expString -> . expString + STRING
    (85) expString -> . STRING
    (86) expString -> . varYVals
    (87) expString -> . funcString
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (20) funcReturn -> . funcInt
    (21) funcReturn -> . funcString
    (22) funcReturn -> . funcBool
    (46) reg -> . { campos }
    (69) p -> . p * exp
    (70) p -> . p / exp
    (71) p -> . p % exp
    (72) p -> . exp
    (90) or -> . or OR and
    (91) or -> . and
    (25) funcString -> . CAPITALIZAR ( expString )
    (43) vecVal -> . ID m
    (23) funcInt -> . MULTIESCALAR ( vec , eMat , param )
    (24) funcInt -> . LENGTH ( vec )
    (26) funcBool -> . COLINEALES ( vec , vec )
    (73) exp -> . exp ^ iSing
    (74) exp -> . iSing
    (92) and -> . and AND eq
    (93) and -> . eq
    (75) iSing -> . - paren
    (76) iSing -> . + paren
    (77) iSing -> . paren
    (94) eq -> . eq EQEQ tBool
    (95) eq -> . eq DISTINTO tBool
    (96) eq -> . mayor
    (78) paren -> . ( eMat )
    (79) paren -> . INT
    (80) paren -> . varYVals
    (81) paren -> . FLOAT
    (82) paren -> . varsOps
    (83) paren -> . funcInt
    (97) mayor -> . tCompare > tCompare
    (98) mayor -> . menor
    (49) varsOps -> . MENOSMENOS sMM
    (50) varsOps -> . MASMAS sMM
    (51) varsOps -> . sMM
    (52) varsOps -> . MENOSMENOS varYVals
    (53) varsOps -> . MASMAS varYVals
    (107) tCompare -> . eMat
    (108) tCompare -> . varsOps
    (109) tCompare -> . varYVals
    (99) menor -> . tCompare < tCompare
    (100) menor -> . not
    (54) sMM -> . varYVals MASMAS
    (55) sMM -> . varYVals MENOSMENOS
    (101) not -> . NOT not
    (102) not -> . tBool
    (103) tBool -> . ( expBool )
    (104) tBool -> . BOOL
    (105) tBool -> . varYVals
    (106) tBool -> . funcBool

    ID              shift and go to state 157
    STRING          shift and go to state 95
    {               shift and go to state 101
    CAPITALIZAR     shift and go to state 24
    MULTIESCALAR    shift and go to state 22
    LENGTH          shift and go to state 25
    COLINEALES      shift and go to state 14
    -               shift and go to state 73
    +               shift and go to state 72
    (               shift and go to state 92
    INT             shift and go to state 79
    FLOAT           shift and go to state 80
    MENOSMENOS      shift and go to state 30
    MASMAS          shift and go to state 27
    NOT             shift and go to state 85
    BOOL            shift and go to state 74

    and                            shift and go to state 64
    funcBool                       shift and go to state 89
    funcInt                        shift and go to state 90
    menor                          shift and go to state 67
    eq                             shift and go to state 68
    vecVal                         shift and go to state 9
    eMat                           shift and go to state 91
    mayor                          shift and go to state 69
    sMM                            shift and go to state 12
    paren                          shift and go to state 77
    reg                            shift and go to state 93
    varsOps                        shift and go to state 94
    expString                      shift and go to state 96
    tCompare                       shift and go to state 76
    campos                         shift and go to state 156
    not                            shift and go to state 78
    funcString                     shift and go to state 98
    funcReturn                     shift and go to state 99
    valores                        shift and go to state 158
    p                              shift and go to state 82
    iSing                          shift and go to state 75
    exp                            shift and go to state 84
    tBool                          shift and go to state 86
    varYVals                       shift and go to state 102
    or                             shift and go to state 81
    expBool                        shift and go to state 103

state 102

    (37) valores -> varYVals .
    (86) expString -> varYVals .
    (80) paren -> varYVals .
    (109) tCompare -> varYVals .
    (54) sMM -> varYVals . MASMAS
    (55) sMM -> varYVals . MENOSMENOS
    (105) tBool -> varYVals .

  ! reduce/reduce conflict for } resolved using rule 37 (valores -> varYVals .)
  ! reduce/reduce conflict for , resolved using rule 37 (valores -> varYVals .)
  ! reduce/reduce conflict for ] resolved using rule 37 (valores -> varYVals .)
  ! reduce/reduce conflict for ; resolved using rule 37 (valores -> varYVals .)
  ! reduce/reduce conflict for ) resolved using rule 37 (valores -> varYVals .)
  ! reduce/reduce conflict for + resolved using rule 80 (paren -> varYVals .)
  ! reduce/reduce conflict for ; resolved using rule 37 (valores -> varYVals .)
  ! reduce/reduce conflict for } resolved using rule 37 (valores -> varYVals .)
  ! reduce/reduce conflict for , resolved using rule 37 (valores -> varYVals .)
  ! reduce/reduce conflict for ] resolved using rule 37 (valores -> varYVals .)
  ! reduce/reduce conflict for ) resolved using rule 37 (valores -> varYVals .)
  ! reduce/reduce conflict for > resolved using rule 80 (paren -> varYVals .)
  ! reduce/reduce conflict for < resolved using rule 80 (paren -> varYVals .)
  ! reduce/reduce conflict for } resolved using rule 37 (valores -> varYVals .)
  ! reduce/reduce conflict for ; resolved using rule 37 (valores -> varYVals .)
  ! reduce/reduce conflict for ) resolved using rule 37 (valores -> varYVals .)
  ! reduce/reduce conflict for , resolved using rule 37 (valores -> varYVals .)
  ! reduce/reduce conflict for ] resolved using rule 37 (valores -> varYVals .)
    ,               reduce using rule 37 (valores -> varYVals .)
    ]               reduce using rule 37 (valores -> varYVals .)
    }               reduce using rule 37 (valores -> varYVals .)
    ;               reduce using rule 37 (valores -> varYVals .)
    )               reduce using rule 37 (valores -> varYVals .)
    ^               reduce using rule 80 (paren -> varYVals .)
    *               reduce using rule 80 (paren -> varYVals .)
    /               reduce using rule 80 (paren -> varYVals .)
    %               reduce using rule 80 (paren -> varYVals .)
    +               reduce using rule 80 (paren -> varYVals .)
    -               reduce using rule 80 (paren -> varYVals .)
    >               reduce using rule 80 (paren -> varYVals .)
    <               reduce using rule 80 (paren -> varYVals .)
    MASMAS          shift and go to state 58
    MENOSMENOS      shift and go to state 59
    EQEQ            reduce using rule 105 (tBool -> varYVals .)
    DISTINTO        reduce using rule 105 (tBool -> varYVals .)
    AND             reduce using rule 105 (tBool -> varYVals .)
    ?               reduce using rule 105 (tBool -> varYVals .)
    OR              reduce using rule 105 (tBool -> varYVals .)

  ! +               [ reduce using rule 86 (expString -> varYVals .) ]
  ! }               [ reduce using rule 86 (expString -> varYVals .) ]
  ! ,               [ reduce using rule 86 (expString -> varYVals .) ]
  ! ]               [ reduce using rule 86 (expString -> varYVals .) ]
  ! ;               [ reduce using rule 86 (expString -> varYVals .) ]
  ! )               [ reduce using rule 86 (expString -> varYVals .) ]
  ! ;               [ reduce using rule 80 (paren -> varYVals .) ]
  ! }               [ reduce using rule 80 (paren -> varYVals .) ]
  ! ,               [ reduce using rule 80 (paren -> varYVals .) ]
  ! ]               [ reduce using rule 80 (paren -> varYVals .) ]
  ! )               [ reduce using rule 80 (paren -> varYVals .) ]
  ! >               [ reduce using rule 109 (tCompare -> varYVals .) ]
  ! <               [ reduce using rule 109 (tCompare -> varYVals .) ]
  ! }               [ reduce using rule 105 (tBool -> varYVals .) ]
  ! ;               [ reduce using rule 105 (tBool -> varYVals .) ]
  ! )               [ reduce using rule 105 (tBool -> varYVals .) ]
  ! ,               [ reduce using rule 105 (tBool -> varYVals .) ]
  ! ]               [ reduce using rule 105 (tBool -> varYVals .) ]


state 103

    (35) valores -> expBool .

    ,               reduce using rule 35 (valores -> expBool .)
    ]               reduce using rule 35 (valores -> expBool .)
    }               reduce using rule 35 (valores -> expBool .)
    ;               reduce using rule 35 (valores -> expBool .)
    )               reduce using rule 35 (valores -> expBool .)


state 104

    (26) funcBool -> COLINEALES ( vec . , vec )

    ,               shift and go to state 159


state 105

    (31) vec -> ID . = [ elem ]

    =               shift and go to state 160


state 106

    (12) loop -> FOR ( varAsig . ; expBool ; varsOps ) bloque

    ;               shift and go to state 161


state 107

    (56) varAsig -> ID . MENOSEQ varAsig
    (57) varAsig -> ID . MASEQ varAsig
    (58) varAsig -> ID . MULEQ varAsig
    (59) varAsig -> ID . DIVEQ varAsig
    (60) varAsig -> ID . = varAsig
    (61) varAsig -> ID . MASEQ valores
    (62) varAsig -> ID . MENOSEQ valores
    (63) varAsig -> ID . MULEQ valores
    (64) varAsig -> ID . DIVEQ valores
    (65) varAsig -> ID . = valores

    MENOSEQ         shift and go to state 42
    MASEQ           shift and go to state 43
    MULEQ           shift and go to state 45
    DIVEQ           shift and go to state 48
    =               shift and go to state 47


state 108

    (56) varAsig -> ID . MENOSEQ varAsig
    (57) varAsig -> ID . MASEQ varAsig
    (58) varAsig -> ID . MULEQ varAsig
    (59) varAsig -> ID . DIVEQ varAsig
    (60) varAsig -> ID . = varAsig
    (61) varAsig -> ID . MASEQ valores
    (62) varAsig -> ID . MENOSEQ valores
    (63) varAsig -> ID . MULEQ valores
    (64) varAsig -> ID . DIVEQ valores
    (65) varAsig -> ID . = valores
    (40) valores -> ID . . ID
    (41) varYVals -> ID .
    (43) vecVal -> ID . m
    (44) m -> . [ INT ]
    (45) m -> . [ INT ] m

    MENOSEQ         shift and go to state 42
    MASEQ           shift and go to state 43
    MULEQ           shift and go to state 45
    DIVEQ           shift and go to state 48
    =               shift and go to state 47
    .               shift and go to state 154
    MASMAS          reduce using rule 41 (varYVals -> ID .)
    MENOSMENOS      reduce using rule 41 (varYVals -> ID .)
    ;               reduce using rule 41 (varYVals -> ID .)
    +               reduce using rule 41 (varYVals -> ID .)
    ^               reduce using rule 41 (varYVals -> ID .)
    *               reduce using rule 41 (varYVals -> ID .)
    /               reduce using rule 41 (varYVals -> ID .)
    %               reduce using rule 41 (varYVals -> ID .)
    -               reduce using rule 41 (varYVals -> ID .)
    >               reduce using rule 41 (varYVals -> ID .)
    <               reduce using rule 41 (varYVals -> ID .)
    EQEQ            reduce using rule 41 (varYVals -> ID .)
    DISTINTO        reduce using rule 41 (varYVals -> ID .)
    AND             reduce using rule 41 (varYVals -> ID .)
    ?               reduce using rule 41 (varYVals -> ID .)
    OR              reduce using rule 41 (varYVals -> ID .)
    [               shift and go to state 46

    m                              shift and go to state 44

state 109

    (56) varAsig -> ID MENOSEQ varAsig .

    ;               reduce using rule 56 (varAsig -> ID MENOSEQ varAsig .)


state 110

    (62) varAsig -> ID MENOSEQ valores .

    ;               reduce using rule 62 (varAsig -> ID MENOSEQ valores .)


state 111

    (57) varAsig -> ID MASEQ varAsig .

    ;               reduce using rule 57 (varAsig -> ID MASEQ varAsig .)


state 112

    (61) varAsig -> ID MASEQ valores .

    ;               reduce using rule 61 (varAsig -> ID MASEQ valores .)


state 113

    (58) varAsig -> ID MULEQ varAsig .

    ;               reduce using rule 58 (varAsig -> ID MULEQ varAsig .)


state 114

    (63) varAsig -> ID MULEQ valores .

    ;               reduce using rule 63 (varAsig -> ID MULEQ valores .)


state 115

    (44) m -> [ INT . ]
    (45) m -> [ INT . ] m

    ]               shift and go to state 162


state 116

    (60) varAsig -> ID = varAsig .

    ;               reduce using rule 60 (varAsig -> ID = varAsig .)


state 117

    (65) varAsig -> ID = valores .

    ;               reduce using rule 65 (varAsig -> ID = valores .)


state 118

    (59) varAsig -> ID DIVEQ varAsig .

    ;               reduce using rule 59 (varAsig -> ID DIVEQ varAsig .)


state 119

    (64) varAsig -> ID DIVEQ valores .

    ;               reduce using rule 64 (varAsig -> ID DIVEQ valores .)


state 120

    (13) if -> IF ( expBool . ) THEN bloque else

    )               shift and go to state 163


state 121

    (23) funcInt -> MULTIESCALAR ( vec . , eMat , param )

    ,               shift and go to state 164


state 122

    (25) funcString -> CAPITALIZAR ( expString . )
    (84) expString -> expString . + STRING

    )               shift and go to state 165
    +               shift and go to state 153


state 123

    (87) expString -> funcString .

    )               reduce using rule 87 (expString -> funcString .)
    +               reduce using rule 87 (expString -> funcString .)


state 124

    (86) expString -> varYVals .

    )               reduce using rule 86 (expString -> varYVals .)
    +               reduce using rule 86 (expString -> varYVals .)


state 125

    (24) funcInt -> LENGTH ( vec . )

    )               shift and go to state 166


state 126

    (11) loop -> DO bloque WHILE ( . expBool ) ;
    (88) expBool -> . or ? expBool : expBool
    (89) expBool -> . or
    (90) or -> . or OR and
    (91) or -> . and
    (92) and -> . and AND eq
    (93) and -> . eq
    (94) eq -> . eq EQEQ tBool
    (95) eq -> . eq DISTINTO tBool
    (96) eq -> . mayor
    (97) mayor -> . tCompare > tCompare
    (98) mayor -> . menor
    (107) tCompare -> . eMat
    (108) tCompare -> . varsOps
    (109) tCompare -> . varYVals
    (99) menor -> . tCompare < tCompare
    (100) menor -> . not
    (66) eMat -> . eMat + p
    (67) eMat -> . eMat - p
    (68) eMat -> . p
    (49) varsOps -> . MENOSMENOS sMM
    (50) varsOps -> . MASMAS sMM
    (51) varsOps -> . sMM
    (52) varsOps -> . MENOSMENOS varYVals
    (53) varsOps -> . MASMAS varYVals
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (101) not -> . NOT not
    (102) not -> . tBool
    (69) p -> . p * exp
    (70) p -> . p / exp
    (71) p -> . p % exp
    (72) p -> . exp
    (54) sMM -> . varYVals MASMAS
    (55) sMM -> . varYVals MENOSMENOS
    (43) vecVal -> . ID m
    (103) tBool -> . ( expBool )
    (104) tBool -> . BOOL
    (105) tBool -> . varYVals
    (106) tBool -> . funcBool
    (73) exp -> . exp ^ iSing
    (74) exp -> . iSing
    (26) funcBool -> . COLINEALES ( vec , vec )
    (75) iSing -> . - paren
    (76) iSing -> . + paren
    (77) iSing -> . paren
    (78) paren -> . ( eMat )
    (79) paren -> . INT
    (80) paren -> . varYVals
    (81) paren -> . FLOAT
    (82) paren -> . varsOps
    (83) paren -> . funcInt
    (23) funcInt -> . MULTIESCALAR ( vec , eMat , param )
    (24) funcInt -> . LENGTH ( vec )

    MENOSMENOS      shift and go to state 30
    MASMAS          shift and go to state 27
    ID              shift and go to state 56
    NOT             shift and go to state 85
    (               shift and go to state 71
    BOOL            shift and go to state 74
    COLINEALES      shift and go to state 14
    -               shift and go to state 73
    +               shift and go to state 72
    INT             shift and go to state 79
    FLOAT           shift and go to state 80
    MULTIESCALAR    shift and go to state 22
    LENGTH          shift and go to state 25

    and                            shift and go to state 64
    funcBool                       shift and go to state 65
    funcInt                        shift and go to state 66
    menor                          shift and go to state 67
    eq                             shift and go to state 68
    mayor                          shift and go to state 69
    eMat                           shift and go to state 70
    vecVal                         shift and go to state 9
    sMM                            shift and go to state 12
    paren                          shift and go to state 77
    iSing                          shift and go to state 75
    tCompare                       shift and go to state 76
    not                            shift and go to state 78
    p                              shift and go to state 82
    varsOps                        shift and go to state 83
    exp                            shift and go to state 84
    tBool                          shift and go to state 86
    varYVals                       shift and go to state 87
    or                             shift and go to state 81
    expBool                        shift and go to state 167

state 127

    (17) bloque -> { g } .

    RETURN          reduce using rule 17 (bloque -> { g } .)
    MENOSMENOS      reduce using rule 17 (bloque -> { g } .)
    MASMAS          reduce using rule 17 (bloque -> { g } .)
    ID              reduce using rule 17 (bloque -> { g } .)
    IF              reduce using rule 17 (bloque -> { g } .)
    WHILE           reduce using rule 17 (bloque -> { g } .)
    DO              reduce using rule 17 (bloque -> { g } .)
    FOR             reduce using rule 17 (bloque -> { g } .)
    PRINT           reduce using rule 17 (bloque -> { g } .)
    MULTIESCALAR    reduce using rule 17 (bloque -> { g } .)
    LENGTH          reduce using rule 17 (bloque -> { g } .)
    CAPITALIZAR     reduce using rule 17 (bloque -> { g } .)
    COLINEALES      reduce using rule 17 (bloque -> { g } .)
    $end            reduce using rule 17 (bloque -> { g } .)
    }               reduce using rule 17 (bloque -> { g } .)
    ELSE            reduce using rule 17 (bloque -> { g } .)


state 128

    (92) and -> and AND . eq
    (94) eq -> . eq EQEQ tBool
    (95) eq -> . eq DISTINTO tBool
    (96) eq -> . mayor
    (97) mayor -> . tCompare > tCompare
    (98) mayor -> . menor
    (107) tCompare -> . eMat
    (108) tCompare -> . varsOps
    (109) tCompare -> . varYVals
    (99) menor -> . tCompare < tCompare
    (100) menor -> . not
    (66) eMat -> . eMat + p
    (67) eMat -> . eMat - p
    (68) eMat -> . p
    (49) varsOps -> . MENOSMENOS sMM
    (50) varsOps -> . MASMAS sMM
    (51) varsOps -> . sMM
    (52) varsOps -> . MENOSMENOS varYVals
    (53) varsOps -> . MASMAS varYVals
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (101) not -> . NOT not
    (102) not -> . tBool
    (69) p -> . p * exp
    (70) p -> . p / exp
    (71) p -> . p % exp
    (72) p -> . exp
    (54) sMM -> . varYVals MASMAS
    (55) sMM -> . varYVals MENOSMENOS
    (43) vecVal -> . ID m
    (103) tBool -> . ( expBool )
    (104) tBool -> . BOOL
    (105) tBool -> . varYVals
    (106) tBool -> . funcBool
    (73) exp -> . exp ^ iSing
    (74) exp -> . iSing
    (26) funcBool -> . COLINEALES ( vec , vec )
    (75) iSing -> . - paren
    (76) iSing -> . + paren
    (77) iSing -> . paren
    (78) paren -> . ( eMat )
    (79) paren -> . INT
    (80) paren -> . varYVals
    (81) paren -> . FLOAT
    (82) paren -> . varsOps
    (83) paren -> . funcInt
    (23) funcInt -> . MULTIESCALAR ( vec , eMat , param )
    (24) funcInt -> . LENGTH ( vec )

    MENOSMENOS      shift and go to state 30
    MASMAS          shift and go to state 27
    ID              shift and go to state 56
    NOT             shift and go to state 85
    (               shift and go to state 71
    BOOL            shift and go to state 74
    COLINEALES      shift and go to state 14
    -               shift and go to state 73
    +               shift and go to state 72
    INT             shift and go to state 79
    FLOAT           shift and go to state 80
    MULTIESCALAR    shift and go to state 22
    LENGTH          shift and go to state 25

    funcBool                       shift and go to state 65
    funcInt                        shift and go to state 66
    menor                          shift and go to state 67
    eq                             shift and go to state 168
    vecVal                         shift and go to state 9
    eMat                           shift and go to state 70
    mayor                          shift and go to state 69
    sMM                            shift and go to state 12
    paren                          shift and go to state 77
    iSing                          shift and go to state 75
    tCompare                       shift and go to state 76
    not                            shift and go to state 78
    p                              shift and go to state 82
    varsOps                        shift and go to state 83
    exp                            shift and go to state 84
    tBool                          shift and go to state 86
    varYVals                       shift and go to state 87

state 129

    (94) eq -> eq EQEQ . tBool
    (103) tBool -> . ( expBool )
    (104) tBool -> . BOOL
    (105) tBool -> . varYVals
    (106) tBool -> . funcBool
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (26) funcBool -> . COLINEALES ( vec , vec )
    (43) vecVal -> . ID m

    (               shift and go to state 149
    BOOL            shift and go to state 74
    ID              shift and go to state 56
    COLINEALES      shift and go to state 14

    funcBool                       shift and go to state 65
    varYVals                       shift and go to state 151
    tBool                          shift and go to state 169
    vecVal                         shift and go to state 9

state 130

    (95) eq -> eq DISTINTO . tBool
    (103) tBool -> . ( expBool )
    (104) tBool -> . BOOL
    (105) tBool -> . varYVals
    (106) tBool -> . funcBool
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (26) funcBool -> . COLINEALES ( vec , vec )
    (43) vecVal -> . ID m

    (               shift and go to state 149
    BOOL            shift and go to state 74
    ID              shift and go to state 56
    COLINEALES      shift and go to state 14

    funcBool                       shift and go to state 65
    varYVals                       shift and go to state 151
    tBool                          shift and go to state 170
    vecVal                         shift and go to state 9

state 131

    (66) eMat -> eMat + . p
    (69) p -> . p * exp
    (70) p -> . p / exp
    (71) p -> . p % exp
    (72) p -> . exp
    (73) exp -> . exp ^ iSing
    (74) exp -> . iSing
    (75) iSing -> . - paren
    (76) iSing -> . + paren
    (77) iSing -> . paren
    (78) paren -> . ( eMat )
    (79) paren -> . INT
    (80) paren -> . varYVals
    (81) paren -> . FLOAT
    (82) paren -> . varsOps
    (83) paren -> . funcInt
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (49) varsOps -> . MENOSMENOS sMM
    (50) varsOps -> . MASMAS sMM
    (51) varsOps -> . sMM
    (52) varsOps -> . MENOSMENOS varYVals
    (53) varsOps -> . MASMAS varYVals
    (23) funcInt -> . MULTIESCALAR ( vec , eMat , param )
    (24) funcInt -> . LENGTH ( vec )
    (43) vecVal -> . ID m
    (54) sMM -> . varYVals MASMAS
    (55) sMM -> . varYVals MENOSMENOS

    -               shift and go to state 73
    +               shift and go to state 72
    (               shift and go to state 136
    INT             shift and go to state 79
    FLOAT           shift and go to state 80
    ID              shift and go to state 56
    MENOSMENOS      shift and go to state 30
    MASMAS          shift and go to state 27
    MULTIESCALAR    shift and go to state 22
    LENGTH          shift and go to state 25

    funcInt                        shift and go to state 66
    p                              shift and go to state 171
    sMM                            shift and go to state 12
    iSing                          shift and go to state 75
    exp                            shift and go to state 84
    paren                          shift and go to state 77
    varYVals                       shift and go to state 139
    vecVal                         shift and go to state 9
    varsOps                        shift and go to state 137

state 132

    (67) eMat -> eMat - . p
    (69) p -> . p * exp
    (70) p -> . p / exp
    (71) p -> . p % exp
    (72) p -> . exp
    (73) exp -> . exp ^ iSing
    (74) exp -> . iSing
    (75) iSing -> . - paren
    (76) iSing -> . + paren
    (77) iSing -> . paren
    (78) paren -> . ( eMat )
    (79) paren -> . INT
    (80) paren -> . varYVals
    (81) paren -> . FLOAT
    (82) paren -> . varsOps
    (83) paren -> . funcInt
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (49) varsOps -> . MENOSMENOS sMM
    (50) varsOps -> . MASMAS sMM
    (51) varsOps -> . sMM
    (52) varsOps -> . MENOSMENOS varYVals
    (53) varsOps -> . MASMAS varYVals
    (23) funcInt -> . MULTIESCALAR ( vec , eMat , param )
    (24) funcInt -> . LENGTH ( vec )
    (43) vecVal -> . ID m
    (54) sMM -> . varYVals MASMAS
    (55) sMM -> . varYVals MENOSMENOS

    -               shift and go to state 73
    +               shift and go to state 72
    (               shift and go to state 136
    INT             shift and go to state 79
    FLOAT           shift and go to state 80
    ID              shift and go to state 56
    MENOSMENOS      shift and go to state 30
    MASMAS          shift and go to state 27
    MULTIESCALAR    shift and go to state 22
    LENGTH          shift and go to state 25

    funcInt                        shift and go to state 66
    p                              shift and go to state 172
    sMM                            shift and go to state 12
    iSing                          shift and go to state 75
    exp                            shift and go to state 84
    paren                          shift and go to state 77
    varYVals                       shift and go to state 139
    vecVal                         shift and go to state 9
    varsOps                        shift and go to state 137

state 133

    (78) paren -> ( eMat . )
    (66) eMat -> eMat . + p
    (67) eMat -> eMat . - p
    (107) tCompare -> eMat .

    )               shift and go to state 173
    +               shift and go to state 131
    -               shift and go to state 132
    >               reduce using rule 107 (tCompare -> eMat .)
    <               reduce using rule 107 (tCompare -> eMat .)


state 134

    (80) paren -> varYVals .
    (109) tCompare -> varYVals .
    (54) sMM -> varYVals . MASMAS
    (55) sMM -> varYVals . MENOSMENOS
    (105) tBool -> varYVals .

  ! reduce/reduce conflict for > resolved using rule 80 (paren -> varYVals .)
  ! reduce/reduce conflict for < resolved using rule 80 (paren -> varYVals .)
  ! reduce/reduce conflict for ) resolved using rule 80 (paren -> varYVals .)
    ^               reduce using rule 80 (paren -> varYVals .)
    *               reduce using rule 80 (paren -> varYVals .)
    /               reduce using rule 80 (paren -> varYVals .)
    %               reduce using rule 80 (paren -> varYVals .)
    )               reduce using rule 80 (paren -> varYVals .)
    +               reduce using rule 80 (paren -> varYVals .)
    -               reduce using rule 80 (paren -> varYVals .)
    >               reduce using rule 80 (paren -> varYVals .)
    <               reduce using rule 80 (paren -> varYVals .)
    MASMAS          shift and go to state 58
    MENOSMENOS      shift and go to state 59
    EQEQ            reduce using rule 105 (tBool -> varYVals .)
    DISTINTO        reduce using rule 105 (tBool -> varYVals .)
    AND             reduce using rule 105 (tBool -> varYVals .)
    ?               reduce using rule 105 (tBool -> varYVals .)
    OR              reduce using rule 105 (tBool -> varYVals .)

  ! >               [ reduce using rule 109 (tCompare -> varYVals .) ]
  ! <               [ reduce using rule 109 (tCompare -> varYVals .) ]
  ! )               [ reduce using rule 105 (tBool -> varYVals .) ]


state 135

    (103) tBool -> ( expBool . )

    )               shift and go to state 174


state 136

    (78) paren -> ( . eMat )
    (66) eMat -> . eMat + p
    (67) eMat -> . eMat - p
    (68) eMat -> . p
    (69) p -> . p * exp
    (70) p -> . p / exp
    (71) p -> . p % exp
    (72) p -> . exp
    (73) exp -> . exp ^ iSing
    (74) exp -> . iSing
    (75) iSing -> . - paren
    (76) iSing -> . + paren
    (77) iSing -> . paren
    (78) paren -> . ( eMat )
    (79) paren -> . INT
    (80) paren -> . varYVals
    (81) paren -> . FLOAT
    (82) paren -> . varsOps
    (83) paren -> . funcInt
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (49) varsOps -> . MENOSMENOS sMM
    (50) varsOps -> . MASMAS sMM
    (51) varsOps -> . sMM
    (52) varsOps -> . MENOSMENOS varYVals
    (53) varsOps -> . MASMAS varYVals
    (23) funcInt -> . MULTIESCALAR ( vec , eMat , param )
    (24) funcInt -> . LENGTH ( vec )
    (43) vecVal -> . ID m
    (54) sMM -> . varYVals MASMAS
    (55) sMM -> . varYVals MENOSMENOS

    -               shift and go to state 73
    +               shift and go to state 72
    (               shift and go to state 136
    INT             shift and go to state 79
    FLOAT           shift and go to state 80
    ID              shift and go to state 56
    MENOSMENOS      shift and go to state 30
    MASMAS          shift and go to state 27
    MULTIESCALAR    shift and go to state 22
    LENGTH          shift and go to state 25

    eMat                           shift and go to state 175
    funcInt                        shift and go to state 66
    p                              shift and go to state 82
    sMM                            shift and go to state 12
    iSing                          shift and go to state 75
    exp                            shift and go to state 84
    paren                          shift and go to state 77
    varYVals                       shift and go to state 139
    vecVal                         shift and go to state 9
    varsOps                        shift and go to state 137

state 137

    (82) paren -> varsOps .

    ^               reduce using rule 82 (paren -> varsOps .)
    *               reduce using rule 82 (paren -> varsOps .)
    /               reduce using rule 82 (paren -> varsOps .)
    %               reduce using rule 82 (paren -> varsOps .)
    +               reduce using rule 82 (paren -> varsOps .)
    -               reduce using rule 82 (paren -> varsOps .)
    >               reduce using rule 82 (paren -> varsOps .)
    <               reduce using rule 82 (paren -> varsOps .)
    )               reduce using rule 82 (paren -> varsOps .)
    ;               reduce using rule 82 (paren -> varsOps .)
    }               reduce using rule 82 (paren -> varsOps .)
    EQEQ            reduce using rule 82 (paren -> varsOps .)
    DISTINTO        reduce using rule 82 (paren -> varsOps .)
    AND             reduce using rule 82 (paren -> varsOps .)
    ?               reduce using rule 82 (paren -> varsOps .)
    OR              reduce using rule 82 (paren -> varsOps .)
    :               reduce using rule 82 (paren -> varsOps .)
    ,               reduce using rule 82 (paren -> varsOps .)
    ]               reduce using rule 82 (paren -> varsOps .)


state 138

    (76) iSing -> + paren .

    ^               reduce using rule 76 (iSing -> + paren .)
    *               reduce using rule 76 (iSing -> + paren .)
    /               reduce using rule 76 (iSing -> + paren .)
    %               reduce using rule 76 (iSing -> + paren .)
    )               reduce using rule 76 (iSing -> + paren .)
    +               reduce using rule 76 (iSing -> + paren .)
    -               reduce using rule 76 (iSing -> + paren .)
    >               reduce using rule 76 (iSing -> + paren .)
    <               reduce using rule 76 (iSing -> + paren .)
    ;               reduce using rule 76 (iSing -> + paren .)
    }               reduce using rule 76 (iSing -> + paren .)
    EQEQ            reduce using rule 76 (iSing -> + paren .)
    DISTINTO        reduce using rule 76 (iSing -> + paren .)
    AND             reduce using rule 76 (iSing -> + paren .)
    ?               reduce using rule 76 (iSing -> + paren .)
    OR              reduce using rule 76 (iSing -> + paren .)
    :               reduce using rule 76 (iSing -> + paren .)
    ,               reduce using rule 76 (iSing -> + paren .)
    ]               reduce using rule 76 (iSing -> + paren .)


state 139

    (80) paren -> varYVals .
    (54) sMM -> varYVals . MASMAS
    (55) sMM -> varYVals . MENOSMENOS

    ^               reduce using rule 80 (paren -> varYVals .)
    *               reduce using rule 80 (paren -> varYVals .)
    /               reduce using rule 80 (paren -> varYVals .)
    %               reduce using rule 80 (paren -> varYVals .)
    +               reduce using rule 80 (paren -> varYVals .)
    -               reduce using rule 80 (paren -> varYVals .)
    >               reduce using rule 80 (paren -> varYVals .)
    <               reduce using rule 80 (paren -> varYVals .)
    )               reduce using rule 80 (paren -> varYVals .)
    ;               reduce using rule 80 (paren -> varYVals .)
    }               reduce using rule 80 (paren -> varYVals .)
    EQEQ            reduce using rule 80 (paren -> varYVals .)
    DISTINTO        reduce using rule 80 (paren -> varYVals .)
    AND             reduce using rule 80 (paren -> varYVals .)
    ?               reduce using rule 80 (paren -> varYVals .)
    OR              reduce using rule 80 (paren -> varYVals .)
    :               reduce using rule 80 (paren -> varYVals .)
    ,               reduce using rule 80 (paren -> varYVals .)
    ]               reduce using rule 80 (paren -> varYVals .)
    MASMAS          shift and go to state 58
    MENOSMENOS      shift and go to state 59


state 140

    (75) iSing -> - paren .

    ^               reduce using rule 75 (iSing -> - paren .)
    *               reduce using rule 75 (iSing -> - paren .)
    /               reduce using rule 75 (iSing -> - paren .)
    %               reduce using rule 75 (iSing -> - paren .)
    )               reduce using rule 75 (iSing -> - paren .)
    +               reduce using rule 75 (iSing -> - paren .)
    -               reduce using rule 75 (iSing -> - paren .)
    >               reduce using rule 75 (iSing -> - paren .)
    <               reduce using rule 75 (iSing -> - paren .)
    ;               reduce using rule 75 (iSing -> - paren .)
    }               reduce using rule 75 (iSing -> - paren .)
    EQEQ            reduce using rule 75 (iSing -> - paren .)
    DISTINTO        reduce using rule 75 (iSing -> - paren .)
    AND             reduce using rule 75 (iSing -> - paren .)
    ?               reduce using rule 75 (iSing -> - paren .)
    OR              reduce using rule 75 (iSing -> - paren .)
    :               reduce using rule 75 (iSing -> - paren .)
    ,               reduce using rule 75 (iSing -> - paren .)
    ]               reduce using rule 75 (iSing -> - paren .)


state 141

    (99) menor -> tCompare < . tCompare
    (107) tCompare -> . eMat
    (108) tCompare -> . varsOps
    (109) tCompare -> . varYVals
    (66) eMat -> . eMat + p
    (67) eMat -> . eMat - p
    (68) eMat -> . p
    (49) varsOps -> . MENOSMENOS sMM
    (50) varsOps -> . MASMAS sMM
    (51) varsOps -> . sMM
    (52) varsOps -> . MENOSMENOS varYVals
    (53) varsOps -> . MASMAS varYVals
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (69) p -> . p * exp
    (70) p -> . p / exp
    (71) p -> . p % exp
    (72) p -> . exp
    (54) sMM -> . varYVals MASMAS
    (55) sMM -> . varYVals MENOSMENOS
    (43) vecVal -> . ID m
    (73) exp -> . exp ^ iSing
    (74) exp -> . iSing
    (75) iSing -> . - paren
    (76) iSing -> . + paren
    (77) iSing -> . paren
    (78) paren -> . ( eMat )
    (79) paren -> . INT
    (80) paren -> . varYVals
    (81) paren -> . FLOAT
    (82) paren -> . varsOps
    (83) paren -> . funcInt
    (23) funcInt -> . MULTIESCALAR ( vec , eMat , param )
    (24) funcInt -> . LENGTH ( vec )

    MENOSMENOS      shift and go to state 30
    MASMAS          shift and go to state 27
    ID              shift and go to state 56
    -               shift and go to state 73
    +               shift and go to state 72
    (               shift and go to state 136
    INT             shift and go to state 79
    FLOAT           shift and go to state 80
    MULTIESCALAR    shift and go to state 22
    LENGTH          shift and go to state 25

    eMat                           shift and go to state 70
    p                              shift and go to state 82
    funcInt                        shift and go to state 66
    tCompare                       shift and go to state 176
    sMM                            shift and go to state 12
    varsOps                        shift and go to state 83
    exp                            shift and go to state 84
    paren                          shift and go to state 77
    varYVals                       shift and go to state 177
    vecVal                         shift and go to state 9
    iSing                          shift and go to state 75

state 142

    (97) mayor -> tCompare > . tCompare
    (107) tCompare -> . eMat
    (108) tCompare -> . varsOps
    (109) tCompare -> . varYVals
    (66) eMat -> . eMat + p
    (67) eMat -> . eMat - p
    (68) eMat -> . p
    (49) varsOps -> . MENOSMENOS sMM
    (50) varsOps -> . MASMAS sMM
    (51) varsOps -> . sMM
    (52) varsOps -> . MENOSMENOS varYVals
    (53) varsOps -> . MASMAS varYVals
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (69) p -> . p * exp
    (70) p -> . p / exp
    (71) p -> . p % exp
    (72) p -> . exp
    (54) sMM -> . varYVals MASMAS
    (55) sMM -> . varYVals MENOSMENOS
    (43) vecVal -> . ID m
    (73) exp -> . exp ^ iSing
    (74) exp -> . iSing
    (75) iSing -> . - paren
    (76) iSing -> . + paren
    (77) iSing -> . paren
    (78) paren -> . ( eMat )
    (79) paren -> . INT
    (80) paren -> . varYVals
    (81) paren -> . FLOAT
    (82) paren -> . varsOps
    (83) paren -> . funcInt
    (23) funcInt -> . MULTIESCALAR ( vec , eMat , param )
    (24) funcInt -> . LENGTH ( vec )

    MENOSMENOS      shift and go to state 30
    MASMAS          shift and go to state 27
    ID              shift and go to state 56
    -               shift and go to state 73
    +               shift and go to state 72
    (               shift and go to state 136
    INT             shift and go to state 79
    FLOAT           shift and go to state 80
    MULTIESCALAR    shift and go to state 22
    LENGTH          shift and go to state 25

    eMat                           shift and go to state 70
    p                              shift and go to state 82
    funcInt                        shift and go to state 66
    tCompare                       shift and go to state 178
    sMM                            shift and go to state 12
    varsOps                        shift and go to state 83
    exp                            shift and go to state 84
    paren                          shift and go to state 77
    varYVals                       shift and go to state 177
    vecVal                         shift and go to state 9
    iSing                          shift and go to state 75

state 143

    (90) or -> or OR . and
    (92) and -> . and AND eq
    (93) and -> . eq
    (94) eq -> . eq EQEQ tBool
    (95) eq -> . eq DISTINTO tBool
    (96) eq -> . mayor
    (97) mayor -> . tCompare > tCompare
    (98) mayor -> . menor
    (107) tCompare -> . eMat
    (108) tCompare -> . varsOps
    (109) tCompare -> . varYVals
    (99) menor -> . tCompare < tCompare
    (100) menor -> . not
    (66) eMat -> . eMat + p
    (67) eMat -> . eMat - p
    (68) eMat -> . p
    (49) varsOps -> . MENOSMENOS sMM
    (50) varsOps -> . MASMAS sMM
    (51) varsOps -> . sMM
    (52) varsOps -> . MENOSMENOS varYVals
    (53) varsOps -> . MASMAS varYVals
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (101) not -> . NOT not
    (102) not -> . tBool
    (69) p -> . p * exp
    (70) p -> . p / exp
    (71) p -> . p % exp
    (72) p -> . exp
    (54) sMM -> . varYVals MASMAS
    (55) sMM -> . varYVals MENOSMENOS
    (43) vecVal -> . ID m
    (103) tBool -> . ( expBool )
    (104) tBool -> . BOOL
    (105) tBool -> . varYVals
    (106) tBool -> . funcBool
    (73) exp -> . exp ^ iSing
    (74) exp -> . iSing
    (26) funcBool -> . COLINEALES ( vec , vec )
    (75) iSing -> . - paren
    (76) iSing -> . + paren
    (77) iSing -> . paren
    (78) paren -> . ( eMat )
    (79) paren -> . INT
    (80) paren -> . varYVals
    (81) paren -> . FLOAT
    (82) paren -> . varsOps
    (83) paren -> . funcInt
    (23) funcInt -> . MULTIESCALAR ( vec , eMat , param )
    (24) funcInt -> . LENGTH ( vec )

    MENOSMENOS      shift and go to state 30
    MASMAS          shift and go to state 27
    ID              shift and go to state 56
    NOT             shift and go to state 85
    (               shift and go to state 71
    BOOL            shift and go to state 74
    COLINEALES      shift and go to state 14
    -               shift and go to state 73
    +               shift and go to state 72
    INT             shift and go to state 79
    FLOAT           shift and go to state 80
    MULTIESCALAR    shift and go to state 22
    LENGTH          shift and go to state 25

    and                            shift and go to state 179
    funcBool                       shift and go to state 65
    funcInt                        shift and go to state 66
    menor                          shift and go to state 67
    eq                             shift and go to state 68
    mayor                          shift and go to state 69
    eMat                           shift and go to state 70
    vecVal                         shift and go to state 9
    sMM                            shift and go to state 12
    paren                          shift and go to state 77
    iSing                          shift and go to state 75
    tCompare                       shift and go to state 76
    not                            shift and go to state 78
    p                              shift and go to state 82
    varsOps                        shift and go to state 83
    exp                            shift and go to state 84
    tBool                          shift and go to state 86
    varYVals                       shift and go to state 87

state 144

    (88) expBool -> or ? . expBool : expBool
    (88) expBool -> . or ? expBool : expBool
    (89) expBool -> . or
    (90) or -> . or OR and
    (91) or -> . and
    (92) and -> . and AND eq
    (93) and -> . eq
    (94) eq -> . eq EQEQ tBool
    (95) eq -> . eq DISTINTO tBool
    (96) eq -> . mayor
    (97) mayor -> . tCompare > tCompare
    (98) mayor -> . menor
    (107) tCompare -> . eMat
    (108) tCompare -> . varsOps
    (109) tCompare -> . varYVals
    (99) menor -> . tCompare < tCompare
    (100) menor -> . not
    (66) eMat -> . eMat + p
    (67) eMat -> . eMat - p
    (68) eMat -> . p
    (49) varsOps -> . MENOSMENOS sMM
    (50) varsOps -> . MASMAS sMM
    (51) varsOps -> . sMM
    (52) varsOps -> . MENOSMENOS varYVals
    (53) varsOps -> . MASMAS varYVals
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (101) not -> . NOT not
    (102) not -> . tBool
    (69) p -> . p * exp
    (70) p -> . p / exp
    (71) p -> . p % exp
    (72) p -> . exp
    (54) sMM -> . varYVals MASMAS
    (55) sMM -> . varYVals MENOSMENOS
    (43) vecVal -> . ID m
    (103) tBool -> . ( expBool )
    (104) tBool -> . BOOL
    (105) tBool -> . varYVals
    (106) tBool -> . funcBool
    (73) exp -> . exp ^ iSing
    (74) exp -> . iSing
    (26) funcBool -> . COLINEALES ( vec , vec )
    (75) iSing -> . - paren
    (76) iSing -> . + paren
    (77) iSing -> . paren
    (78) paren -> . ( eMat )
    (79) paren -> . INT
    (80) paren -> . varYVals
    (81) paren -> . FLOAT
    (82) paren -> . varsOps
    (83) paren -> . funcInt
    (23) funcInt -> . MULTIESCALAR ( vec , eMat , param )
    (24) funcInt -> . LENGTH ( vec )

    MENOSMENOS      shift and go to state 30
    MASMAS          shift and go to state 27
    ID              shift and go to state 56
    NOT             shift and go to state 85
    (               shift and go to state 71
    BOOL            shift and go to state 74
    COLINEALES      shift and go to state 14
    -               shift and go to state 73
    +               shift and go to state 72
    INT             shift and go to state 79
    FLOAT           shift and go to state 80
    MULTIESCALAR    shift and go to state 22
    LENGTH          shift and go to state 25

    and                            shift and go to state 64
    funcBool                       shift and go to state 65
    funcInt                        shift and go to state 66
    menor                          shift and go to state 67
    eq                             shift and go to state 68
    mayor                          shift and go to state 69
    eMat                           shift and go to state 70
    vecVal                         shift and go to state 9
    sMM                            shift and go to state 12
    paren                          shift and go to state 77
    iSing                          shift and go to state 75
    tCompare                       shift and go to state 76
    not                            shift and go to state 78
    p                              shift and go to state 82
    varsOps                        shift and go to state 83
    exp                            shift and go to state 84
    tBool                          shift and go to state 86
    varYVals                       shift and go to state 87
    or                             shift and go to state 81
    expBool                        shift and go to state 180

state 145

    (69) p -> p * . exp
    (73) exp -> . exp ^ iSing
    (74) exp -> . iSing
    (75) iSing -> . - paren
    (76) iSing -> . + paren
    (77) iSing -> . paren
    (78) paren -> . ( eMat )
    (79) paren -> . INT
    (80) paren -> . varYVals
    (81) paren -> . FLOAT
    (82) paren -> . varsOps
    (83) paren -> . funcInt
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (49) varsOps -> . MENOSMENOS sMM
    (50) varsOps -> . MASMAS sMM
    (51) varsOps -> . sMM
    (52) varsOps -> . MENOSMENOS varYVals
    (53) varsOps -> . MASMAS varYVals
    (23) funcInt -> . MULTIESCALAR ( vec , eMat , param )
    (24) funcInt -> . LENGTH ( vec )
    (43) vecVal -> . ID m
    (54) sMM -> . varYVals MASMAS
    (55) sMM -> . varYVals MENOSMENOS

    -               shift and go to state 73
    +               shift and go to state 72
    (               shift and go to state 136
    INT             shift and go to state 79
    FLOAT           shift and go to state 80
    ID              shift and go to state 56
    MENOSMENOS      shift and go to state 30
    MASMAS          shift and go to state 27
    MULTIESCALAR    shift and go to state 22
    LENGTH          shift and go to state 25

    funcInt                        shift and go to state 66
    sMM                            shift and go to state 12
    iSing                          shift and go to state 75
    exp                            shift and go to state 181
    paren                          shift and go to state 77
    varYVals                       shift and go to state 139
    vecVal                         shift and go to state 9
    varsOps                        shift and go to state 137

state 146

    (71) p -> p % . exp
    (73) exp -> . exp ^ iSing
    (74) exp -> . iSing
    (75) iSing -> . - paren
    (76) iSing -> . + paren
    (77) iSing -> . paren
    (78) paren -> . ( eMat )
    (79) paren -> . INT
    (80) paren -> . varYVals
    (81) paren -> . FLOAT
    (82) paren -> . varsOps
    (83) paren -> . funcInt
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (49) varsOps -> . MENOSMENOS sMM
    (50) varsOps -> . MASMAS sMM
    (51) varsOps -> . sMM
    (52) varsOps -> . MENOSMENOS varYVals
    (53) varsOps -> . MASMAS varYVals
    (23) funcInt -> . MULTIESCALAR ( vec , eMat , param )
    (24) funcInt -> . LENGTH ( vec )
    (43) vecVal -> . ID m
    (54) sMM -> . varYVals MASMAS
    (55) sMM -> . varYVals MENOSMENOS

    -               shift and go to state 73
    +               shift and go to state 72
    (               shift and go to state 136
    INT             shift and go to state 79
    FLOAT           shift and go to state 80
    ID              shift and go to state 56
    MENOSMENOS      shift and go to state 30
    MASMAS          shift and go to state 27
    MULTIESCALAR    shift and go to state 22
    LENGTH          shift and go to state 25

    funcInt                        shift and go to state 66
    sMM                            shift and go to state 12
    iSing                          shift and go to state 75
    exp                            shift and go to state 182
    paren                          shift and go to state 77
    varYVals                       shift and go to state 139
    vecVal                         shift and go to state 9
    varsOps                        shift and go to state 137

state 147

    (70) p -> p / . exp
    (73) exp -> . exp ^ iSing
    (74) exp -> . iSing
    (75) iSing -> . - paren
    (76) iSing -> . + paren
    (77) iSing -> . paren
    (78) paren -> . ( eMat )
    (79) paren -> . INT
    (80) paren -> . varYVals
    (81) paren -> . FLOAT
    (82) paren -> . varsOps
    (83) paren -> . funcInt
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (49) varsOps -> . MENOSMENOS sMM
    (50) varsOps -> . MASMAS sMM
    (51) varsOps -> . sMM
    (52) varsOps -> . MENOSMENOS varYVals
    (53) varsOps -> . MASMAS varYVals
    (23) funcInt -> . MULTIESCALAR ( vec , eMat , param )
    (24) funcInt -> . LENGTH ( vec )
    (43) vecVal -> . ID m
    (54) sMM -> . varYVals MASMAS
    (55) sMM -> . varYVals MENOSMENOS

    -               shift and go to state 73
    +               shift and go to state 72
    (               shift and go to state 136
    INT             shift and go to state 79
    FLOAT           shift and go to state 80
    ID              shift and go to state 56
    MENOSMENOS      shift and go to state 30
    MASMAS          shift and go to state 27
    MULTIESCALAR    shift and go to state 22
    LENGTH          shift and go to state 25

    funcInt                        shift and go to state 66
    sMM                            shift and go to state 12
    iSing                          shift and go to state 75
    exp                            shift and go to state 183
    paren                          shift and go to state 77
    varYVals                       shift and go to state 139
    vecVal                         shift and go to state 9
    varsOps                        shift and go to state 137

state 148

    (73) exp -> exp ^ . iSing
    (75) iSing -> . - paren
    (76) iSing -> . + paren
    (77) iSing -> . paren
    (78) paren -> . ( eMat )
    (79) paren -> . INT
    (80) paren -> . varYVals
    (81) paren -> . FLOAT
    (82) paren -> . varsOps
    (83) paren -> . funcInt
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (49) varsOps -> . MENOSMENOS sMM
    (50) varsOps -> . MASMAS sMM
    (51) varsOps -> . sMM
    (52) varsOps -> . MENOSMENOS varYVals
    (53) varsOps -> . MASMAS varYVals
    (23) funcInt -> . MULTIESCALAR ( vec , eMat , param )
    (24) funcInt -> . LENGTH ( vec )
    (43) vecVal -> . ID m
    (54) sMM -> . varYVals MASMAS
    (55) sMM -> . varYVals MENOSMENOS

    -               shift and go to state 73
    +               shift and go to state 72
    (               shift and go to state 136
    INT             shift and go to state 79
    FLOAT           shift and go to state 80
    ID              shift and go to state 56
    MENOSMENOS      shift and go to state 30
    MASMAS          shift and go to state 27
    MULTIESCALAR    shift and go to state 22
    LENGTH          shift and go to state 25

    funcInt                        shift and go to state 66
    sMM                            shift and go to state 12
    varsOps                        shift and go to state 137
    paren                          shift and go to state 77
    varYVals                       shift and go to state 139
    vecVal                         shift and go to state 9
    iSing                          shift and go to state 184

state 149

    (103) tBool -> ( . expBool )
    (88) expBool -> . or ? expBool : expBool
    (89) expBool -> . or
    (90) or -> . or OR and
    (91) or -> . and
    (92) and -> . and AND eq
    (93) and -> . eq
    (94) eq -> . eq EQEQ tBool
    (95) eq -> . eq DISTINTO tBool
    (96) eq -> . mayor
    (97) mayor -> . tCompare > tCompare
    (98) mayor -> . menor
    (107) tCompare -> . eMat
    (108) tCompare -> . varsOps
    (109) tCompare -> . varYVals
    (99) menor -> . tCompare < tCompare
    (100) menor -> . not
    (66) eMat -> . eMat + p
    (67) eMat -> . eMat - p
    (68) eMat -> . p
    (49) varsOps -> . MENOSMENOS sMM
    (50) varsOps -> . MASMAS sMM
    (51) varsOps -> . sMM
    (52) varsOps -> . MENOSMENOS varYVals
    (53) varsOps -> . MASMAS varYVals
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (101) not -> . NOT not
    (102) not -> . tBool
    (69) p -> . p * exp
    (70) p -> . p / exp
    (71) p -> . p % exp
    (72) p -> . exp
    (54) sMM -> . varYVals MASMAS
    (55) sMM -> . varYVals MENOSMENOS
    (43) vecVal -> . ID m
    (103) tBool -> . ( expBool )
    (104) tBool -> . BOOL
    (105) tBool -> . varYVals
    (106) tBool -> . funcBool
    (73) exp -> . exp ^ iSing
    (74) exp -> . iSing
    (26) funcBool -> . COLINEALES ( vec , vec )
    (75) iSing -> . - paren
    (76) iSing -> . + paren
    (77) iSing -> . paren
    (78) paren -> . ( eMat )
    (79) paren -> . INT
    (80) paren -> . varYVals
    (81) paren -> . FLOAT
    (82) paren -> . varsOps
    (83) paren -> . funcInt
    (23) funcInt -> . MULTIESCALAR ( vec , eMat , param )
    (24) funcInt -> . LENGTH ( vec )

    MENOSMENOS      shift and go to state 30
    MASMAS          shift and go to state 27
    ID              shift and go to state 56
    NOT             shift and go to state 85
    (               shift and go to state 71
    BOOL            shift and go to state 74
    COLINEALES      shift and go to state 14
    -               shift and go to state 73
    +               shift and go to state 72
    INT             shift and go to state 79
    FLOAT           shift and go to state 80
    MULTIESCALAR    shift and go to state 22
    LENGTH          shift and go to state 25

    and                            shift and go to state 64
    funcBool                       shift and go to state 65
    funcInt                        shift and go to state 66
    menor                          shift and go to state 67
    eq                             shift and go to state 68
    mayor                          shift and go to state 69
    eMat                           shift and go to state 70
    vecVal                         shift and go to state 9
    sMM                            shift and go to state 12
    paren                          shift and go to state 77
    iSing                          shift and go to state 75
    tCompare                       shift and go to state 76
    not                            shift and go to state 78
    p                              shift and go to state 82
    varsOps                        shift and go to state 83
    exp                            shift and go to state 84
    tBool                          shift and go to state 86
    varYVals                       shift and go to state 87
    or                             shift and go to state 81
    expBool                        shift and go to state 135

state 150

    (101) not -> NOT not .

    EQEQ            reduce using rule 101 (not -> NOT not .)
    DISTINTO        reduce using rule 101 (not -> NOT not .)
    AND             reduce using rule 101 (not -> NOT not .)
    ?               reduce using rule 101 (not -> NOT not .)
    OR              reduce using rule 101 (not -> NOT not .)
    ;               reduce using rule 101 (not -> NOT not .)
    )               reduce using rule 101 (not -> NOT not .)
    }               reduce using rule 101 (not -> NOT not .)
    :               reduce using rule 101 (not -> NOT not .)
    ,               reduce using rule 101 (not -> NOT not .)
    ]               reduce using rule 101 (not -> NOT not .)


state 151

    (105) tBool -> varYVals .

    EQEQ            reduce using rule 105 (tBool -> varYVals .)
    DISTINTO        reduce using rule 105 (tBool -> varYVals .)
    AND             reduce using rule 105 (tBool -> varYVals .)
    ?               reduce using rule 105 (tBool -> varYVals .)
    OR              reduce using rule 105 (tBool -> varYVals .)
    )               reduce using rule 105 (tBool -> varYVals .)
    ;               reduce using rule 105 (tBool -> varYVals .)
    }               reduce using rule 105 (tBool -> varYVals .)
    :               reduce using rule 105 (tBool -> varYVals .)
    ,               reduce using rule 105 (tBool -> varYVals .)
    ]               reduce using rule 105 (tBool -> varYVals .)


state 152

    (10) loop -> WHILE ( expBool ) . bloque
    (16) bloque -> . sentencia
    (17) bloque -> . { g }
    (4) sentencia -> . varsOps ;
    (5) sentencia -> . func ;
    (6) sentencia -> . varAsig ;
    (7) sentencia -> . RETURN ;
    (49) varsOps -> . MENOSMENOS sMM
    (50) varsOps -> . MASMAS sMM
    (51) varsOps -> . sMM
    (52) varsOps -> . MENOSMENOS varYVals
    (53) varsOps -> . MASMAS varYVals
    (18) func -> . funcReturn
    (19) func -> . funcVoid
    (56) varAsig -> . ID MENOSEQ varAsig
    (57) varAsig -> . ID MASEQ varAsig
    (58) varAsig -> . ID MULEQ varAsig
    (59) varAsig -> . ID DIVEQ varAsig
    (60) varAsig -> . ID = varAsig
    (61) varAsig -> . ID MASEQ valores
    (62) varAsig -> . ID MENOSEQ valores
    (63) varAsig -> . ID MULEQ valores
    (64) varAsig -> . ID DIVEQ valores
    (65) varAsig -> . ID = valores
    (54) sMM -> . varYVals MASMAS
    (55) sMM -> . varYVals MENOSMENOS
    (20) funcReturn -> . funcInt
    (21) funcReturn -> . funcString
    (22) funcReturn -> . funcBool
    (27) funcVoid -> . PRINT ( valores )
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (23) funcInt -> . MULTIESCALAR ( vec , eMat , param )
    (24) funcInt -> . LENGTH ( vec )
    (25) funcString -> . CAPITALIZAR ( expString )
    (26) funcBool -> . COLINEALES ( vec , vec )
    (43) vecVal -> . ID m

    {               shift and go to state 33
    RETURN          shift and go to state 2
    MENOSMENOS      shift and go to state 30
    MASMAS          shift and go to state 27
    ID              shift and go to state 17
    PRINT           shift and go to state 8
    MULTIESCALAR    shift and go to state 22
    LENGTH          shift and go to state 25
    CAPITALIZAR     shift and go to state 24
    COLINEALES      shift and go to state 14

    varAsig                        shift and go to state 19
    sentencia                      shift and go to state 32
    funcBool                       shift and go to state 3
    funcString                     shift and go to state 21
    funcVoid                       shift and go to state 13
    funcReturn                     shift and go to state 23
    vecVal                         shift and go to state 9
    sMM                            shift and go to state 12
    varsOps                        shift and go to state 28
    func                           shift and go to state 16
    bloque                         shift and go to state 185
    varYVals                       shift and go to state 29
    funcInt                        shift and go to state 5

state 153

    (84) expString -> expString + . STRING

    STRING          shift and go to state 186


state 154

    (40) valores -> ID . . ID

    ID              shift and go to state 187


state 155

    (27) funcVoid -> PRINT ( valores ) .

    ;               reduce using rule 27 (funcVoid -> PRINT ( valores ) .)


state 156

    (46) reg -> { campos . }

    }               shift and go to state 188


state 157

    (47) campos -> ID . : valores , campos
    (40) valores -> ID . . ID
    (41) varYVals -> ID .
    (43) vecVal -> ID . m
    (44) m -> . [ INT ]
    (45) m -> . [ INT ] m

    :               shift and go to state 189
    .               shift and go to state 154
    MASMAS          reduce using rule 41 (varYVals -> ID .)
    MENOSMENOS      reduce using rule 41 (varYVals -> ID .)
    }               reduce using rule 41 (varYVals -> ID .)
    +               reduce using rule 41 (varYVals -> ID .)
    ^               reduce using rule 41 (varYVals -> ID .)
    *               reduce using rule 41 (varYVals -> ID .)
    /               reduce using rule 41 (varYVals -> ID .)
    %               reduce using rule 41 (varYVals -> ID .)
    -               reduce using rule 41 (varYVals -> ID .)
    >               reduce using rule 41 (varYVals -> ID .)
    <               reduce using rule 41 (varYVals -> ID .)
    EQEQ            reduce using rule 41 (varYVals -> ID .)
    DISTINTO        reduce using rule 41 (varYVals -> ID .)
    AND             reduce using rule 41 (varYVals -> ID .)
    ?               reduce using rule 41 (varYVals -> ID .)
    OR              reduce using rule 41 (varYVals -> ID .)
    [               shift and go to state 46

    m                              shift and go to state 44

state 158

    (48) campos -> valores .

    }               reduce using rule 48 (campos -> valores .)


state 159

    (26) funcBool -> COLINEALES ( vec , . vec )
    (31) vec -> . ID = [ elem ]

    ID              shift and go to state 105

    vec                            shift and go to state 190

state 160

    (31) vec -> ID = . [ elem ]

    [               shift and go to state 191


state 161

    (12) loop -> FOR ( varAsig ; . expBool ; varsOps ) bloque
    (88) expBool -> . or ? expBool : expBool
    (89) expBool -> . or
    (90) or -> . or OR and
    (91) or -> . and
    (92) and -> . and AND eq
    (93) and -> . eq
    (94) eq -> . eq EQEQ tBool
    (95) eq -> . eq DISTINTO tBool
    (96) eq -> . mayor
    (97) mayor -> . tCompare > tCompare
    (98) mayor -> . menor
    (107) tCompare -> . eMat
    (108) tCompare -> . varsOps
    (109) tCompare -> . varYVals
    (99) menor -> . tCompare < tCompare
    (100) menor -> . not
    (66) eMat -> . eMat + p
    (67) eMat -> . eMat - p
    (68) eMat -> . p
    (49) varsOps -> . MENOSMENOS sMM
    (50) varsOps -> . MASMAS sMM
    (51) varsOps -> . sMM
    (52) varsOps -> . MENOSMENOS varYVals
    (53) varsOps -> . MASMAS varYVals
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (101) not -> . NOT not
    (102) not -> . tBool
    (69) p -> . p * exp
    (70) p -> . p / exp
    (71) p -> . p % exp
    (72) p -> . exp
    (54) sMM -> . varYVals MASMAS
    (55) sMM -> . varYVals MENOSMENOS
    (43) vecVal -> . ID m
    (103) tBool -> . ( expBool )
    (104) tBool -> . BOOL
    (105) tBool -> . varYVals
    (106) tBool -> . funcBool
    (73) exp -> . exp ^ iSing
    (74) exp -> . iSing
    (26) funcBool -> . COLINEALES ( vec , vec )
    (75) iSing -> . - paren
    (76) iSing -> . + paren
    (77) iSing -> . paren
    (78) paren -> . ( eMat )
    (79) paren -> . INT
    (80) paren -> . varYVals
    (81) paren -> . FLOAT
    (82) paren -> . varsOps
    (83) paren -> . funcInt
    (23) funcInt -> . MULTIESCALAR ( vec , eMat , param )
    (24) funcInt -> . LENGTH ( vec )

    MENOSMENOS      shift and go to state 30
    MASMAS          shift and go to state 27
    ID              shift and go to state 56
    NOT             shift and go to state 85
    (               shift and go to state 71
    BOOL            shift and go to state 74
    COLINEALES      shift and go to state 14
    -               shift and go to state 73
    +               shift and go to state 72
    INT             shift and go to state 79
    FLOAT           shift and go to state 80
    MULTIESCALAR    shift and go to state 22
    LENGTH          shift and go to state 25

    and                            shift and go to state 64
    funcBool                       shift and go to state 65
    funcInt                        shift and go to state 66
    menor                          shift and go to state 67
    eq                             shift and go to state 68
    mayor                          shift and go to state 69
    eMat                           shift and go to state 70
    vecVal                         shift and go to state 9
    sMM                            shift and go to state 12
    paren                          shift and go to state 77
    iSing                          shift and go to state 75
    tCompare                       shift and go to state 76
    not                            shift and go to state 78
    p                              shift and go to state 82
    varsOps                        shift and go to state 83
    exp                            shift and go to state 84
    tBool                          shift and go to state 86
    varYVals                       shift and go to state 87
    or                             shift and go to state 81
    expBool                        shift and go to state 192

state 162

    (44) m -> [ INT ] .
    (45) m -> [ INT ] . m
    (44) m -> . [ INT ]
    (45) m -> . [ INT ] m

    MASMAS          reduce using rule 44 (m -> [ INT ] .)
    MENOSMENOS      reduce using rule 44 (m -> [ INT ] .)
    ;               reduce using rule 44 (m -> [ INT ] .)
    +               reduce using rule 44 (m -> [ INT ] .)
    ^               reduce using rule 44 (m -> [ INT ] .)
    *               reduce using rule 44 (m -> [ INT ] .)
    /               reduce using rule 44 (m -> [ INT ] .)
    %               reduce using rule 44 (m -> [ INT ] .)
    -               reduce using rule 44 (m -> [ INT ] .)
    >               reduce using rule 44 (m -> [ INT ] .)
    <               reduce using rule 44 (m -> [ INT ] .)
    EQEQ            reduce using rule 44 (m -> [ INT ] .)
    DISTINTO        reduce using rule 44 (m -> [ INT ] .)
    AND             reduce using rule 44 (m -> [ INT ] .)
    ?               reduce using rule 44 (m -> [ INT ] .)
    OR              reduce using rule 44 (m -> [ INT ] .)
    )               reduce using rule 44 (m -> [ INT ] .)
    }               reduce using rule 44 (m -> [ INT ] .)
    :               reduce using rule 44 (m -> [ INT ] .)
    ,               reduce using rule 44 (m -> [ INT ] .)
    ]               reduce using rule 44 (m -> [ INT ] .)
    [               shift and go to state 46

    m                              shift and go to state 193

state 163

    (13) if -> IF ( expBool ) . THEN bloque else

    THEN            shift and go to state 194


state 164

    (23) funcInt -> MULTIESCALAR ( vec , . eMat , param )
    (66) eMat -> . eMat + p
    (67) eMat -> . eMat - p
    (68) eMat -> . p
    (69) p -> . p * exp
    (70) p -> . p / exp
    (71) p -> . p % exp
    (72) p -> . exp
    (73) exp -> . exp ^ iSing
    (74) exp -> . iSing
    (75) iSing -> . - paren
    (76) iSing -> . + paren
    (77) iSing -> . paren
    (78) paren -> . ( eMat )
    (79) paren -> . INT
    (80) paren -> . varYVals
    (81) paren -> . FLOAT
    (82) paren -> . varsOps
    (83) paren -> . funcInt
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (49) varsOps -> . MENOSMENOS sMM
    (50) varsOps -> . MASMAS sMM
    (51) varsOps -> . sMM
    (52) varsOps -> . MENOSMENOS varYVals
    (53) varsOps -> . MASMAS varYVals
    (23) funcInt -> . MULTIESCALAR ( vec , eMat , param )
    (24) funcInt -> . LENGTH ( vec )
    (43) vecVal -> . ID m
    (54) sMM -> . varYVals MASMAS
    (55) sMM -> . varYVals MENOSMENOS

    -               shift and go to state 73
    +               shift and go to state 72
    (               shift and go to state 136
    INT             shift and go to state 79
    FLOAT           shift and go to state 80
    ID              shift and go to state 56
    MENOSMENOS      shift and go to state 30
    MASMAS          shift and go to state 27
    MULTIESCALAR    shift and go to state 22
    LENGTH          shift and go to state 25

    eMat                           shift and go to state 195
    funcInt                        shift and go to state 66
    p                              shift and go to state 82
    sMM                            shift and go to state 12
    iSing                          shift and go to state 75
    exp                            shift and go to state 84
    paren                          shift and go to state 77
    varsOps                        shift and go to state 137
    varYVals                       shift and go to state 139
    vecVal                         shift and go to state 9

state 165

    (25) funcString -> CAPITALIZAR ( expString ) .

    ;               reduce using rule 25 (funcString -> CAPITALIZAR ( expString ) .)
    +               reduce using rule 25 (funcString -> CAPITALIZAR ( expString ) .)
    }               reduce using rule 25 (funcString -> CAPITALIZAR ( expString ) .)
    )               reduce using rule 25 (funcString -> CAPITALIZAR ( expString ) .)
    ,               reduce using rule 25 (funcString -> CAPITALIZAR ( expString ) .)
    ]               reduce using rule 25 (funcString -> CAPITALIZAR ( expString ) .)


state 166

    (24) funcInt -> LENGTH ( vec ) .

    ^               reduce using rule 24 (funcInt -> LENGTH ( vec ) .)
    *               reduce using rule 24 (funcInt -> LENGTH ( vec ) .)
    /               reduce using rule 24 (funcInt -> LENGTH ( vec ) .)
    %               reduce using rule 24 (funcInt -> LENGTH ( vec ) .)
    )               reduce using rule 24 (funcInt -> LENGTH ( vec ) .)
    +               reduce using rule 24 (funcInt -> LENGTH ( vec ) .)
    -               reduce using rule 24 (funcInt -> LENGTH ( vec ) .)
    ;               reduce using rule 24 (funcInt -> LENGTH ( vec ) .)
    >               reduce using rule 24 (funcInt -> LENGTH ( vec ) .)
    <               reduce using rule 24 (funcInt -> LENGTH ( vec ) .)
    ,               reduce using rule 24 (funcInt -> LENGTH ( vec ) .)
    ]               reduce using rule 24 (funcInt -> LENGTH ( vec ) .)
    }               reduce using rule 24 (funcInt -> LENGTH ( vec ) .)
    EQEQ            reduce using rule 24 (funcInt -> LENGTH ( vec ) .)
    DISTINTO        reduce using rule 24 (funcInt -> LENGTH ( vec ) .)
    AND             reduce using rule 24 (funcInt -> LENGTH ( vec ) .)
    ?               reduce using rule 24 (funcInt -> LENGTH ( vec ) .)
    OR              reduce using rule 24 (funcInt -> LENGTH ( vec ) .)
    :               reduce using rule 24 (funcInt -> LENGTH ( vec ) .)


state 167

    (11) loop -> DO bloque WHILE ( expBool . ) ;

    )               shift and go to state 196


state 168

    (92) and -> and AND eq .
    (94) eq -> eq . EQEQ tBool
    (95) eq -> eq . DISTINTO tBool

    AND             reduce using rule 92 (and -> and AND eq .)
    ?               reduce using rule 92 (and -> and AND eq .)
    OR              reduce using rule 92 (and -> and AND eq .)
    )               reduce using rule 92 (and -> and AND eq .)
    ,               reduce using rule 92 (and -> and AND eq .)
    ]               reduce using rule 92 (and -> and AND eq .)
    }               reduce using rule 92 (and -> and AND eq .)
    ;               reduce using rule 92 (and -> and AND eq .)
    :               reduce using rule 92 (and -> and AND eq .)
    EQEQ            shift and go to state 129
    DISTINTO        shift and go to state 130


state 169

    (94) eq -> eq EQEQ tBool .

    EQEQ            reduce using rule 94 (eq -> eq EQEQ tBool .)
    DISTINTO        reduce using rule 94 (eq -> eq EQEQ tBool .)
    AND             reduce using rule 94 (eq -> eq EQEQ tBool .)
    ?               reduce using rule 94 (eq -> eq EQEQ tBool .)
    OR              reduce using rule 94 (eq -> eq EQEQ tBool .)
    )               reduce using rule 94 (eq -> eq EQEQ tBool .)
    ,               reduce using rule 94 (eq -> eq EQEQ tBool .)
    ]               reduce using rule 94 (eq -> eq EQEQ tBool .)
    ;               reduce using rule 94 (eq -> eq EQEQ tBool .)
    }               reduce using rule 94 (eq -> eq EQEQ tBool .)
    :               reduce using rule 94 (eq -> eq EQEQ tBool .)


state 170

    (95) eq -> eq DISTINTO tBool .

    EQEQ            reduce using rule 95 (eq -> eq DISTINTO tBool .)
    DISTINTO        reduce using rule 95 (eq -> eq DISTINTO tBool .)
    AND             reduce using rule 95 (eq -> eq DISTINTO tBool .)
    ?               reduce using rule 95 (eq -> eq DISTINTO tBool .)
    OR              reduce using rule 95 (eq -> eq DISTINTO tBool .)
    )               reduce using rule 95 (eq -> eq DISTINTO tBool .)
    ,               reduce using rule 95 (eq -> eq DISTINTO tBool .)
    ]               reduce using rule 95 (eq -> eq DISTINTO tBool .)
    ;               reduce using rule 95 (eq -> eq DISTINTO tBool .)
    }               reduce using rule 95 (eq -> eq DISTINTO tBool .)
    :               reduce using rule 95 (eq -> eq DISTINTO tBool .)


state 171

    (66) eMat -> eMat + p .
    (69) p -> p . * exp
    (70) p -> p . / exp
    (71) p -> p . % exp

    +               reduce using rule 66 (eMat -> eMat + p .)
    -               reduce using rule 66 (eMat -> eMat + p .)
    ;               reduce using rule 66 (eMat -> eMat + p .)
    >               reduce using rule 66 (eMat -> eMat + p .)
    <               reduce using rule 66 (eMat -> eMat + p .)
    )               reduce using rule 66 (eMat -> eMat + p .)
    }               reduce using rule 66 (eMat -> eMat + p .)
    EQEQ            reduce using rule 66 (eMat -> eMat + p .)
    DISTINTO        reduce using rule 66 (eMat -> eMat + p .)
    AND             reduce using rule 66 (eMat -> eMat + p .)
    ?               reduce using rule 66 (eMat -> eMat + p .)
    OR              reduce using rule 66 (eMat -> eMat + p .)
    :               reduce using rule 66 (eMat -> eMat + p .)
    ,               reduce using rule 66 (eMat -> eMat + p .)
    ]               reduce using rule 66 (eMat -> eMat + p .)
    *               shift and go to state 145
    /               shift and go to state 147
    %               shift and go to state 146


state 172

    (67) eMat -> eMat - p .
    (69) p -> p . * exp
    (70) p -> p . / exp
    (71) p -> p . % exp

    +               reduce using rule 67 (eMat -> eMat - p .)
    -               reduce using rule 67 (eMat -> eMat - p .)
    ;               reduce using rule 67 (eMat -> eMat - p .)
    >               reduce using rule 67 (eMat -> eMat - p .)
    <               reduce using rule 67 (eMat -> eMat - p .)
    )               reduce using rule 67 (eMat -> eMat - p .)
    }               reduce using rule 67 (eMat -> eMat - p .)
    EQEQ            reduce using rule 67 (eMat -> eMat - p .)
    DISTINTO        reduce using rule 67 (eMat -> eMat - p .)
    AND             reduce using rule 67 (eMat -> eMat - p .)
    ?               reduce using rule 67 (eMat -> eMat - p .)
    OR              reduce using rule 67 (eMat -> eMat - p .)
    :               reduce using rule 67 (eMat -> eMat - p .)
    ,               reduce using rule 67 (eMat -> eMat - p .)
    ]               reduce using rule 67 (eMat -> eMat - p .)
    *               shift and go to state 145
    /               shift and go to state 147
    %               shift and go to state 146


state 173

    (78) paren -> ( eMat ) .

    ^               reduce using rule 78 (paren -> ( eMat ) .)
    *               reduce using rule 78 (paren -> ( eMat ) .)
    /               reduce using rule 78 (paren -> ( eMat ) .)
    %               reduce using rule 78 (paren -> ( eMat ) .)
    +               reduce using rule 78 (paren -> ( eMat ) .)
    -               reduce using rule 78 (paren -> ( eMat ) .)
    >               reduce using rule 78 (paren -> ( eMat ) .)
    <               reduce using rule 78 (paren -> ( eMat ) .)
    )               reduce using rule 78 (paren -> ( eMat ) .)
    ;               reduce using rule 78 (paren -> ( eMat ) .)
    }               reduce using rule 78 (paren -> ( eMat ) .)
    EQEQ            reduce using rule 78 (paren -> ( eMat ) .)
    DISTINTO        reduce using rule 78 (paren -> ( eMat ) .)
    AND             reduce using rule 78 (paren -> ( eMat ) .)
    ?               reduce using rule 78 (paren -> ( eMat ) .)
    OR              reduce using rule 78 (paren -> ( eMat ) .)
    :               reduce using rule 78 (paren -> ( eMat ) .)
    ,               reduce using rule 78 (paren -> ( eMat ) .)
    ]               reduce using rule 78 (paren -> ( eMat ) .)


state 174

    (103) tBool -> ( expBool ) .

    EQEQ            reduce using rule 103 (tBool -> ( expBool ) .)
    DISTINTO        reduce using rule 103 (tBool -> ( expBool ) .)
    AND             reduce using rule 103 (tBool -> ( expBool ) .)
    ?               reduce using rule 103 (tBool -> ( expBool ) .)
    OR              reduce using rule 103 (tBool -> ( expBool ) .)
    )               reduce using rule 103 (tBool -> ( expBool ) .)
    ;               reduce using rule 103 (tBool -> ( expBool ) .)
    }               reduce using rule 103 (tBool -> ( expBool ) .)
    :               reduce using rule 103 (tBool -> ( expBool ) .)
    ,               reduce using rule 103 (tBool -> ( expBool ) .)
    ]               reduce using rule 103 (tBool -> ( expBool ) .)


state 175

    (78) paren -> ( eMat . )
    (66) eMat -> eMat . + p
    (67) eMat -> eMat . - p

    )               shift and go to state 173
    +               shift and go to state 131
    -               shift and go to state 132


state 176

    (99) menor -> tCompare < tCompare .

    EQEQ            reduce using rule 99 (menor -> tCompare < tCompare .)
    DISTINTO        reduce using rule 99 (menor -> tCompare < tCompare .)
    AND             reduce using rule 99 (menor -> tCompare < tCompare .)
    ?               reduce using rule 99 (menor -> tCompare < tCompare .)
    OR              reduce using rule 99 (menor -> tCompare < tCompare .)
    ,               reduce using rule 99 (menor -> tCompare < tCompare .)
    ]               reduce using rule 99 (menor -> tCompare < tCompare .)
    )               reduce using rule 99 (menor -> tCompare < tCompare .)
    ;               reduce using rule 99 (menor -> tCompare < tCompare .)
    }               reduce using rule 99 (menor -> tCompare < tCompare .)
    :               reduce using rule 99 (menor -> tCompare < tCompare .)


state 177

    (109) tCompare -> varYVals .
    (54) sMM -> varYVals . MASMAS
    (55) sMM -> varYVals . MENOSMENOS
    (80) paren -> varYVals .

  ! reduce/reduce conflict for EQEQ resolved using rule 80 (paren -> varYVals .)
  ! reduce/reduce conflict for DISTINTO resolved using rule 80 (paren -> varYVals .)
  ! reduce/reduce conflict for AND resolved using rule 80 (paren -> varYVals .)
  ! reduce/reduce conflict for ? resolved using rule 80 (paren -> varYVals .)
  ! reduce/reduce conflict for OR resolved using rule 80 (paren -> varYVals .)
  ! reduce/reduce conflict for ) resolved using rule 80 (paren -> varYVals .)
  ! reduce/reduce conflict for ; resolved using rule 80 (paren -> varYVals .)
  ! reduce/reduce conflict for } resolved using rule 80 (paren -> varYVals .)
  ! reduce/reduce conflict for : resolved using rule 80 (paren -> varYVals .)
  ! reduce/reduce conflict for , resolved using rule 80 (paren -> varYVals .)
  ! reduce/reduce conflict for ] resolved using rule 80 (paren -> varYVals .)
    MASMAS          shift and go to state 58
    MENOSMENOS      shift and go to state 59
    ^               reduce using rule 80 (paren -> varYVals .)
    *               reduce using rule 80 (paren -> varYVals .)
    /               reduce using rule 80 (paren -> varYVals .)
    %               reduce using rule 80 (paren -> varYVals .)
    +               reduce using rule 80 (paren -> varYVals .)
    -               reduce using rule 80 (paren -> varYVals .)
    EQEQ            reduce using rule 80 (paren -> varYVals .)
    DISTINTO        reduce using rule 80 (paren -> varYVals .)
    AND             reduce using rule 80 (paren -> varYVals .)
    ?               reduce using rule 80 (paren -> varYVals .)
    OR              reduce using rule 80 (paren -> varYVals .)
    )               reduce using rule 80 (paren -> varYVals .)
    ;               reduce using rule 80 (paren -> varYVals .)
    }               reduce using rule 80 (paren -> varYVals .)
    :               reduce using rule 80 (paren -> varYVals .)
    ,               reduce using rule 80 (paren -> varYVals .)
    ]               reduce using rule 80 (paren -> varYVals .)

  ! EQEQ            [ reduce using rule 109 (tCompare -> varYVals .) ]
  ! DISTINTO        [ reduce using rule 109 (tCompare -> varYVals .) ]
  ! AND             [ reduce using rule 109 (tCompare -> varYVals .) ]
  ! ?               [ reduce using rule 109 (tCompare -> varYVals .) ]
  ! OR              [ reduce using rule 109 (tCompare -> varYVals .) ]
  ! )               [ reduce using rule 109 (tCompare -> varYVals .) ]
  ! ;               [ reduce using rule 109 (tCompare -> varYVals .) ]
  ! }               [ reduce using rule 109 (tCompare -> varYVals .) ]
  ! :               [ reduce using rule 109 (tCompare -> varYVals .) ]
  ! ,               [ reduce using rule 109 (tCompare -> varYVals .) ]
  ! ]               [ reduce using rule 109 (tCompare -> varYVals .) ]


state 178

    (97) mayor -> tCompare > tCompare .

    EQEQ            reduce using rule 97 (mayor -> tCompare > tCompare .)
    DISTINTO        reduce using rule 97 (mayor -> tCompare > tCompare .)
    AND             reduce using rule 97 (mayor -> tCompare > tCompare .)
    ?               reduce using rule 97 (mayor -> tCompare > tCompare .)
    OR              reduce using rule 97 (mayor -> tCompare > tCompare .)
    )               reduce using rule 97 (mayor -> tCompare > tCompare .)
    ;               reduce using rule 97 (mayor -> tCompare > tCompare .)
    }               reduce using rule 97 (mayor -> tCompare > tCompare .)
    :               reduce using rule 97 (mayor -> tCompare > tCompare .)
    ,               reduce using rule 97 (mayor -> tCompare > tCompare .)
    ]               reduce using rule 97 (mayor -> tCompare > tCompare .)


state 179

    (90) or -> or OR and .
    (92) and -> and . AND eq

    ?               reduce using rule 90 (or -> or OR and .)
    OR              reduce using rule 90 (or -> or OR and .)
    ;               reduce using rule 90 (or -> or OR and .)
    )               reduce using rule 90 (or -> or OR and .)
    }               reduce using rule 90 (or -> or OR and .)
    :               reduce using rule 90 (or -> or OR and .)
    ,               reduce using rule 90 (or -> or OR and .)
    ]               reduce using rule 90 (or -> or OR and .)
    AND             shift and go to state 128


state 180

    (88) expBool -> or ? expBool . : expBool

    :               shift and go to state 197


state 181

    (69) p -> p * exp .
    (73) exp -> exp . ^ iSing

    *               reduce using rule 69 (p -> p * exp .)
    /               reduce using rule 69 (p -> p * exp .)
    %               reduce using rule 69 (p -> p * exp .)
    +               reduce using rule 69 (p -> p * exp .)
    -               reduce using rule 69 (p -> p * exp .)
    )               reduce using rule 69 (p -> p * exp .)
    >               reduce using rule 69 (p -> p * exp .)
    <               reduce using rule 69 (p -> p * exp .)
    ;               reduce using rule 69 (p -> p * exp .)
    }               reduce using rule 69 (p -> p * exp .)
    EQEQ            reduce using rule 69 (p -> p * exp .)
    DISTINTO        reduce using rule 69 (p -> p * exp .)
    AND             reduce using rule 69 (p -> p * exp .)
    ?               reduce using rule 69 (p -> p * exp .)
    OR              reduce using rule 69 (p -> p * exp .)
    :               reduce using rule 69 (p -> p * exp .)
    ,               reduce using rule 69 (p -> p * exp .)
    ]               reduce using rule 69 (p -> p * exp .)
    ^               shift and go to state 148


state 182

    (71) p -> p % exp .
    (73) exp -> exp . ^ iSing

    *               reduce using rule 71 (p -> p % exp .)
    /               reduce using rule 71 (p -> p % exp .)
    %               reduce using rule 71 (p -> p % exp .)
    +               reduce using rule 71 (p -> p % exp .)
    -               reduce using rule 71 (p -> p % exp .)
    )               reduce using rule 71 (p -> p % exp .)
    >               reduce using rule 71 (p -> p % exp .)
    <               reduce using rule 71 (p -> p % exp .)
    ;               reduce using rule 71 (p -> p % exp .)
    }               reduce using rule 71 (p -> p % exp .)
    EQEQ            reduce using rule 71 (p -> p % exp .)
    DISTINTO        reduce using rule 71 (p -> p % exp .)
    AND             reduce using rule 71 (p -> p % exp .)
    ?               reduce using rule 71 (p -> p % exp .)
    OR              reduce using rule 71 (p -> p % exp .)
    :               reduce using rule 71 (p -> p % exp .)
    ,               reduce using rule 71 (p -> p % exp .)
    ]               reduce using rule 71 (p -> p % exp .)
    ^               shift and go to state 148


state 183

    (70) p -> p / exp .
    (73) exp -> exp . ^ iSing

    *               reduce using rule 70 (p -> p / exp .)
    /               reduce using rule 70 (p -> p / exp .)
    %               reduce using rule 70 (p -> p / exp .)
    +               reduce using rule 70 (p -> p / exp .)
    -               reduce using rule 70 (p -> p / exp .)
    )               reduce using rule 70 (p -> p / exp .)
    >               reduce using rule 70 (p -> p / exp .)
    <               reduce using rule 70 (p -> p / exp .)
    ;               reduce using rule 70 (p -> p / exp .)
    }               reduce using rule 70 (p -> p / exp .)
    EQEQ            reduce using rule 70 (p -> p / exp .)
    DISTINTO        reduce using rule 70 (p -> p / exp .)
    AND             reduce using rule 70 (p -> p / exp .)
    ?               reduce using rule 70 (p -> p / exp .)
    OR              reduce using rule 70 (p -> p / exp .)
    :               reduce using rule 70 (p -> p / exp .)
    ,               reduce using rule 70 (p -> p / exp .)
    ]               reduce using rule 70 (p -> p / exp .)
    ^               shift and go to state 148


state 184

    (73) exp -> exp ^ iSing .

    ^               reduce using rule 73 (exp -> exp ^ iSing .)
    *               reduce using rule 73 (exp -> exp ^ iSing .)
    /               reduce using rule 73 (exp -> exp ^ iSing .)
    %               reduce using rule 73 (exp -> exp ^ iSing .)
    +               reduce using rule 73 (exp -> exp ^ iSing .)
    -               reduce using rule 73 (exp -> exp ^ iSing .)
    >               reduce using rule 73 (exp -> exp ^ iSing .)
    <               reduce using rule 73 (exp -> exp ^ iSing .)
    ,               reduce using rule 73 (exp -> exp ^ iSing .)
    ;               reduce using rule 73 (exp -> exp ^ iSing .)
    }               reduce using rule 73 (exp -> exp ^ iSing .)
    EQEQ            reduce using rule 73 (exp -> exp ^ iSing .)
    DISTINTO        reduce using rule 73 (exp -> exp ^ iSing .)
    AND             reduce using rule 73 (exp -> exp ^ iSing .)
    ?               reduce using rule 73 (exp -> exp ^ iSing .)
    OR              reduce using rule 73 (exp -> exp ^ iSing .)
    )               reduce using rule 73 (exp -> exp ^ iSing .)
    :               reduce using rule 73 (exp -> exp ^ iSing .)
    ]               reduce using rule 73 (exp -> exp ^ iSing .)


state 185

    (10) loop -> WHILE ( expBool ) bloque .

    RETURN          reduce using rule 10 (loop -> WHILE ( expBool ) bloque .)
    MENOSMENOS      reduce using rule 10 (loop -> WHILE ( expBool ) bloque .)
    MASMAS          reduce using rule 10 (loop -> WHILE ( expBool ) bloque .)
    ID              reduce using rule 10 (loop -> WHILE ( expBool ) bloque .)
    IF              reduce using rule 10 (loop -> WHILE ( expBool ) bloque .)
    WHILE           reduce using rule 10 (loop -> WHILE ( expBool ) bloque .)
    DO              reduce using rule 10 (loop -> WHILE ( expBool ) bloque .)
    FOR             reduce using rule 10 (loop -> WHILE ( expBool ) bloque .)
    PRINT           reduce using rule 10 (loop -> WHILE ( expBool ) bloque .)
    MULTIESCALAR    reduce using rule 10 (loop -> WHILE ( expBool ) bloque .)
    LENGTH          reduce using rule 10 (loop -> WHILE ( expBool ) bloque .)
    CAPITALIZAR     reduce using rule 10 (loop -> WHILE ( expBool ) bloque .)
    COLINEALES      reduce using rule 10 (loop -> WHILE ( expBool ) bloque .)
    $end            reduce using rule 10 (loop -> WHILE ( expBool ) bloque .)
    }               reduce using rule 10 (loop -> WHILE ( expBool ) bloque .)


state 186

    (84) expString -> expString + STRING .

    +               reduce using rule 84 (expString -> expString + STRING .)
    }               reduce using rule 84 (expString -> expString + STRING .)
    ,               reduce using rule 84 (expString -> expString + STRING .)
    ]               reduce using rule 84 (expString -> expString + STRING .)
    )               reduce using rule 84 (expString -> expString + STRING .)
    ;               reduce using rule 84 (expString -> expString + STRING .)


state 187

    (40) valores -> ID . ID .

    ,               reduce using rule 40 (valores -> ID . ID .)
    ]               reduce using rule 40 (valores -> ID . ID .)
    }               reduce using rule 40 (valores -> ID . ID .)
    ;               reduce using rule 40 (valores -> ID . ID .)
    )               reduce using rule 40 (valores -> ID . ID .)


state 188

    (46) reg -> { campos } .

    ,               reduce using rule 46 (reg -> { campos } .)
    ]               reduce using rule 46 (reg -> { campos } .)
    ;               reduce using rule 46 (reg -> { campos } .)
    )               reduce using rule 46 (reg -> { campos } .)
    }               reduce using rule 46 (reg -> { campos } .)


state 189

    (47) campos -> ID : . valores , campos
    (34) valores -> . eMat
    (35) valores -> . expBool
    (36) valores -> . expString
    (37) valores -> . varYVals
    (38) valores -> . funcReturn
    (39) valores -> . reg
    (40) valores -> . ID . ID
    (66) eMat -> . eMat + p
    (67) eMat -> . eMat - p
    (68) eMat -> . p
    (88) expBool -> . or ? expBool : expBool
    (89) expBool -> . or
    (84) expString -> . expString + STRING
    (85) expString -> . STRING
    (86) expString -> . varYVals
    (87) expString -> . funcString
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (20) funcReturn -> . funcInt
    (21) funcReturn -> . funcString
    (22) funcReturn -> . funcBool
    (46) reg -> . { campos }
    (69) p -> . p * exp
    (70) p -> . p / exp
    (71) p -> . p % exp
    (72) p -> . exp
    (90) or -> . or OR and
    (91) or -> . and
    (25) funcString -> . CAPITALIZAR ( expString )
    (43) vecVal -> . ID m
    (23) funcInt -> . MULTIESCALAR ( vec , eMat , param )
    (24) funcInt -> . LENGTH ( vec )
    (26) funcBool -> . COLINEALES ( vec , vec )
    (73) exp -> . exp ^ iSing
    (74) exp -> . iSing
    (92) and -> . and AND eq
    (93) and -> . eq
    (75) iSing -> . - paren
    (76) iSing -> . + paren
    (77) iSing -> . paren
    (94) eq -> . eq EQEQ tBool
    (95) eq -> . eq DISTINTO tBool
    (96) eq -> . mayor
    (78) paren -> . ( eMat )
    (79) paren -> . INT
    (80) paren -> . varYVals
    (81) paren -> . FLOAT
    (82) paren -> . varsOps
    (83) paren -> . funcInt
    (97) mayor -> . tCompare > tCompare
    (98) mayor -> . menor
    (49) varsOps -> . MENOSMENOS sMM
    (50) varsOps -> . MASMAS sMM
    (51) varsOps -> . sMM
    (52) varsOps -> . MENOSMENOS varYVals
    (53) varsOps -> . MASMAS varYVals
    (107) tCompare -> . eMat
    (108) tCompare -> . varsOps
    (109) tCompare -> . varYVals
    (99) menor -> . tCompare < tCompare
    (100) menor -> . not
    (54) sMM -> . varYVals MASMAS
    (55) sMM -> . varYVals MENOSMENOS
    (101) not -> . NOT not
    (102) not -> . tBool
    (103) tBool -> . ( expBool )
    (104) tBool -> . BOOL
    (105) tBool -> . varYVals
    (106) tBool -> . funcBool

    ID              shift and go to state 97
    STRING          shift and go to state 95
    {               shift and go to state 101
    CAPITALIZAR     shift and go to state 24
    MULTIESCALAR    shift and go to state 22
    LENGTH          shift and go to state 25
    COLINEALES      shift and go to state 14
    -               shift and go to state 73
    +               shift and go to state 72
    (               shift and go to state 92
    INT             shift and go to state 79
    FLOAT           shift and go to state 80
    MENOSMENOS      shift and go to state 30
    MASMAS          shift and go to state 27
    NOT             shift and go to state 85
    BOOL            shift and go to state 74

    and                            shift and go to state 64
    funcBool                       shift and go to state 89
    funcInt                        shift and go to state 90
    menor                          shift and go to state 67
    eq                             shift and go to state 68
    vecVal                         shift and go to state 9
    eMat                           shift and go to state 91
    mayor                          shift and go to state 69
    sMM                            shift and go to state 12
    paren                          shift and go to state 77
    reg                            shift and go to state 93
    varsOps                        shift and go to state 94
    expString                      shift and go to state 96
    tCompare                       shift and go to state 76
    not                            shift and go to state 78
    funcString                     shift and go to state 98
    funcReturn                     shift and go to state 99
    valores                        shift and go to state 198
    p                              shift and go to state 82
    iSing                          shift and go to state 75
    exp                            shift and go to state 84
    tBool                          shift and go to state 86
    varYVals                       shift and go to state 102
    or                             shift and go to state 81
    expBool                        shift and go to state 103

state 190

    (26) funcBool -> COLINEALES ( vec , vec . )

    )               shift and go to state 199


state 191

    (31) vec -> ID = [ . elem ]
    (32) elem -> . valores , elem
    (33) elem -> . valores
    (34) valores -> . eMat
    (35) valores -> . expBool
    (36) valores -> . expString
    (37) valores -> . varYVals
    (38) valores -> . funcReturn
    (39) valores -> . reg
    (40) valores -> . ID . ID
    (66) eMat -> . eMat + p
    (67) eMat -> . eMat - p
    (68) eMat -> . p
    (88) expBool -> . or ? expBool : expBool
    (89) expBool -> . or
    (84) expString -> . expString + STRING
    (85) expString -> . STRING
    (86) expString -> . varYVals
    (87) expString -> . funcString
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (20) funcReturn -> . funcInt
    (21) funcReturn -> . funcString
    (22) funcReturn -> . funcBool
    (46) reg -> . { campos }
    (69) p -> . p * exp
    (70) p -> . p / exp
    (71) p -> . p % exp
    (72) p -> . exp
    (90) or -> . or OR and
    (91) or -> . and
    (25) funcString -> . CAPITALIZAR ( expString )
    (43) vecVal -> . ID m
    (23) funcInt -> . MULTIESCALAR ( vec , eMat , param )
    (24) funcInt -> . LENGTH ( vec )
    (26) funcBool -> . COLINEALES ( vec , vec )
    (73) exp -> . exp ^ iSing
    (74) exp -> . iSing
    (92) and -> . and AND eq
    (93) and -> . eq
    (75) iSing -> . - paren
    (76) iSing -> . + paren
    (77) iSing -> . paren
    (94) eq -> . eq EQEQ tBool
    (95) eq -> . eq DISTINTO tBool
    (96) eq -> . mayor
    (78) paren -> . ( eMat )
    (79) paren -> . INT
    (80) paren -> . varYVals
    (81) paren -> . FLOAT
    (82) paren -> . varsOps
    (83) paren -> . funcInt
    (97) mayor -> . tCompare > tCompare
    (98) mayor -> . menor
    (49) varsOps -> . MENOSMENOS sMM
    (50) varsOps -> . MASMAS sMM
    (51) varsOps -> . sMM
    (52) varsOps -> . MENOSMENOS varYVals
    (53) varsOps -> . MASMAS varYVals
    (107) tCompare -> . eMat
    (108) tCompare -> . varsOps
    (109) tCompare -> . varYVals
    (99) menor -> . tCompare < tCompare
    (100) menor -> . not
    (54) sMM -> . varYVals MASMAS
    (55) sMM -> . varYVals MENOSMENOS
    (101) not -> . NOT not
    (102) not -> . tBool
    (103) tBool -> . ( expBool )
    (104) tBool -> . BOOL
    (105) tBool -> . varYVals
    (106) tBool -> . funcBool

    ID              shift and go to state 97
    STRING          shift and go to state 95
    {               shift and go to state 101
    CAPITALIZAR     shift and go to state 24
    MULTIESCALAR    shift and go to state 22
    LENGTH          shift and go to state 25
    COLINEALES      shift and go to state 14
    -               shift and go to state 73
    +               shift and go to state 72
    (               shift and go to state 92
    INT             shift and go to state 79
    FLOAT           shift and go to state 80
    MENOSMENOS      shift and go to state 30
    MASMAS          shift and go to state 27
    NOT             shift and go to state 85
    BOOL            shift and go to state 74

    and                            shift and go to state 64
    funcBool                       shift and go to state 89
    funcInt                        shift and go to state 90
    valores                        shift and go to state 201
    menor                          shift and go to state 67
    eq                             shift and go to state 68
    vecVal                         shift and go to state 9
    eMat                           shift and go to state 91
    mayor                          shift and go to state 69
    sMM                            shift and go to state 12
    paren                          shift and go to state 77
    reg                            shift and go to state 93
    varsOps                        shift and go to state 94
    expString                      shift and go to state 96
    tCompare                       shift and go to state 76
    not                            shift and go to state 78
    funcString                     shift and go to state 98
    funcReturn                     shift and go to state 99
    elem                           shift and go to state 200
    p                              shift and go to state 82
    iSing                          shift and go to state 75
    exp                            shift and go to state 84
    tBool                          shift and go to state 86
    varYVals                       shift and go to state 102
    or                             shift and go to state 81
    expBool                        shift and go to state 103

state 192

    (12) loop -> FOR ( varAsig ; expBool . ; varsOps ) bloque

    ;               shift and go to state 202


state 193

    (45) m -> [ INT ] m .

    MASMAS          reduce using rule 45 (m -> [ INT ] m .)
    MENOSMENOS      reduce using rule 45 (m -> [ INT ] m .)
    ;               reduce using rule 45 (m -> [ INT ] m .)
    +               reduce using rule 45 (m -> [ INT ] m .)
    ^               reduce using rule 45 (m -> [ INT ] m .)
    *               reduce using rule 45 (m -> [ INT ] m .)
    /               reduce using rule 45 (m -> [ INT ] m .)
    %               reduce using rule 45 (m -> [ INT ] m .)
    -               reduce using rule 45 (m -> [ INT ] m .)
    >               reduce using rule 45 (m -> [ INT ] m .)
    <               reduce using rule 45 (m -> [ INT ] m .)
    EQEQ            reduce using rule 45 (m -> [ INT ] m .)
    DISTINTO        reduce using rule 45 (m -> [ INT ] m .)
    AND             reduce using rule 45 (m -> [ INT ] m .)
    ?               reduce using rule 45 (m -> [ INT ] m .)
    OR              reduce using rule 45 (m -> [ INT ] m .)
    )               reduce using rule 45 (m -> [ INT ] m .)
    }               reduce using rule 45 (m -> [ INT ] m .)
    :               reduce using rule 45 (m -> [ INT ] m .)
    ,               reduce using rule 45 (m -> [ INT ] m .)
    ]               reduce using rule 45 (m -> [ INT ] m .)


state 194

    (13) if -> IF ( expBool ) THEN . bloque else
    (16) bloque -> . sentencia
    (17) bloque -> . { g }
    (4) sentencia -> . varsOps ;
    (5) sentencia -> . func ;
    (6) sentencia -> . varAsig ;
    (7) sentencia -> . RETURN ;
    (49) varsOps -> . MENOSMENOS sMM
    (50) varsOps -> . MASMAS sMM
    (51) varsOps -> . sMM
    (52) varsOps -> . MENOSMENOS varYVals
    (53) varsOps -> . MASMAS varYVals
    (18) func -> . funcReturn
    (19) func -> . funcVoid
    (56) varAsig -> . ID MENOSEQ varAsig
    (57) varAsig -> . ID MASEQ varAsig
    (58) varAsig -> . ID MULEQ varAsig
    (59) varAsig -> . ID DIVEQ varAsig
    (60) varAsig -> . ID = varAsig
    (61) varAsig -> . ID MASEQ valores
    (62) varAsig -> . ID MENOSEQ valores
    (63) varAsig -> . ID MULEQ valores
    (64) varAsig -> . ID DIVEQ valores
    (65) varAsig -> . ID = valores
    (54) sMM -> . varYVals MASMAS
    (55) sMM -> . varYVals MENOSMENOS
    (20) funcReturn -> . funcInt
    (21) funcReturn -> . funcString
    (22) funcReturn -> . funcBool
    (27) funcVoid -> . PRINT ( valores )
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (23) funcInt -> . MULTIESCALAR ( vec , eMat , param )
    (24) funcInt -> . LENGTH ( vec )
    (25) funcString -> . CAPITALIZAR ( expString )
    (26) funcBool -> . COLINEALES ( vec , vec )
    (43) vecVal -> . ID m

    {               shift and go to state 33
    RETURN          shift and go to state 2
    MENOSMENOS      shift and go to state 30
    MASMAS          shift and go to state 27
    ID              shift and go to state 17
    PRINT           shift and go to state 8
    MULTIESCALAR    shift and go to state 22
    LENGTH          shift and go to state 25
    CAPITALIZAR     shift and go to state 24
    COLINEALES      shift and go to state 14

    funcBool                       shift and go to state 3
    funcInt                        shift and go to state 5
    bloque                         shift and go to state 203
    vecVal                         shift and go to state 9
    sentencia                      shift and go to state 32
    sMM                            shift and go to state 12
    funcVoid                       shift and go to state 13
    func                           shift and go to state 16
    varAsig                        shift and go to state 19
    funcString                     shift and go to state 21
    funcReturn                     shift and go to state 23
    varsOps                        shift and go to state 28
    varYVals                       shift and go to state 29

state 195

    (23) funcInt -> MULTIESCALAR ( vec , eMat . , param )
    (66) eMat -> eMat . + p
    (67) eMat -> eMat . - p

    ,               shift and go to state 204
    +               shift and go to state 131
    -               shift and go to state 132


state 196

    (11) loop -> DO bloque WHILE ( expBool ) . ;

    ;               shift and go to state 205


state 197

    (88) expBool -> or ? expBool : . expBool
    (88) expBool -> . or ? expBool : expBool
    (89) expBool -> . or
    (90) or -> . or OR and
    (91) or -> . and
    (92) and -> . and AND eq
    (93) and -> . eq
    (94) eq -> . eq EQEQ tBool
    (95) eq -> . eq DISTINTO tBool
    (96) eq -> . mayor
    (97) mayor -> . tCompare > tCompare
    (98) mayor -> . menor
    (107) tCompare -> . eMat
    (108) tCompare -> . varsOps
    (109) tCompare -> . varYVals
    (99) menor -> . tCompare < tCompare
    (100) menor -> . not
    (66) eMat -> . eMat + p
    (67) eMat -> . eMat - p
    (68) eMat -> . p
    (49) varsOps -> . MENOSMENOS sMM
    (50) varsOps -> . MASMAS sMM
    (51) varsOps -> . sMM
    (52) varsOps -> . MENOSMENOS varYVals
    (53) varsOps -> . MASMAS varYVals
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (101) not -> . NOT not
    (102) not -> . tBool
    (69) p -> . p * exp
    (70) p -> . p / exp
    (71) p -> . p % exp
    (72) p -> . exp
    (54) sMM -> . varYVals MASMAS
    (55) sMM -> . varYVals MENOSMENOS
    (43) vecVal -> . ID m
    (103) tBool -> . ( expBool )
    (104) tBool -> . BOOL
    (105) tBool -> . varYVals
    (106) tBool -> . funcBool
    (73) exp -> . exp ^ iSing
    (74) exp -> . iSing
    (26) funcBool -> . COLINEALES ( vec , vec )
    (75) iSing -> . - paren
    (76) iSing -> . + paren
    (77) iSing -> . paren
    (78) paren -> . ( eMat )
    (79) paren -> . INT
    (80) paren -> . varYVals
    (81) paren -> . FLOAT
    (82) paren -> . varsOps
    (83) paren -> . funcInt
    (23) funcInt -> . MULTIESCALAR ( vec , eMat , param )
    (24) funcInt -> . LENGTH ( vec )

    MENOSMENOS      shift and go to state 30
    MASMAS          shift and go to state 27
    ID              shift and go to state 56
    NOT             shift and go to state 85
    (               shift and go to state 71
    BOOL            shift and go to state 74
    COLINEALES      shift and go to state 14
    -               shift and go to state 73
    +               shift and go to state 72
    INT             shift and go to state 79
    FLOAT           shift and go to state 80
    MULTIESCALAR    shift and go to state 22
    LENGTH          shift and go to state 25

    and                            shift and go to state 64
    funcBool                       shift and go to state 65
    funcInt                        shift and go to state 66
    menor                          shift and go to state 67
    eq                             shift and go to state 68
    mayor                          shift and go to state 69
    eMat                           shift and go to state 70
    vecVal                         shift and go to state 9
    sMM                            shift and go to state 12
    paren                          shift and go to state 77
    iSing                          shift and go to state 75
    tCompare                       shift and go to state 76
    not                            shift and go to state 78
    p                              shift and go to state 82
    varsOps                        shift and go to state 83
    exp                            shift and go to state 84
    tBool                          shift and go to state 86
    varYVals                       shift and go to state 87
    or                             shift and go to state 81
    expBool                        shift and go to state 206

state 198

    (47) campos -> ID : valores . , campos

    ,               shift and go to state 207


state 199

    (26) funcBool -> COLINEALES ( vec , vec ) .

    ,               reduce using rule 26 (funcBool -> COLINEALES ( vec , vec ) .)
    EQEQ            reduce using rule 26 (funcBool -> COLINEALES ( vec , vec ) .)
    DISTINTO        reduce using rule 26 (funcBool -> COLINEALES ( vec , vec ) .)
    AND             reduce using rule 26 (funcBool -> COLINEALES ( vec , vec ) .)
    ?               reduce using rule 26 (funcBool -> COLINEALES ( vec , vec ) .)
    OR              reduce using rule 26 (funcBool -> COLINEALES ( vec , vec ) .)
    )               reduce using rule 26 (funcBool -> COLINEALES ( vec , vec ) .)
    ]               reduce using rule 26 (funcBool -> COLINEALES ( vec , vec ) .)
    ;               reduce using rule 26 (funcBool -> COLINEALES ( vec , vec ) .)
    }               reduce using rule 26 (funcBool -> COLINEALES ( vec , vec ) .)
    :               reduce using rule 26 (funcBool -> COLINEALES ( vec , vec ) .)


state 200

    (31) vec -> ID = [ elem . ]

    ]               shift and go to state 208


state 201

    (32) elem -> valores . , elem
    (33) elem -> valores .

    ,               shift and go to state 209
    ]               reduce using rule 33 (elem -> valores .)


state 202

    (12) loop -> FOR ( varAsig ; expBool ; . varsOps ) bloque
    (49) varsOps -> . MENOSMENOS sMM
    (50) varsOps -> . MASMAS sMM
    (51) varsOps -> . sMM
    (52) varsOps -> . MENOSMENOS varYVals
    (53) varsOps -> . MASMAS varYVals
    (54) sMM -> . varYVals MASMAS
    (55) sMM -> . varYVals MENOSMENOS
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (43) vecVal -> . ID m

    MENOSMENOS      shift and go to state 30
    MASMAS          shift and go to state 27
    ID              shift and go to state 56

    sMM                            shift and go to state 12
    varsOps                        shift and go to state 210
    varYVals                       shift and go to state 29
    vecVal                         shift and go to state 9

state 203

    (13) if -> IF ( expBool ) THEN bloque . else
    (14) else -> . ELSE bloque
    (15) else -> . empty
    (30) empty -> .

    ELSE            shift and go to state 213
    RETURN          reduce using rule 30 (empty -> .)
    MENOSMENOS      reduce using rule 30 (empty -> .)
    MASMAS          reduce using rule 30 (empty -> .)
    ID              reduce using rule 30 (empty -> .)
    IF              reduce using rule 30 (empty -> .)
    WHILE           reduce using rule 30 (empty -> .)
    DO              reduce using rule 30 (empty -> .)
    FOR             reduce using rule 30 (empty -> .)
    PRINT           reduce using rule 30 (empty -> .)
    MULTIESCALAR    reduce using rule 30 (empty -> .)
    LENGTH          reduce using rule 30 (empty -> .)
    CAPITALIZAR     reduce using rule 30 (empty -> .)
    COLINEALES      reduce using rule 30 (empty -> .)
    $end            reduce using rule 30 (empty -> .)
    }               reduce using rule 30 (empty -> .)

    empty                          shift and go to state 212
    else                           shift and go to state 211

state 204

    (23) funcInt -> MULTIESCALAR ( vec , eMat , . param )
    (28) param -> . expBool
    (29) param -> . empty
    (88) expBool -> . or ? expBool : expBool
    (89) expBool -> . or
    (30) empty -> .
    (90) or -> . or OR and
    (91) or -> . and
    (92) and -> . and AND eq
    (93) and -> . eq
    (94) eq -> . eq EQEQ tBool
    (95) eq -> . eq DISTINTO tBool
    (96) eq -> . mayor
    (97) mayor -> . tCompare > tCompare
    (98) mayor -> . menor
    (107) tCompare -> . eMat
    (108) tCompare -> . varsOps
    (109) tCompare -> . varYVals
    (99) menor -> . tCompare < tCompare
    (100) menor -> . not
    (66) eMat -> . eMat + p
    (67) eMat -> . eMat - p
    (68) eMat -> . p
    (49) varsOps -> . MENOSMENOS sMM
    (50) varsOps -> . MASMAS sMM
    (51) varsOps -> . sMM
    (52) varsOps -> . MENOSMENOS varYVals
    (53) varsOps -> . MASMAS varYVals
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (101) not -> . NOT not
    (102) not -> . tBool
    (69) p -> . p * exp
    (70) p -> . p / exp
    (71) p -> . p % exp
    (72) p -> . exp
    (54) sMM -> . varYVals MASMAS
    (55) sMM -> . varYVals MENOSMENOS
    (43) vecVal -> . ID m
    (103) tBool -> . ( expBool )
    (104) tBool -> . BOOL
    (105) tBool -> . varYVals
    (106) tBool -> . funcBool
    (73) exp -> . exp ^ iSing
    (74) exp -> . iSing
    (26) funcBool -> . COLINEALES ( vec , vec )
    (75) iSing -> . - paren
    (76) iSing -> . + paren
    (77) iSing -> . paren
    (78) paren -> . ( eMat )
    (79) paren -> . INT
    (80) paren -> . varYVals
    (81) paren -> . FLOAT
    (82) paren -> . varsOps
    (83) paren -> . funcInt
    (23) funcInt -> . MULTIESCALAR ( vec , eMat , param )
    (24) funcInt -> . LENGTH ( vec )

    )               reduce using rule 30 (empty -> .)
    MENOSMENOS      shift and go to state 30
    MASMAS          shift and go to state 27
    ID              shift and go to state 56
    NOT             shift and go to state 85
    (               shift and go to state 71
    BOOL            shift and go to state 74
    COLINEALES      shift and go to state 14
    -               shift and go to state 73
    +               shift and go to state 72
    INT             shift and go to state 79
    FLOAT           shift and go to state 80
    MULTIESCALAR    shift and go to state 22
    LENGTH          shift and go to state 25

    and                            shift and go to state 64
    funcBool                       shift and go to state 65
    funcInt                        shift and go to state 66
    menor                          shift and go to state 67
    eq                             shift and go to state 68
    mayor                          shift and go to state 69
    eMat                           shift and go to state 70
    param                          shift and go to state 214
    vecVal                         shift and go to state 9
    sMM                            shift and go to state 12
    paren                          shift and go to state 77
    empty                          shift and go to state 215
    varsOps                        shift and go to state 83
    tCompare                       shift and go to state 76
    not                            shift and go to state 78
    p                              shift and go to state 82
    iSing                          shift and go to state 75
    exp                            shift and go to state 84
    tBool                          shift and go to state 86
    varYVals                       shift and go to state 87
    or                             shift and go to state 81
    expBool                        shift and go to state 216

state 205

    (11) loop -> DO bloque WHILE ( expBool ) ; .

    RETURN          reduce using rule 11 (loop -> DO bloque WHILE ( expBool ) ; .)
    MENOSMENOS      reduce using rule 11 (loop -> DO bloque WHILE ( expBool ) ; .)
    MASMAS          reduce using rule 11 (loop -> DO bloque WHILE ( expBool ) ; .)
    ID              reduce using rule 11 (loop -> DO bloque WHILE ( expBool ) ; .)
    IF              reduce using rule 11 (loop -> DO bloque WHILE ( expBool ) ; .)
    WHILE           reduce using rule 11 (loop -> DO bloque WHILE ( expBool ) ; .)
    DO              reduce using rule 11 (loop -> DO bloque WHILE ( expBool ) ; .)
    FOR             reduce using rule 11 (loop -> DO bloque WHILE ( expBool ) ; .)
    PRINT           reduce using rule 11 (loop -> DO bloque WHILE ( expBool ) ; .)
    MULTIESCALAR    reduce using rule 11 (loop -> DO bloque WHILE ( expBool ) ; .)
    LENGTH          reduce using rule 11 (loop -> DO bloque WHILE ( expBool ) ; .)
    CAPITALIZAR     reduce using rule 11 (loop -> DO bloque WHILE ( expBool ) ; .)
    COLINEALES      reduce using rule 11 (loop -> DO bloque WHILE ( expBool ) ; .)
    $end            reduce using rule 11 (loop -> DO bloque WHILE ( expBool ) ; .)
    }               reduce using rule 11 (loop -> DO bloque WHILE ( expBool ) ; .)


state 206

    (88) expBool -> or ? expBool : expBool .

    }               reduce using rule 88 (expBool -> or ? expBool : expBool .)
    )               reduce using rule 88 (expBool -> or ? expBool : expBool .)
    ;               reduce using rule 88 (expBool -> or ? expBool : expBool .)
    :               reduce using rule 88 (expBool -> or ? expBool : expBool .)
    ,               reduce using rule 88 (expBool -> or ? expBool : expBool .)
    ]               reduce using rule 88 (expBool -> or ? expBool : expBool .)


state 207

    (47) campos -> ID : valores , . campos
    (47) campos -> . ID : valores , campos
    (48) campos -> . valores
    (34) valores -> . eMat
    (35) valores -> . expBool
    (36) valores -> . expString
    (37) valores -> . varYVals
    (38) valores -> . funcReturn
    (39) valores -> . reg
    (40) valores -> . ID . ID
    (66) eMat -> . eMat + p
    (67) eMat -> . eMat - p
    (68) eMat -> . p
    (88) expBool -> . or ? expBool : expBool
    (89) expBool -> . or
    (84) expString -> . expString + STRING
    (85) expString -> . STRING
    (86) expString -> . varYVals
    (87) expString -> . funcString
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (20) funcReturn -> . funcInt
    (21) funcReturn -> . funcString
    (22) funcReturn -> . funcBool
    (46) reg -> . { campos }
    (69) p -> . p * exp
    (70) p -> . p / exp
    (71) p -> . p % exp
    (72) p -> . exp
    (90) or -> . or OR and
    (91) or -> . and
    (25) funcString -> . CAPITALIZAR ( expString )
    (43) vecVal -> . ID m
    (23) funcInt -> . MULTIESCALAR ( vec , eMat , param )
    (24) funcInt -> . LENGTH ( vec )
    (26) funcBool -> . COLINEALES ( vec , vec )
    (73) exp -> . exp ^ iSing
    (74) exp -> . iSing
    (92) and -> . and AND eq
    (93) and -> . eq
    (75) iSing -> . - paren
    (76) iSing -> . + paren
    (77) iSing -> . paren
    (94) eq -> . eq EQEQ tBool
    (95) eq -> . eq DISTINTO tBool
    (96) eq -> . mayor
    (78) paren -> . ( eMat )
    (79) paren -> . INT
    (80) paren -> . varYVals
    (81) paren -> . FLOAT
    (82) paren -> . varsOps
    (83) paren -> . funcInt
    (97) mayor -> . tCompare > tCompare
    (98) mayor -> . menor
    (49) varsOps -> . MENOSMENOS sMM
    (50) varsOps -> . MASMAS sMM
    (51) varsOps -> . sMM
    (52) varsOps -> . MENOSMENOS varYVals
    (53) varsOps -> . MASMAS varYVals
    (107) tCompare -> . eMat
    (108) tCompare -> . varsOps
    (109) tCompare -> . varYVals
    (99) menor -> . tCompare < tCompare
    (100) menor -> . not
    (54) sMM -> . varYVals MASMAS
    (55) sMM -> . varYVals MENOSMENOS
    (101) not -> . NOT not
    (102) not -> . tBool
    (103) tBool -> . ( expBool )
    (104) tBool -> . BOOL
    (105) tBool -> . varYVals
    (106) tBool -> . funcBool

    ID              shift and go to state 157
    STRING          shift and go to state 95
    {               shift and go to state 101
    CAPITALIZAR     shift and go to state 24
    MULTIESCALAR    shift and go to state 22
    LENGTH          shift and go to state 25
    COLINEALES      shift and go to state 14
    -               shift and go to state 73
    +               shift and go to state 72
    (               shift and go to state 92
    INT             shift and go to state 79
    FLOAT           shift and go to state 80
    MENOSMENOS      shift and go to state 30
    MASMAS          shift and go to state 27
    NOT             shift and go to state 85
    BOOL            shift and go to state 74

    and                            shift and go to state 64
    funcBool                       shift and go to state 89
    funcInt                        shift and go to state 90
    menor                          shift and go to state 67
    eq                             shift and go to state 68
    vecVal                         shift and go to state 9
    eMat                           shift and go to state 91
    mayor                          shift and go to state 69
    sMM                            shift and go to state 12
    paren                          shift and go to state 77
    reg                            shift and go to state 93
    varsOps                        shift and go to state 94
    expString                      shift and go to state 96
    tCompare                       shift and go to state 76
    campos                         shift and go to state 217
    not                            shift and go to state 78
    funcString                     shift and go to state 98
    funcReturn                     shift and go to state 99
    valores                        shift and go to state 158
    p                              shift and go to state 82
    iSing                          shift and go to state 75
    exp                            shift and go to state 84
    tBool                          shift and go to state 86
    varYVals                       shift and go to state 102
    or                             shift and go to state 81
    expBool                        shift and go to state 103

state 208

    (31) vec -> ID = [ elem ] .

    )               reduce using rule 31 (vec -> ID = [ elem ] .)
    ,               reduce using rule 31 (vec -> ID = [ elem ] .)


state 209

    (32) elem -> valores , . elem
    (32) elem -> . valores , elem
    (33) elem -> . valores
    (34) valores -> . eMat
    (35) valores -> . expBool
    (36) valores -> . expString
    (37) valores -> . varYVals
    (38) valores -> . funcReturn
    (39) valores -> . reg
    (40) valores -> . ID . ID
    (66) eMat -> . eMat + p
    (67) eMat -> . eMat - p
    (68) eMat -> . p
    (88) expBool -> . or ? expBool : expBool
    (89) expBool -> . or
    (84) expString -> . expString + STRING
    (85) expString -> . STRING
    (86) expString -> . varYVals
    (87) expString -> . funcString
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (20) funcReturn -> . funcInt
    (21) funcReturn -> . funcString
    (22) funcReturn -> . funcBool
    (46) reg -> . { campos }
    (69) p -> . p * exp
    (70) p -> . p / exp
    (71) p -> . p % exp
    (72) p -> . exp
    (90) or -> . or OR and
    (91) or -> . and
    (25) funcString -> . CAPITALIZAR ( expString )
    (43) vecVal -> . ID m
    (23) funcInt -> . MULTIESCALAR ( vec , eMat , param )
    (24) funcInt -> . LENGTH ( vec )
    (26) funcBool -> . COLINEALES ( vec , vec )
    (73) exp -> . exp ^ iSing
    (74) exp -> . iSing
    (92) and -> . and AND eq
    (93) and -> . eq
    (75) iSing -> . - paren
    (76) iSing -> . + paren
    (77) iSing -> . paren
    (94) eq -> . eq EQEQ tBool
    (95) eq -> . eq DISTINTO tBool
    (96) eq -> . mayor
    (78) paren -> . ( eMat )
    (79) paren -> . INT
    (80) paren -> . varYVals
    (81) paren -> . FLOAT
    (82) paren -> . varsOps
    (83) paren -> . funcInt
    (97) mayor -> . tCompare > tCompare
    (98) mayor -> . menor
    (49) varsOps -> . MENOSMENOS sMM
    (50) varsOps -> . MASMAS sMM
    (51) varsOps -> . sMM
    (52) varsOps -> . MENOSMENOS varYVals
    (53) varsOps -> . MASMAS varYVals
    (107) tCompare -> . eMat
    (108) tCompare -> . varsOps
    (109) tCompare -> . varYVals
    (99) menor -> . tCompare < tCompare
    (100) menor -> . not
    (54) sMM -> . varYVals MASMAS
    (55) sMM -> . varYVals MENOSMENOS
    (101) not -> . NOT not
    (102) not -> . tBool
    (103) tBool -> . ( expBool )
    (104) tBool -> . BOOL
    (105) tBool -> . varYVals
    (106) tBool -> . funcBool

    ID              shift and go to state 97
    STRING          shift and go to state 95
    {               shift and go to state 101
    CAPITALIZAR     shift and go to state 24
    MULTIESCALAR    shift and go to state 22
    LENGTH          shift and go to state 25
    COLINEALES      shift and go to state 14
    -               shift and go to state 73
    +               shift and go to state 72
    (               shift and go to state 92
    INT             shift and go to state 79
    FLOAT           shift and go to state 80
    MENOSMENOS      shift and go to state 30
    MASMAS          shift and go to state 27
    NOT             shift and go to state 85
    BOOL            shift and go to state 74

    and                            shift and go to state 64
    funcBool                       shift and go to state 89
    funcInt                        shift and go to state 90
    elem                           shift and go to state 218
    menor                          shift and go to state 67
    eq                             shift and go to state 68
    vecVal                         shift and go to state 9
    eMat                           shift and go to state 91
    mayor                          shift and go to state 69
    sMM                            shift and go to state 12
    paren                          shift and go to state 77
    reg                            shift and go to state 93
    varsOps                        shift and go to state 94
    expString                      shift and go to state 96
    tCompare                       shift and go to state 76
    not                            shift and go to state 78
    funcString                     shift and go to state 98
    funcReturn                     shift and go to state 99
    valores                        shift and go to state 201
    p                              shift and go to state 82
    iSing                          shift and go to state 75
    exp                            shift and go to state 84
    tBool                          shift and go to state 86
    varYVals                       shift and go to state 102
    or                             shift and go to state 81
    expBool                        shift and go to state 103

state 210

    (12) loop -> FOR ( varAsig ; expBool ; varsOps . ) bloque

    )               shift and go to state 219


state 211

    (13) if -> IF ( expBool ) THEN bloque else .

    RETURN          reduce using rule 13 (if -> IF ( expBool ) THEN bloque else .)
    MENOSMENOS      reduce using rule 13 (if -> IF ( expBool ) THEN bloque else .)
    MASMAS          reduce using rule 13 (if -> IF ( expBool ) THEN bloque else .)
    ID              reduce using rule 13 (if -> IF ( expBool ) THEN bloque else .)
    IF              reduce using rule 13 (if -> IF ( expBool ) THEN bloque else .)
    WHILE           reduce using rule 13 (if -> IF ( expBool ) THEN bloque else .)
    DO              reduce using rule 13 (if -> IF ( expBool ) THEN bloque else .)
    FOR             reduce using rule 13 (if -> IF ( expBool ) THEN bloque else .)
    PRINT           reduce using rule 13 (if -> IF ( expBool ) THEN bloque else .)
    MULTIESCALAR    reduce using rule 13 (if -> IF ( expBool ) THEN bloque else .)
    LENGTH          reduce using rule 13 (if -> IF ( expBool ) THEN bloque else .)
    CAPITALIZAR     reduce using rule 13 (if -> IF ( expBool ) THEN bloque else .)
    COLINEALES      reduce using rule 13 (if -> IF ( expBool ) THEN bloque else .)
    $end            reduce using rule 13 (if -> IF ( expBool ) THEN bloque else .)
    }               reduce using rule 13 (if -> IF ( expBool ) THEN bloque else .)


state 212

    (15) else -> empty .

    RETURN          reduce using rule 15 (else -> empty .)
    MENOSMENOS      reduce using rule 15 (else -> empty .)
    MASMAS          reduce using rule 15 (else -> empty .)
    ID              reduce using rule 15 (else -> empty .)
    IF              reduce using rule 15 (else -> empty .)
    WHILE           reduce using rule 15 (else -> empty .)
    DO              reduce using rule 15 (else -> empty .)
    FOR             reduce using rule 15 (else -> empty .)
    PRINT           reduce using rule 15 (else -> empty .)
    MULTIESCALAR    reduce using rule 15 (else -> empty .)
    LENGTH          reduce using rule 15 (else -> empty .)
    CAPITALIZAR     reduce using rule 15 (else -> empty .)
    COLINEALES      reduce using rule 15 (else -> empty .)
    $end            reduce using rule 15 (else -> empty .)
    }               reduce using rule 15 (else -> empty .)


state 213

    (14) else -> ELSE . bloque
    (16) bloque -> . sentencia
    (17) bloque -> . { g }
    (4) sentencia -> . varsOps ;
    (5) sentencia -> . func ;
    (6) sentencia -> . varAsig ;
    (7) sentencia -> . RETURN ;
    (49) varsOps -> . MENOSMENOS sMM
    (50) varsOps -> . MASMAS sMM
    (51) varsOps -> . sMM
    (52) varsOps -> . MENOSMENOS varYVals
    (53) varsOps -> . MASMAS varYVals
    (18) func -> . funcReturn
    (19) func -> . funcVoid
    (56) varAsig -> . ID MENOSEQ varAsig
    (57) varAsig -> . ID MASEQ varAsig
    (58) varAsig -> . ID MULEQ varAsig
    (59) varAsig -> . ID DIVEQ varAsig
    (60) varAsig -> . ID = varAsig
    (61) varAsig -> . ID MASEQ valores
    (62) varAsig -> . ID MENOSEQ valores
    (63) varAsig -> . ID MULEQ valores
    (64) varAsig -> . ID DIVEQ valores
    (65) varAsig -> . ID = valores
    (54) sMM -> . varYVals MASMAS
    (55) sMM -> . varYVals MENOSMENOS
    (20) funcReturn -> . funcInt
    (21) funcReturn -> . funcString
    (22) funcReturn -> . funcBool
    (27) funcVoid -> . PRINT ( valores )
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (23) funcInt -> . MULTIESCALAR ( vec , eMat , param )
    (24) funcInt -> . LENGTH ( vec )
    (25) funcString -> . CAPITALIZAR ( expString )
    (26) funcBool -> . COLINEALES ( vec , vec )
    (43) vecVal -> . ID m

    {               shift and go to state 33
    RETURN          shift and go to state 2
    MENOSMENOS      shift and go to state 30
    MASMAS          shift and go to state 27
    ID              shift and go to state 17
    PRINT           shift and go to state 8
    MULTIESCALAR    shift and go to state 22
    LENGTH          shift and go to state 25
    CAPITALIZAR     shift and go to state 24
    COLINEALES      shift and go to state 14

    varAsig                        shift and go to state 19
    sentencia                      shift and go to state 32
    funcBool                       shift and go to state 3
    funcString                     shift and go to state 21
    funcVoid                       shift and go to state 13
    funcReturn                     shift and go to state 23
    vecVal                         shift and go to state 9
    sMM                            shift and go to state 12
    varsOps                        shift and go to state 28
    func                           shift and go to state 16
    bloque                         shift and go to state 220
    varYVals                       shift and go to state 29
    funcInt                        shift and go to state 5

state 214

    (23) funcInt -> MULTIESCALAR ( vec , eMat , param . )

    )               shift and go to state 221


state 215

    (29) param -> empty .

    )               reduce using rule 29 (param -> empty .)


state 216

    (28) param -> expBool .

    )               reduce using rule 28 (param -> expBool .)


state 217

    (47) campos -> ID : valores , campos .

    }               reduce using rule 47 (campos -> ID : valores , campos .)


state 218

    (32) elem -> valores , elem .

    ]               reduce using rule 32 (elem -> valores , elem .)


state 219

    (12) loop -> FOR ( varAsig ; expBool ; varsOps ) . bloque
    (16) bloque -> . sentencia
    (17) bloque -> . { g }
    (4) sentencia -> . varsOps ;
    (5) sentencia -> . func ;
    (6) sentencia -> . varAsig ;
    (7) sentencia -> . RETURN ;
    (49) varsOps -> . MENOSMENOS sMM
    (50) varsOps -> . MASMAS sMM
    (51) varsOps -> . sMM
    (52) varsOps -> . MENOSMENOS varYVals
    (53) varsOps -> . MASMAS varYVals
    (18) func -> . funcReturn
    (19) func -> . funcVoid
    (56) varAsig -> . ID MENOSEQ varAsig
    (57) varAsig -> . ID MASEQ varAsig
    (58) varAsig -> . ID MULEQ varAsig
    (59) varAsig -> . ID DIVEQ varAsig
    (60) varAsig -> . ID = varAsig
    (61) varAsig -> . ID MASEQ valores
    (62) varAsig -> . ID MENOSEQ valores
    (63) varAsig -> . ID MULEQ valores
    (64) varAsig -> . ID DIVEQ valores
    (65) varAsig -> . ID = valores
    (54) sMM -> . varYVals MASMAS
    (55) sMM -> . varYVals MENOSMENOS
    (20) funcReturn -> . funcInt
    (21) funcReturn -> . funcString
    (22) funcReturn -> . funcBool
    (27) funcVoid -> . PRINT ( valores )
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (23) funcInt -> . MULTIESCALAR ( vec , eMat , param )
    (24) funcInt -> . LENGTH ( vec )
    (25) funcString -> . CAPITALIZAR ( expString )
    (26) funcBool -> . COLINEALES ( vec , vec )
    (43) vecVal -> . ID m

    {               shift and go to state 33
    RETURN          shift and go to state 2
    MENOSMENOS      shift and go to state 30
    MASMAS          shift and go to state 27
    ID              shift and go to state 17
    PRINT           shift and go to state 8
    MULTIESCALAR    shift and go to state 22
    LENGTH          shift and go to state 25
    CAPITALIZAR     shift and go to state 24
    COLINEALES      shift and go to state 14

    varAsig                        shift and go to state 19
    sentencia                      shift and go to state 32
    funcBool                       shift and go to state 3
    funcString                     shift and go to state 21
    funcVoid                       shift and go to state 13
    funcReturn                     shift and go to state 23
    vecVal                         shift and go to state 9
    sMM                            shift and go to state 12
    varsOps                        shift and go to state 28
    func                           shift and go to state 16
    bloque                         shift and go to state 222
    varYVals                       shift and go to state 29
    funcInt                        shift and go to state 5

state 220

    (14) else -> ELSE bloque .

    RETURN          reduce using rule 14 (else -> ELSE bloque .)
    MENOSMENOS      reduce using rule 14 (else -> ELSE bloque .)
    MASMAS          reduce using rule 14 (else -> ELSE bloque .)
    ID              reduce using rule 14 (else -> ELSE bloque .)
    IF              reduce using rule 14 (else -> ELSE bloque .)
    WHILE           reduce using rule 14 (else -> ELSE bloque .)
    DO              reduce using rule 14 (else -> ELSE bloque .)
    FOR             reduce using rule 14 (else -> ELSE bloque .)
    PRINT           reduce using rule 14 (else -> ELSE bloque .)
    MULTIESCALAR    reduce using rule 14 (else -> ELSE bloque .)
    LENGTH          reduce using rule 14 (else -> ELSE bloque .)
    CAPITALIZAR     reduce using rule 14 (else -> ELSE bloque .)
    COLINEALES      reduce using rule 14 (else -> ELSE bloque .)
    $end            reduce using rule 14 (else -> ELSE bloque .)
    }               reduce using rule 14 (else -> ELSE bloque .)


state 221

    (23) funcInt -> MULTIESCALAR ( vec , eMat , param ) .

    ^               reduce using rule 23 (funcInt -> MULTIESCALAR ( vec , eMat , param ) .)
    *               reduce using rule 23 (funcInt -> MULTIESCALAR ( vec , eMat , param ) .)
    /               reduce using rule 23 (funcInt -> MULTIESCALAR ( vec , eMat , param ) .)
    %               reduce using rule 23 (funcInt -> MULTIESCALAR ( vec , eMat , param ) .)
    )               reduce using rule 23 (funcInt -> MULTIESCALAR ( vec , eMat , param ) .)
    +               reduce using rule 23 (funcInt -> MULTIESCALAR ( vec , eMat , param ) .)
    -               reduce using rule 23 (funcInt -> MULTIESCALAR ( vec , eMat , param ) .)
    ;               reduce using rule 23 (funcInt -> MULTIESCALAR ( vec , eMat , param ) .)
    >               reduce using rule 23 (funcInt -> MULTIESCALAR ( vec , eMat , param ) .)
    <               reduce using rule 23 (funcInt -> MULTIESCALAR ( vec , eMat , param ) .)
    ,               reduce using rule 23 (funcInt -> MULTIESCALAR ( vec , eMat , param ) .)
    ]               reduce using rule 23 (funcInt -> MULTIESCALAR ( vec , eMat , param ) .)
    }               reduce using rule 23 (funcInt -> MULTIESCALAR ( vec , eMat , param ) .)
    EQEQ            reduce using rule 23 (funcInt -> MULTIESCALAR ( vec , eMat , param ) .)
    DISTINTO        reduce using rule 23 (funcInt -> MULTIESCALAR ( vec , eMat , param ) .)
    AND             reduce using rule 23 (funcInt -> MULTIESCALAR ( vec , eMat , param ) .)
    ?               reduce using rule 23 (funcInt -> MULTIESCALAR ( vec , eMat , param ) .)
    OR              reduce using rule 23 (funcInt -> MULTIESCALAR ( vec , eMat , param ) .)
    :               reduce using rule 23 (funcInt -> MULTIESCALAR ( vec , eMat , param ) .)


state 222

    (12) loop -> FOR ( varAsig ; expBool ; varsOps ) bloque .

    RETURN          reduce using rule 12 (loop -> FOR ( varAsig ; expBool ; varsOps ) bloque .)
    MENOSMENOS      reduce using rule 12 (loop -> FOR ( varAsig ; expBool ; varsOps ) bloque .)
    MASMAS          reduce using rule 12 (loop -> FOR ( varAsig ; expBool ; varsOps ) bloque .)
    ID              reduce using rule 12 (loop -> FOR ( varAsig ; expBool ; varsOps ) bloque .)
    IF              reduce using rule 12 (loop -> FOR ( varAsig ; expBool ; varsOps ) bloque .)
    WHILE           reduce using rule 12 (loop -> FOR ( varAsig ; expBool ; varsOps ) bloque .)
    DO              reduce using rule 12 (loop -> FOR ( varAsig ; expBool ; varsOps ) bloque .)
    FOR             reduce using rule 12 (loop -> FOR ( varAsig ; expBool ; varsOps ) bloque .)
    PRINT           reduce using rule 12 (loop -> FOR ( varAsig ; expBool ; varsOps ) bloque .)
    MULTIESCALAR    reduce using rule 12 (loop -> FOR ( varAsig ; expBool ; varsOps ) bloque .)
    LENGTH          reduce using rule 12 (loop -> FOR ( varAsig ; expBool ; varsOps ) bloque .)
    CAPITALIZAR     reduce using rule 12 (loop -> FOR ( varAsig ; expBool ; varsOps ) bloque .)
    COLINEALES      reduce using rule 12 (loop -> FOR ( varAsig ; expBool ; varsOps ) bloque .)
    $end            reduce using rule 12 (loop -> FOR ( varAsig ; expBool ; varsOps ) bloque .)
    }               reduce using rule 12 (loop -> FOR ( varAsig ; expBool ; varsOps ) bloque .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: reduce/reduce conflict in state 83 resolved using rule (paren -> varsOps)
WARNING: rejected rule (tCompare -> varsOps) in state 83
WARNING: reduce/reduce conflict in state 87 resolved using rule (paren -> varYVals)
WARNING: rejected rule (tCompare -> varYVals) in state 87
WARNING: reduce/reduce conflict in state 89 resolved using rule (funcReturn -> funcBool)
WARNING: rejected rule (tBool -> funcBool) in state 89
WARNING: reduce/reduce conflict in state 90 resolved using rule (funcReturn -> funcInt)
WARNING: rejected rule (paren -> funcInt) in state 90
WARNING: reduce/reduce conflict in state 94 resolved using rule (paren -> varsOps)
WARNING: rejected rule (tCompare -> varsOps) in state 94
WARNING: reduce/reduce conflict in state 98 resolved using rule (funcReturn -> funcString)
WARNING: rejected rule (expString -> funcString) in state 98
WARNING: reduce/reduce conflict in state 102 resolved using rule (valores -> varYVals)
WARNING: rejected rule (expString -> varYVals) in state 102
WARNING: reduce/reduce conflict in state 102 resolved using rule (paren -> varYVals)
WARNING: rejected rule (expString -> varYVals) in state 102
WARNING: reduce/reduce conflict in state 102 resolved using rule (valores -> varYVals)
WARNING: rejected rule (paren -> varYVals) in state 102
WARNING: reduce/reduce conflict in state 102 resolved using rule (paren -> varYVals)
WARNING: rejected rule (tCompare -> varYVals) in state 102
WARNING: reduce/reduce conflict in state 102 resolved using rule (valores -> varYVals)
WARNING: rejected rule (tBool -> varYVals) in state 102
WARNING: reduce/reduce conflict in state 134 resolved using rule (paren -> varYVals)
WARNING: rejected rule (tCompare -> varYVals) in state 134
WARNING: reduce/reduce conflict in state 134 resolved using rule (paren -> varYVals)
WARNING: rejected rule (tBool -> varYVals) in state 134
WARNING: reduce/reduce conflict in state 177 resolved using rule (paren -> varYVals)
WARNING: rejected rule (tCompare -> varYVals) in state 177
WARNING: Rule (tCompare -> varsOps) is never reduced
WARNING: Rule (tCompare -> varYVals) is never reduced
