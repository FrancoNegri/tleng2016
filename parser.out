Created by PLY version 3.8 (http://www.dabeaz.com/ply)

Unused terminals:

    COMMENT
    BEGIN
    END

Grammar

Rule 0     S' -> g
Rule 1     g -> sentencia g
Rule 2     g -> ctrl g
Rule 3     g -> empty
Rule 4     sentencia -> varOps ;
Rule 5     sentencia -> func ;
Rule 6     sentencia -> varAsig ;
Rule 7     sentencia -> RETURN ;
Rule 8     ctrl -> if
Rule 9     ctrl -> loop
Rule 10    loop -> WHILE ( varExpresion ) bloque
Rule 11    loop -> DO bloque WHILE ( varExpresion ) ;
Rule 12    loop -> FOR ( varAsig ; varExpresion ; varOps ) bloque
Rule 13    if -> IF ( varExpresion ) THEN bloque else
Rule 14    else -> ELSE bloque
Rule 15    else -> empty
Rule 16    bloque -> sentencia
Rule 17    bloque -> { g }
Rule 18    varExpresion -> varExpresion + varExpresion
Rule 19    varExpresion -> varExpresion - varExpresion
Rule 20    varExpresion -> varExpresion * varExpresion
Rule 21    varExpresion -> varExpresion / varExpresion
Rule 22    varExpresion -> varExpresion % varExpresion
Rule 23    varExpresion -> varExpresion ^ varExpresion
Rule 24    varExpresion -> ( - ( varExpresion ) )
Rule 25    varExpresion -> ( + ( varExpresion ) )
Rule 26    varExpresion -> varExpresion ? varExpresion : varExpresion
Rule 27    varExpresion -> varExpresion AND varExpresion
Rule 28    varExpresion -> NOT varExpresion
Rule 29    varExpresion -> varExpresion OR varExpresion
Rule 30    varExpresion -> varExpresion EQEQ varExpresion
Rule 31    varExpresion -> varExpresion DISTINTO varExpresion
Rule 32    varExpresion -> varExpresion > varExpresion
Rule 33    varExpresion -> varExpresion < varExpresion
Rule 34    varExpresion -> ( varExpresion )
Rule 35    varExpresion -> tipos
Rule 36    varExpresion -> funcReturn
Rule 37    varExpresion -> varOps
Rule 38    varExpresion -> vec
Rule 39    varExpresion -> reg
Rule 40    varExpresion -> vars
Rule 41    tipos -> INT
Rule 42    tipos -> FLOAT
Rule 43    tipos -> STRING
Rule 44    tipos -> BOOL
Rule 45    vec -> [ elem ]
Rule 46    vec -> ID m
Rule 47    elem -> varExpresion , elem
Rule 48    elem -> varExpresion
Rule 49    m -> [ varExpresion ]
Rule 50    m -> m [ varExpresion ]
Rule 51    reg -> { campos }
Rule 52    reg -> ID . ID
Rule 53    campos -> ID : varExpresion , campos
Rule 54    campos -> ID : varExpresion
Rule 55    varOps -> MASMAS ID
Rule 56    varOps -> MENOSMENOS ID
Rule 57    varOps -> ID MASMAS
Rule 58    varOps -> ID MENOSMENOS
Rule 59    func -> funcReturn
Rule 60    func -> funcVoid
Rule 61    funcReturn -> funcInt
Rule 62    funcReturn -> funcString
Rule 63    funcReturn -> funcBool
Rule 64    funcInt -> MULTIESCALAR ( varExpresion , varExpresion , param )
Rule 65    funcInt -> LENGTH ( varExpresion )
Rule 66    funcString -> CAPITALIZAR ( varExpresion )
Rule 67    funcBool -> COLINEALES ( varExpresion , varExpresion )
Rule 68    funcVoid -> PRINT ( varExpresion )
Rule 69    param -> varExpresion
Rule 70    param -> empty
Rule 71    empty -> <empty>
Rule 72    varAsig -> vars MENOSEQ varAsig
Rule 73    varAsig -> vars MASEQ varAsig
Rule 74    varAsig -> vars MULEQ varAsig
Rule 75    varAsig -> vars DIVEQ varAsig
Rule 76    varAsig -> vars = varAsig
Rule 77    varAsig -> vars MASEQ varExpresion
Rule 78    varAsig -> vars MENOSEQ varExpresion
Rule 79    varAsig -> vars MULEQ varExpresion
Rule 80    varAsig -> vars DIVEQ varExpresion
Rule 81    varAsig -> vars = varExpresion
Rule 82    vars -> ID
Rule 83    vars -> RES

Terminals, with rules where they appear

%                    : 22
(                    : 10 11 12 13 24 24 25 25 34 64 65 66 67 68
)                    : 10 11 12 13 24 24 25 25 34 64 65 66 67 68
*                    : 20
+                    : 18 25
,                    : 47 53 64 64 67
-                    : 19 24
.                    : 52
/                    : 21
:                    : 26 53 54
;                    : 4 5 6 7 11 12 12
<                    : 33
=                    : 76 81
>                    : 32
?                    : 26
AND                  : 27
BEGIN                : 
BOOL                 : 44
CAPITALIZAR          : 66
COLINEALES           : 67
COMMENT              : 
DISTINTO             : 31
DIVEQ                : 75 80
DO                   : 11
ELSE                 : 14
END                  : 
EQEQ                 : 30
FLOAT                : 42
FOR                  : 12
ID                   : 46 52 52 53 54 55 56 57 58 82
IF                   : 13
INT                  : 41
LENGTH               : 65
MASEQ                : 73 77
MASMAS               : 55 57
MENOSEQ              : 72 78
MENOSMENOS           : 56 58
MULEQ                : 74 79
MULTIESCALAR         : 64
NOT                  : 28
OR                   : 29
PRINT                : 68
RES                  : 83
RETURN               : 7
STRING               : 43
THEN                 : 13
WHILE                : 10 11
[                    : 45 49 50
]                    : 45 49 50
^                    : 23
error                : 
{                    : 17 51
}                    : 17 51

Nonterminals, with rules where they appear

bloque               : 10 11 12 13 14
campos               : 51 53
ctrl                 : 2
elem                 : 45 47
else                 : 13
empty                : 3 15 70
func                 : 5
funcBool             : 63
funcInt              : 61
funcReturn           : 36 59
funcString           : 62
funcVoid             : 60
g                    : 1 2 17 0
if                   : 8
loop                 : 9
m                    : 46 50
param                : 64
reg                  : 39
sentencia            : 1 16
tipos                : 35
varAsig              : 6 12 72 73 74 75 76
varExpresion         : 10 11 12 13 18 18 19 19 20 20 21 21 22 22 23 23 24 25 26 26 26 27 27 28 29 29 30 30 31 31 32 32 33 33 34 47 48 49 50 53 54 64 64 65 66 67 67 68 69 77 78 79 80 81
varOps               : 4 12 37
vars                 : 40 72 73 74 75 76 77 78 79 80 81
vec                  : 38

Parsing method: LALR

state 0

    (0) S' -> . g
    (1) g -> . sentencia g
    (2) g -> . ctrl g
    (3) g -> . empty
    (4) sentencia -> . varOps ;
    (5) sentencia -> . func ;
    (6) sentencia -> . varAsig ;
    (7) sentencia -> . RETURN ;
    (8) ctrl -> . if
    (9) ctrl -> . loop
    (71) empty -> .
    (55) varOps -> . MASMAS ID
    (56) varOps -> . MENOSMENOS ID
    (57) varOps -> . ID MASMAS
    (58) varOps -> . ID MENOSMENOS
    (59) func -> . funcReturn
    (60) func -> . funcVoid
    (72) varAsig -> . vars MENOSEQ varAsig
    (73) varAsig -> . vars MASEQ varAsig
    (74) varAsig -> . vars MULEQ varAsig
    (75) varAsig -> . vars DIVEQ varAsig
    (76) varAsig -> . vars = varAsig
    (77) varAsig -> . vars MASEQ varExpresion
    (78) varAsig -> . vars MENOSEQ varExpresion
    (79) varAsig -> . vars MULEQ varExpresion
    (80) varAsig -> . vars DIVEQ varExpresion
    (81) varAsig -> . vars = varExpresion
    (13) if -> . IF ( varExpresion ) THEN bloque else
    (10) loop -> . WHILE ( varExpresion ) bloque
    (11) loop -> . DO bloque WHILE ( varExpresion ) ;
    (12) loop -> . FOR ( varAsig ; varExpresion ; varOps ) bloque
    (61) funcReturn -> . funcInt
    (62) funcReturn -> . funcString
    (63) funcReturn -> . funcBool
    (68) funcVoid -> . PRINT ( varExpresion )
    (82) vars -> . ID
    (83) vars -> . RES
    (64) funcInt -> . MULTIESCALAR ( varExpresion , varExpresion , param )
    (65) funcInt -> . LENGTH ( varExpresion )
    (66) funcString -> . CAPITALIZAR ( varExpresion )
    (67) funcBool -> . COLINEALES ( varExpresion , varExpresion )

    RETURN          shift and go to state 2
    $end            reduce using rule 71 (empty -> .)
    MASMAS          shift and go to state 27
    MENOSMENOS      shift and go to state 29
    ID              shift and go to state 17
    IF              shift and go to state 18
    WHILE           shift and go to state 7
    DO              shift and go to state 1
    FOR             shift and go to state 15
    PRINT           shift and go to state 8
    RES             shift and go to state 5
    MULTIESCALAR    shift and go to state 22
    LENGTH          shift and go to state 25
    CAPITALIZAR     shift and go to state 24
    COLINEALES      shift and go to state 14

    varAsig                        shift and go to state 19
    sentencia                      shift and go to state 10
    funcString                     shift and go to state 21
    vars                           shift and go to state 3
    g                              shift and go to state 20
    ctrl                           shift and go to state 4
    funcVoid                       shift and go to state 13
    funcReturn                     shift and go to state 23
    varOps                         shift and go to state 12
    funcBool                       shift and go to state 11
    loop                           shift and go to state 28
    func                           shift and go to state 16
    funcInt                        shift and go to state 6
    empty                          shift and go to state 26
    if                             shift and go to state 9

state 1

    (11) loop -> DO . bloque WHILE ( varExpresion ) ;
    (16) bloque -> . sentencia
    (17) bloque -> . { g }
    (4) sentencia -> . varOps ;
    (5) sentencia -> . func ;
    (6) sentencia -> . varAsig ;
    (7) sentencia -> . RETURN ;
    (55) varOps -> . MASMAS ID
    (56) varOps -> . MENOSMENOS ID
    (57) varOps -> . ID MASMAS
    (58) varOps -> . ID MENOSMENOS
    (59) func -> . funcReturn
    (60) func -> . funcVoid
    (72) varAsig -> . vars MENOSEQ varAsig
    (73) varAsig -> . vars MASEQ varAsig
    (74) varAsig -> . vars MULEQ varAsig
    (75) varAsig -> . vars DIVEQ varAsig
    (76) varAsig -> . vars = varAsig
    (77) varAsig -> . vars MASEQ varExpresion
    (78) varAsig -> . vars MENOSEQ varExpresion
    (79) varAsig -> . vars MULEQ varExpresion
    (80) varAsig -> . vars DIVEQ varExpresion
    (81) varAsig -> . vars = varExpresion
    (61) funcReturn -> . funcInt
    (62) funcReturn -> . funcString
    (63) funcReturn -> . funcBool
    (68) funcVoid -> . PRINT ( varExpresion )
    (82) vars -> . ID
    (83) vars -> . RES
    (64) funcInt -> . MULTIESCALAR ( varExpresion , varExpresion , param )
    (65) funcInt -> . LENGTH ( varExpresion )
    (66) funcString -> . CAPITALIZAR ( varExpresion )
    (67) funcBool -> . COLINEALES ( varExpresion , varExpresion )

    {               shift and go to state 32
    RETURN          shift and go to state 2
    MASMAS          shift and go to state 27
    MENOSMENOS      shift and go to state 29
    ID              shift and go to state 17
    PRINT           shift and go to state 8
    RES             shift and go to state 5
    MULTIESCALAR    shift and go to state 22
    LENGTH          shift and go to state 25
    CAPITALIZAR     shift and go to state 24
    COLINEALES      shift and go to state 14

    varAsig                        shift and go to state 19
    sentencia                      shift and go to state 31
    vars                           shift and go to state 3
    funcString                     shift and go to state 21
    funcReturn                     shift and go to state 23
    varOps                         shift and go to state 12
    funcBool                       shift and go to state 11
    funcVoid                       shift and go to state 13
    func                           shift and go to state 16
    bloque                         shift and go to state 30
    funcInt                        shift and go to state 6

state 2

    (7) sentencia -> RETURN . ;

    ;               shift and go to state 33


state 3

    (72) varAsig -> vars . MENOSEQ varAsig
    (73) varAsig -> vars . MASEQ varAsig
    (74) varAsig -> vars . MULEQ varAsig
    (75) varAsig -> vars . DIVEQ varAsig
    (76) varAsig -> vars . = varAsig
    (77) varAsig -> vars . MASEQ varExpresion
    (78) varAsig -> vars . MENOSEQ varExpresion
    (79) varAsig -> vars . MULEQ varExpresion
    (80) varAsig -> vars . DIVEQ varExpresion
    (81) varAsig -> vars . = varExpresion

    MENOSEQ         shift and go to state 34
    MASEQ           shift and go to state 35
    MULEQ           shift and go to state 36
    DIVEQ           shift and go to state 38
    =               shift and go to state 37


state 4

    (2) g -> ctrl . g
    (1) g -> . sentencia g
    (2) g -> . ctrl g
    (3) g -> . empty
    (4) sentencia -> . varOps ;
    (5) sentencia -> . func ;
    (6) sentencia -> . varAsig ;
    (7) sentencia -> . RETURN ;
    (8) ctrl -> . if
    (9) ctrl -> . loop
    (71) empty -> .
    (55) varOps -> . MASMAS ID
    (56) varOps -> . MENOSMENOS ID
    (57) varOps -> . ID MASMAS
    (58) varOps -> . ID MENOSMENOS
    (59) func -> . funcReturn
    (60) func -> . funcVoid
    (72) varAsig -> . vars MENOSEQ varAsig
    (73) varAsig -> . vars MASEQ varAsig
    (74) varAsig -> . vars MULEQ varAsig
    (75) varAsig -> . vars DIVEQ varAsig
    (76) varAsig -> . vars = varAsig
    (77) varAsig -> . vars MASEQ varExpresion
    (78) varAsig -> . vars MENOSEQ varExpresion
    (79) varAsig -> . vars MULEQ varExpresion
    (80) varAsig -> . vars DIVEQ varExpresion
    (81) varAsig -> . vars = varExpresion
    (13) if -> . IF ( varExpresion ) THEN bloque else
    (10) loop -> . WHILE ( varExpresion ) bloque
    (11) loop -> . DO bloque WHILE ( varExpresion ) ;
    (12) loop -> . FOR ( varAsig ; varExpresion ; varOps ) bloque
    (61) funcReturn -> . funcInt
    (62) funcReturn -> . funcString
    (63) funcReturn -> . funcBool
    (68) funcVoid -> . PRINT ( varExpresion )
    (82) vars -> . ID
    (83) vars -> . RES
    (64) funcInt -> . MULTIESCALAR ( varExpresion , varExpresion , param )
    (65) funcInt -> . LENGTH ( varExpresion )
    (66) funcString -> . CAPITALIZAR ( varExpresion )
    (67) funcBool -> . COLINEALES ( varExpresion , varExpresion )

    RETURN          shift and go to state 2
    $end            reduce using rule 71 (empty -> .)
    }               reduce using rule 71 (empty -> .)
    MASMAS          shift and go to state 27
    MENOSMENOS      shift and go to state 29
    ID              shift and go to state 17
    IF              shift and go to state 18
    WHILE           shift and go to state 7
    DO              shift and go to state 1
    FOR             shift and go to state 15
    PRINT           shift and go to state 8
    RES             shift and go to state 5
    MULTIESCALAR    shift and go to state 22
    LENGTH          shift and go to state 25
    CAPITALIZAR     shift and go to state 24
    COLINEALES      shift and go to state 14

    varAsig                        shift and go to state 19
    sentencia                      shift and go to state 10
    funcString                     shift and go to state 21
    vars                           shift and go to state 3
    g                              shift and go to state 39
    ctrl                           shift and go to state 4
    funcVoid                       shift and go to state 13
    funcReturn                     shift and go to state 23
    varOps                         shift and go to state 12
    funcBool                       shift and go to state 11
    loop                           shift and go to state 28
    func                           shift and go to state 16
    funcInt                        shift and go to state 6
    empty                          shift and go to state 26
    if                             shift and go to state 9

state 5

    (83) vars -> RES .

    MENOSEQ         reduce using rule 83 (vars -> RES .)
    MASEQ           reduce using rule 83 (vars -> RES .)
    MULEQ           reduce using rule 83 (vars -> RES .)
    DIVEQ           reduce using rule 83 (vars -> RES .)
    =               reduce using rule 83 (vars -> RES .)
    +               reduce using rule 83 (vars -> RES .)
    -               reduce using rule 83 (vars -> RES .)
    *               reduce using rule 83 (vars -> RES .)
    /               reduce using rule 83 (vars -> RES .)
    %               reduce using rule 83 (vars -> RES .)
    ^               reduce using rule 83 (vars -> RES .)
    ?               reduce using rule 83 (vars -> RES .)
    AND             reduce using rule 83 (vars -> RES .)
    OR              reduce using rule 83 (vars -> RES .)
    EQEQ            reduce using rule 83 (vars -> RES .)
    DISTINTO        reduce using rule 83 (vars -> RES .)
    >               reduce using rule 83 (vars -> RES .)
    <               reduce using rule 83 (vars -> RES .)
    ;               reduce using rule 83 (vars -> RES .)
    )               reduce using rule 83 (vars -> RES .)
    ,               reduce using rule 83 (vars -> RES .)
    ]               reduce using rule 83 (vars -> RES .)
    :               reduce using rule 83 (vars -> RES .)
    }               reduce using rule 83 (vars -> RES .)


state 6

    (61) funcReturn -> funcInt .

    ]               reduce using rule 61 (funcReturn -> funcInt .)
    +               reduce using rule 61 (funcReturn -> funcInt .)
    -               reduce using rule 61 (funcReturn -> funcInt .)
    *               reduce using rule 61 (funcReturn -> funcInt .)
    /               reduce using rule 61 (funcReturn -> funcInt .)
    %               reduce using rule 61 (funcReturn -> funcInt .)
    ^               reduce using rule 61 (funcReturn -> funcInt .)
    ?               reduce using rule 61 (funcReturn -> funcInt .)
    AND             reduce using rule 61 (funcReturn -> funcInt .)
    OR              reduce using rule 61 (funcReturn -> funcInt .)
    EQEQ            reduce using rule 61 (funcReturn -> funcInt .)
    DISTINTO        reduce using rule 61 (funcReturn -> funcInt .)
    >               reduce using rule 61 (funcReturn -> funcInt .)
    <               reduce using rule 61 (funcReturn -> funcInt .)
    ;               reduce using rule 61 (funcReturn -> funcInt .)
    )               reduce using rule 61 (funcReturn -> funcInt .)
    ,               reduce using rule 61 (funcReturn -> funcInt .)
    :               reduce using rule 61 (funcReturn -> funcInt .)
    }               reduce using rule 61 (funcReturn -> funcInt .)


state 7

    (10) loop -> WHILE . ( varExpresion ) bloque

    (               shift and go to state 40


state 8

    (68) funcVoid -> PRINT . ( varExpresion )

    (               shift and go to state 41


state 9

    (8) ctrl -> if .

    RETURN          reduce using rule 8 (ctrl -> if .)
    MASMAS          reduce using rule 8 (ctrl -> if .)
    MENOSMENOS      reduce using rule 8 (ctrl -> if .)
    ID              reduce using rule 8 (ctrl -> if .)
    IF              reduce using rule 8 (ctrl -> if .)
    WHILE           reduce using rule 8 (ctrl -> if .)
    DO              reduce using rule 8 (ctrl -> if .)
    FOR             reduce using rule 8 (ctrl -> if .)
    PRINT           reduce using rule 8 (ctrl -> if .)
    RES             reduce using rule 8 (ctrl -> if .)
    MULTIESCALAR    reduce using rule 8 (ctrl -> if .)
    LENGTH          reduce using rule 8 (ctrl -> if .)
    CAPITALIZAR     reduce using rule 8 (ctrl -> if .)
    COLINEALES      reduce using rule 8 (ctrl -> if .)
    $end            reduce using rule 8 (ctrl -> if .)
    }               reduce using rule 8 (ctrl -> if .)


state 10

    (1) g -> sentencia . g
    (1) g -> . sentencia g
    (2) g -> . ctrl g
    (3) g -> . empty
    (4) sentencia -> . varOps ;
    (5) sentencia -> . func ;
    (6) sentencia -> . varAsig ;
    (7) sentencia -> . RETURN ;
    (8) ctrl -> . if
    (9) ctrl -> . loop
    (71) empty -> .
    (55) varOps -> . MASMAS ID
    (56) varOps -> . MENOSMENOS ID
    (57) varOps -> . ID MASMAS
    (58) varOps -> . ID MENOSMENOS
    (59) func -> . funcReturn
    (60) func -> . funcVoid
    (72) varAsig -> . vars MENOSEQ varAsig
    (73) varAsig -> . vars MASEQ varAsig
    (74) varAsig -> . vars MULEQ varAsig
    (75) varAsig -> . vars DIVEQ varAsig
    (76) varAsig -> . vars = varAsig
    (77) varAsig -> . vars MASEQ varExpresion
    (78) varAsig -> . vars MENOSEQ varExpresion
    (79) varAsig -> . vars MULEQ varExpresion
    (80) varAsig -> . vars DIVEQ varExpresion
    (81) varAsig -> . vars = varExpresion
    (13) if -> . IF ( varExpresion ) THEN bloque else
    (10) loop -> . WHILE ( varExpresion ) bloque
    (11) loop -> . DO bloque WHILE ( varExpresion ) ;
    (12) loop -> . FOR ( varAsig ; varExpresion ; varOps ) bloque
    (61) funcReturn -> . funcInt
    (62) funcReturn -> . funcString
    (63) funcReturn -> . funcBool
    (68) funcVoid -> . PRINT ( varExpresion )
    (82) vars -> . ID
    (83) vars -> . RES
    (64) funcInt -> . MULTIESCALAR ( varExpresion , varExpresion , param )
    (65) funcInt -> . LENGTH ( varExpresion )
    (66) funcString -> . CAPITALIZAR ( varExpresion )
    (67) funcBool -> . COLINEALES ( varExpresion , varExpresion )

    RETURN          shift and go to state 2
    $end            reduce using rule 71 (empty -> .)
    }               reduce using rule 71 (empty -> .)
    MASMAS          shift and go to state 27
    MENOSMENOS      shift and go to state 29
    ID              shift and go to state 17
    IF              shift and go to state 18
    WHILE           shift and go to state 7
    DO              shift and go to state 1
    FOR             shift and go to state 15
    PRINT           shift and go to state 8
    RES             shift and go to state 5
    MULTIESCALAR    shift and go to state 22
    LENGTH          shift and go to state 25
    CAPITALIZAR     shift and go to state 24
    COLINEALES      shift and go to state 14

    varAsig                        shift and go to state 19
    sentencia                      shift and go to state 10
    funcString                     shift and go to state 21
    vars                           shift and go to state 3
    g                              shift and go to state 42
    ctrl                           shift and go to state 4
    funcVoid                       shift and go to state 13
    funcReturn                     shift and go to state 23
    varOps                         shift and go to state 12
    funcBool                       shift and go to state 11
    loop                           shift and go to state 28
    func                           shift and go to state 16
    funcInt                        shift and go to state 6
    empty                          shift and go to state 26
    if                             shift and go to state 9

state 11

    (63) funcReturn -> funcBool .

    ]               reduce using rule 63 (funcReturn -> funcBool .)
    +               reduce using rule 63 (funcReturn -> funcBool .)
    -               reduce using rule 63 (funcReturn -> funcBool .)
    *               reduce using rule 63 (funcReturn -> funcBool .)
    /               reduce using rule 63 (funcReturn -> funcBool .)
    %               reduce using rule 63 (funcReturn -> funcBool .)
    ^               reduce using rule 63 (funcReturn -> funcBool .)
    ?               reduce using rule 63 (funcReturn -> funcBool .)
    AND             reduce using rule 63 (funcReturn -> funcBool .)
    OR              reduce using rule 63 (funcReturn -> funcBool .)
    EQEQ            reduce using rule 63 (funcReturn -> funcBool .)
    DISTINTO        reduce using rule 63 (funcReturn -> funcBool .)
    >               reduce using rule 63 (funcReturn -> funcBool .)
    <               reduce using rule 63 (funcReturn -> funcBool .)
    ;               reduce using rule 63 (funcReturn -> funcBool .)
    )               reduce using rule 63 (funcReturn -> funcBool .)
    ,               reduce using rule 63 (funcReturn -> funcBool .)
    :               reduce using rule 63 (funcReturn -> funcBool .)
    }               reduce using rule 63 (funcReturn -> funcBool .)


state 12

    (4) sentencia -> varOps . ;

    ;               shift and go to state 43


state 13

    (60) func -> funcVoid .

    ;               reduce using rule 60 (func -> funcVoid .)


state 14

    (67) funcBool -> COLINEALES . ( varExpresion , varExpresion )

    (               shift and go to state 44


state 15

    (12) loop -> FOR . ( varAsig ; varExpresion ; varOps ) bloque

    (               shift and go to state 45


state 16

    (5) sentencia -> func . ;

    ;               shift and go to state 46


state 17

    (57) varOps -> ID . MASMAS
    (58) varOps -> ID . MENOSMENOS
    (82) vars -> ID .

    MASMAS          shift and go to state 47
    MENOSMENOS      shift and go to state 48
    MENOSEQ         reduce using rule 82 (vars -> ID .)
    MASEQ           reduce using rule 82 (vars -> ID .)
    MULEQ           reduce using rule 82 (vars -> ID .)
    DIVEQ           reduce using rule 82 (vars -> ID .)
    =               reduce using rule 82 (vars -> ID .)


state 18

    (13) if -> IF . ( varExpresion ) THEN bloque else

    (               shift and go to state 49


state 19

    (6) sentencia -> varAsig . ;

    ;               shift and go to state 50


state 20

    (0) S' -> g .



state 21

    (62) funcReturn -> funcString .

    ]               reduce using rule 62 (funcReturn -> funcString .)
    +               reduce using rule 62 (funcReturn -> funcString .)
    -               reduce using rule 62 (funcReturn -> funcString .)
    *               reduce using rule 62 (funcReturn -> funcString .)
    /               reduce using rule 62 (funcReturn -> funcString .)
    %               reduce using rule 62 (funcReturn -> funcString .)
    ^               reduce using rule 62 (funcReturn -> funcString .)
    ?               reduce using rule 62 (funcReturn -> funcString .)
    AND             reduce using rule 62 (funcReturn -> funcString .)
    OR              reduce using rule 62 (funcReturn -> funcString .)
    EQEQ            reduce using rule 62 (funcReturn -> funcString .)
    DISTINTO        reduce using rule 62 (funcReturn -> funcString .)
    >               reduce using rule 62 (funcReturn -> funcString .)
    <               reduce using rule 62 (funcReturn -> funcString .)
    ;               reduce using rule 62 (funcReturn -> funcString .)
    )               reduce using rule 62 (funcReturn -> funcString .)
    ,               reduce using rule 62 (funcReturn -> funcString .)
    :               reduce using rule 62 (funcReturn -> funcString .)
    }               reduce using rule 62 (funcReturn -> funcString .)


state 22

    (64) funcInt -> MULTIESCALAR . ( varExpresion , varExpresion , param )

    (               shift and go to state 51


state 23

    (59) func -> funcReturn .

    ;               reduce using rule 59 (func -> funcReturn .)


state 24

    (66) funcString -> CAPITALIZAR . ( varExpresion )

    (               shift and go to state 52


state 25

    (65) funcInt -> LENGTH . ( varExpresion )

    (               shift and go to state 53


state 26

    (3) g -> empty .

    $end            reduce using rule 3 (g -> empty .)
    }               reduce using rule 3 (g -> empty .)


state 27

    (55) varOps -> MASMAS . ID

    ID              shift and go to state 54


state 28

    (9) ctrl -> loop .

    RETURN          reduce using rule 9 (ctrl -> loop .)
    MASMAS          reduce using rule 9 (ctrl -> loop .)
    MENOSMENOS      reduce using rule 9 (ctrl -> loop .)
    ID              reduce using rule 9 (ctrl -> loop .)
    IF              reduce using rule 9 (ctrl -> loop .)
    WHILE           reduce using rule 9 (ctrl -> loop .)
    DO              reduce using rule 9 (ctrl -> loop .)
    FOR             reduce using rule 9 (ctrl -> loop .)
    PRINT           reduce using rule 9 (ctrl -> loop .)
    RES             reduce using rule 9 (ctrl -> loop .)
    MULTIESCALAR    reduce using rule 9 (ctrl -> loop .)
    LENGTH          reduce using rule 9 (ctrl -> loop .)
    CAPITALIZAR     reduce using rule 9 (ctrl -> loop .)
    COLINEALES      reduce using rule 9 (ctrl -> loop .)
    $end            reduce using rule 9 (ctrl -> loop .)
    }               reduce using rule 9 (ctrl -> loop .)


state 29

    (56) varOps -> MENOSMENOS . ID

    ID              shift and go to state 55


state 30

    (11) loop -> DO bloque . WHILE ( varExpresion ) ;

    WHILE           shift and go to state 56


state 31

    (16) bloque -> sentencia .

    ELSE            reduce using rule 16 (bloque -> sentencia .)
    RETURN          reduce using rule 16 (bloque -> sentencia .)
    MASMAS          reduce using rule 16 (bloque -> sentencia .)
    MENOSMENOS      reduce using rule 16 (bloque -> sentencia .)
    ID              reduce using rule 16 (bloque -> sentencia .)
    IF              reduce using rule 16 (bloque -> sentencia .)
    WHILE           reduce using rule 16 (bloque -> sentencia .)
    DO              reduce using rule 16 (bloque -> sentencia .)
    FOR             reduce using rule 16 (bloque -> sentencia .)
    PRINT           reduce using rule 16 (bloque -> sentencia .)
    RES             reduce using rule 16 (bloque -> sentencia .)
    MULTIESCALAR    reduce using rule 16 (bloque -> sentencia .)
    LENGTH          reduce using rule 16 (bloque -> sentencia .)
    CAPITALIZAR     reduce using rule 16 (bloque -> sentencia .)
    COLINEALES      reduce using rule 16 (bloque -> sentencia .)
    $end            reduce using rule 16 (bloque -> sentencia .)
    }               reduce using rule 16 (bloque -> sentencia .)


state 32

    (17) bloque -> { . g }
    (1) g -> . sentencia g
    (2) g -> . ctrl g
    (3) g -> . empty
    (4) sentencia -> . varOps ;
    (5) sentencia -> . func ;
    (6) sentencia -> . varAsig ;
    (7) sentencia -> . RETURN ;
    (8) ctrl -> . if
    (9) ctrl -> . loop
    (71) empty -> .
    (55) varOps -> . MASMAS ID
    (56) varOps -> . MENOSMENOS ID
    (57) varOps -> . ID MASMAS
    (58) varOps -> . ID MENOSMENOS
    (59) func -> . funcReturn
    (60) func -> . funcVoid
    (72) varAsig -> . vars MENOSEQ varAsig
    (73) varAsig -> . vars MASEQ varAsig
    (74) varAsig -> . vars MULEQ varAsig
    (75) varAsig -> . vars DIVEQ varAsig
    (76) varAsig -> . vars = varAsig
    (77) varAsig -> . vars MASEQ varExpresion
    (78) varAsig -> . vars MENOSEQ varExpresion
    (79) varAsig -> . vars MULEQ varExpresion
    (80) varAsig -> . vars DIVEQ varExpresion
    (81) varAsig -> . vars = varExpresion
    (13) if -> . IF ( varExpresion ) THEN bloque else
    (10) loop -> . WHILE ( varExpresion ) bloque
    (11) loop -> . DO bloque WHILE ( varExpresion ) ;
    (12) loop -> . FOR ( varAsig ; varExpresion ; varOps ) bloque
    (61) funcReturn -> . funcInt
    (62) funcReturn -> . funcString
    (63) funcReturn -> . funcBool
    (68) funcVoid -> . PRINT ( varExpresion )
    (82) vars -> . ID
    (83) vars -> . RES
    (64) funcInt -> . MULTIESCALAR ( varExpresion , varExpresion , param )
    (65) funcInt -> . LENGTH ( varExpresion )
    (66) funcString -> . CAPITALIZAR ( varExpresion )
    (67) funcBool -> . COLINEALES ( varExpresion , varExpresion )

    RETURN          shift and go to state 2
    }               reduce using rule 71 (empty -> .)
    MASMAS          shift and go to state 27
    MENOSMENOS      shift and go to state 29
    ID              shift and go to state 17
    IF              shift and go to state 18
    WHILE           shift and go to state 7
    DO              shift and go to state 1
    FOR             shift and go to state 15
    PRINT           shift and go to state 8
    RES             shift and go to state 5
    MULTIESCALAR    shift and go to state 22
    LENGTH          shift and go to state 25
    CAPITALIZAR     shift and go to state 24
    COLINEALES      shift and go to state 14

    varAsig                        shift and go to state 19
    sentencia                      shift and go to state 10
    funcString                     shift and go to state 21
    vars                           shift and go to state 3
    g                              shift and go to state 57
    ctrl                           shift and go to state 4
    funcVoid                       shift and go to state 13
    funcReturn                     shift and go to state 23
    varOps                         shift and go to state 12
    funcBool                       shift and go to state 11
    loop                           shift and go to state 28
    func                           shift and go to state 16
    funcInt                        shift and go to state 6
    empty                          shift and go to state 26
    if                             shift and go to state 9

state 33

    (7) sentencia -> RETURN ; .

    RETURN          reduce using rule 7 (sentencia -> RETURN ; .)
    MASMAS          reduce using rule 7 (sentencia -> RETURN ; .)
    MENOSMENOS      reduce using rule 7 (sentencia -> RETURN ; .)
    ID              reduce using rule 7 (sentencia -> RETURN ; .)
    IF              reduce using rule 7 (sentencia -> RETURN ; .)
    WHILE           reduce using rule 7 (sentencia -> RETURN ; .)
    DO              reduce using rule 7 (sentencia -> RETURN ; .)
    FOR             reduce using rule 7 (sentencia -> RETURN ; .)
    PRINT           reduce using rule 7 (sentencia -> RETURN ; .)
    RES             reduce using rule 7 (sentencia -> RETURN ; .)
    MULTIESCALAR    reduce using rule 7 (sentencia -> RETURN ; .)
    LENGTH          reduce using rule 7 (sentencia -> RETURN ; .)
    CAPITALIZAR     reduce using rule 7 (sentencia -> RETURN ; .)
    COLINEALES      reduce using rule 7 (sentencia -> RETURN ; .)
    $end            reduce using rule 7 (sentencia -> RETURN ; .)
    }               reduce using rule 7 (sentencia -> RETURN ; .)
    ELSE            reduce using rule 7 (sentencia -> RETURN ; .)


state 34

    (72) varAsig -> vars MENOSEQ . varAsig
    (78) varAsig -> vars MENOSEQ . varExpresion
    (72) varAsig -> . vars MENOSEQ varAsig
    (73) varAsig -> . vars MASEQ varAsig
    (74) varAsig -> . vars MULEQ varAsig
    (75) varAsig -> . vars DIVEQ varAsig
    (76) varAsig -> . vars = varAsig
    (77) varAsig -> . vars MASEQ varExpresion
    (78) varAsig -> . vars MENOSEQ varExpresion
    (79) varAsig -> . vars MULEQ varExpresion
    (80) varAsig -> . vars DIVEQ varExpresion
    (81) varAsig -> . vars = varExpresion
    (18) varExpresion -> . varExpresion + varExpresion
    (19) varExpresion -> . varExpresion - varExpresion
    (20) varExpresion -> . varExpresion * varExpresion
    (21) varExpresion -> . varExpresion / varExpresion
    (22) varExpresion -> . varExpresion % varExpresion
    (23) varExpresion -> . varExpresion ^ varExpresion
    (24) varExpresion -> . ( - ( varExpresion ) )
    (25) varExpresion -> . ( + ( varExpresion ) )
    (26) varExpresion -> . varExpresion ? varExpresion : varExpresion
    (27) varExpresion -> . varExpresion AND varExpresion
    (28) varExpresion -> . NOT varExpresion
    (29) varExpresion -> . varExpresion OR varExpresion
    (30) varExpresion -> . varExpresion EQEQ varExpresion
    (31) varExpresion -> . varExpresion DISTINTO varExpresion
    (32) varExpresion -> . varExpresion > varExpresion
    (33) varExpresion -> . varExpresion < varExpresion
    (34) varExpresion -> . ( varExpresion )
    (35) varExpresion -> . tipos
    (36) varExpresion -> . funcReturn
    (37) varExpresion -> . varOps
    (38) varExpresion -> . vec
    (39) varExpresion -> . reg
    (40) varExpresion -> . vars
    (82) vars -> . ID
    (83) vars -> . RES
    (41) tipos -> . INT
    (42) tipos -> . FLOAT
    (43) tipos -> . STRING
    (44) tipos -> . BOOL
    (61) funcReturn -> . funcInt
    (62) funcReturn -> . funcString
    (63) funcReturn -> . funcBool
    (55) varOps -> . MASMAS ID
    (56) varOps -> . MENOSMENOS ID
    (57) varOps -> . ID MASMAS
    (58) varOps -> . ID MENOSMENOS
    (45) vec -> . [ elem ]
    (46) vec -> . ID m
    (51) reg -> . { campos }
    (52) reg -> . ID . ID
    (64) funcInt -> . MULTIESCALAR ( varExpresion , varExpresion , param )
    (65) funcInt -> . LENGTH ( varExpresion )
    (66) funcString -> . CAPITALIZAR ( varExpresion )
    (67) funcBool -> . COLINEALES ( varExpresion , varExpresion )

    (               shift and go to state 63
    NOT             shift and go to state 73
    ID              shift and go to state 66
    RES             shift and go to state 5
    INT             shift and go to state 68
    FLOAT           shift and go to state 70
    STRING          shift and go to state 64
    BOOL            shift and go to state 72
    MASMAS          shift and go to state 27
    MENOSMENOS      shift and go to state 29
    [               shift and go to state 65
    {               shift and go to state 74
    MULTIESCALAR    shift and go to state 22
    LENGTH          shift and go to state 25
    CAPITALIZAR     shift and go to state 24
    COLINEALES      shift and go to state 14

    varAsig                        shift and go to state 67
    funcBool                       shift and go to state 11
    vars                           shift and go to state 59
    funcString                     shift and go to state 21
    varExpresion                   shift and go to state 60
    funcReturn                     shift and go to state 69
    varOps                         shift and go to state 58
    tipos                          shift and go to state 61
    vec                            shift and go to state 62
    funcInt                        shift and go to state 6
    reg                            shift and go to state 71

state 35

    (73) varAsig -> vars MASEQ . varAsig
    (77) varAsig -> vars MASEQ . varExpresion
    (72) varAsig -> . vars MENOSEQ varAsig
    (73) varAsig -> . vars MASEQ varAsig
    (74) varAsig -> . vars MULEQ varAsig
    (75) varAsig -> . vars DIVEQ varAsig
    (76) varAsig -> . vars = varAsig
    (77) varAsig -> . vars MASEQ varExpresion
    (78) varAsig -> . vars MENOSEQ varExpresion
    (79) varAsig -> . vars MULEQ varExpresion
    (80) varAsig -> . vars DIVEQ varExpresion
    (81) varAsig -> . vars = varExpresion
    (18) varExpresion -> . varExpresion + varExpresion
    (19) varExpresion -> . varExpresion - varExpresion
    (20) varExpresion -> . varExpresion * varExpresion
    (21) varExpresion -> . varExpresion / varExpresion
    (22) varExpresion -> . varExpresion % varExpresion
    (23) varExpresion -> . varExpresion ^ varExpresion
    (24) varExpresion -> . ( - ( varExpresion ) )
    (25) varExpresion -> . ( + ( varExpresion ) )
    (26) varExpresion -> . varExpresion ? varExpresion : varExpresion
    (27) varExpresion -> . varExpresion AND varExpresion
    (28) varExpresion -> . NOT varExpresion
    (29) varExpresion -> . varExpresion OR varExpresion
    (30) varExpresion -> . varExpresion EQEQ varExpresion
    (31) varExpresion -> . varExpresion DISTINTO varExpresion
    (32) varExpresion -> . varExpresion > varExpresion
    (33) varExpresion -> . varExpresion < varExpresion
    (34) varExpresion -> . ( varExpresion )
    (35) varExpresion -> . tipos
    (36) varExpresion -> . funcReturn
    (37) varExpresion -> . varOps
    (38) varExpresion -> . vec
    (39) varExpresion -> . reg
    (40) varExpresion -> . vars
    (82) vars -> . ID
    (83) vars -> . RES
    (41) tipos -> . INT
    (42) tipos -> . FLOAT
    (43) tipos -> . STRING
    (44) tipos -> . BOOL
    (61) funcReturn -> . funcInt
    (62) funcReturn -> . funcString
    (63) funcReturn -> . funcBool
    (55) varOps -> . MASMAS ID
    (56) varOps -> . MENOSMENOS ID
    (57) varOps -> . ID MASMAS
    (58) varOps -> . ID MENOSMENOS
    (45) vec -> . [ elem ]
    (46) vec -> . ID m
    (51) reg -> . { campos }
    (52) reg -> . ID . ID
    (64) funcInt -> . MULTIESCALAR ( varExpresion , varExpresion , param )
    (65) funcInt -> . LENGTH ( varExpresion )
    (66) funcString -> . CAPITALIZAR ( varExpresion )
    (67) funcBool -> . COLINEALES ( varExpresion , varExpresion )

    (               shift and go to state 63
    NOT             shift and go to state 73
    ID              shift and go to state 66
    RES             shift and go to state 5
    INT             shift and go to state 68
    FLOAT           shift and go to state 70
    STRING          shift and go to state 64
    BOOL            shift and go to state 72
    MASMAS          shift and go to state 27
    MENOSMENOS      shift and go to state 29
    [               shift and go to state 65
    {               shift and go to state 74
    MULTIESCALAR    shift and go to state 22
    LENGTH          shift and go to state 25
    CAPITALIZAR     shift and go to state 24
    COLINEALES      shift and go to state 14

    varAsig                        shift and go to state 76
    funcBool                       shift and go to state 11
    vars                           shift and go to state 59
    funcString                     shift and go to state 21
    varExpresion                   shift and go to state 75
    funcReturn                     shift and go to state 69
    varOps                         shift and go to state 58
    tipos                          shift and go to state 61
    vec                            shift and go to state 62
    funcInt                        shift and go to state 6
    reg                            shift and go to state 71

state 36

    (74) varAsig -> vars MULEQ . varAsig
    (79) varAsig -> vars MULEQ . varExpresion
    (72) varAsig -> . vars MENOSEQ varAsig
    (73) varAsig -> . vars MASEQ varAsig
    (74) varAsig -> . vars MULEQ varAsig
    (75) varAsig -> . vars DIVEQ varAsig
    (76) varAsig -> . vars = varAsig
    (77) varAsig -> . vars MASEQ varExpresion
    (78) varAsig -> . vars MENOSEQ varExpresion
    (79) varAsig -> . vars MULEQ varExpresion
    (80) varAsig -> . vars DIVEQ varExpresion
    (81) varAsig -> . vars = varExpresion
    (18) varExpresion -> . varExpresion + varExpresion
    (19) varExpresion -> . varExpresion - varExpresion
    (20) varExpresion -> . varExpresion * varExpresion
    (21) varExpresion -> . varExpresion / varExpresion
    (22) varExpresion -> . varExpresion % varExpresion
    (23) varExpresion -> . varExpresion ^ varExpresion
    (24) varExpresion -> . ( - ( varExpresion ) )
    (25) varExpresion -> . ( + ( varExpresion ) )
    (26) varExpresion -> . varExpresion ? varExpresion : varExpresion
    (27) varExpresion -> . varExpresion AND varExpresion
    (28) varExpresion -> . NOT varExpresion
    (29) varExpresion -> . varExpresion OR varExpresion
    (30) varExpresion -> . varExpresion EQEQ varExpresion
    (31) varExpresion -> . varExpresion DISTINTO varExpresion
    (32) varExpresion -> . varExpresion > varExpresion
    (33) varExpresion -> . varExpresion < varExpresion
    (34) varExpresion -> . ( varExpresion )
    (35) varExpresion -> . tipos
    (36) varExpresion -> . funcReturn
    (37) varExpresion -> . varOps
    (38) varExpresion -> . vec
    (39) varExpresion -> . reg
    (40) varExpresion -> . vars
    (82) vars -> . ID
    (83) vars -> . RES
    (41) tipos -> . INT
    (42) tipos -> . FLOAT
    (43) tipos -> . STRING
    (44) tipos -> . BOOL
    (61) funcReturn -> . funcInt
    (62) funcReturn -> . funcString
    (63) funcReturn -> . funcBool
    (55) varOps -> . MASMAS ID
    (56) varOps -> . MENOSMENOS ID
    (57) varOps -> . ID MASMAS
    (58) varOps -> . ID MENOSMENOS
    (45) vec -> . [ elem ]
    (46) vec -> . ID m
    (51) reg -> . { campos }
    (52) reg -> . ID . ID
    (64) funcInt -> . MULTIESCALAR ( varExpresion , varExpresion , param )
    (65) funcInt -> . LENGTH ( varExpresion )
    (66) funcString -> . CAPITALIZAR ( varExpresion )
    (67) funcBool -> . COLINEALES ( varExpresion , varExpresion )

    (               shift and go to state 63
    NOT             shift and go to state 73
    ID              shift and go to state 66
    RES             shift and go to state 5
    INT             shift and go to state 68
    FLOAT           shift and go to state 70
    STRING          shift and go to state 64
    BOOL            shift and go to state 72
    MASMAS          shift and go to state 27
    MENOSMENOS      shift and go to state 29
    [               shift and go to state 65
    {               shift and go to state 74
    MULTIESCALAR    shift and go to state 22
    LENGTH          shift and go to state 25
    CAPITALIZAR     shift and go to state 24
    COLINEALES      shift and go to state 14

    varAsig                        shift and go to state 78
    funcBool                       shift and go to state 11
    vars                           shift and go to state 59
    funcString                     shift and go to state 21
    varExpresion                   shift and go to state 77
    funcReturn                     shift and go to state 69
    varOps                         shift and go to state 58
    tipos                          shift and go to state 61
    vec                            shift and go to state 62
    funcInt                        shift and go to state 6
    reg                            shift and go to state 71

state 37

    (76) varAsig -> vars = . varAsig
    (81) varAsig -> vars = . varExpresion
    (72) varAsig -> . vars MENOSEQ varAsig
    (73) varAsig -> . vars MASEQ varAsig
    (74) varAsig -> . vars MULEQ varAsig
    (75) varAsig -> . vars DIVEQ varAsig
    (76) varAsig -> . vars = varAsig
    (77) varAsig -> . vars MASEQ varExpresion
    (78) varAsig -> . vars MENOSEQ varExpresion
    (79) varAsig -> . vars MULEQ varExpresion
    (80) varAsig -> . vars DIVEQ varExpresion
    (81) varAsig -> . vars = varExpresion
    (18) varExpresion -> . varExpresion + varExpresion
    (19) varExpresion -> . varExpresion - varExpresion
    (20) varExpresion -> . varExpresion * varExpresion
    (21) varExpresion -> . varExpresion / varExpresion
    (22) varExpresion -> . varExpresion % varExpresion
    (23) varExpresion -> . varExpresion ^ varExpresion
    (24) varExpresion -> . ( - ( varExpresion ) )
    (25) varExpresion -> . ( + ( varExpresion ) )
    (26) varExpresion -> . varExpresion ? varExpresion : varExpresion
    (27) varExpresion -> . varExpresion AND varExpresion
    (28) varExpresion -> . NOT varExpresion
    (29) varExpresion -> . varExpresion OR varExpresion
    (30) varExpresion -> . varExpresion EQEQ varExpresion
    (31) varExpresion -> . varExpresion DISTINTO varExpresion
    (32) varExpresion -> . varExpresion > varExpresion
    (33) varExpresion -> . varExpresion < varExpresion
    (34) varExpresion -> . ( varExpresion )
    (35) varExpresion -> . tipos
    (36) varExpresion -> . funcReturn
    (37) varExpresion -> . varOps
    (38) varExpresion -> . vec
    (39) varExpresion -> . reg
    (40) varExpresion -> . vars
    (82) vars -> . ID
    (83) vars -> . RES
    (41) tipos -> . INT
    (42) tipos -> . FLOAT
    (43) tipos -> . STRING
    (44) tipos -> . BOOL
    (61) funcReturn -> . funcInt
    (62) funcReturn -> . funcString
    (63) funcReturn -> . funcBool
    (55) varOps -> . MASMAS ID
    (56) varOps -> . MENOSMENOS ID
    (57) varOps -> . ID MASMAS
    (58) varOps -> . ID MENOSMENOS
    (45) vec -> . [ elem ]
    (46) vec -> . ID m
    (51) reg -> . { campos }
    (52) reg -> . ID . ID
    (64) funcInt -> . MULTIESCALAR ( varExpresion , varExpresion , param )
    (65) funcInt -> . LENGTH ( varExpresion )
    (66) funcString -> . CAPITALIZAR ( varExpresion )
    (67) funcBool -> . COLINEALES ( varExpresion , varExpresion )

    (               shift and go to state 63
    NOT             shift and go to state 73
    ID              shift and go to state 66
    RES             shift and go to state 5
    INT             shift and go to state 68
    FLOAT           shift and go to state 70
    STRING          shift and go to state 64
    BOOL            shift and go to state 72
    MASMAS          shift and go to state 27
    MENOSMENOS      shift and go to state 29
    [               shift and go to state 65
    {               shift and go to state 74
    MULTIESCALAR    shift and go to state 22
    LENGTH          shift and go to state 25
    CAPITALIZAR     shift and go to state 24
    COLINEALES      shift and go to state 14

    varAsig                        shift and go to state 80
    funcBool                       shift and go to state 11
    vars                           shift and go to state 59
    funcString                     shift and go to state 21
    varExpresion                   shift and go to state 79
    funcReturn                     shift and go to state 69
    varOps                         shift and go to state 58
    tipos                          shift and go to state 61
    vec                            shift and go to state 62
    funcInt                        shift and go to state 6
    reg                            shift and go to state 71

state 38

    (75) varAsig -> vars DIVEQ . varAsig
    (80) varAsig -> vars DIVEQ . varExpresion
    (72) varAsig -> . vars MENOSEQ varAsig
    (73) varAsig -> . vars MASEQ varAsig
    (74) varAsig -> . vars MULEQ varAsig
    (75) varAsig -> . vars DIVEQ varAsig
    (76) varAsig -> . vars = varAsig
    (77) varAsig -> . vars MASEQ varExpresion
    (78) varAsig -> . vars MENOSEQ varExpresion
    (79) varAsig -> . vars MULEQ varExpresion
    (80) varAsig -> . vars DIVEQ varExpresion
    (81) varAsig -> . vars = varExpresion
    (18) varExpresion -> . varExpresion + varExpresion
    (19) varExpresion -> . varExpresion - varExpresion
    (20) varExpresion -> . varExpresion * varExpresion
    (21) varExpresion -> . varExpresion / varExpresion
    (22) varExpresion -> . varExpresion % varExpresion
    (23) varExpresion -> . varExpresion ^ varExpresion
    (24) varExpresion -> . ( - ( varExpresion ) )
    (25) varExpresion -> . ( + ( varExpresion ) )
    (26) varExpresion -> . varExpresion ? varExpresion : varExpresion
    (27) varExpresion -> . varExpresion AND varExpresion
    (28) varExpresion -> . NOT varExpresion
    (29) varExpresion -> . varExpresion OR varExpresion
    (30) varExpresion -> . varExpresion EQEQ varExpresion
    (31) varExpresion -> . varExpresion DISTINTO varExpresion
    (32) varExpresion -> . varExpresion > varExpresion
    (33) varExpresion -> . varExpresion < varExpresion
    (34) varExpresion -> . ( varExpresion )
    (35) varExpresion -> . tipos
    (36) varExpresion -> . funcReturn
    (37) varExpresion -> . varOps
    (38) varExpresion -> . vec
    (39) varExpresion -> . reg
    (40) varExpresion -> . vars
    (82) vars -> . ID
    (83) vars -> . RES
    (41) tipos -> . INT
    (42) tipos -> . FLOAT
    (43) tipos -> . STRING
    (44) tipos -> . BOOL
    (61) funcReturn -> . funcInt
    (62) funcReturn -> . funcString
    (63) funcReturn -> . funcBool
    (55) varOps -> . MASMAS ID
    (56) varOps -> . MENOSMENOS ID
    (57) varOps -> . ID MASMAS
    (58) varOps -> . ID MENOSMENOS
    (45) vec -> . [ elem ]
    (46) vec -> . ID m
    (51) reg -> . { campos }
    (52) reg -> . ID . ID
    (64) funcInt -> . MULTIESCALAR ( varExpresion , varExpresion , param )
    (65) funcInt -> . LENGTH ( varExpresion )
    (66) funcString -> . CAPITALIZAR ( varExpresion )
    (67) funcBool -> . COLINEALES ( varExpresion , varExpresion )

    (               shift and go to state 63
    NOT             shift and go to state 73
    ID              shift and go to state 66
    RES             shift and go to state 5
    INT             shift and go to state 68
    FLOAT           shift and go to state 70
    STRING          shift and go to state 64
    BOOL            shift and go to state 72
    MASMAS          shift and go to state 27
    MENOSMENOS      shift and go to state 29
    [               shift and go to state 65
    {               shift and go to state 74
    MULTIESCALAR    shift and go to state 22
    LENGTH          shift and go to state 25
    CAPITALIZAR     shift and go to state 24
    COLINEALES      shift and go to state 14

    varAsig                        shift and go to state 82
    funcBool                       shift and go to state 11
    vars                           shift and go to state 59
    funcString                     shift and go to state 21
    varExpresion                   shift and go to state 81
    funcReturn                     shift and go to state 69
    varOps                         shift and go to state 58
    tipos                          shift and go to state 61
    vec                            shift and go to state 62
    funcInt                        shift and go to state 6
    reg                            shift and go to state 71

state 39

    (2) g -> ctrl g .

    $end            reduce using rule 2 (g -> ctrl g .)
    }               reduce using rule 2 (g -> ctrl g .)


state 40

    (10) loop -> WHILE ( . varExpresion ) bloque
    (18) varExpresion -> . varExpresion + varExpresion
    (19) varExpresion -> . varExpresion - varExpresion
    (20) varExpresion -> . varExpresion * varExpresion
    (21) varExpresion -> . varExpresion / varExpresion
    (22) varExpresion -> . varExpresion % varExpresion
    (23) varExpresion -> . varExpresion ^ varExpresion
    (24) varExpresion -> . ( - ( varExpresion ) )
    (25) varExpresion -> . ( + ( varExpresion ) )
    (26) varExpresion -> . varExpresion ? varExpresion : varExpresion
    (27) varExpresion -> . varExpresion AND varExpresion
    (28) varExpresion -> . NOT varExpresion
    (29) varExpresion -> . varExpresion OR varExpresion
    (30) varExpresion -> . varExpresion EQEQ varExpresion
    (31) varExpresion -> . varExpresion DISTINTO varExpresion
    (32) varExpresion -> . varExpresion > varExpresion
    (33) varExpresion -> . varExpresion < varExpresion
    (34) varExpresion -> . ( varExpresion )
    (35) varExpresion -> . tipos
    (36) varExpresion -> . funcReturn
    (37) varExpresion -> . varOps
    (38) varExpresion -> . vec
    (39) varExpresion -> . reg
    (40) varExpresion -> . vars
    (41) tipos -> . INT
    (42) tipos -> . FLOAT
    (43) tipos -> . STRING
    (44) tipos -> . BOOL
    (61) funcReturn -> . funcInt
    (62) funcReturn -> . funcString
    (63) funcReturn -> . funcBool
    (55) varOps -> . MASMAS ID
    (56) varOps -> . MENOSMENOS ID
    (57) varOps -> . ID MASMAS
    (58) varOps -> . ID MENOSMENOS
    (45) vec -> . [ elem ]
    (46) vec -> . ID m
    (51) reg -> . { campos }
    (52) reg -> . ID . ID
    (82) vars -> . ID
    (83) vars -> . RES
    (64) funcInt -> . MULTIESCALAR ( varExpresion , varExpresion , param )
    (65) funcInt -> . LENGTH ( varExpresion )
    (66) funcString -> . CAPITALIZAR ( varExpresion )
    (67) funcBool -> . COLINEALES ( varExpresion , varExpresion )

    (               shift and go to state 63
    NOT             shift and go to state 73
    INT             shift and go to state 68
    FLOAT           shift and go to state 70
    STRING          shift and go to state 64
    BOOL            shift and go to state 72
    MASMAS          shift and go to state 27
    MENOSMENOS      shift and go to state 29
    ID              shift and go to state 85
    [               shift and go to state 65
    {               shift and go to state 74
    RES             shift and go to state 5
    MULTIESCALAR    shift and go to state 22
    LENGTH          shift and go to state 25
    CAPITALIZAR     shift and go to state 24
    COLINEALES      shift and go to state 14

    funcBool                       shift and go to state 11
    vars                           shift and go to state 83
    funcString                     shift and go to state 21
    varExpresion                   shift and go to state 84
    funcReturn                     shift and go to state 69
    varOps                         shift and go to state 58
    tipos                          shift and go to state 61
    vec                            shift and go to state 62
    funcInt                        shift and go to state 6
    reg                            shift and go to state 71

state 41

    (68) funcVoid -> PRINT ( . varExpresion )
    (18) varExpresion -> . varExpresion + varExpresion
    (19) varExpresion -> . varExpresion - varExpresion
    (20) varExpresion -> . varExpresion * varExpresion
    (21) varExpresion -> . varExpresion / varExpresion
    (22) varExpresion -> . varExpresion % varExpresion
    (23) varExpresion -> . varExpresion ^ varExpresion
    (24) varExpresion -> . ( - ( varExpresion ) )
    (25) varExpresion -> . ( + ( varExpresion ) )
    (26) varExpresion -> . varExpresion ? varExpresion : varExpresion
    (27) varExpresion -> . varExpresion AND varExpresion
    (28) varExpresion -> . NOT varExpresion
    (29) varExpresion -> . varExpresion OR varExpresion
    (30) varExpresion -> . varExpresion EQEQ varExpresion
    (31) varExpresion -> . varExpresion DISTINTO varExpresion
    (32) varExpresion -> . varExpresion > varExpresion
    (33) varExpresion -> . varExpresion < varExpresion
    (34) varExpresion -> . ( varExpresion )
    (35) varExpresion -> . tipos
    (36) varExpresion -> . funcReturn
    (37) varExpresion -> . varOps
    (38) varExpresion -> . vec
    (39) varExpresion -> . reg
    (40) varExpresion -> . vars
    (41) tipos -> . INT
    (42) tipos -> . FLOAT
    (43) tipos -> . STRING
    (44) tipos -> . BOOL
    (61) funcReturn -> . funcInt
    (62) funcReturn -> . funcString
    (63) funcReturn -> . funcBool
    (55) varOps -> . MASMAS ID
    (56) varOps -> . MENOSMENOS ID
    (57) varOps -> . ID MASMAS
    (58) varOps -> . ID MENOSMENOS
    (45) vec -> . [ elem ]
    (46) vec -> . ID m
    (51) reg -> . { campos }
    (52) reg -> . ID . ID
    (82) vars -> . ID
    (83) vars -> . RES
    (64) funcInt -> . MULTIESCALAR ( varExpresion , varExpresion , param )
    (65) funcInt -> . LENGTH ( varExpresion )
    (66) funcString -> . CAPITALIZAR ( varExpresion )
    (67) funcBool -> . COLINEALES ( varExpresion , varExpresion )

    (               shift and go to state 63
    NOT             shift and go to state 73
    INT             shift and go to state 68
    FLOAT           shift and go to state 70
    STRING          shift and go to state 64
    BOOL            shift and go to state 72
    MASMAS          shift and go to state 27
    MENOSMENOS      shift and go to state 29
    ID              shift and go to state 85
    [               shift and go to state 65
    {               shift and go to state 74
    RES             shift and go to state 5
    MULTIESCALAR    shift and go to state 22
    LENGTH          shift and go to state 25
    CAPITALIZAR     shift and go to state 24
    COLINEALES      shift and go to state 14

    funcBool                       shift and go to state 11
    vars                           shift and go to state 83
    funcString                     shift and go to state 21
    varExpresion                   shift and go to state 86
    funcReturn                     shift and go to state 69
    varOps                         shift and go to state 58
    tipos                          shift and go to state 61
    vec                            shift and go to state 62
    funcInt                        shift and go to state 6
    reg                            shift and go to state 71

state 42

    (1) g -> sentencia g .

    $end            reduce using rule 1 (g -> sentencia g .)
    }               reduce using rule 1 (g -> sentencia g .)


state 43

    (4) sentencia -> varOps ; .

    RETURN          reduce using rule 4 (sentencia -> varOps ; .)
    MASMAS          reduce using rule 4 (sentencia -> varOps ; .)
    MENOSMENOS      reduce using rule 4 (sentencia -> varOps ; .)
    ID              reduce using rule 4 (sentencia -> varOps ; .)
    IF              reduce using rule 4 (sentencia -> varOps ; .)
    WHILE           reduce using rule 4 (sentencia -> varOps ; .)
    DO              reduce using rule 4 (sentencia -> varOps ; .)
    FOR             reduce using rule 4 (sentencia -> varOps ; .)
    PRINT           reduce using rule 4 (sentencia -> varOps ; .)
    RES             reduce using rule 4 (sentencia -> varOps ; .)
    MULTIESCALAR    reduce using rule 4 (sentencia -> varOps ; .)
    LENGTH          reduce using rule 4 (sentencia -> varOps ; .)
    CAPITALIZAR     reduce using rule 4 (sentencia -> varOps ; .)
    COLINEALES      reduce using rule 4 (sentencia -> varOps ; .)
    $end            reduce using rule 4 (sentencia -> varOps ; .)
    }               reduce using rule 4 (sentencia -> varOps ; .)
    ELSE            reduce using rule 4 (sentencia -> varOps ; .)


state 44

    (67) funcBool -> COLINEALES ( . varExpresion , varExpresion )
    (18) varExpresion -> . varExpresion + varExpresion
    (19) varExpresion -> . varExpresion - varExpresion
    (20) varExpresion -> . varExpresion * varExpresion
    (21) varExpresion -> . varExpresion / varExpresion
    (22) varExpresion -> . varExpresion % varExpresion
    (23) varExpresion -> . varExpresion ^ varExpresion
    (24) varExpresion -> . ( - ( varExpresion ) )
    (25) varExpresion -> . ( + ( varExpresion ) )
    (26) varExpresion -> . varExpresion ? varExpresion : varExpresion
    (27) varExpresion -> . varExpresion AND varExpresion
    (28) varExpresion -> . NOT varExpresion
    (29) varExpresion -> . varExpresion OR varExpresion
    (30) varExpresion -> . varExpresion EQEQ varExpresion
    (31) varExpresion -> . varExpresion DISTINTO varExpresion
    (32) varExpresion -> . varExpresion > varExpresion
    (33) varExpresion -> . varExpresion < varExpresion
    (34) varExpresion -> . ( varExpresion )
    (35) varExpresion -> . tipos
    (36) varExpresion -> . funcReturn
    (37) varExpresion -> . varOps
    (38) varExpresion -> . vec
    (39) varExpresion -> . reg
    (40) varExpresion -> . vars
    (41) tipos -> . INT
    (42) tipos -> . FLOAT
    (43) tipos -> . STRING
    (44) tipos -> . BOOL
    (61) funcReturn -> . funcInt
    (62) funcReturn -> . funcString
    (63) funcReturn -> . funcBool
    (55) varOps -> . MASMAS ID
    (56) varOps -> . MENOSMENOS ID
    (57) varOps -> . ID MASMAS
    (58) varOps -> . ID MENOSMENOS
    (45) vec -> . [ elem ]
    (46) vec -> . ID m
    (51) reg -> . { campos }
    (52) reg -> . ID . ID
    (82) vars -> . ID
    (83) vars -> . RES
    (64) funcInt -> . MULTIESCALAR ( varExpresion , varExpresion , param )
    (65) funcInt -> . LENGTH ( varExpresion )
    (66) funcString -> . CAPITALIZAR ( varExpresion )
    (67) funcBool -> . COLINEALES ( varExpresion , varExpresion )

    (               shift and go to state 63
    NOT             shift and go to state 73
    INT             shift and go to state 68
    FLOAT           shift and go to state 70
    STRING          shift and go to state 64
    BOOL            shift and go to state 72
    MASMAS          shift and go to state 27
    MENOSMENOS      shift and go to state 29
    ID              shift and go to state 85
    [               shift and go to state 65
    {               shift and go to state 74
    RES             shift and go to state 5
    MULTIESCALAR    shift and go to state 22
    LENGTH          shift and go to state 25
    CAPITALIZAR     shift and go to state 24
    COLINEALES      shift and go to state 14

    funcBool                       shift and go to state 11
    vars                           shift and go to state 83
    funcString                     shift and go to state 21
    varExpresion                   shift and go to state 87
    funcReturn                     shift and go to state 69
    varOps                         shift and go to state 58
    tipos                          shift and go to state 61
    vec                            shift and go to state 62
    funcInt                        shift and go to state 6
    reg                            shift and go to state 71

state 45

    (12) loop -> FOR ( . varAsig ; varExpresion ; varOps ) bloque
    (72) varAsig -> . vars MENOSEQ varAsig
    (73) varAsig -> . vars MASEQ varAsig
    (74) varAsig -> . vars MULEQ varAsig
    (75) varAsig -> . vars DIVEQ varAsig
    (76) varAsig -> . vars = varAsig
    (77) varAsig -> . vars MASEQ varExpresion
    (78) varAsig -> . vars MENOSEQ varExpresion
    (79) varAsig -> . vars MULEQ varExpresion
    (80) varAsig -> . vars DIVEQ varExpresion
    (81) varAsig -> . vars = varExpresion
    (82) vars -> . ID
    (83) vars -> . RES

    ID              shift and go to state 89
    RES             shift and go to state 5

    varAsig                        shift and go to state 88
    vars                           shift and go to state 3

state 46

    (5) sentencia -> func ; .

    RETURN          reduce using rule 5 (sentencia -> func ; .)
    MASMAS          reduce using rule 5 (sentencia -> func ; .)
    MENOSMENOS      reduce using rule 5 (sentencia -> func ; .)
    ID              reduce using rule 5 (sentencia -> func ; .)
    IF              reduce using rule 5 (sentencia -> func ; .)
    WHILE           reduce using rule 5 (sentencia -> func ; .)
    DO              reduce using rule 5 (sentencia -> func ; .)
    FOR             reduce using rule 5 (sentencia -> func ; .)
    PRINT           reduce using rule 5 (sentencia -> func ; .)
    RES             reduce using rule 5 (sentencia -> func ; .)
    MULTIESCALAR    reduce using rule 5 (sentencia -> func ; .)
    LENGTH          reduce using rule 5 (sentencia -> func ; .)
    CAPITALIZAR     reduce using rule 5 (sentencia -> func ; .)
    COLINEALES      reduce using rule 5 (sentencia -> func ; .)
    $end            reduce using rule 5 (sentencia -> func ; .)
    }               reduce using rule 5 (sentencia -> func ; .)
    ELSE            reduce using rule 5 (sentencia -> func ; .)


state 47

    (57) varOps -> ID MASMAS .

    )               reduce using rule 57 (varOps -> ID MASMAS .)
    +               reduce using rule 57 (varOps -> ID MASMAS .)
    -               reduce using rule 57 (varOps -> ID MASMAS .)
    *               reduce using rule 57 (varOps -> ID MASMAS .)
    /               reduce using rule 57 (varOps -> ID MASMAS .)
    %               reduce using rule 57 (varOps -> ID MASMAS .)
    ^               reduce using rule 57 (varOps -> ID MASMAS .)
    ?               reduce using rule 57 (varOps -> ID MASMAS .)
    AND             reduce using rule 57 (varOps -> ID MASMAS .)
    OR              reduce using rule 57 (varOps -> ID MASMAS .)
    EQEQ            reduce using rule 57 (varOps -> ID MASMAS .)
    DISTINTO        reduce using rule 57 (varOps -> ID MASMAS .)
    >               reduce using rule 57 (varOps -> ID MASMAS .)
    <               reduce using rule 57 (varOps -> ID MASMAS .)
    ;               reduce using rule 57 (varOps -> ID MASMAS .)
    ,               reduce using rule 57 (varOps -> ID MASMAS .)
    ]               reduce using rule 57 (varOps -> ID MASMAS .)
    :               reduce using rule 57 (varOps -> ID MASMAS .)
    }               reduce using rule 57 (varOps -> ID MASMAS .)


state 48

    (58) varOps -> ID MENOSMENOS .

    )               reduce using rule 58 (varOps -> ID MENOSMENOS .)
    +               reduce using rule 58 (varOps -> ID MENOSMENOS .)
    -               reduce using rule 58 (varOps -> ID MENOSMENOS .)
    *               reduce using rule 58 (varOps -> ID MENOSMENOS .)
    /               reduce using rule 58 (varOps -> ID MENOSMENOS .)
    %               reduce using rule 58 (varOps -> ID MENOSMENOS .)
    ^               reduce using rule 58 (varOps -> ID MENOSMENOS .)
    ?               reduce using rule 58 (varOps -> ID MENOSMENOS .)
    AND             reduce using rule 58 (varOps -> ID MENOSMENOS .)
    OR              reduce using rule 58 (varOps -> ID MENOSMENOS .)
    EQEQ            reduce using rule 58 (varOps -> ID MENOSMENOS .)
    DISTINTO        reduce using rule 58 (varOps -> ID MENOSMENOS .)
    >               reduce using rule 58 (varOps -> ID MENOSMENOS .)
    <               reduce using rule 58 (varOps -> ID MENOSMENOS .)
    ;               reduce using rule 58 (varOps -> ID MENOSMENOS .)
    ,               reduce using rule 58 (varOps -> ID MENOSMENOS .)
    ]               reduce using rule 58 (varOps -> ID MENOSMENOS .)
    :               reduce using rule 58 (varOps -> ID MENOSMENOS .)
    }               reduce using rule 58 (varOps -> ID MENOSMENOS .)


state 49

    (13) if -> IF ( . varExpresion ) THEN bloque else
    (18) varExpresion -> . varExpresion + varExpresion
    (19) varExpresion -> . varExpresion - varExpresion
    (20) varExpresion -> . varExpresion * varExpresion
    (21) varExpresion -> . varExpresion / varExpresion
    (22) varExpresion -> . varExpresion % varExpresion
    (23) varExpresion -> . varExpresion ^ varExpresion
    (24) varExpresion -> . ( - ( varExpresion ) )
    (25) varExpresion -> . ( + ( varExpresion ) )
    (26) varExpresion -> . varExpresion ? varExpresion : varExpresion
    (27) varExpresion -> . varExpresion AND varExpresion
    (28) varExpresion -> . NOT varExpresion
    (29) varExpresion -> . varExpresion OR varExpresion
    (30) varExpresion -> . varExpresion EQEQ varExpresion
    (31) varExpresion -> . varExpresion DISTINTO varExpresion
    (32) varExpresion -> . varExpresion > varExpresion
    (33) varExpresion -> . varExpresion < varExpresion
    (34) varExpresion -> . ( varExpresion )
    (35) varExpresion -> . tipos
    (36) varExpresion -> . funcReturn
    (37) varExpresion -> . varOps
    (38) varExpresion -> . vec
    (39) varExpresion -> . reg
    (40) varExpresion -> . vars
    (41) tipos -> . INT
    (42) tipos -> . FLOAT
    (43) tipos -> . STRING
    (44) tipos -> . BOOL
    (61) funcReturn -> . funcInt
    (62) funcReturn -> . funcString
    (63) funcReturn -> . funcBool
    (55) varOps -> . MASMAS ID
    (56) varOps -> . MENOSMENOS ID
    (57) varOps -> . ID MASMAS
    (58) varOps -> . ID MENOSMENOS
    (45) vec -> . [ elem ]
    (46) vec -> . ID m
    (51) reg -> . { campos }
    (52) reg -> . ID . ID
    (82) vars -> . ID
    (83) vars -> . RES
    (64) funcInt -> . MULTIESCALAR ( varExpresion , varExpresion , param )
    (65) funcInt -> . LENGTH ( varExpresion )
    (66) funcString -> . CAPITALIZAR ( varExpresion )
    (67) funcBool -> . COLINEALES ( varExpresion , varExpresion )

    (               shift and go to state 63
    NOT             shift and go to state 73
    INT             shift and go to state 68
    FLOAT           shift and go to state 70
    STRING          shift and go to state 64
    BOOL            shift and go to state 72
    MASMAS          shift and go to state 27
    MENOSMENOS      shift and go to state 29
    ID              shift and go to state 85
    [               shift and go to state 65
    {               shift and go to state 74
    RES             shift and go to state 5
    MULTIESCALAR    shift and go to state 22
    LENGTH          shift and go to state 25
    CAPITALIZAR     shift and go to state 24
    COLINEALES      shift and go to state 14

    funcBool                       shift and go to state 11
    vars                           shift and go to state 83
    funcString                     shift and go to state 21
    varExpresion                   shift and go to state 90
    funcReturn                     shift and go to state 69
    varOps                         shift and go to state 58
    tipos                          shift and go to state 61
    vec                            shift and go to state 62
    funcInt                        shift and go to state 6
    reg                            shift and go to state 71

state 50

    (6) sentencia -> varAsig ; .

    RETURN          reduce using rule 6 (sentencia -> varAsig ; .)
    MASMAS          reduce using rule 6 (sentencia -> varAsig ; .)
    MENOSMENOS      reduce using rule 6 (sentencia -> varAsig ; .)
    ID              reduce using rule 6 (sentencia -> varAsig ; .)
    IF              reduce using rule 6 (sentencia -> varAsig ; .)
    WHILE           reduce using rule 6 (sentencia -> varAsig ; .)
    DO              reduce using rule 6 (sentencia -> varAsig ; .)
    FOR             reduce using rule 6 (sentencia -> varAsig ; .)
    PRINT           reduce using rule 6 (sentencia -> varAsig ; .)
    RES             reduce using rule 6 (sentencia -> varAsig ; .)
    MULTIESCALAR    reduce using rule 6 (sentencia -> varAsig ; .)
    LENGTH          reduce using rule 6 (sentencia -> varAsig ; .)
    CAPITALIZAR     reduce using rule 6 (sentencia -> varAsig ; .)
    COLINEALES      reduce using rule 6 (sentencia -> varAsig ; .)
    $end            reduce using rule 6 (sentencia -> varAsig ; .)
    }               reduce using rule 6 (sentencia -> varAsig ; .)
    ELSE            reduce using rule 6 (sentencia -> varAsig ; .)


state 51

    (64) funcInt -> MULTIESCALAR ( . varExpresion , varExpresion , param )
    (18) varExpresion -> . varExpresion + varExpresion
    (19) varExpresion -> . varExpresion - varExpresion
    (20) varExpresion -> . varExpresion * varExpresion
    (21) varExpresion -> . varExpresion / varExpresion
    (22) varExpresion -> . varExpresion % varExpresion
    (23) varExpresion -> . varExpresion ^ varExpresion
    (24) varExpresion -> . ( - ( varExpresion ) )
    (25) varExpresion -> . ( + ( varExpresion ) )
    (26) varExpresion -> . varExpresion ? varExpresion : varExpresion
    (27) varExpresion -> . varExpresion AND varExpresion
    (28) varExpresion -> . NOT varExpresion
    (29) varExpresion -> . varExpresion OR varExpresion
    (30) varExpresion -> . varExpresion EQEQ varExpresion
    (31) varExpresion -> . varExpresion DISTINTO varExpresion
    (32) varExpresion -> . varExpresion > varExpresion
    (33) varExpresion -> . varExpresion < varExpresion
    (34) varExpresion -> . ( varExpresion )
    (35) varExpresion -> . tipos
    (36) varExpresion -> . funcReturn
    (37) varExpresion -> . varOps
    (38) varExpresion -> . vec
    (39) varExpresion -> . reg
    (40) varExpresion -> . vars
    (41) tipos -> . INT
    (42) tipos -> . FLOAT
    (43) tipos -> . STRING
    (44) tipos -> . BOOL
    (61) funcReturn -> . funcInt
    (62) funcReturn -> . funcString
    (63) funcReturn -> . funcBool
    (55) varOps -> . MASMAS ID
    (56) varOps -> . MENOSMENOS ID
    (57) varOps -> . ID MASMAS
    (58) varOps -> . ID MENOSMENOS
    (45) vec -> . [ elem ]
    (46) vec -> . ID m
    (51) reg -> . { campos }
    (52) reg -> . ID . ID
    (82) vars -> . ID
    (83) vars -> . RES
    (64) funcInt -> . MULTIESCALAR ( varExpresion , varExpresion , param )
    (65) funcInt -> . LENGTH ( varExpresion )
    (66) funcString -> . CAPITALIZAR ( varExpresion )
    (67) funcBool -> . COLINEALES ( varExpresion , varExpresion )

    (               shift and go to state 63
    NOT             shift and go to state 73
    INT             shift and go to state 68
    FLOAT           shift and go to state 70
    STRING          shift and go to state 64
    BOOL            shift and go to state 72
    MASMAS          shift and go to state 27
    MENOSMENOS      shift and go to state 29
    ID              shift and go to state 85
    [               shift and go to state 65
    {               shift and go to state 74
    RES             shift and go to state 5
    MULTIESCALAR    shift and go to state 22
    LENGTH          shift and go to state 25
    CAPITALIZAR     shift and go to state 24
    COLINEALES      shift and go to state 14

    funcBool                       shift and go to state 11
    vars                           shift and go to state 83
    funcString                     shift and go to state 21
    varExpresion                   shift and go to state 91
    funcReturn                     shift and go to state 69
    varOps                         shift and go to state 58
    tipos                          shift and go to state 61
    vec                            shift and go to state 62
    funcInt                        shift and go to state 6
    reg                            shift and go to state 71

state 52

    (66) funcString -> CAPITALIZAR ( . varExpresion )
    (18) varExpresion -> . varExpresion + varExpresion
    (19) varExpresion -> . varExpresion - varExpresion
    (20) varExpresion -> . varExpresion * varExpresion
    (21) varExpresion -> . varExpresion / varExpresion
    (22) varExpresion -> . varExpresion % varExpresion
    (23) varExpresion -> . varExpresion ^ varExpresion
    (24) varExpresion -> . ( - ( varExpresion ) )
    (25) varExpresion -> . ( + ( varExpresion ) )
    (26) varExpresion -> . varExpresion ? varExpresion : varExpresion
    (27) varExpresion -> . varExpresion AND varExpresion
    (28) varExpresion -> . NOT varExpresion
    (29) varExpresion -> . varExpresion OR varExpresion
    (30) varExpresion -> . varExpresion EQEQ varExpresion
    (31) varExpresion -> . varExpresion DISTINTO varExpresion
    (32) varExpresion -> . varExpresion > varExpresion
    (33) varExpresion -> . varExpresion < varExpresion
    (34) varExpresion -> . ( varExpresion )
    (35) varExpresion -> . tipos
    (36) varExpresion -> . funcReturn
    (37) varExpresion -> . varOps
    (38) varExpresion -> . vec
    (39) varExpresion -> . reg
    (40) varExpresion -> . vars
    (41) tipos -> . INT
    (42) tipos -> . FLOAT
    (43) tipos -> . STRING
    (44) tipos -> . BOOL
    (61) funcReturn -> . funcInt
    (62) funcReturn -> . funcString
    (63) funcReturn -> . funcBool
    (55) varOps -> . MASMAS ID
    (56) varOps -> . MENOSMENOS ID
    (57) varOps -> . ID MASMAS
    (58) varOps -> . ID MENOSMENOS
    (45) vec -> . [ elem ]
    (46) vec -> . ID m
    (51) reg -> . { campos }
    (52) reg -> . ID . ID
    (82) vars -> . ID
    (83) vars -> . RES
    (64) funcInt -> . MULTIESCALAR ( varExpresion , varExpresion , param )
    (65) funcInt -> . LENGTH ( varExpresion )
    (66) funcString -> . CAPITALIZAR ( varExpresion )
    (67) funcBool -> . COLINEALES ( varExpresion , varExpresion )

    (               shift and go to state 63
    NOT             shift and go to state 73
    INT             shift and go to state 68
    FLOAT           shift and go to state 70
    STRING          shift and go to state 64
    BOOL            shift and go to state 72
    MASMAS          shift and go to state 27
    MENOSMENOS      shift and go to state 29
    ID              shift and go to state 85
    [               shift and go to state 65
    {               shift and go to state 74
    RES             shift and go to state 5
    MULTIESCALAR    shift and go to state 22
    LENGTH          shift and go to state 25
    CAPITALIZAR     shift and go to state 24
    COLINEALES      shift and go to state 14

    funcBool                       shift and go to state 11
    vars                           shift and go to state 83
    funcString                     shift and go to state 21
    varExpresion                   shift and go to state 92
    funcReturn                     shift and go to state 69
    varOps                         shift and go to state 58
    tipos                          shift and go to state 61
    vec                            shift and go to state 62
    funcInt                        shift and go to state 6
    reg                            shift and go to state 71

state 53

    (65) funcInt -> LENGTH ( . varExpresion )
    (18) varExpresion -> . varExpresion + varExpresion
    (19) varExpresion -> . varExpresion - varExpresion
    (20) varExpresion -> . varExpresion * varExpresion
    (21) varExpresion -> . varExpresion / varExpresion
    (22) varExpresion -> . varExpresion % varExpresion
    (23) varExpresion -> . varExpresion ^ varExpresion
    (24) varExpresion -> . ( - ( varExpresion ) )
    (25) varExpresion -> . ( + ( varExpresion ) )
    (26) varExpresion -> . varExpresion ? varExpresion : varExpresion
    (27) varExpresion -> . varExpresion AND varExpresion
    (28) varExpresion -> . NOT varExpresion
    (29) varExpresion -> . varExpresion OR varExpresion
    (30) varExpresion -> . varExpresion EQEQ varExpresion
    (31) varExpresion -> . varExpresion DISTINTO varExpresion
    (32) varExpresion -> . varExpresion > varExpresion
    (33) varExpresion -> . varExpresion < varExpresion
    (34) varExpresion -> . ( varExpresion )
    (35) varExpresion -> . tipos
    (36) varExpresion -> . funcReturn
    (37) varExpresion -> . varOps
    (38) varExpresion -> . vec
    (39) varExpresion -> . reg
    (40) varExpresion -> . vars
    (41) tipos -> . INT
    (42) tipos -> . FLOAT
    (43) tipos -> . STRING
    (44) tipos -> . BOOL
    (61) funcReturn -> . funcInt
    (62) funcReturn -> . funcString
    (63) funcReturn -> . funcBool
    (55) varOps -> . MASMAS ID
    (56) varOps -> . MENOSMENOS ID
    (57) varOps -> . ID MASMAS
    (58) varOps -> . ID MENOSMENOS
    (45) vec -> . [ elem ]
    (46) vec -> . ID m
    (51) reg -> . { campos }
    (52) reg -> . ID . ID
    (82) vars -> . ID
    (83) vars -> . RES
    (64) funcInt -> . MULTIESCALAR ( varExpresion , varExpresion , param )
    (65) funcInt -> . LENGTH ( varExpresion )
    (66) funcString -> . CAPITALIZAR ( varExpresion )
    (67) funcBool -> . COLINEALES ( varExpresion , varExpresion )

    (               shift and go to state 63
    NOT             shift and go to state 73
    INT             shift and go to state 68
    FLOAT           shift and go to state 70
    STRING          shift and go to state 64
    BOOL            shift and go to state 72
    MASMAS          shift and go to state 27
    MENOSMENOS      shift and go to state 29
    ID              shift and go to state 85
    [               shift and go to state 65
    {               shift and go to state 74
    RES             shift and go to state 5
    MULTIESCALAR    shift and go to state 22
    LENGTH          shift and go to state 25
    CAPITALIZAR     shift and go to state 24
    COLINEALES      shift and go to state 14

    funcBool                       shift and go to state 11
    vars                           shift and go to state 83
    funcString                     shift and go to state 21
    varExpresion                   shift and go to state 93
    funcReturn                     shift and go to state 69
    varOps                         shift and go to state 58
    tipos                          shift and go to state 61
    vec                            shift and go to state 62
    funcInt                        shift and go to state 6
    reg                            shift and go to state 71

state 54

    (55) varOps -> MASMAS ID .

    )               reduce using rule 55 (varOps -> MASMAS ID .)
    +               reduce using rule 55 (varOps -> MASMAS ID .)
    -               reduce using rule 55 (varOps -> MASMAS ID .)
    *               reduce using rule 55 (varOps -> MASMAS ID .)
    /               reduce using rule 55 (varOps -> MASMAS ID .)
    %               reduce using rule 55 (varOps -> MASMAS ID .)
    ^               reduce using rule 55 (varOps -> MASMAS ID .)
    ?               reduce using rule 55 (varOps -> MASMAS ID .)
    AND             reduce using rule 55 (varOps -> MASMAS ID .)
    OR              reduce using rule 55 (varOps -> MASMAS ID .)
    EQEQ            reduce using rule 55 (varOps -> MASMAS ID .)
    DISTINTO        reduce using rule 55 (varOps -> MASMAS ID .)
    >               reduce using rule 55 (varOps -> MASMAS ID .)
    <               reduce using rule 55 (varOps -> MASMAS ID .)
    ;               reduce using rule 55 (varOps -> MASMAS ID .)
    ,               reduce using rule 55 (varOps -> MASMAS ID .)
    ]               reduce using rule 55 (varOps -> MASMAS ID .)
    :               reduce using rule 55 (varOps -> MASMAS ID .)
    }               reduce using rule 55 (varOps -> MASMAS ID .)


state 55

    (56) varOps -> MENOSMENOS ID .

    )               reduce using rule 56 (varOps -> MENOSMENOS ID .)
    +               reduce using rule 56 (varOps -> MENOSMENOS ID .)
    -               reduce using rule 56 (varOps -> MENOSMENOS ID .)
    *               reduce using rule 56 (varOps -> MENOSMENOS ID .)
    /               reduce using rule 56 (varOps -> MENOSMENOS ID .)
    %               reduce using rule 56 (varOps -> MENOSMENOS ID .)
    ^               reduce using rule 56 (varOps -> MENOSMENOS ID .)
    ?               reduce using rule 56 (varOps -> MENOSMENOS ID .)
    AND             reduce using rule 56 (varOps -> MENOSMENOS ID .)
    OR              reduce using rule 56 (varOps -> MENOSMENOS ID .)
    EQEQ            reduce using rule 56 (varOps -> MENOSMENOS ID .)
    DISTINTO        reduce using rule 56 (varOps -> MENOSMENOS ID .)
    >               reduce using rule 56 (varOps -> MENOSMENOS ID .)
    <               reduce using rule 56 (varOps -> MENOSMENOS ID .)
    ;               reduce using rule 56 (varOps -> MENOSMENOS ID .)
    ,               reduce using rule 56 (varOps -> MENOSMENOS ID .)
    ]               reduce using rule 56 (varOps -> MENOSMENOS ID .)
    :               reduce using rule 56 (varOps -> MENOSMENOS ID .)
    }               reduce using rule 56 (varOps -> MENOSMENOS ID .)


state 56

    (11) loop -> DO bloque WHILE . ( varExpresion ) ;

    (               shift and go to state 94


state 57

    (17) bloque -> { g . }

    }               shift and go to state 95


state 58

    (37) varExpresion -> varOps .

    +               reduce using rule 37 (varExpresion -> varOps .)
    -               reduce using rule 37 (varExpresion -> varOps .)
    *               reduce using rule 37 (varExpresion -> varOps .)
    /               reduce using rule 37 (varExpresion -> varOps .)
    %               reduce using rule 37 (varExpresion -> varOps .)
    ^               reduce using rule 37 (varExpresion -> varOps .)
    ?               reduce using rule 37 (varExpresion -> varOps .)
    AND             reduce using rule 37 (varExpresion -> varOps .)
    OR              reduce using rule 37 (varExpresion -> varOps .)
    EQEQ            reduce using rule 37 (varExpresion -> varOps .)
    DISTINTO        reduce using rule 37 (varExpresion -> varOps .)
    >               reduce using rule 37 (varExpresion -> varOps .)
    <               reduce using rule 37 (varExpresion -> varOps .)
    ;               reduce using rule 37 (varExpresion -> varOps .)
    )               reduce using rule 37 (varExpresion -> varOps .)
    ,               reduce using rule 37 (varExpresion -> varOps .)
    ]               reduce using rule 37 (varExpresion -> varOps .)
    :               reduce using rule 37 (varExpresion -> varOps .)
    }               reduce using rule 37 (varExpresion -> varOps .)


state 59

    (72) varAsig -> vars . MENOSEQ varAsig
    (73) varAsig -> vars . MASEQ varAsig
    (74) varAsig -> vars . MULEQ varAsig
    (75) varAsig -> vars . DIVEQ varAsig
    (76) varAsig -> vars . = varAsig
    (77) varAsig -> vars . MASEQ varExpresion
    (78) varAsig -> vars . MENOSEQ varExpresion
    (79) varAsig -> vars . MULEQ varExpresion
    (80) varAsig -> vars . DIVEQ varExpresion
    (81) varAsig -> vars . = varExpresion
    (40) varExpresion -> vars .

    MENOSEQ         shift and go to state 34
    MASEQ           shift and go to state 35
    MULEQ           shift and go to state 36
    DIVEQ           shift and go to state 38
    =               shift and go to state 37
    +               reduce using rule 40 (varExpresion -> vars .)
    -               reduce using rule 40 (varExpresion -> vars .)
    *               reduce using rule 40 (varExpresion -> vars .)
    /               reduce using rule 40 (varExpresion -> vars .)
    %               reduce using rule 40 (varExpresion -> vars .)
    ^               reduce using rule 40 (varExpresion -> vars .)
    ?               reduce using rule 40 (varExpresion -> vars .)
    AND             reduce using rule 40 (varExpresion -> vars .)
    OR              reduce using rule 40 (varExpresion -> vars .)
    EQEQ            reduce using rule 40 (varExpresion -> vars .)
    DISTINTO        reduce using rule 40 (varExpresion -> vars .)
    >               reduce using rule 40 (varExpresion -> vars .)
    <               reduce using rule 40 (varExpresion -> vars .)
    ;               reduce using rule 40 (varExpresion -> vars .)


state 60

    (78) varAsig -> vars MENOSEQ varExpresion .
    (18) varExpresion -> varExpresion . + varExpresion
    (19) varExpresion -> varExpresion . - varExpresion
    (20) varExpresion -> varExpresion . * varExpresion
    (21) varExpresion -> varExpresion . / varExpresion
    (22) varExpresion -> varExpresion . % varExpresion
    (23) varExpresion -> varExpresion . ^ varExpresion
    (26) varExpresion -> varExpresion . ? varExpresion : varExpresion
    (27) varExpresion -> varExpresion . AND varExpresion
    (29) varExpresion -> varExpresion . OR varExpresion
    (30) varExpresion -> varExpresion . EQEQ varExpresion
    (31) varExpresion -> varExpresion . DISTINTO varExpresion
    (32) varExpresion -> varExpresion . > varExpresion
    (33) varExpresion -> varExpresion . < varExpresion

    ;               reduce using rule 78 (varAsig -> vars MENOSEQ varExpresion .)
    +               shift and go to state 100
    -               shift and go to state 102
    *               shift and go to state 101
    /               shift and go to state 103
    %               shift and go to state 97
    ^               shift and go to state 108
    ?               shift and go to state 107
    AND             shift and go to state 96
    OR              shift and go to state 106
    EQEQ            shift and go to state 105
    DISTINTO        shift and go to state 98
    >               shift and go to state 99
    <               shift and go to state 104


state 61

    (35) varExpresion -> tipos .

    +               reduce using rule 35 (varExpresion -> tipos .)
    -               reduce using rule 35 (varExpresion -> tipos .)
    *               reduce using rule 35 (varExpresion -> tipos .)
    /               reduce using rule 35 (varExpresion -> tipos .)
    %               reduce using rule 35 (varExpresion -> tipos .)
    ^               reduce using rule 35 (varExpresion -> tipos .)
    ?               reduce using rule 35 (varExpresion -> tipos .)
    AND             reduce using rule 35 (varExpresion -> tipos .)
    OR              reduce using rule 35 (varExpresion -> tipos .)
    EQEQ            reduce using rule 35 (varExpresion -> tipos .)
    DISTINTO        reduce using rule 35 (varExpresion -> tipos .)
    >               reduce using rule 35 (varExpresion -> tipos .)
    <               reduce using rule 35 (varExpresion -> tipos .)
    ;               reduce using rule 35 (varExpresion -> tipos .)
    )               reduce using rule 35 (varExpresion -> tipos .)
    ,               reduce using rule 35 (varExpresion -> tipos .)
    ]               reduce using rule 35 (varExpresion -> tipos .)
    :               reduce using rule 35 (varExpresion -> tipos .)
    }               reduce using rule 35 (varExpresion -> tipos .)


state 62

    (38) varExpresion -> vec .

    +               reduce using rule 38 (varExpresion -> vec .)
    -               reduce using rule 38 (varExpresion -> vec .)
    *               reduce using rule 38 (varExpresion -> vec .)
    /               reduce using rule 38 (varExpresion -> vec .)
    %               reduce using rule 38 (varExpresion -> vec .)
    ^               reduce using rule 38 (varExpresion -> vec .)
    ?               reduce using rule 38 (varExpresion -> vec .)
    AND             reduce using rule 38 (varExpresion -> vec .)
    OR              reduce using rule 38 (varExpresion -> vec .)
    EQEQ            reduce using rule 38 (varExpresion -> vec .)
    DISTINTO        reduce using rule 38 (varExpresion -> vec .)
    >               reduce using rule 38 (varExpresion -> vec .)
    <               reduce using rule 38 (varExpresion -> vec .)
    ;               reduce using rule 38 (varExpresion -> vec .)
    )               reduce using rule 38 (varExpresion -> vec .)
    ,               reduce using rule 38 (varExpresion -> vec .)
    ]               reduce using rule 38 (varExpresion -> vec .)
    :               reduce using rule 38 (varExpresion -> vec .)
    }               reduce using rule 38 (varExpresion -> vec .)


state 63

    (24) varExpresion -> ( . - ( varExpresion ) )
    (25) varExpresion -> ( . + ( varExpresion ) )
    (34) varExpresion -> ( . varExpresion )
    (18) varExpresion -> . varExpresion + varExpresion
    (19) varExpresion -> . varExpresion - varExpresion
    (20) varExpresion -> . varExpresion * varExpresion
    (21) varExpresion -> . varExpresion / varExpresion
    (22) varExpresion -> . varExpresion % varExpresion
    (23) varExpresion -> . varExpresion ^ varExpresion
    (24) varExpresion -> . ( - ( varExpresion ) )
    (25) varExpresion -> . ( + ( varExpresion ) )
    (26) varExpresion -> . varExpresion ? varExpresion : varExpresion
    (27) varExpresion -> . varExpresion AND varExpresion
    (28) varExpresion -> . NOT varExpresion
    (29) varExpresion -> . varExpresion OR varExpresion
    (30) varExpresion -> . varExpresion EQEQ varExpresion
    (31) varExpresion -> . varExpresion DISTINTO varExpresion
    (32) varExpresion -> . varExpresion > varExpresion
    (33) varExpresion -> . varExpresion < varExpresion
    (34) varExpresion -> . ( varExpresion )
    (35) varExpresion -> . tipos
    (36) varExpresion -> . funcReturn
    (37) varExpresion -> . varOps
    (38) varExpresion -> . vec
    (39) varExpresion -> . reg
    (40) varExpresion -> . vars
    (41) tipos -> . INT
    (42) tipos -> . FLOAT
    (43) tipos -> . STRING
    (44) tipos -> . BOOL
    (61) funcReturn -> . funcInt
    (62) funcReturn -> . funcString
    (63) funcReturn -> . funcBool
    (55) varOps -> . MASMAS ID
    (56) varOps -> . MENOSMENOS ID
    (57) varOps -> . ID MASMAS
    (58) varOps -> . ID MENOSMENOS
    (45) vec -> . [ elem ]
    (46) vec -> . ID m
    (51) reg -> . { campos }
    (52) reg -> . ID . ID
    (82) vars -> . ID
    (83) vars -> . RES
    (64) funcInt -> . MULTIESCALAR ( varExpresion , varExpresion , param )
    (65) funcInt -> . LENGTH ( varExpresion )
    (66) funcString -> . CAPITALIZAR ( varExpresion )
    (67) funcBool -> . COLINEALES ( varExpresion , varExpresion )

    -               shift and go to state 110
    +               shift and go to state 109
    (               shift and go to state 63
    NOT             shift and go to state 73
    INT             shift and go to state 68
    FLOAT           shift and go to state 70
    STRING          shift and go to state 64
    BOOL            shift and go to state 72
    MASMAS          shift and go to state 27
    MENOSMENOS      shift and go to state 29
    ID              shift and go to state 85
    [               shift and go to state 65
    {               shift and go to state 74
    RES             shift and go to state 5
    MULTIESCALAR    shift and go to state 22
    LENGTH          shift and go to state 25
    CAPITALIZAR     shift and go to state 24
    COLINEALES      shift and go to state 14

    funcBool                       shift and go to state 11
    vars                           shift and go to state 83
    funcString                     shift and go to state 21
    varExpresion                   shift and go to state 111
    funcReturn                     shift and go to state 69
    varOps                         shift and go to state 58
    tipos                          shift and go to state 61
    vec                            shift and go to state 62
    funcInt                        shift and go to state 6
    reg                            shift and go to state 71

state 64

    (43) tipos -> STRING .

    +               reduce using rule 43 (tipos -> STRING .)
    -               reduce using rule 43 (tipos -> STRING .)
    *               reduce using rule 43 (tipos -> STRING .)
    /               reduce using rule 43 (tipos -> STRING .)
    %               reduce using rule 43 (tipos -> STRING .)
    ^               reduce using rule 43 (tipos -> STRING .)
    ?               reduce using rule 43 (tipos -> STRING .)
    AND             reduce using rule 43 (tipos -> STRING .)
    OR              reduce using rule 43 (tipos -> STRING .)
    EQEQ            reduce using rule 43 (tipos -> STRING .)
    DISTINTO        reduce using rule 43 (tipos -> STRING .)
    >               reduce using rule 43 (tipos -> STRING .)
    <               reduce using rule 43 (tipos -> STRING .)
    ;               reduce using rule 43 (tipos -> STRING .)
    )               reduce using rule 43 (tipos -> STRING .)
    ,               reduce using rule 43 (tipos -> STRING .)
    ]               reduce using rule 43 (tipos -> STRING .)
    :               reduce using rule 43 (tipos -> STRING .)
    }               reduce using rule 43 (tipos -> STRING .)


state 65

    (45) vec -> [ . elem ]
    (47) elem -> . varExpresion , elem
    (48) elem -> . varExpresion
    (18) varExpresion -> . varExpresion + varExpresion
    (19) varExpresion -> . varExpresion - varExpresion
    (20) varExpresion -> . varExpresion * varExpresion
    (21) varExpresion -> . varExpresion / varExpresion
    (22) varExpresion -> . varExpresion % varExpresion
    (23) varExpresion -> . varExpresion ^ varExpresion
    (24) varExpresion -> . ( - ( varExpresion ) )
    (25) varExpresion -> . ( + ( varExpresion ) )
    (26) varExpresion -> . varExpresion ? varExpresion : varExpresion
    (27) varExpresion -> . varExpresion AND varExpresion
    (28) varExpresion -> . NOT varExpresion
    (29) varExpresion -> . varExpresion OR varExpresion
    (30) varExpresion -> . varExpresion EQEQ varExpresion
    (31) varExpresion -> . varExpresion DISTINTO varExpresion
    (32) varExpresion -> . varExpresion > varExpresion
    (33) varExpresion -> . varExpresion < varExpresion
    (34) varExpresion -> . ( varExpresion )
    (35) varExpresion -> . tipos
    (36) varExpresion -> . funcReturn
    (37) varExpresion -> . varOps
    (38) varExpresion -> . vec
    (39) varExpresion -> . reg
    (40) varExpresion -> . vars
    (41) tipos -> . INT
    (42) tipos -> . FLOAT
    (43) tipos -> . STRING
    (44) tipos -> . BOOL
    (61) funcReturn -> . funcInt
    (62) funcReturn -> . funcString
    (63) funcReturn -> . funcBool
    (55) varOps -> . MASMAS ID
    (56) varOps -> . MENOSMENOS ID
    (57) varOps -> . ID MASMAS
    (58) varOps -> . ID MENOSMENOS
    (45) vec -> . [ elem ]
    (46) vec -> . ID m
    (51) reg -> . { campos }
    (52) reg -> . ID . ID
    (82) vars -> . ID
    (83) vars -> . RES
    (64) funcInt -> . MULTIESCALAR ( varExpresion , varExpresion , param )
    (65) funcInt -> . LENGTH ( varExpresion )
    (66) funcString -> . CAPITALIZAR ( varExpresion )
    (67) funcBool -> . COLINEALES ( varExpresion , varExpresion )

    (               shift and go to state 63
    NOT             shift and go to state 73
    INT             shift and go to state 68
    FLOAT           shift and go to state 70
    STRING          shift and go to state 64
    BOOL            shift and go to state 72
    MASMAS          shift and go to state 27
    MENOSMENOS      shift and go to state 29
    ID              shift and go to state 85
    [               shift and go to state 65
    {               shift and go to state 74
    RES             shift and go to state 5
    MULTIESCALAR    shift and go to state 22
    LENGTH          shift and go to state 25
    CAPITALIZAR     shift and go to state 24
    COLINEALES      shift and go to state 14

    funcBool                       shift and go to state 11
    vars                           shift and go to state 83
    funcString                     shift and go to state 21
    varExpresion                   shift and go to state 112
    funcReturn                     shift and go to state 69
    varOps                         shift and go to state 58
    elem                           shift and go to state 113
    tipos                          shift and go to state 61
    vec                            shift and go to state 62
    funcInt                        shift and go to state 6
    reg                            shift and go to state 71

state 66

    (82) vars -> ID .
    (57) varOps -> ID . MASMAS
    (58) varOps -> ID . MENOSMENOS
    (46) vec -> ID . m
    (52) reg -> ID . . ID
    (49) m -> . [ varExpresion ]
    (50) m -> . m [ varExpresion ]

    MENOSEQ         reduce using rule 82 (vars -> ID .)
    MASEQ           reduce using rule 82 (vars -> ID .)
    MULEQ           reduce using rule 82 (vars -> ID .)
    DIVEQ           reduce using rule 82 (vars -> ID .)
    =               reduce using rule 82 (vars -> ID .)
    +               reduce using rule 82 (vars -> ID .)
    -               reduce using rule 82 (vars -> ID .)
    *               reduce using rule 82 (vars -> ID .)
    /               reduce using rule 82 (vars -> ID .)
    %               reduce using rule 82 (vars -> ID .)
    ^               reduce using rule 82 (vars -> ID .)
    ?               reduce using rule 82 (vars -> ID .)
    AND             reduce using rule 82 (vars -> ID .)
    OR              reduce using rule 82 (vars -> ID .)
    EQEQ            reduce using rule 82 (vars -> ID .)
    DISTINTO        reduce using rule 82 (vars -> ID .)
    >               reduce using rule 82 (vars -> ID .)
    <               reduce using rule 82 (vars -> ID .)
    ;               reduce using rule 82 (vars -> ID .)
    MASMAS          shift and go to state 47
    MENOSMENOS      shift and go to state 48
    .               shift and go to state 115
    [               shift and go to state 116

    m                              shift and go to state 114

state 67

    (72) varAsig -> vars MENOSEQ varAsig .

    ;               reduce using rule 72 (varAsig -> vars MENOSEQ varAsig .)


state 68

    (41) tipos -> INT .

    +               reduce using rule 41 (tipos -> INT .)
    -               reduce using rule 41 (tipos -> INT .)
    *               reduce using rule 41 (tipos -> INT .)
    /               reduce using rule 41 (tipos -> INT .)
    %               reduce using rule 41 (tipos -> INT .)
    ^               reduce using rule 41 (tipos -> INT .)
    ?               reduce using rule 41 (tipos -> INT .)
    AND             reduce using rule 41 (tipos -> INT .)
    OR              reduce using rule 41 (tipos -> INT .)
    EQEQ            reduce using rule 41 (tipos -> INT .)
    DISTINTO        reduce using rule 41 (tipos -> INT .)
    >               reduce using rule 41 (tipos -> INT .)
    <               reduce using rule 41 (tipos -> INT .)
    ;               reduce using rule 41 (tipos -> INT .)
    )               reduce using rule 41 (tipos -> INT .)
    ,               reduce using rule 41 (tipos -> INT .)
    ]               reduce using rule 41 (tipos -> INT .)
    :               reduce using rule 41 (tipos -> INT .)
    }               reduce using rule 41 (tipos -> INT .)


state 69

    (36) varExpresion -> funcReturn .

    +               reduce using rule 36 (varExpresion -> funcReturn .)
    -               reduce using rule 36 (varExpresion -> funcReturn .)
    *               reduce using rule 36 (varExpresion -> funcReturn .)
    /               reduce using rule 36 (varExpresion -> funcReturn .)
    %               reduce using rule 36 (varExpresion -> funcReturn .)
    ^               reduce using rule 36 (varExpresion -> funcReturn .)
    ?               reduce using rule 36 (varExpresion -> funcReturn .)
    AND             reduce using rule 36 (varExpresion -> funcReturn .)
    OR              reduce using rule 36 (varExpresion -> funcReturn .)
    EQEQ            reduce using rule 36 (varExpresion -> funcReturn .)
    DISTINTO        reduce using rule 36 (varExpresion -> funcReturn .)
    >               reduce using rule 36 (varExpresion -> funcReturn .)
    <               reduce using rule 36 (varExpresion -> funcReturn .)
    ;               reduce using rule 36 (varExpresion -> funcReturn .)
    )               reduce using rule 36 (varExpresion -> funcReturn .)
    ,               reduce using rule 36 (varExpresion -> funcReturn .)
    ]               reduce using rule 36 (varExpresion -> funcReturn .)
    :               reduce using rule 36 (varExpresion -> funcReturn .)
    }               reduce using rule 36 (varExpresion -> funcReturn .)


state 70

    (42) tipos -> FLOAT .

    +               reduce using rule 42 (tipos -> FLOAT .)
    -               reduce using rule 42 (tipos -> FLOAT .)
    *               reduce using rule 42 (tipos -> FLOAT .)
    /               reduce using rule 42 (tipos -> FLOAT .)
    %               reduce using rule 42 (tipos -> FLOAT .)
    ^               reduce using rule 42 (tipos -> FLOAT .)
    ?               reduce using rule 42 (tipos -> FLOAT .)
    AND             reduce using rule 42 (tipos -> FLOAT .)
    OR              reduce using rule 42 (tipos -> FLOAT .)
    EQEQ            reduce using rule 42 (tipos -> FLOAT .)
    DISTINTO        reduce using rule 42 (tipos -> FLOAT .)
    >               reduce using rule 42 (tipos -> FLOAT .)
    <               reduce using rule 42 (tipos -> FLOAT .)
    ;               reduce using rule 42 (tipos -> FLOAT .)
    )               reduce using rule 42 (tipos -> FLOAT .)
    ,               reduce using rule 42 (tipos -> FLOAT .)
    ]               reduce using rule 42 (tipos -> FLOAT .)
    :               reduce using rule 42 (tipos -> FLOAT .)
    }               reduce using rule 42 (tipos -> FLOAT .)


state 71

    (39) varExpresion -> reg .

    +               reduce using rule 39 (varExpresion -> reg .)
    -               reduce using rule 39 (varExpresion -> reg .)
    *               reduce using rule 39 (varExpresion -> reg .)
    /               reduce using rule 39 (varExpresion -> reg .)
    %               reduce using rule 39 (varExpresion -> reg .)
    ^               reduce using rule 39 (varExpresion -> reg .)
    ?               reduce using rule 39 (varExpresion -> reg .)
    AND             reduce using rule 39 (varExpresion -> reg .)
    OR              reduce using rule 39 (varExpresion -> reg .)
    EQEQ            reduce using rule 39 (varExpresion -> reg .)
    DISTINTO        reduce using rule 39 (varExpresion -> reg .)
    >               reduce using rule 39 (varExpresion -> reg .)
    <               reduce using rule 39 (varExpresion -> reg .)
    ;               reduce using rule 39 (varExpresion -> reg .)
    )               reduce using rule 39 (varExpresion -> reg .)
    ,               reduce using rule 39 (varExpresion -> reg .)
    ]               reduce using rule 39 (varExpresion -> reg .)
    :               reduce using rule 39 (varExpresion -> reg .)
    }               reduce using rule 39 (varExpresion -> reg .)


state 72

    (44) tipos -> BOOL .

    +               reduce using rule 44 (tipos -> BOOL .)
    -               reduce using rule 44 (tipos -> BOOL .)
    *               reduce using rule 44 (tipos -> BOOL .)
    /               reduce using rule 44 (tipos -> BOOL .)
    %               reduce using rule 44 (tipos -> BOOL .)
    ^               reduce using rule 44 (tipos -> BOOL .)
    ?               reduce using rule 44 (tipos -> BOOL .)
    AND             reduce using rule 44 (tipos -> BOOL .)
    OR              reduce using rule 44 (tipos -> BOOL .)
    EQEQ            reduce using rule 44 (tipos -> BOOL .)
    DISTINTO        reduce using rule 44 (tipos -> BOOL .)
    >               reduce using rule 44 (tipos -> BOOL .)
    <               reduce using rule 44 (tipos -> BOOL .)
    ;               reduce using rule 44 (tipos -> BOOL .)
    )               reduce using rule 44 (tipos -> BOOL .)
    ,               reduce using rule 44 (tipos -> BOOL .)
    ]               reduce using rule 44 (tipos -> BOOL .)
    :               reduce using rule 44 (tipos -> BOOL .)
    }               reduce using rule 44 (tipos -> BOOL .)


state 73

    (28) varExpresion -> NOT . varExpresion
    (18) varExpresion -> . varExpresion + varExpresion
    (19) varExpresion -> . varExpresion - varExpresion
    (20) varExpresion -> . varExpresion * varExpresion
    (21) varExpresion -> . varExpresion / varExpresion
    (22) varExpresion -> . varExpresion % varExpresion
    (23) varExpresion -> . varExpresion ^ varExpresion
    (24) varExpresion -> . ( - ( varExpresion ) )
    (25) varExpresion -> . ( + ( varExpresion ) )
    (26) varExpresion -> . varExpresion ? varExpresion : varExpresion
    (27) varExpresion -> . varExpresion AND varExpresion
    (28) varExpresion -> . NOT varExpresion
    (29) varExpresion -> . varExpresion OR varExpresion
    (30) varExpresion -> . varExpresion EQEQ varExpresion
    (31) varExpresion -> . varExpresion DISTINTO varExpresion
    (32) varExpresion -> . varExpresion > varExpresion
    (33) varExpresion -> . varExpresion < varExpresion
    (34) varExpresion -> . ( varExpresion )
    (35) varExpresion -> . tipos
    (36) varExpresion -> . funcReturn
    (37) varExpresion -> . varOps
    (38) varExpresion -> . vec
    (39) varExpresion -> . reg
    (40) varExpresion -> . vars
    (41) tipos -> . INT
    (42) tipos -> . FLOAT
    (43) tipos -> . STRING
    (44) tipos -> . BOOL
    (61) funcReturn -> . funcInt
    (62) funcReturn -> . funcString
    (63) funcReturn -> . funcBool
    (55) varOps -> . MASMAS ID
    (56) varOps -> . MENOSMENOS ID
    (57) varOps -> . ID MASMAS
    (58) varOps -> . ID MENOSMENOS
    (45) vec -> . [ elem ]
    (46) vec -> . ID m
    (51) reg -> . { campos }
    (52) reg -> . ID . ID
    (82) vars -> . ID
    (83) vars -> . RES
    (64) funcInt -> . MULTIESCALAR ( varExpresion , varExpresion , param )
    (65) funcInt -> . LENGTH ( varExpresion )
    (66) funcString -> . CAPITALIZAR ( varExpresion )
    (67) funcBool -> . COLINEALES ( varExpresion , varExpresion )

    (               shift and go to state 63
    NOT             shift and go to state 73
    INT             shift and go to state 68
    FLOAT           shift and go to state 70
    STRING          shift and go to state 64
    BOOL            shift and go to state 72
    MASMAS          shift and go to state 27
    MENOSMENOS      shift and go to state 29
    ID              shift and go to state 85
    [               shift and go to state 65
    {               shift and go to state 74
    RES             shift and go to state 5
    MULTIESCALAR    shift and go to state 22
    LENGTH          shift and go to state 25
    CAPITALIZAR     shift and go to state 24
    COLINEALES      shift and go to state 14

    funcBool                       shift and go to state 11
    vars                           shift and go to state 83
    funcString                     shift and go to state 21
    varExpresion                   shift and go to state 117
    funcReturn                     shift and go to state 69
    varOps                         shift and go to state 58
    tipos                          shift and go to state 61
    vec                            shift and go to state 62
    funcInt                        shift and go to state 6
    reg                            shift and go to state 71

state 74

    (51) reg -> { . campos }
    (53) campos -> . ID : varExpresion , campos
    (54) campos -> . ID : varExpresion

    ID              shift and go to state 119

    campos                         shift and go to state 118

state 75

    (77) varAsig -> vars MASEQ varExpresion .
    (18) varExpresion -> varExpresion . + varExpresion
    (19) varExpresion -> varExpresion . - varExpresion
    (20) varExpresion -> varExpresion . * varExpresion
    (21) varExpresion -> varExpresion . / varExpresion
    (22) varExpresion -> varExpresion . % varExpresion
    (23) varExpresion -> varExpresion . ^ varExpresion
    (26) varExpresion -> varExpresion . ? varExpresion : varExpresion
    (27) varExpresion -> varExpresion . AND varExpresion
    (29) varExpresion -> varExpresion . OR varExpresion
    (30) varExpresion -> varExpresion . EQEQ varExpresion
    (31) varExpresion -> varExpresion . DISTINTO varExpresion
    (32) varExpresion -> varExpresion . > varExpresion
    (33) varExpresion -> varExpresion . < varExpresion

    ;               reduce using rule 77 (varAsig -> vars MASEQ varExpresion .)
    +               shift and go to state 100
    -               shift and go to state 102
    *               shift and go to state 101
    /               shift and go to state 103
    %               shift and go to state 97
    ^               shift and go to state 108
    ?               shift and go to state 107
    AND             shift and go to state 96
    OR              shift and go to state 106
    EQEQ            shift and go to state 105
    DISTINTO        shift and go to state 98
    >               shift and go to state 99
    <               shift and go to state 104


state 76

    (73) varAsig -> vars MASEQ varAsig .

    ;               reduce using rule 73 (varAsig -> vars MASEQ varAsig .)


state 77

    (79) varAsig -> vars MULEQ varExpresion .
    (18) varExpresion -> varExpresion . + varExpresion
    (19) varExpresion -> varExpresion . - varExpresion
    (20) varExpresion -> varExpresion . * varExpresion
    (21) varExpresion -> varExpresion . / varExpresion
    (22) varExpresion -> varExpresion . % varExpresion
    (23) varExpresion -> varExpresion . ^ varExpresion
    (26) varExpresion -> varExpresion . ? varExpresion : varExpresion
    (27) varExpresion -> varExpresion . AND varExpresion
    (29) varExpresion -> varExpresion . OR varExpresion
    (30) varExpresion -> varExpresion . EQEQ varExpresion
    (31) varExpresion -> varExpresion . DISTINTO varExpresion
    (32) varExpresion -> varExpresion . > varExpresion
    (33) varExpresion -> varExpresion . < varExpresion

    ;               reduce using rule 79 (varAsig -> vars MULEQ varExpresion .)
    +               shift and go to state 100
    -               shift and go to state 102
    *               shift and go to state 101
    /               shift and go to state 103
    %               shift and go to state 97
    ^               shift and go to state 108
    ?               shift and go to state 107
    AND             shift and go to state 96
    OR              shift and go to state 106
    EQEQ            shift and go to state 105
    DISTINTO        shift and go to state 98
    >               shift and go to state 99
    <               shift and go to state 104


state 78

    (74) varAsig -> vars MULEQ varAsig .

    ;               reduce using rule 74 (varAsig -> vars MULEQ varAsig .)


state 79

    (81) varAsig -> vars = varExpresion .
    (18) varExpresion -> varExpresion . + varExpresion
    (19) varExpresion -> varExpresion . - varExpresion
    (20) varExpresion -> varExpresion . * varExpresion
    (21) varExpresion -> varExpresion . / varExpresion
    (22) varExpresion -> varExpresion . % varExpresion
    (23) varExpresion -> varExpresion . ^ varExpresion
    (26) varExpresion -> varExpresion . ? varExpresion : varExpresion
    (27) varExpresion -> varExpresion . AND varExpresion
    (29) varExpresion -> varExpresion . OR varExpresion
    (30) varExpresion -> varExpresion . EQEQ varExpresion
    (31) varExpresion -> varExpresion . DISTINTO varExpresion
    (32) varExpresion -> varExpresion . > varExpresion
    (33) varExpresion -> varExpresion . < varExpresion

    ;               reduce using rule 81 (varAsig -> vars = varExpresion .)
    +               shift and go to state 100
    -               shift and go to state 102
    *               shift and go to state 101
    /               shift and go to state 103
    %               shift and go to state 97
    ^               shift and go to state 108
    ?               shift and go to state 107
    AND             shift and go to state 96
    OR              shift and go to state 106
    EQEQ            shift and go to state 105
    DISTINTO        shift and go to state 98
    >               shift and go to state 99
    <               shift and go to state 104


state 80

    (76) varAsig -> vars = varAsig .

    ;               reduce using rule 76 (varAsig -> vars = varAsig .)


state 81

    (80) varAsig -> vars DIVEQ varExpresion .
    (18) varExpresion -> varExpresion . + varExpresion
    (19) varExpresion -> varExpresion . - varExpresion
    (20) varExpresion -> varExpresion . * varExpresion
    (21) varExpresion -> varExpresion . / varExpresion
    (22) varExpresion -> varExpresion . % varExpresion
    (23) varExpresion -> varExpresion . ^ varExpresion
    (26) varExpresion -> varExpresion . ? varExpresion : varExpresion
    (27) varExpresion -> varExpresion . AND varExpresion
    (29) varExpresion -> varExpresion . OR varExpresion
    (30) varExpresion -> varExpresion . EQEQ varExpresion
    (31) varExpresion -> varExpresion . DISTINTO varExpresion
    (32) varExpresion -> varExpresion . > varExpresion
    (33) varExpresion -> varExpresion . < varExpresion

    ;               reduce using rule 80 (varAsig -> vars DIVEQ varExpresion .)
    +               shift and go to state 100
    -               shift and go to state 102
    *               shift and go to state 101
    /               shift and go to state 103
    %               shift and go to state 97
    ^               shift and go to state 108
    ?               shift and go to state 107
    AND             shift and go to state 96
    OR              shift and go to state 106
    EQEQ            shift and go to state 105
    DISTINTO        shift and go to state 98
    >               shift and go to state 99
    <               shift and go to state 104


state 82

    (75) varAsig -> vars DIVEQ varAsig .

    ;               reduce using rule 75 (varAsig -> vars DIVEQ varAsig .)


state 83

    (40) varExpresion -> vars .

    +               reduce using rule 40 (varExpresion -> vars .)
    -               reduce using rule 40 (varExpresion -> vars .)
    *               reduce using rule 40 (varExpresion -> vars .)
    /               reduce using rule 40 (varExpresion -> vars .)
    %               reduce using rule 40 (varExpresion -> vars .)
    ^               reduce using rule 40 (varExpresion -> vars .)
    ?               reduce using rule 40 (varExpresion -> vars .)
    AND             reduce using rule 40 (varExpresion -> vars .)
    OR              reduce using rule 40 (varExpresion -> vars .)
    EQEQ            reduce using rule 40 (varExpresion -> vars .)
    DISTINTO        reduce using rule 40 (varExpresion -> vars .)
    >               reduce using rule 40 (varExpresion -> vars .)
    <               reduce using rule 40 (varExpresion -> vars .)
    ;               reduce using rule 40 (varExpresion -> vars .)
    )               reduce using rule 40 (varExpresion -> vars .)
    ,               reduce using rule 40 (varExpresion -> vars .)
    ]               reduce using rule 40 (varExpresion -> vars .)
    :               reduce using rule 40 (varExpresion -> vars .)
    }               reduce using rule 40 (varExpresion -> vars .)


state 84

    (10) loop -> WHILE ( varExpresion . ) bloque
    (18) varExpresion -> varExpresion . + varExpresion
    (19) varExpresion -> varExpresion . - varExpresion
    (20) varExpresion -> varExpresion . * varExpresion
    (21) varExpresion -> varExpresion . / varExpresion
    (22) varExpresion -> varExpresion . % varExpresion
    (23) varExpresion -> varExpresion . ^ varExpresion
    (26) varExpresion -> varExpresion . ? varExpresion : varExpresion
    (27) varExpresion -> varExpresion . AND varExpresion
    (29) varExpresion -> varExpresion . OR varExpresion
    (30) varExpresion -> varExpresion . EQEQ varExpresion
    (31) varExpresion -> varExpresion . DISTINTO varExpresion
    (32) varExpresion -> varExpresion . > varExpresion
    (33) varExpresion -> varExpresion . < varExpresion

    )               shift and go to state 120
    +               shift and go to state 100
    -               shift and go to state 102
    *               shift and go to state 101
    /               shift and go to state 103
    %               shift and go to state 97
    ^               shift and go to state 108
    ?               shift and go to state 107
    AND             shift and go to state 96
    OR              shift and go to state 106
    EQEQ            shift and go to state 105
    DISTINTO        shift and go to state 98
    >               shift and go to state 99
    <               shift and go to state 104


state 85

    (57) varOps -> ID . MASMAS
    (58) varOps -> ID . MENOSMENOS
    (46) vec -> ID . m
    (52) reg -> ID . . ID
    (82) vars -> ID .
    (49) m -> . [ varExpresion ]
    (50) m -> . m [ varExpresion ]

    MASMAS          shift and go to state 47
    MENOSMENOS      shift and go to state 48
    .               shift and go to state 115
    +               reduce using rule 82 (vars -> ID .)
    -               reduce using rule 82 (vars -> ID .)
    *               reduce using rule 82 (vars -> ID .)
    /               reduce using rule 82 (vars -> ID .)
    %               reduce using rule 82 (vars -> ID .)
    ^               reduce using rule 82 (vars -> ID .)
    ?               reduce using rule 82 (vars -> ID .)
    AND             reduce using rule 82 (vars -> ID .)
    OR              reduce using rule 82 (vars -> ID .)
    EQEQ            reduce using rule 82 (vars -> ID .)
    DISTINTO        reduce using rule 82 (vars -> ID .)
    >               reduce using rule 82 (vars -> ID .)
    <               reduce using rule 82 (vars -> ID .)
    ;               reduce using rule 82 (vars -> ID .)
    )               reduce using rule 82 (vars -> ID .)
    ,               reduce using rule 82 (vars -> ID .)
    ]               reduce using rule 82 (vars -> ID .)
    :               reduce using rule 82 (vars -> ID .)
    }               reduce using rule 82 (vars -> ID .)
    [               shift and go to state 116

    m                              shift and go to state 114

state 86

    (68) funcVoid -> PRINT ( varExpresion . )
    (18) varExpresion -> varExpresion . + varExpresion
    (19) varExpresion -> varExpresion . - varExpresion
    (20) varExpresion -> varExpresion . * varExpresion
    (21) varExpresion -> varExpresion . / varExpresion
    (22) varExpresion -> varExpresion . % varExpresion
    (23) varExpresion -> varExpresion . ^ varExpresion
    (26) varExpresion -> varExpresion . ? varExpresion : varExpresion
    (27) varExpresion -> varExpresion . AND varExpresion
    (29) varExpresion -> varExpresion . OR varExpresion
    (30) varExpresion -> varExpresion . EQEQ varExpresion
    (31) varExpresion -> varExpresion . DISTINTO varExpresion
    (32) varExpresion -> varExpresion . > varExpresion
    (33) varExpresion -> varExpresion . < varExpresion

    )               shift and go to state 121
    +               shift and go to state 100
    -               shift and go to state 102
    *               shift and go to state 101
    /               shift and go to state 103
    %               shift and go to state 97
    ^               shift and go to state 108
    ?               shift and go to state 107
    AND             shift and go to state 96
    OR              shift and go to state 106
    EQEQ            shift and go to state 105
    DISTINTO        shift and go to state 98
    >               shift and go to state 99
    <               shift and go to state 104


state 87

    (67) funcBool -> COLINEALES ( varExpresion . , varExpresion )
    (18) varExpresion -> varExpresion . + varExpresion
    (19) varExpresion -> varExpresion . - varExpresion
    (20) varExpresion -> varExpresion . * varExpresion
    (21) varExpresion -> varExpresion . / varExpresion
    (22) varExpresion -> varExpresion . % varExpresion
    (23) varExpresion -> varExpresion . ^ varExpresion
    (26) varExpresion -> varExpresion . ? varExpresion : varExpresion
    (27) varExpresion -> varExpresion . AND varExpresion
    (29) varExpresion -> varExpresion . OR varExpresion
    (30) varExpresion -> varExpresion . EQEQ varExpresion
    (31) varExpresion -> varExpresion . DISTINTO varExpresion
    (32) varExpresion -> varExpresion . > varExpresion
    (33) varExpresion -> varExpresion . < varExpresion

    ,               shift and go to state 122
    +               shift and go to state 100
    -               shift and go to state 102
    *               shift and go to state 101
    /               shift and go to state 103
    %               shift and go to state 97
    ^               shift and go to state 108
    ?               shift and go to state 107
    AND             shift and go to state 96
    OR              shift and go to state 106
    EQEQ            shift and go to state 105
    DISTINTO        shift and go to state 98
    >               shift and go to state 99
    <               shift and go to state 104


state 88

    (12) loop -> FOR ( varAsig . ; varExpresion ; varOps ) bloque

    ;               shift and go to state 123


state 89

    (82) vars -> ID .

    MENOSEQ         reduce using rule 82 (vars -> ID .)
    MASEQ           reduce using rule 82 (vars -> ID .)
    MULEQ           reduce using rule 82 (vars -> ID .)
    DIVEQ           reduce using rule 82 (vars -> ID .)
    =               reduce using rule 82 (vars -> ID .)


state 90

    (13) if -> IF ( varExpresion . ) THEN bloque else
    (18) varExpresion -> varExpresion . + varExpresion
    (19) varExpresion -> varExpresion . - varExpresion
    (20) varExpresion -> varExpresion . * varExpresion
    (21) varExpresion -> varExpresion . / varExpresion
    (22) varExpresion -> varExpresion . % varExpresion
    (23) varExpresion -> varExpresion . ^ varExpresion
    (26) varExpresion -> varExpresion . ? varExpresion : varExpresion
    (27) varExpresion -> varExpresion . AND varExpresion
    (29) varExpresion -> varExpresion . OR varExpresion
    (30) varExpresion -> varExpresion . EQEQ varExpresion
    (31) varExpresion -> varExpresion . DISTINTO varExpresion
    (32) varExpresion -> varExpresion . > varExpresion
    (33) varExpresion -> varExpresion . < varExpresion

    )               shift and go to state 124
    +               shift and go to state 100
    -               shift and go to state 102
    *               shift and go to state 101
    /               shift and go to state 103
    %               shift and go to state 97
    ^               shift and go to state 108
    ?               shift and go to state 107
    AND             shift and go to state 96
    OR              shift and go to state 106
    EQEQ            shift and go to state 105
    DISTINTO        shift and go to state 98
    >               shift and go to state 99
    <               shift and go to state 104


state 91

    (64) funcInt -> MULTIESCALAR ( varExpresion . , varExpresion , param )
    (18) varExpresion -> varExpresion . + varExpresion
    (19) varExpresion -> varExpresion . - varExpresion
    (20) varExpresion -> varExpresion . * varExpresion
    (21) varExpresion -> varExpresion . / varExpresion
    (22) varExpresion -> varExpresion . % varExpresion
    (23) varExpresion -> varExpresion . ^ varExpresion
    (26) varExpresion -> varExpresion . ? varExpresion : varExpresion
    (27) varExpresion -> varExpresion . AND varExpresion
    (29) varExpresion -> varExpresion . OR varExpresion
    (30) varExpresion -> varExpresion . EQEQ varExpresion
    (31) varExpresion -> varExpresion . DISTINTO varExpresion
    (32) varExpresion -> varExpresion . > varExpresion
    (33) varExpresion -> varExpresion . < varExpresion

    ,               shift and go to state 125
    +               shift and go to state 100
    -               shift and go to state 102
    *               shift and go to state 101
    /               shift and go to state 103
    %               shift and go to state 97
    ^               shift and go to state 108
    ?               shift and go to state 107
    AND             shift and go to state 96
    OR              shift and go to state 106
    EQEQ            shift and go to state 105
    DISTINTO        shift and go to state 98
    >               shift and go to state 99
    <               shift and go to state 104


state 92

    (66) funcString -> CAPITALIZAR ( varExpresion . )
    (18) varExpresion -> varExpresion . + varExpresion
    (19) varExpresion -> varExpresion . - varExpresion
    (20) varExpresion -> varExpresion . * varExpresion
    (21) varExpresion -> varExpresion . / varExpresion
    (22) varExpresion -> varExpresion . % varExpresion
    (23) varExpresion -> varExpresion . ^ varExpresion
    (26) varExpresion -> varExpresion . ? varExpresion : varExpresion
    (27) varExpresion -> varExpresion . AND varExpresion
    (29) varExpresion -> varExpresion . OR varExpresion
    (30) varExpresion -> varExpresion . EQEQ varExpresion
    (31) varExpresion -> varExpresion . DISTINTO varExpresion
    (32) varExpresion -> varExpresion . > varExpresion
    (33) varExpresion -> varExpresion . < varExpresion

    )               shift and go to state 126
    +               shift and go to state 100
    -               shift and go to state 102
    *               shift and go to state 101
    /               shift and go to state 103
    %               shift and go to state 97
    ^               shift and go to state 108
    ?               shift and go to state 107
    AND             shift and go to state 96
    OR              shift and go to state 106
    EQEQ            shift and go to state 105
    DISTINTO        shift and go to state 98
    >               shift and go to state 99
    <               shift and go to state 104


state 93

    (65) funcInt -> LENGTH ( varExpresion . )
    (18) varExpresion -> varExpresion . + varExpresion
    (19) varExpresion -> varExpresion . - varExpresion
    (20) varExpresion -> varExpresion . * varExpresion
    (21) varExpresion -> varExpresion . / varExpresion
    (22) varExpresion -> varExpresion . % varExpresion
    (23) varExpresion -> varExpresion . ^ varExpresion
    (26) varExpresion -> varExpresion . ? varExpresion : varExpresion
    (27) varExpresion -> varExpresion . AND varExpresion
    (29) varExpresion -> varExpresion . OR varExpresion
    (30) varExpresion -> varExpresion . EQEQ varExpresion
    (31) varExpresion -> varExpresion . DISTINTO varExpresion
    (32) varExpresion -> varExpresion . > varExpresion
    (33) varExpresion -> varExpresion . < varExpresion

    )               shift and go to state 127
    +               shift and go to state 100
    -               shift and go to state 102
    *               shift and go to state 101
    /               shift and go to state 103
    %               shift and go to state 97
    ^               shift and go to state 108
    ?               shift and go to state 107
    AND             shift and go to state 96
    OR              shift and go to state 106
    EQEQ            shift and go to state 105
    DISTINTO        shift and go to state 98
    >               shift and go to state 99
    <               shift and go to state 104


state 94

    (11) loop -> DO bloque WHILE ( . varExpresion ) ;
    (18) varExpresion -> . varExpresion + varExpresion
    (19) varExpresion -> . varExpresion - varExpresion
    (20) varExpresion -> . varExpresion * varExpresion
    (21) varExpresion -> . varExpresion / varExpresion
    (22) varExpresion -> . varExpresion % varExpresion
    (23) varExpresion -> . varExpresion ^ varExpresion
    (24) varExpresion -> . ( - ( varExpresion ) )
    (25) varExpresion -> . ( + ( varExpresion ) )
    (26) varExpresion -> . varExpresion ? varExpresion : varExpresion
    (27) varExpresion -> . varExpresion AND varExpresion
    (28) varExpresion -> . NOT varExpresion
    (29) varExpresion -> . varExpresion OR varExpresion
    (30) varExpresion -> . varExpresion EQEQ varExpresion
    (31) varExpresion -> . varExpresion DISTINTO varExpresion
    (32) varExpresion -> . varExpresion > varExpresion
    (33) varExpresion -> . varExpresion < varExpresion
    (34) varExpresion -> . ( varExpresion )
    (35) varExpresion -> . tipos
    (36) varExpresion -> . funcReturn
    (37) varExpresion -> . varOps
    (38) varExpresion -> . vec
    (39) varExpresion -> . reg
    (40) varExpresion -> . vars
    (41) tipos -> . INT
    (42) tipos -> . FLOAT
    (43) tipos -> . STRING
    (44) tipos -> . BOOL
    (61) funcReturn -> . funcInt
    (62) funcReturn -> . funcString
    (63) funcReturn -> . funcBool
    (55) varOps -> . MASMAS ID
    (56) varOps -> . MENOSMENOS ID
    (57) varOps -> . ID MASMAS
    (58) varOps -> . ID MENOSMENOS
    (45) vec -> . [ elem ]
    (46) vec -> . ID m
    (51) reg -> . { campos }
    (52) reg -> . ID . ID
    (82) vars -> . ID
    (83) vars -> . RES
    (64) funcInt -> . MULTIESCALAR ( varExpresion , varExpresion , param )
    (65) funcInt -> . LENGTH ( varExpresion )
    (66) funcString -> . CAPITALIZAR ( varExpresion )
    (67) funcBool -> . COLINEALES ( varExpresion , varExpresion )

    (               shift and go to state 63
    NOT             shift and go to state 73
    INT             shift and go to state 68
    FLOAT           shift and go to state 70
    STRING          shift and go to state 64
    BOOL            shift and go to state 72
    MASMAS          shift and go to state 27
    MENOSMENOS      shift and go to state 29
    ID              shift and go to state 85
    [               shift and go to state 65
    {               shift and go to state 74
    RES             shift and go to state 5
    MULTIESCALAR    shift and go to state 22
    LENGTH          shift and go to state 25
    CAPITALIZAR     shift and go to state 24
    COLINEALES      shift and go to state 14

    funcBool                       shift and go to state 11
    vars                           shift and go to state 83
    funcString                     shift and go to state 21
    varExpresion                   shift and go to state 128
    funcReturn                     shift and go to state 69
    varOps                         shift and go to state 58
    tipos                          shift and go to state 61
    vec                            shift and go to state 62
    funcInt                        shift and go to state 6
    reg                            shift and go to state 71

state 95

    (17) bloque -> { g } .

    ELSE            reduce using rule 17 (bloque -> { g } .)
    RETURN          reduce using rule 17 (bloque -> { g } .)
    MASMAS          reduce using rule 17 (bloque -> { g } .)
    MENOSMENOS      reduce using rule 17 (bloque -> { g } .)
    ID              reduce using rule 17 (bloque -> { g } .)
    IF              reduce using rule 17 (bloque -> { g } .)
    WHILE           reduce using rule 17 (bloque -> { g } .)
    DO              reduce using rule 17 (bloque -> { g } .)
    FOR             reduce using rule 17 (bloque -> { g } .)
    PRINT           reduce using rule 17 (bloque -> { g } .)
    RES             reduce using rule 17 (bloque -> { g } .)
    MULTIESCALAR    reduce using rule 17 (bloque -> { g } .)
    LENGTH          reduce using rule 17 (bloque -> { g } .)
    CAPITALIZAR     reduce using rule 17 (bloque -> { g } .)
    COLINEALES      reduce using rule 17 (bloque -> { g } .)
    $end            reduce using rule 17 (bloque -> { g } .)
    }               reduce using rule 17 (bloque -> { g } .)


state 96

    (27) varExpresion -> varExpresion AND . varExpresion
    (18) varExpresion -> . varExpresion + varExpresion
    (19) varExpresion -> . varExpresion - varExpresion
    (20) varExpresion -> . varExpresion * varExpresion
    (21) varExpresion -> . varExpresion / varExpresion
    (22) varExpresion -> . varExpresion % varExpresion
    (23) varExpresion -> . varExpresion ^ varExpresion
    (24) varExpresion -> . ( - ( varExpresion ) )
    (25) varExpresion -> . ( + ( varExpresion ) )
    (26) varExpresion -> . varExpresion ? varExpresion : varExpresion
    (27) varExpresion -> . varExpresion AND varExpresion
    (28) varExpresion -> . NOT varExpresion
    (29) varExpresion -> . varExpresion OR varExpresion
    (30) varExpresion -> . varExpresion EQEQ varExpresion
    (31) varExpresion -> . varExpresion DISTINTO varExpresion
    (32) varExpresion -> . varExpresion > varExpresion
    (33) varExpresion -> . varExpresion < varExpresion
    (34) varExpresion -> . ( varExpresion )
    (35) varExpresion -> . tipos
    (36) varExpresion -> . funcReturn
    (37) varExpresion -> . varOps
    (38) varExpresion -> . vec
    (39) varExpresion -> . reg
    (40) varExpresion -> . vars
    (41) tipos -> . INT
    (42) tipos -> . FLOAT
    (43) tipos -> . STRING
    (44) tipos -> . BOOL
    (61) funcReturn -> . funcInt
    (62) funcReturn -> . funcString
    (63) funcReturn -> . funcBool
    (55) varOps -> . MASMAS ID
    (56) varOps -> . MENOSMENOS ID
    (57) varOps -> . ID MASMAS
    (58) varOps -> . ID MENOSMENOS
    (45) vec -> . [ elem ]
    (46) vec -> . ID m
    (51) reg -> . { campos }
    (52) reg -> . ID . ID
    (82) vars -> . ID
    (83) vars -> . RES
    (64) funcInt -> . MULTIESCALAR ( varExpresion , varExpresion , param )
    (65) funcInt -> . LENGTH ( varExpresion )
    (66) funcString -> . CAPITALIZAR ( varExpresion )
    (67) funcBool -> . COLINEALES ( varExpresion , varExpresion )

    (               shift and go to state 63
    NOT             shift and go to state 73
    INT             shift and go to state 68
    FLOAT           shift and go to state 70
    STRING          shift and go to state 64
    BOOL            shift and go to state 72
    MASMAS          shift and go to state 27
    MENOSMENOS      shift and go to state 29
    ID              shift and go to state 85
    [               shift and go to state 65
    {               shift and go to state 74
    RES             shift and go to state 5
    MULTIESCALAR    shift and go to state 22
    LENGTH          shift and go to state 25
    CAPITALIZAR     shift and go to state 24
    COLINEALES      shift and go to state 14

    funcBool                       shift and go to state 11
    vars                           shift and go to state 83
    funcString                     shift and go to state 21
    varExpresion                   shift and go to state 129
    funcReturn                     shift and go to state 69
    varOps                         shift and go to state 58
    tipos                          shift and go to state 61
    vec                            shift and go to state 62
    funcInt                        shift and go to state 6
    reg                            shift and go to state 71

state 97

    (22) varExpresion -> varExpresion % . varExpresion
    (18) varExpresion -> . varExpresion + varExpresion
    (19) varExpresion -> . varExpresion - varExpresion
    (20) varExpresion -> . varExpresion * varExpresion
    (21) varExpresion -> . varExpresion / varExpresion
    (22) varExpresion -> . varExpresion % varExpresion
    (23) varExpresion -> . varExpresion ^ varExpresion
    (24) varExpresion -> . ( - ( varExpresion ) )
    (25) varExpresion -> . ( + ( varExpresion ) )
    (26) varExpresion -> . varExpresion ? varExpresion : varExpresion
    (27) varExpresion -> . varExpresion AND varExpresion
    (28) varExpresion -> . NOT varExpresion
    (29) varExpresion -> . varExpresion OR varExpresion
    (30) varExpresion -> . varExpresion EQEQ varExpresion
    (31) varExpresion -> . varExpresion DISTINTO varExpresion
    (32) varExpresion -> . varExpresion > varExpresion
    (33) varExpresion -> . varExpresion < varExpresion
    (34) varExpresion -> . ( varExpresion )
    (35) varExpresion -> . tipos
    (36) varExpresion -> . funcReturn
    (37) varExpresion -> . varOps
    (38) varExpresion -> . vec
    (39) varExpresion -> . reg
    (40) varExpresion -> . vars
    (41) tipos -> . INT
    (42) tipos -> . FLOAT
    (43) tipos -> . STRING
    (44) tipos -> . BOOL
    (61) funcReturn -> . funcInt
    (62) funcReturn -> . funcString
    (63) funcReturn -> . funcBool
    (55) varOps -> . MASMAS ID
    (56) varOps -> . MENOSMENOS ID
    (57) varOps -> . ID MASMAS
    (58) varOps -> . ID MENOSMENOS
    (45) vec -> . [ elem ]
    (46) vec -> . ID m
    (51) reg -> . { campos }
    (52) reg -> . ID . ID
    (82) vars -> . ID
    (83) vars -> . RES
    (64) funcInt -> . MULTIESCALAR ( varExpresion , varExpresion , param )
    (65) funcInt -> . LENGTH ( varExpresion )
    (66) funcString -> . CAPITALIZAR ( varExpresion )
    (67) funcBool -> . COLINEALES ( varExpresion , varExpresion )

    (               shift and go to state 63
    NOT             shift and go to state 73
    INT             shift and go to state 68
    FLOAT           shift and go to state 70
    STRING          shift and go to state 64
    BOOL            shift and go to state 72
    MASMAS          shift and go to state 27
    MENOSMENOS      shift and go to state 29
    ID              shift and go to state 85
    [               shift and go to state 65
    {               shift and go to state 74
    RES             shift and go to state 5
    MULTIESCALAR    shift and go to state 22
    LENGTH          shift and go to state 25
    CAPITALIZAR     shift and go to state 24
    COLINEALES      shift and go to state 14

    funcBool                       shift and go to state 11
    vars                           shift and go to state 83
    funcString                     shift and go to state 21
    varExpresion                   shift and go to state 130
    funcReturn                     shift and go to state 69
    varOps                         shift and go to state 58
    tipos                          shift and go to state 61
    vec                            shift and go to state 62
    funcInt                        shift and go to state 6
    reg                            shift and go to state 71

state 98

    (31) varExpresion -> varExpresion DISTINTO . varExpresion
    (18) varExpresion -> . varExpresion + varExpresion
    (19) varExpresion -> . varExpresion - varExpresion
    (20) varExpresion -> . varExpresion * varExpresion
    (21) varExpresion -> . varExpresion / varExpresion
    (22) varExpresion -> . varExpresion % varExpresion
    (23) varExpresion -> . varExpresion ^ varExpresion
    (24) varExpresion -> . ( - ( varExpresion ) )
    (25) varExpresion -> . ( + ( varExpresion ) )
    (26) varExpresion -> . varExpresion ? varExpresion : varExpresion
    (27) varExpresion -> . varExpresion AND varExpresion
    (28) varExpresion -> . NOT varExpresion
    (29) varExpresion -> . varExpresion OR varExpresion
    (30) varExpresion -> . varExpresion EQEQ varExpresion
    (31) varExpresion -> . varExpresion DISTINTO varExpresion
    (32) varExpresion -> . varExpresion > varExpresion
    (33) varExpresion -> . varExpresion < varExpresion
    (34) varExpresion -> . ( varExpresion )
    (35) varExpresion -> . tipos
    (36) varExpresion -> . funcReturn
    (37) varExpresion -> . varOps
    (38) varExpresion -> . vec
    (39) varExpresion -> . reg
    (40) varExpresion -> . vars
    (41) tipos -> . INT
    (42) tipos -> . FLOAT
    (43) tipos -> . STRING
    (44) tipos -> . BOOL
    (61) funcReturn -> . funcInt
    (62) funcReturn -> . funcString
    (63) funcReturn -> . funcBool
    (55) varOps -> . MASMAS ID
    (56) varOps -> . MENOSMENOS ID
    (57) varOps -> . ID MASMAS
    (58) varOps -> . ID MENOSMENOS
    (45) vec -> . [ elem ]
    (46) vec -> . ID m
    (51) reg -> . { campos }
    (52) reg -> . ID . ID
    (82) vars -> . ID
    (83) vars -> . RES
    (64) funcInt -> . MULTIESCALAR ( varExpresion , varExpresion , param )
    (65) funcInt -> . LENGTH ( varExpresion )
    (66) funcString -> . CAPITALIZAR ( varExpresion )
    (67) funcBool -> . COLINEALES ( varExpresion , varExpresion )

    (               shift and go to state 63
    NOT             shift and go to state 73
    INT             shift and go to state 68
    FLOAT           shift and go to state 70
    STRING          shift and go to state 64
    BOOL            shift and go to state 72
    MASMAS          shift and go to state 27
    MENOSMENOS      shift and go to state 29
    ID              shift and go to state 85
    [               shift and go to state 65
    {               shift and go to state 74
    RES             shift and go to state 5
    MULTIESCALAR    shift and go to state 22
    LENGTH          shift and go to state 25
    CAPITALIZAR     shift and go to state 24
    COLINEALES      shift and go to state 14

    funcBool                       shift and go to state 11
    vars                           shift and go to state 83
    funcString                     shift and go to state 21
    varExpresion                   shift and go to state 131
    funcReturn                     shift and go to state 69
    varOps                         shift and go to state 58
    tipos                          shift and go to state 61
    vec                            shift and go to state 62
    funcInt                        shift and go to state 6
    reg                            shift and go to state 71

state 99

    (32) varExpresion -> varExpresion > . varExpresion
    (18) varExpresion -> . varExpresion + varExpresion
    (19) varExpresion -> . varExpresion - varExpresion
    (20) varExpresion -> . varExpresion * varExpresion
    (21) varExpresion -> . varExpresion / varExpresion
    (22) varExpresion -> . varExpresion % varExpresion
    (23) varExpresion -> . varExpresion ^ varExpresion
    (24) varExpresion -> . ( - ( varExpresion ) )
    (25) varExpresion -> . ( + ( varExpresion ) )
    (26) varExpresion -> . varExpresion ? varExpresion : varExpresion
    (27) varExpresion -> . varExpresion AND varExpresion
    (28) varExpresion -> . NOT varExpresion
    (29) varExpresion -> . varExpresion OR varExpresion
    (30) varExpresion -> . varExpresion EQEQ varExpresion
    (31) varExpresion -> . varExpresion DISTINTO varExpresion
    (32) varExpresion -> . varExpresion > varExpresion
    (33) varExpresion -> . varExpresion < varExpresion
    (34) varExpresion -> . ( varExpresion )
    (35) varExpresion -> . tipos
    (36) varExpresion -> . funcReturn
    (37) varExpresion -> . varOps
    (38) varExpresion -> . vec
    (39) varExpresion -> . reg
    (40) varExpresion -> . vars
    (41) tipos -> . INT
    (42) tipos -> . FLOAT
    (43) tipos -> . STRING
    (44) tipos -> . BOOL
    (61) funcReturn -> . funcInt
    (62) funcReturn -> . funcString
    (63) funcReturn -> . funcBool
    (55) varOps -> . MASMAS ID
    (56) varOps -> . MENOSMENOS ID
    (57) varOps -> . ID MASMAS
    (58) varOps -> . ID MENOSMENOS
    (45) vec -> . [ elem ]
    (46) vec -> . ID m
    (51) reg -> . { campos }
    (52) reg -> . ID . ID
    (82) vars -> . ID
    (83) vars -> . RES
    (64) funcInt -> . MULTIESCALAR ( varExpresion , varExpresion , param )
    (65) funcInt -> . LENGTH ( varExpresion )
    (66) funcString -> . CAPITALIZAR ( varExpresion )
    (67) funcBool -> . COLINEALES ( varExpresion , varExpresion )

    (               shift and go to state 63
    NOT             shift and go to state 73
    INT             shift and go to state 68
    FLOAT           shift and go to state 70
    STRING          shift and go to state 64
    BOOL            shift and go to state 72
    MASMAS          shift and go to state 27
    MENOSMENOS      shift and go to state 29
    ID              shift and go to state 85
    [               shift and go to state 65
    {               shift and go to state 74
    RES             shift and go to state 5
    MULTIESCALAR    shift and go to state 22
    LENGTH          shift and go to state 25
    CAPITALIZAR     shift and go to state 24
    COLINEALES      shift and go to state 14

    funcBool                       shift and go to state 11
    vars                           shift and go to state 83
    funcString                     shift and go to state 21
    varExpresion                   shift and go to state 132
    funcReturn                     shift and go to state 69
    varOps                         shift and go to state 58
    tipos                          shift and go to state 61
    vec                            shift and go to state 62
    funcInt                        shift and go to state 6
    reg                            shift and go to state 71

state 100

    (18) varExpresion -> varExpresion + . varExpresion
    (18) varExpresion -> . varExpresion + varExpresion
    (19) varExpresion -> . varExpresion - varExpresion
    (20) varExpresion -> . varExpresion * varExpresion
    (21) varExpresion -> . varExpresion / varExpresion
    (22) varExpresion -> . varExpresion % varExpresion
    (23) varExpresion -> . varExpresion ^ varExpresion
    (24) varExpresion -> . ( - ( varExpresion ) )
    (25) varExpresion -> . ( + ( varExpresion ) )
    (26) varExpresion -> . varExpresion ? varExpresion : varExpresion
    (27) varExpresion -> . varExpresion AND varExpresion
    (28) varExpresion -> . NOT varExpresion
    (29) varExpresion -> . varExpresion OR varExpresion
    (30) varExpresion -> . varExpresion EQEQ varExpresion
    (31) varExpresion -> . varExpresion DISTINTO varExpresion
    (32) varExpresion -> . varExpresion > varExpresion
    (33) varExpresion -> . varExpresion < varExpresion
    (34) varExpresion -> . ( varExpresion )
    (35) varExpresion -> . tipos
    (36) varExpresion -> . funcReturn
    (37) varExpresion -> . varOps
    (38) varExpresion -> . vec
    (39) varExpresion -> . reg
    (40) varExpresion -> . vars
    (41) tipos -> . INT
    (42) tipos -> . FLOAT
    (43) tipos -> . STRING
    (44) tipos -> . BOOL
    (61) funcReturn -> . funcInt
    (62) funcReturn -> . funcString
    (63) funcReturn -> . funcBool
    (55) varOps -> . MASMAS ID
    (56) varOps -> . MENOSMENOS ID
    (57) varOps -> . ID MASMAS
    (58) varOps -> . ID MENOSMENOS
    (45) vec -> . [ elem ]
    (46) vec -> . ID m
    (51) reg -> . { campos }
    (52) reg -> . ID . ID
    (82) vars -> . ID
    (83) vars -> . RES
    (64) funcInt -> . MULTIESCALAR ( varExpresion , varExpresion , param )
    (65) funcInt -> . LENGTH ( varExpresion )
    (66) funcString -> . CAPITALIZAR ( varExpresion )
    (67) funcBool -> . COLINEALES ( varExpresion , varExpresion )

    (               shift and go to state 63
    NOT             shift and go to state 73
    INT             shift and go to state 68
    FLOAT           shift and go to state 70
    STRING          shift and go to state 64
    BOOL            shift and go to state 72
    MASMAS          shift and go to state 27
    MENOSMENOS      shift and go to state 29
    ID              shift and go to state 85
    [               shift and go to state 65
    {               shift and go to state 74
    RES             shift and go to state 5
    MULTIESCALAR    shift and go to state 22
    LENGTH          shift and go to state 25
    CAPITALIZAR     shift and go to state 24
    COLINEALES      shift and go to state 14

    funcBool                       shift and go to state 11
    vars                           shift and go to state 83
    funcString                     shift and go to state 21
    varExpresion                   shift and go to state 133
    funcReturn                     shift and go to state 69
    varOps                         shift and go to state 58
    tipos                          shift and go to state 61
    vec                            shift and go to state 62
    funcInt                        shift and go to state 6
    reg                            shift and go to state 71

state 101

    (20) varExpresion -> varExpresion * . varExpresion
    (18) varExpresion -> . varExpresion + varExpresion
    (19) varExpresion -> . varExpresion - varExpresion
    (20) varExpresion -> . varExpresion * varExpresion
    (21) varExpresion -> . varExpresion / varExpresion
    (22) varExpresion -> . varExpresion % varExpresion
    (23) varExpresion -> . varExpresion ^ varExpresion
    (24) varExpresion -> . ( - ( varExpresion ) )
    (25) varExpresion -> . ( + ( varExpresion ) )
    (26) varExpresion -> . varExpresion ? varExpresion : varExpresion
    (27) varExpresion -> . varExpresion AND varExpresion
    (28) varExpresion -> . NOT varExpresion
    (29) varExpresion -> . varExpresion OR varExpresion
    (30) varExpresion -> . varExpresion EQEQ varExpresion
    (31) varExpresion -> . varExpresion DISTINTO varExpresion
    (32) varExpresion -> . varExpresion > varExpresion
    (33) varExpresion -> . varExpresion < varExpresion
    (34) varExpresion -> . ( varExpresion )
    (35) varExpresion -> . tipos
    (36) varExpresion -> . funcReturn
    (37) varExpresion -> . varOps
    (38) varExpresion -> . vec
    (39) varExpresion -> . reg
    (40) varExpresion -> . vars
    (41) tipos -> . INT
    (42) tipos -> . FLOAT
    (43) tipos -> . STRING
    (44) tipos -> . BOOL
    (61) funcReturn -> . funcInt
    (62) funcReturn -> . funcString
    (63) funcReturn -> . funcBool
    (55) varOps -> . MASMAS ID
    (56) varOps -> . MENOSMENOS ID
    (57) varOps -> . ID MASMAS
    (58) varOps -> . ID MENOSMENOS
    (45) vec -> . [ elem ]
    (46) vec -> . ID m
    (51) reg -> . { campos }
    (52) reg -> . ID . ID
    (82) vars -> . ID
    (83) vars -> . RES
    (64) funcInt -> . MULTIESCALAR ( varExpresion , varExpresion , param )
    (65) funcInt -> . LENGTH ( varExpresion )
    (66) funcString -> . CAPITALIZAR ( varExpresion )
    (67) funcBool -> . COLINEALES ( varExpresion , varExpresion )

    (               shift and go to state 63
    NOT             shift and go to state 73
    INT             shift and go to state 68
    FLOAT           shift and go to state 70
    STRING          shift and go to state 64
    BOOL            shift and go to state 72
    MASMAS          shift and go to state 27
    MENOSMENOS      shift and go to state 29
    ID              shift and go to state 85
    [               shift and go to state 65
    {               shift and go to state 74
    RES             shift and go to state 5
    MULTIESCALAR    shift and go to state 22
    LENGTH          shift and go to state 25
    CAPITALIZAR     shift and go to state 24
    COLINEALES      shift and go to state 14

    funcBool                       shift and go to state 11
    vars                           shift and go to state 83
    funcString                     shift and go to state 21
    varExpresion                   shift and go to state 134
    funcReturn                     shift and go to state 69
    varOps                         shift and go to state 58
    tipos                          shift and go to state 61
    vec                            shift and go to state 62
    funcInt                        shift and go to state 6
    reg                            shift and go to state 71

state 102

    (19) varExpresion -> varExpresion - . varExpresion
    (18) varExpresion -> . varExpresion + varExpresion
    (19) varExpresion -> . varExpresion - varExpresion
    (20) varExpresion -> . varExpresion * varExpresion
    (21) varExpresion -> . varExpresion / varExpresion
    (22) varExpresion -> . varExpresion % varExpresion
    (23) varExpresion -> . varExpresion ^ varExpresion
    (24) varExpresion -> . ( - ( varExpresion ) )
    (25) varExpresion -> . ( + ( varExpresion ) )
    (26) varExpresion -> . varExpresion ? varExpresion : varExpresion
    (27) varExpresion -> . varExpresion AND varExpresion
    (28) varExpresion -> . NOT varExpresion
    (29) varExpresion -> . varExpresion OR varExpresion
    (30) varExpresion -> . varExpresion EQEQ varExpresion
    (31) varExpresion -> . varExpresion DISTINTO varExpresion
    (32) varExpresion -> . varExpresion > varExpresion
    (33) varExpresion -> . varExpresion < varExpresion
    (34) varExpresion -> . ( varExpresion )
    (35) varExpresion -> . tipos
    (36) varExpresion -> . funcReturn
    (37) varExpresion -> . varOps
    (38) varExpresion -> . vec
    (39) varExpresion -> . reg
    (40) varExpresion -> . vars
    (41) tipos -> . INT
    (42) tipos -> . FLOAT
    (43) tipos -> . STRING
    (44) tipos -> . BOOL
    (61) funcReturn -> . funcInt
    (62) funcReturn -> . funcString
    (63) funcReturn -> . funcBool
    (55) varOps -> . MASMAS ID
    (56) varOps -> . MENOSMENOS ID
    (57) varOps -> . ID MASMAS
    (58) varOps -> . ID MENOSMENOS
    (45) vec -> . [ elem ]
    (46) vec -> . ID m
    (51) reg -> . { campos }
    (52) reg -> . ID . ID
    (82) vars -> . ID
    (83) vars -> . RES
    (64) funcInt -> . MULTIESCALAR ( varExpresion , varExpresion , param )
    (65) funcInt -> . LENGTH ( varExpresion )
    (66) funcString -> . CAPITALIZAR ( varExpresion )
    (67) funcBool -> . COLINEALES ( varExpresion , varExpresion )

    (               shift and go to state 63
    NOT             shift and go to state 73
    INT             shift and go to state 68
    FLOAT           shift and go to state 70
    STRING          shift and go to state 64
    BOOL            shift and go to state 72
    MASMAS          shift and go to state 27
    MENOSMENOS      shift and go to state 29
    ID              shift and go to state 85
    [               shift and go to state 65
    {               shift and go to state 74
    RES             shift and go to state 5
    MULTIESCALAR    shift and go to state 22
    LENGTH          shift and go to state 25
    CAPITALIZAR     shift and go to state 24
    COLINEALES      shift and go to state 14

    funcBool                       shift and go to state 11
    vars                           shift and go to state 83
    funcString                     shift and go to state 21
    varExpresion                   shift and go to state 135
    funcReturn                     shift and go to state 69
    varOps                         shift and go to state 58
    tipos                          shift and go to state 61
    vec                            shift and go to state 62
    funcInt                        shift and go to state 6
    reg                            shift and go to state 71

state 103

    (21) varExpresion -> varExpresion / . varExpresion
    (18) varExpresion -> . varExpresion + varExpresion
    (19) varExpresion -> . varExpresion - varExpresion
    (20) varExpresion -> . varExpresion * varExpresion
    (21) varExpresion -> . varExpresion / varExpresion
    (22) varExpresion -> . varExpresion % varExpresion
    (23) varExpresion -> . varExpresion ^ varExpresion
    (24) varExpresion -> . ( - ( varExpresion ) )
    (25) varExpresion -> . ( + ( varExpresion ) )
    (26) varExpresion -> . varExpresion ? varExpresion : varExpresion
    (27) varExpresion -> . varExpresion AND varExpresion
    (28) varExpresion -> . NOT varExpresion
    (29) varExpresion -> . varExpresion OR varExpresion
    (30) varExpresion -> . varExpresion EQEQ varExpresion
    (31) varExpresion -> . varExpresion DISTINTO varExpresion
    (32) varExpresion -> . varExpresion > varExpresion
    (33) varExpresion -> . varExpresion < varExpresion
    (34) varExpresion -> . ( varExpresion )
    (35) varExpresion -> . tipos
    (36) varExpresion -> . funcReturn
    (37) varExpresion -> . varOps
    (38) varExpresion -> . vec
    (39) varExpresion -> . reg
    (40) varExpresion -> . vars
    (41) tipos -> . INT
    (42) tipos -> . FLOAT
    (43) tipos -> . STRING
    (44) tipos -> . BOOL
    (61) funcReturn -> . funcInt
    (62) funcReturn -> . funcString
    (63) funcReturn -> . funcBool
    (55) varOps -> . MASMAS ID
    (56) varOps -> . MENOSMENOS ID
    (57) varOps -> . ID MASMAS
    (58) varOps -> . ID MENOSMENOS
    (45) vec -> . [ elem ]
    (46) vec -> . ID m
    (51) reg -> . { campos }
    (52) reg -> . ID . ID
    (82) vars -> . ID
    (83) vars -> . RES
    (64) funcInt -> . MULTIESCALAR ( varExpresion , varExpresion , param )
    (65) funcInt -> . LENGTH ( varExpresion )
    (66) funcString -> . CAPITALIZAR ( varExpresion )
    (67) funcBool -> . COLINEALES ( varExpresion , varExpresion )

    (               shift and go to state 63
    NOT             shift and go to state 73
    INT             shift and go to state 68
    FLOAT           shift and go to state 70
    STRING          shift and go to state 64
    BOOL            shift and go to state 72
    MASMAS          shift and go to state 27
    MENOSMENOS      shift and go to state 29
    ID              shift and go to state 85
    [               shift and go to state 65
    {               shift and go to state 74
    RES             shift and go to state 5
    MULTIESCALAR    shift and go to state 22
    LENGTH          shift and go to state 25
    CAPITALIZAR     shift and go to state 24
    COLINEALES      shift and go to state 14

    funcBool                       shift and go to state 11
    vars                           shift and go to state 83
    funcString                     shift and go to state 21
    varExpresion                   shift and go to state 136
    funcReturn                     shift and go to state 69
    varOps                         shift and go to state 58
    tipos                          shift and go to state 61
    vec                            shift and go to state 62
    funcInt                        shift and go to state 6
    reg                            shift and go to state 71

state 104

    (33) varExpresion -> varExpresion < . varExpresion
    (18) varExpresion -> . varExpresion + varExpresion
    (19) varExpresion -> . varExpresion - varExpresion
    (20) varExpresion -> . varExpresion * varExpresion
    (21) varExpresion -> . varExpresion / varExpresion
    (22) varExpresion -> . varExpresion % varExpresion
    (23) varExpresion -> . varExpresion ^ varExpresion
    (24) varExpresion -> . ( - ( varExpresion ) )
    (25) varExpresion -> . ( + ( varExpresion ) )
    (26) varExpresion -> . varExpresion ? varExpresion : varExpresion
    (27) varExpresion -> . varExpresion AND varExpresion
    (28) varExpresion -> . NOT varExpresion
    (29) varExpresion -> . varExpresion OR varExpresion
    (30) varExpresion -> . varExpresion EQEQ varExpresion
    (31) varExpresion -> . varExpresion DISTINTO varExpresion
    (32) varExpresion -> . varExpresion > varExpresion
    (33) varExpresion -> . varExpresion < varExpresion
    (34) varExpresion -> . ( varExpresion )
    (35) varExpresion -> . tipos
    (36) varExpresion -> . funcReturn
    (37) varExpresion -> . varOps
    (38) varExpresion -> . vec
    (39) varExpresion -> . reg
    (40) varExpresion -> . vars
    (41) tipos -> . INT
    (42) tipos -> . FLOAT
    (43) tipos -> . STRING
    (44) tipos -> . BOOL
    (61) funcReturn -> . funcInt
    (62) funcReturn -> . funcString
    (63) funcReturn -> . funcBool
    (55) varOps -> . MASMAS ID
    (56) varOps -> . MENOSMENOS ID
    (57) varOps -> . ID MASMAS
    (58) varOps -> . ID MENOSMENOS
    (45) vec -> . [ elem ]
    (46) vec -> . ID m
    (51) reg -> . { campos }
    (52) reg -> . ID . ID
    (82) vars -> . ID
    (83) vars -> . RES
    (64) funcInt -> . MULTIESCALAR ( varExpresion , varExpresion , param )
    (65) funcInt -> . LENGTH ( varExpresion )
    (66) funcString -> . CAPITALIZAR ( varExpresion )
    (67) funcBool -> . COLINEALES ( varExpresion , varExpresion )

    (               shift and go to state 63
    NOT             shift and go to state 73
    INT             shift and go to state 68
    FLOAT           shift and go to state 70
    STRING          shift and go to state 64
    BOOL            shift and go to state 72
    MASMAS          shift and go to state 27
    MENOSMENOS      shift and go to state 29
    ID              shift and go to state 85
    [               shift and go to state 65
    {               shift and go to state 74
    RES             shift and go to state 5
    MULTIESCALAR    shift and go to state 22
    LENGTH          shift and go to state 25
    CAPITALIZAR     shift and go to state 24
    COLINEALES      shift and go to state 14

    funcBool                       shift and go to state 11
    vars                           shift and go to state 83
    funcString                     shift and go to state 21
    varExpresion                   shift and go to state 137
    funcReturn                     shift and go to state 69
    varOps                         shift and go to state 58
    tipos                          shift and go to state 61
    vec                            shift and go to state 62
    funcInt                        shift and go to state 6
    reg                            shift and go to state 71

state 105

    (30) varExpresion -> varExpresion EQEQ . varExpresion
    (18) varExpresion -> . varExpresion + varExpresion
    (19) varExpresion -> . varExpresion - varExpresion
    (20) varExpresion -> . varExpresion * varExpresion
    (21) varExpresion -> . varExpresion / varExpresion
    (22) varExpresion -> . varExpresion % varExpresion
    (23) varExpresion -> . varExpresion ^ varExpresion
    (24) varExpresion -> . ( - ( varExpresion ) )
    (25) varExpresion -> . ( + ( varExpresion ) )
    (26) varExpresion -> . varExpresion ? varExpresion : varExpresion
    (27) varExpresion -> . varExpresion AND varExpresion
    (28) varExpresion -> . NOT varExpresion
    (29) varExpresion -> . varExpresion OR varExpresion
    (30) varExpresion -> . varExpresion EQEQ varExpresion
    (31) varExpresion -> . varExpresion DISTINTO varExpresion
    (32) varExpresion -> . varExpresion > varExpresion
    (33) varExpresion -> . varExpresion < varExpresion
    (34) varExpresion -> . ( varExpresion )
    (35) varExpresion -> . tipos
    (36) varExpresion -> . funcReturn
    (37) varExpresion -> . varOps
    (38) varExpresion -> . vec
    (39) varExpresion -> . reg
    (40) varExpresion -> . vars
    (41) tipos -> . INT
    (42) tipos -> . FLOAT
    (43) tipos -> . STRING
    (44) tipos -> . BOOL
    (61) funcReturn -> . funcInt
    (62) funcReturn -> . funcString
    (63) funcReturn -> . funcBool
    (55) varOps -> . MASMAS ID
    (56) varOps -> . MENOSMENOS ID
    (57) varOps -> . ID MASMAS
    (58) varOps -> . ID MENOSMENOS
    (45) vec -> . [ elem ]
    (46) vec -> . ID m
    (51) reg -> . { campos }
    (52) reg -> . ID . ID
    (82) vars -> . ID
    (83) vars -> . RES
    (64) funcInt -> . MULTIESCALAR ( varExpresion , varExpresion , param )
    (65) funcInt -> . LENGTH ( varExpresion )
    (66) funcString -> . CAPITALIZAR ( varExpresion )
    (67) funcBool -> . COLINEALES ( varExpresion , varExpresion )

    (               shift and go to state 63
    NOT             shift and go to state 73
    INT             shift and go to state 68
    FLOAT           shift and go to state 70
    STRING          shift and go to state 64
    BOOL            shift and go to state 72
    MASMAS          shift and go to state 27
    MENOSMENOS      shift and go to state 29
    ID              shift and go to state 85
    [               shift and go to state 65
    {               shift and go to state 74
    RES             shift and go to state 5
    MULTIESCALAR    shift and go to state 22
    LENGTH          shift and go to state 25
    CAPITALIZAR     shift and go to state 24
    COLINEALES      shift and go to state 14

    funcBool                       shift and go to state 11
    vars                           shift and go to state 83
    funcString                     shift and go to state 21
    varExpresion                   shift and go to state 138
    funcReturn                     shift and go to state 69
    varOps                         shift and go to state 58
    tipos                          shift and go to state 61
    vec                            shift and go to state 62
    funcInt                        shift and go to state 6
    reg                            shift and go to state 71

state 106

    (29) varExpresion -> varExpresion OR . varExpresion
    (18) varExpresion -> . varExpresion + varExpresion
    (19) varExpresion -> . varExpresion - varExpresion
    (20) varExpresion -> . varExpresion * varExpresion
    (21) varExpresion -> . varExpresion / varExpresion
    (22) varExpresion -> . varExpresion % varExpresion
    (23) varExpresion -> . varExpresion ^ varExpresion
    (24) varExpresion -> . ( - ( varExpresion ) )
    (25) varExpresion -> . ( + ( varExpresion ) )
    (26) varExpresion -> . varExpresion ? varExpresion : varExpresion
    (27) varExpresion -> . varExpresion AND varExpresion
    (28) varExpresion -> . NOT varExpresion
    (29) varExpresion -> . varExpresion OR varExpresion
    (30) varExpresion -> . varExpresion EQEQ varExpresion
    (31) varExpresion -> . varExpresion DISTINTO varExpresion
    (32) varExpresion -> . varExpresion > varExpresion
    (33) varExpresion -> . varExpresion < varExpresion
    (34) varExpresion -> . ( varExpresion )
    (35) varExpresion -> . tipos
    (36) varExpresion -> . funcReturn
    (37) varExpresion -> . varOps
    (38) varExpresion -> . vec
    (39) varExpresion -> . reg
    (40) varExpresion -> . vars
    (41) tipos -> . INT
    (42) tipos -> . FLOAT
    (43) tipos -> . STRING
    (44) tipos -> . BOOL
    (61) funcReturn -> . funcInt
    (62) funcReturn -> . funcString
    (63) funcReturn -> . funcBool
    (55) varOps -> . MASMAS ID
    (56) varOps -> . MENOSMENOS ID
    (57) varOps -> . ID MASMAS
    (58) varOps -> . ID MENOSMENOS
    (45) vec -> . [ elem ]
    (46) vec -> . ID m
    (51) reg -> . { campos }
    (52) reg -> . ID . ID
    (82) vars -> . ID
    (83) vars -> . RES
    (64) funcInt -> . MULTIESCALAR ( varExpresion , varExpresion , param )
    (65) funcInt -> . LENGTH ( varExpresion )
    (66) funcString -> . CAPITALIZAR ( varExpresion )
    (67) funcBool -> . COLINEALES ( varExpresion , varExpresion )

    (               shift and go to state 63
    NOT             shift and go to state 73
    INT             shift and go to state 68
    FLOAT           shift and go to state 70
    STRING          shift and go to state 64
    BOOL            shift and go to state 72
    MASMAS          shift and go to state 27
    MENOSMENOS      shift and go to state 29
    ID              shift and go to state 85
    [               shift and go to state 65
    {               shift and go to state 74
    RES             shift and go to state 5
    MULTIESCALAR    shift and go to state 22
    LENGTH          shift and go to state 25
    CAPITALIZAR     shift and go to state 24
    COLINEALES      shift and go to state 14

    funcBool                       shift and go to state 11
    vars                           shift and go to state 83
    funcString                     shift and go to state 21
    varExpresion                   shift and go to state 139
    funcReturn                     shift and go to state 69
    varOps                         shift and go to state 58
    tipos                          shift and go to state 61
    vec                            shift and go to state 62
    funcInt                        shift and go to state 6
    reg                            shift and go to state 71

state 107

    (26) varExpresion -> varExpresion ? . varExpresion : varExpresion
    (18) varExpresion -> . varExpresion + varExpresion
    (19) varExpresion -> . varExpresion - varExpresion
    (20) varExpresion -> . varExpresion * varExpresion
    (21) varExpresion -> . varExpresion / varExpresion
    (22) varExpresion -> . varExpresion % varExpresion
    (23) varExpresion -> . varExpresion ^ varExpresion
    (24) varExpresion -> . ( - ( varExpresion ) )
    (25) varExpresion -> . ( + ( varExpresion ) )
    (26) varExpresion -> . varExpresion ? varExpresion : varExpresion
    (27) varExpresion -> . varExpresion AND varExpresion
    (28) varExpresion -> . NOT varExpresion
    (29) varExpresion -> . varExpresion OR varExpresion
    (30) varExpresion -> . varExpresion EQEQ varExpresion
    (31) varExpresion -> . varExpresion DISTINTO varExpresion
    (32) varExpresion -> . varExpresion > varExpresion
    (33) varExpresion -> . varExpresion < varExpresion
    (34) varExpresion -> . ( varExpresion )
    (35) varExpresion -> . tipos
    (36) varExpresion -> . funcReturn
    (37) varExpresion -> . varOps
    (38) varExpresion -> . vec
    (39) varExpresion -> . reg
    (40) varExpresion -> . vars
    (41) tipos -> . INT
    (42) tipos -> . FLOAT
    (43) tipos -> . STRING
    (44) tipos -> . BOOL
    (61) funcReturn -> . funcInt
    (62) funcReturn -> . funcString
    (63) funcReturn -> . funcBool
    (55) varOps -> . MASMAS ID
    (56) varOps -> . MENOSMENOS ID
    (57) varOps -> . ID MASMAS
    (58) varOps -> . ID MENOSMENOS
    (45) vec -> . [ elem ]
    (46) vec -> . ID m
    (51) reg -> . { campos }
    (52) reg -> . ID . ID
    (82) vars -> . ID
    (83) vars -> . RES
    (64) funcInt -> . MULTIESCALAR ( varExpresion , varExpresion , param )
    (65) funcInt -> . LENGTH ( varExpresion )
    (66) funcString -> . CAPITALIZAR ( varExpresion )
    (67) funcBool -> . COLINEALES ( varExpresion , varExpresion )

    (               shift and go to state 63
    NOT             shift and go to state 73
    INT             shift and go to state 68
    FLOAT           shift and go to state 70
    STRING          shift and go to state 64
    BOOL            shift and go to state 72
    MASMAS          shift and go to state 27
    MENOSMENOS      shift and go to state 29
    ID              shift and go to state 85
    [               shift and go to state 65
    {               shift and go to state 74
    RES             shift and go to state 5
    MULTIESCALAR    shift and go to state 22
    LENGTH          shift and go to state 25
    CAPITALIZAR     shift and go to state 24
    COLINEALES      shift and go to state 14

    funcBool                       shift and go to state 11
    vars                           shift and go to state 83
    funcString                     shift and go to state 21
    varExpresion                   shift and go to state 140
    funcReturn                     shift and go to state 69
    varOps                         shift and go to state 58
    tipos                          shift and go to state 61
    vec                            shift and go to state 62
    funcInt                        shift and go to state 6
    reg                            shift and go to state 71

state 108

    (23) varExpresion -> varExpresion ^ . varExpresion
    (18) varExpresion -> . varExpresion + varExpresion
    (19) varExpresion -> . varExpresion - varExpresion
    (20) varExpresion -> . varExpresion * varExpresion
    (21) varExpresion -> . varExpresion / varExpresion
    (22) varExpresion -> . varExpresion % varExpresion
    (23) varExpresion -> . varExpresion ^ varExpresion
    (24) varExpresion -> . ( - ( varExpresion ) )
    (25) varExpresion -> . ( + ( varExpresion ) )
    (26) varExpresion -> . varExpresion ? varExpresion : varExpresion
    (27) varExpresion -> . varExpresion AND varExpresion
    (28) varExpresion -> . NOT varExpresion
    (29) varExpresion -> . varExpresion OR varExpresion
    (30) varExpresion -> . varExpresion EQEQ varExpresion
    (31) varExpresion -> . varExpresion DISTINTO varExpresion
    (32) varExpresion -> . varExpresion > varExpresion
    (33) varExpresion -> . varExpresion < varExpresion
    (34) varExpresion -> . ( varExpresion )
    (35) varExpresion -> . tipos
    (36) varExpresion -> . funcReturn
    (37) varExpresion -> . varOps
    (38) varExpresion -> . vec
    (39) varExpresion -> . reg
    (40) varExpresion -> . vars
    (41) tipos -> . INT
    (42) tipos -> . FLOAT
    (43) tipos -> . STRING
    (44) tipos -> . BOOL
    (61) funcReturn -> . funcInt
    (62) funcReturn -> . funcString
    (63) funcReturn -> . funcBool
    (55) varOps -> . MASMAS ID
    (56) varOps -> . MENOSMENOS ID
    (57) varOps -> . ID MASMAS
    (58) varOps -> . ID MENOSMENOS
    (45) vec -> . [ elem ]
    (46) vec -> . ID m
    (51) reg -> . { campos }
    (52) reg -> . ID . ID
    (82) vars -> . ID
    (83) vars -> . RES
    (64) funcInt -> . MULTIESCALAR ( varExpresion , varExpresion , param )
    (65) funcInt -> . LENGTH ( varExpresion )
    (66) funcString -> . CAPITALIZAR ( varExpresion )
    (67) funcBool -> . COLINEALES ( varExpresion , varExpresion )

    (               shift and go to state 63
    NOT             shift and go to state 73
    INT             shift and go to state 68
    FLOAT           shift and go to state 70
    STRING          shift and go to state 64
    BOOL            shift and go to state 72
    MASMAS          shift and go to state 27
    MENOSMENOS      shift and go to state 29
    ID              shift and go to state 85
    [               shift and go to state 65
    {               shift and go to state 74
    RES             shift and go to state 5
    MULTIESCALAR    shift and go to state 22
    LENGTH          shift and go to state 25
    CAPITALIZAR     shift and go to state 24
    COLINEALES      shift and go to state 14

    funcBool                       shift and go to state 11
    vars                           shift and go to state 83
    funcString                     shift and go to state 21
    varExpresion                   shift and go to state 141
    funcReturn                     shift and go to state 69
    varOps                         shift and go to state 58
    tipos                          shift and go to state 61
    vec                            shift and go to state 62
    funcInt                        shift and go to state 6
    reg                            shift and go to state 71

state 109

    (25) varExpresion -> ( + . ( varExpresion ) )

    (               shift and go to state 142


state 110

    (24) varExpresion -> ( - . ( varExpresion ) )

    (               shift and go to state 143


state 111

    (34) varExpresion -> ( varExpresion . )
    (18) varExpresion -> varExpresion . + varExpresion
    (19) varExpresion -> varExpresion . - varExpresion
    (20) varExpresion -> varExpresion . * varExpresion
    (21) varExpresion -> varExpresion . / varExpresion
    (22) varExpresion -> varExpresion . % varExpresion
    (23) varExpresion -> varExpresion . ^ varExpresion
    (26) varExpresion -> varExpresion . ? varExpresion : varExpresion
    (27) varExpresion -> varExpresion . AND varExpresion
    (29) varExpresion -> varExpresion . OR varExpresion
    (30) varExpresion -> varExpresion . EQEQ varExpresion
    (31) varExpresion -> varExpresion . DISTINTO varExpresion
    (32) varExpresion -> varExpresion . > varExpresion
    (33) varExpresion -> varExpresion . < varExpresion

    )               shift and go to state 144
    +               shift and go to state 100
    -               shift and go to state 102
    *               shift and go to state 101
    /               shift and go to state 103
    %               shift and go to state 97
    ^               shift and go to state 108
    ?               shift and go to state 107
    AND             shift and go to state 96
    OR              shift and go to state 106
    EQEQ            shift and go to state 105
    DISTINTO        shift and go to state 98
    >               shift and go to state 99
    <               shift and go to state 104


state 112

    (47) elem -> varExpresion . , elem
    (48) elem -> varExpresion .
    (18) varExpresion -> varExpresion . + varExpresion
    (19) varExpresion -> varExpresion . - varExpresion
    (20) varExpresion -> varExpresion . * varExpresion
    (21) varExpresion -> varExpresion . / varExpresion
    (22) varExpresion -> varExpresion . % varExpresion
    (23) varExpresion -> varExpresion . ^ varExpresion
    (26) varExpresion -> varExpresion . ? varExpresion : varExpresion
    (27) varExpresion -> varExpresion . AND varExpresion
    (29) varExpresion -> varExpresion . OR varExpresion
    (30) varExpresion -> varExpresion . EQEQ varExpresion
    (31) varExpresion -> varExpresion . DISTINTO varExpresion
    (32) varExpresion -> varExpresion . > varExpresion
    (33) varExpresion -> varExpresion . < varExpresion

    ,               shift and go to state 145
    ]               reduce using rule 48 (elem -> varExpresion .)
    +               shift and go to state 100
    -               shift and go to state 102
    *               shift and go to state 101
    /               shift and go to state 103
    %               shift and go to state 97
    ^               shift and go to state 108
    ?               shift and go to state 107
    AND             shift and go to state 96
    OR              shift and go to state 106
    EQEQ            shift and go to state 105
    DISTINTO        shift and go to state 98
    >               shift and go to state 99
    <               shift and go to state 104


state 113

    (45) vec -> [ elem . ]

    ]               shift and go to state 146


state 114

    (46) vec -> ID m .
    (50) m -> m . [ varExpresion ]

    )               reduce using rule 46 (vec -> ID m .)
    +               reduce using rule 46 (vec -> ID m .)
    -               reduce using rule 46 (vec -> ID m .)
    *               reduce using rule 46 (vec -> ID m .)
    /               reduce using rule 46 (vec -> ID m .)
    %               reduce using rule 46 (vec -> ID m .)
    ^               reduce using rule 46 (vec -> ID m .)
    ?               reduce using rule 46 (vec -> ID m .)
    AND             reduce using rule 46 (vec -> ID m .)
    OR              reduce using rule 46 (vec -> ID m .)
    EQEQ            reduce using rule 46 (vec -> ID m .)
    DISTINTO        reduce using rule 46 (vec -> ID m .)
    >               reduce using rule 46 (vec -> ID m .)
    <               reduce using rule 46 (vec -> ID m .)
    ,               reduce using rule 46 (vec -> ID m .)
    ;               reduce using rule 46 (vec -> ID m .)
    ]               reduce using rule 46 (vec -> ID m .)
    :               reduce using rule 46 (vec -> ID m .)
    }               reduce using rule 46 (vec -> ID m .)
    [               shift and go to state 147


state 115

    (52) reg -> ID . . ID

    ID              shift and go to state 148


state 116

    (49) m -> [ . varExpresion ]
    (18) varExpresion -> . varExpresion + varExpresion
    (19) varExpresion -> . varExpresion - varExpresion
    (20) varExpresion -> . varExpresion * varExpresion
    (21) varExpresion -> . varExpresion / varExpresion
    (22) varExpresion -> . varExpresion % varExpresion
    (23) varExpresion -> . varExpresion ^ varExpresion
    (24) varExpresion -> . ( - ( varExpresion ) )
    (25) varExpresion -> . ( + ( varExpresion ) )
    (26) varExpresion -> . varExpresion ? varExpresion : varExpresion
    (27) varExpresion -> . varExpresion AND varExpresion
    (28) varExpresion -> . NOT varExpresion
    (29) varExpresion -> . varExpresion OR varExpresion
    (30) varExpresion -> . varExpresion EQEQ varExpresion
    (31) varExpresion -> . varExpresion DISTINTO varExpresion
    (32) varExpresion -> . varExpresion > varExpresion
    (33) varExpresion -> . varExpresion < varExpresion
    (34) varExpresion -> . ( varExpresion )
    (35) varExpresion -> . tipos
    (36) varExpresion -> . funcReturn
    (37) varExpresion -> . varOps
    (38) varExpresion -> . vec
    (39) varExpresion -> . reg
    (40) varExpresion -> . vars
    (41) tipos -> . INT
    (42) tipos -> . FLOAT
    (43) tipos -> . STRING
    (44) tipos -> . BOOL
    (61) funcReturn -> . funcInt
    (62) funcReturn -> . funcString
    (63) funcReturn -> . funcBool
    (55) varOps -> . MASMAS ID
    (56) varOps -> . MENOSMENOS ID
    (57) varOps -> . ID MASMAS
    (58) varOps -> . ID MENOSMENOS
    (45) vec -> . [ elem ]
    (46) vec -> . ID m
    (51) reg -> . { campos }
    (52) reg -> . ID . ID
    (82) vars -> . ID
    (83) vars -> . RES
    (64) funcInt -> . MULTIESCALAR ( varExpresion , varExpresion , param )
    (65) funcInt -> . LENGTH ( varExpresion )
    (66) funcString -> . CAPITALIZAR ( varExpresion )
    (67) funcBool -> . COLINEALES ( varExpresion , varExpresion )

    (               shift and go to state 63
    NOT             shift and go to state 73
    INT             shift and go to state 68
    FLOAT           shift and go to state 70
    STRING          shift and go to state 64
    BOOL            shift and go to state 72
    MASMAS          shift and go to state 27
    MENOSMENOS      shift and go to state 29
    ID              shift and go to state 85
    [               shift and go to state 65
    {               shift and go to state 74
    RES             shift and go to state 5
    MULTIESCALAR    shift and go to state 22
    LENGTH          shift and go to state 25
    CAPITALIZAR     shift and go to state 24
    COLINEALES      shift and go to state 14

    funcBool                       shift and go to state 11
    vars                           shift and go to state 83
    funcString                     shift and go to state 21
    varExpresion                   shift and go to state 149
    funcReturn                     shift and go to state 69
    varOps                         shift and go to state 58
    tipos                          shift and go to state 61
    vec                            shift and go to state 62
    funcInt                        shift and go to state 6
    reg                            shift and go to state 71

state 117

    (28) varExpresion -> NOT varExpresion .
    (18) varExpresion -> varExpresion . + varExpresion
    (19) varExpresion -> varExpresion . - varExpresion
    (20) varExpresion -> varExpresion . * varExpresion
    (21) varExpresion -> varExpresion . / varExpresion
    (22) varExpresion -> varExpresion . % varExpresion
    (23) varExpresion -> varExpresion . ^ varExpresion
    (26) varExpresion -> varExpresion . ? varExpresion : varExpresion
    (27) varExpresion -> varExpresion . AND varExpresion
    (29) varExpresion -> varExpresion . OR varExpresion
    (30) varExpresion -> varExpresion . EQEQ varExpresion
    (31) varExpresion -> varExpresion . DISTINTO varExpresion
    (32) varExpresion -> varExpresion . > varExpresion
    (33) varExpresion -> varExpresion . < varExpresion

    +               reduce using rule 28 (varExpresion -> NOT varExpresion .)
    -               reduce using rule 28 (varExpresion -> NOT varExpresion .)
    *               reduce using rule 28 (varExpresion -> NOT varExpresion .)
    /               reduce using rule 28 (varExpresion -> NOT varExpresion .)
    %               reduce using rule 28 (varExpresion -> NOT varExpresion .)
    ^               reduce using rule 28 (varExpresion -> NOT varExpresion .)
    ?               reduce using rule 28 (varExpresion -> NOT varExpresion .)
    AND             reduce using rule 28 (varExpresion -> NOT varExpresion .)
    OR              reduce using rule 28 (varExpresion -> NOT varExpresion .)
    EQEQ            reduce using rule 28 (varExpresion -> NOT varExpresion .)
    DISTINTO        reduce using rule 28 (varExpresion -> NOT varExpresion .)
    >               reduce using rule 28 (varExpresion -> NOT varExpresion .)
    <               reduce using rule 28 (varExpresion -> NOT varExpresion .)
    ;               reduce using rule 28 (varExpresion -> NOT varExpresion .)
    )               reduce using rule 28 (varExpresion -> NOT varExpresion .)
    ,               reduce using rule 28 (varExpresion -> NOT varExpresion .)
    ]               reduce using rule 28 (varExpresion -> NOT varExpresion .)
    :               reduce using rule 28 (varExpresion -> NOT varExpresion .)
    }               reduce using rule 28 (varExpresion -> NOT varExpresion .)

  ! +               [ shift and go to state 100 ]
  ! -               [ shift and go to state 102 ]
  ! *               [ shift and go to state 101 ]
  ! /               [ shift and go to state 103 ]
  ! %               [ shift and go to state 97 ]
  ! ^               [ shift and go to state 108 ]
  ! ?               [ shift and go to state 107 ]
  ! AND             [ shift and go to state 96 ]
  ! OR              [ shift and go to state 106 ]
  ! EQEQ            [ shift and go to state 105 ]
  ! DISTINTO        [ shift and go to state 98 ]
  ! >               [ shift and go to state 99 ]
  ! <               [ shift and go to state 104 ]


state 118

    (51) reg -> { campos . }

    }               shift and go to state 150


state 119

    (53) campos -> ID . : varExpresion , campos
    (54) campos -> ID . : varExpresion

    :               shift and go to state 151


state 120

    (10) loop -> WHILE ( varExpresion ) . bloque
    (16) bloque -> . sentencia
    (17) bloque -> . { g }
    (4) sentencia -> . varOps ;
    (5) sentencia -> . func ;
    (6) sentencia -> . varAsig ;
    (7) sentencia -> . RETURN ;
    (55) varOps -> . MASMAS ID
    (56) varOps -> . MENOSMENOS ID
    (57) varOps -> . ID MASMAS
    (58) varOps -> . ID MENOSMENOS
    (59) func -> . funcReturn
    (60) func -> . funcVoid
    (72) varAsig -> . vars MENOSEQ varAsig
    (73) varAsig -> . vars MASEQ varAsig
    (74) varAsig -> . vars MULEQ varAsig
    (75) varAsig -> . vars DIVEQ varAsig
    (76) varAsig -> . vars = varAsig
    (77) varAsig -> . vars MASEQ varExpresion
    (78) varAsig -> . vars MENOSEQ varExpresion
    (79) varAsig -> . vars MULEQ varExpresion
    (80) varAsig -> . vars DIVEQ varExpresion
    (81) varAsig -> . vars = varExpresion
    (61) funcReturn -> . funcInt
    (62) funcReturn -> . funcString
    (63) funcReturn -> . funcBool
    (68) funcVoid -> . PRINT ( varExpresion )
    (82) vars -> . ID
    (83) vars -> . RES
    (64) funcInt -> . MULTIESCALAR ( varExpresion , varExpresion , param )
    (65) funcInt -> . LENGTH ( varExpresion )
    (66) funcString -> . CAPITALIZAR ( varExpresion )
    (67) funcBool -> . COLINEALES ( varExpresion , varExpresion )

    {               shift and go to state 32
    RETURN          shift and go to state 2
    MASMAS          shift and go to state 27
    MENOSMENOS      shift and go to state 29
    ID              shift and go to state 17
    PRINT           shift and go to state 8
    RES             shift and go to state 5
    MULTIESCALAR    shift and go to state 22
    LENGTH          shift and go to state 25
    CAPITALIZAR     shift and go to state 24
    COLINEALES      shift and go to state 14

    varAsig                        shift and go to state 19
    sentencia                      shift and go to state 31
    vars                           shift and go to state 3
    funcString                     shift and go to state 21
    funcReturn                     shift and go to state 23
    varOps                         shift and go to state 12
    funcBool                       shift and go to state 11
    funcVoid                       shift and go to state 13
    func                           shift and go to state 16
    bloque                         shift and go to state 152
    funcInt                        shift and go to state 6

state 121

    (68) funcVoid -> PRINT ( varExpresion ) .

    ;               reduce using rule 68 (funcVoid -> PRINT ( varExpresion ) .)


state 122

    (67) funcBool -> COLINEALES ( varExpresion , . varExpresion )
    (18) varExpresion -> . varExpresion + varExpresion
    (19) varExpresion -> . varExpresion - varExpresion
    (20) varExpresion -> . varExpresion * varExpresion
    (21) varExpresion -> . varExpresion / varExpresion
    (22) varExpresion -> . varExpresion % varExpresion
    (23) varExpresion -> . varExpresion ^ varExpresion
    (24) varExpresion -> . ( - ( varExpresion ) )
    (25) varExpresion -> . ( + ( varExpresion ) )
    (26) varExpresion -> . varExpresion ? varExpresion : varExpresion
    (27) varExpresion -> . varExpresion AND varExpresion
    (28) varExpresion -> . NOT varExpresion
    (29) varExpresion -> . varExpresion OR varExpresion
    (30) varExpresion -> . varExpresion EQEQ varExpresion
    (31) varExpresion -> . varExpresion DISTINTO varExpresion
    (32) varExpresion -> . varExpresion > varExpresion
    (33) varExpresion -> . varExpresion < varExpresion
    (34) varExpresion -> . ( varExpresion )
    (35) varExpresion -> . tipos
    (36) varExpresion -> . funcReturn
    (37) varExpresion -> . varOps
    (38) varExpresion -> . vec
    (39) varExpresion -> . reg
    (40) varExpresion -> . vars
    (41) tipos -> . INT
    (42) tipos -> . FLOAT
    (43) tipos -> . STRING
    (44) tipos -> . BOOL
    (61) funcReturn -> . funcInt
    (62) funcReturn -> . funcString
    (63) funcReturn -> . funcBool
    (55) varOps -> . MASMAS ID
    (56) varOps -> . MENOSMENOS ID
    (57) varOps -> . ID MASMAS
    (58) varOps -> . ID MENOSMENOS
    (45) vec -> . [ elem ]
    (46) vec -> . ID m
    (51) reg -> . { campos }
    (52) reg -> . ID . ID
    (82) vars -> . ID
    (83) vars -> . RES
    (64) funcInt -> . MULTIESCALAR ( varExpresion , varExpresion , param )
    (65) funcInt -> . LENGTH ( varExpresion )
    (66) funcString -> . CAPITALIZAR ( varExpresion )
    (67) funcBool -> . COLINEALES ( varExpresion , varExpresion )

    (               shift and go to state 63
    NOT             shift and go to state 73
    INT             shift and go to state 68
    FLOAT           shift and go to state 70
    STRING          shift and go to state 64
    BOOL            shift and go to state 72
    MASMAS          shift and go to state 27
    MENOSMENOS      shift and go to state 29
    ID              shift and go to state 85
    [               shift and go to state 65
    {               shift and go to state 74
    RES             shift and go to state 5
    MULTIESCALAR    shift and go to state 22
    LENGTH          shift and go to state 25
    CAPITALIZAR     shift and go to state 24
    COLINEALES      shift and go to state 14

    funcBool                       shift and go to state 11
    vars                           shift and go to state 83
    funcString                     shift and go to state 21
    varExpresion                   shift and go to state 153
    funcReturn                     shift and go to state 69
    varOps                         shift and go to state 58
    tipos                          shift and go to state 61
    vec                            shift and go to state 62
    funcInt                        shift and go to state 6
    reg                            shift and go to state 71

state 123

    (12) loop -> FOR ( varAsig ; . varExpresion ; varOps ) bloque
    (18) varExpresion -> . varExpresion + varExpresion
    (19) varExpresion -> . varExpresion - varExpresion
    (20) varExpresion -> . varExpresion * varExpresion
    (21) varExpresion -> . varExpresion / varExpresion
    (22) varExpresion -> . varExpresion % varExpresion
    (23) varExpresion -> . varExpresion ^ varExpresion
    (24) varExpresion -> . ( - ( varExpresion ) )
    (25) varExpresion -> . ( + ( varExpresion ) )
    (26) varExpresion -> . varExpresion ? varExpresion : varExpresion
    (27) varExpresion -> . varExpresion AND varExpresion
    (28) varExpresion -> . NOT varExpresion
    (29) varExpresion -> . varExpresion OR varExpresion
    (30) varExpresion -> . varExpresion EQEQ varExpresion
    (31) varExpresion -> . varExpresion DISTINTO varExpresion
    (32) varExpresion -> . varExpresion > varExpresion
    (33) varExpresion -> . varExpresion < varExpresion
    (34) varExpresion -> . ( varExpresion )
    (35) varExpresion -> . tipos
    (36) varExpresion -> . funcReturn
    (37) varExpresion -> . varOps
    (38) varExpresion -> . vec
    (39) varExpresion -> . reg
    (40) varExpresion -> . vars
    (41) tipos -> . INT
    (42) tipos -> . FLOAT
    (43) tipos -> . STRING
    (44) tipos -> . BOOL
    (61) funcReturn -> . funcInt
    (62) funcReturn -> . funcString
    (63) funcReturn -> . funcBool
    (55) varOps -> . MASMAS ID
    (56) varOps -> . MENOSMENOS ID
    (57) varOps -> . ID MASMAS
    (58) varOps -> . ID MENOSMENOS
    (45) vec -> . [ elem ]
    (46) vec -> . ID m
    (51) reg -> . { campos }
    (52) reg -> . ID . ID
    (82) vars -> . ID
    (83) vars -> . RES
    (64) funcInt -> . MULTIESCALAR ( varExpresion , varExpresion , param )
    (65) funcInt -> . LENGTH ( varExpresion )
    (66) funcString -> . CAPITALIZAR ( varExpresion )
    (67) funcBool -> . COLINEALES ( varExpresion , varExpresion )

    (               shift and go to state 63
    NOT             shift and go to state 73
    INT             shift and go to state 68
    FLOAT           shift and go to state 70
    STRING          shift and go to state 64
    BOOL            shift and go to state 72
    MASMAS          shift and go to state 27
    MENOSMENOS      shift and go to state 29
    ID              shift and go to state 85
    [               shift and go to state 65
    {               shift and go to state 74
    RES             shift and go to state 5
    MULTIESCALAR    shift and go to state 22
    LENGTH          shift and go to state 25
    CAPITALIZAR     shift and go to state 24
    COLINEALES      shift and go to state 14

    funcBool                       shift and go to state 11
    vars                           shift and go to state 83
    funcString                     shift and go to state 21
    varExpresion                   shift and go to state 154
    funcReturn                     shift and go to state 69
    varOps                         shift and go to state 58
    tipos                          shift and go to state 61
    vec                            shift and go to state 62
    funcInt                        shift and go to state 6
    reg                            shift and go to state 71

state 124

    (13) if -> IF ( varExpresion ) . THEN bloque else

    THEN            shift and go to state 155


state 125

    (64) funcInt -> MULTIESCALAR ( varExpresion , . varExpresion , param )
    (18) varExpresion -> . varExpresion + varExpresion
    (19) varExpresion -> . varExpresion - varExpresion
    (20) varExpresion -> . varExpresion * varExpresion
    (21) varExpresion -> . varExpresion / varExpresion
    (22) varExpresion -> . varExpresion % varExpresion
    (23) varExpresion -> . varExpresion ^ varExpresion
    (24) varExpresion -> . ( - ( varExpresion ) )
    (25) varExpresion -> . ( + ( varExpresion ) )
    (26) varExpresion -> . varExpresion ? varExpresion : varExpresion
    (27) varExpresion -> . varExpresion AND varExpresion
    (28) varExpresion -> . NOT varExpresion
    (29) varExpresion -> . varExpresion OR varExpresion
    (30) varExpresion -> . varExpresion EQEQ varExpresion
    (31) varExpresion -> . varExpresion DISTINTO varExpresion
    (32) varExpresion -> . varExpresion > varExpresion
    (33) varExpresion -> . varExpresion < varExpresion
    (34) varExpresion -> . ( varExpresion )
    (35) varExpresion -> . tipos
    (36) varExpresion -> . funcReturn
    (37) varExpresion -> . varOps
    (38) varExpresion -> . vec
    (39) varExpresion -> . reg
    (40) varExpresion -> . vars
    (41) tipos -> . INT
    (42) tipos -> . FLOAT
    (43) tipos -> . STRING
    (44) tipos -> . BOOL
    (61) funcReturn -> . funcInt
    (62) funcReturn -> . funcString
    (63) funcReturn -> . funcBool
    (55) varOps -> . MASMAS ID
    (56) varOps -> . MENOSMENOS ID
    (57) varOps -> . ID MASMAS
    (58) varOps -> . ID MENOSMENOS
    (45) vec -> . [ elem ]
    (46) vec -> . ID m
    (51) reg -> . { campos }
    (52) reg -> . ID . ID
    (82) vars -> . ID
    (83) vars -> . RES
    (64) funcInt -> . MULTIESCALAR ( varExpresion , varExpresion , param )
    (65) funcInt -> . LENGTH ( varExpresion )
    (66) funcString -> . CAPITALIZAR ( varExpresion )
    (67) funcBool -> . COLINEALES ( varExpresion , varExpresion )

    (               shift and go to state 63
    NOT             shift and go to state 73
    INT             shift and go to state 68
    FLOAT           shift and go to state 70
    STRING          shift and go to state 64
    BOOL            shift and go to state 72
    MASMAS          shift and go to state 27
    MENOSMENOS      shift and go to state 29
    ID              shift and go to state 85
    [               shift and go to state 65
    {               shift and go to state 74
    RES             shift and go to state 5
    MULTIESCALAR    shift and go to state 22
    LENGTH          shift and go to state 25
    CAPITALIZAR     shift and go to state 24
    COLINEALES      shift and go to state 14

    funcBool                       shift and go to state 11
    vars                           shift and go to state 83
    funcString                     shift and go to state 21
    varExpresion                   shift and go to state 156
    funcReturn                     shift and go to state 69
    varOps                         shift and go to state 58
    tipos                          shift and go to state 61
    vec                            shift and go to state 62
    funcInt                        shift and go to state 6
    reg                            shift and go to state 71

state 126

    (66) funcString -> CAPITALIZAR ( varExpresion ) .

    +               reduce using rule 66 (funcString -> CAPITALIZAR ( varExpresion ) .)
    -               reduce using rule 66 (funcString -> CAPITALIZAR ( varExpresion ) .)
    *               reduce using rule 66 (funcString -> CAPITALIZAR ( varExpresion ) .)
    /               reduce using rule 66 (funcString -> CAPITALIZAR ( varExpresion ) .)
    %               reduce using rule 66 (funcString -> CAPITALIZAR ( varExpresion ) .)
    ^               reduce using rule 66 (funcString -> CAPITALIZAR ( varExpresion ) .)
    ?               reduce using rule 66 (funcString -> CAPITALIZAR ( varExpresion ) .)
    AND             reduce using rule 66 (funcString -> CAPITALIZAR ( varExpresion ) .)
    OR              reduce using rule 66 (funcString -> CAPITALIZAR ( varExpresion ) .)
    EQEQ            reduce using rule 66 (funcString -> CAPITALIZAR ( varExpresion ) .)
    DISTINTO        reduce using rule 66 (funcString -> CAPITALIZAR ( varExpresion ) .)
    >               reduce using rule 66 (funcString -> CAPITALIZAR ( varExpresion ) .)
    <               reduce using rule 66 (funcString -> CAPITALIZAR ( varExpresion ) .)
    ;               reduce using rule 66 (funcString -> CAPITALIZAR ( varExpresion ) .)
    )               reduce using rule 66 (funcString -> CAPITALIZAR ( varExpresion ) .)
    ,               reduce using rule 66 (funcString -> CAPITALIZAR ( varExpresion ) .)
    ]               reduce using rule 66 (funcString -> CAPITALIZAR ( varExpresion ) .)
    :               reduce using rule 66 (funcString -> CAPITALIZAR ( varExpresion ) .)
    }               reduce using rule 66 (funcString -> CAPITALIZAR ( varExpresion ) .)


state 127

    (65) funcInt -> LENGTH ( varExpresion ) .

    ;               reduce using rule 65 (funcInt -> LENGTH ( varExpresion ) .)
    +               reduce using rule 65 (funcInt -> LENGTH ( varExpresion ) .)
    -               reduce using rule 65 (funcInt -> LENGTH ( varExpresion ) .)
    *               reduce using rule 65 (funcInt -> LENGTH ( varExpresion ) .)
    /               reduce using rule 65 (funcInt -> LENGTH ( varExpresion ) .)
    %               reduce using rule 65 (funcInt -> LENGTH ( varExpresion ) .)
    ^               reduce using rule 65 (funcInt -> LENGTH ( varExpresion ) .)
    ?               reduce using rule 65 (funcInt -> LENGTH ( varExpresion ) .)
    AND             reduce using rule 65 (funcInt -> LENGTH ( varExpresion ) .)
    OR              reduce using rule 65 (funcInt -> LENGTH ( varExpresion ) .)
    EQEQ            reduce using rule 65 (funcInt -> LENGTH ( varExpresion ) .)
    DISTINTO        reduce using rule 65 (funcInt -> LENGTH ( varExpresion ) .)
    >               reduce using rule 65 (funcInt -> LENGTH ( varExpresion ) .)
    <               reduce using rule 65 (funcInt -> LENGTH ( varExpresion ) .)
    )               reduce using rule 65 (funcInt -> LENGTH ( varExpresion ) .)
    ,               reduce using rule 65 (funcInt -> LENGTH ( varExpresion ) .)
    ]               reduce using rule 65 (funcInt -> LENGTH ( varExpresion ) .)
    :               reduce using rule 65 (funcInt -> LENGTH ( varExpresion ) .)
    }               reduce using rule 65 (funcInt -> LENGTH ( varExpresion ) .)


state 128

    (11) loop -> DO bloque WHILE ( varExpresion . ) ;
    (18) varExpresion -> varExpresion . + varExpresion
    (19) varExpresion -> varExpresion . - varExpresion
    (20) varExpresion -> varExpresion . * varExpresion
    (21) varExpresion -> varExpresion . / varExpresion
    (22) varExpresion -> varExpresion . % varExpresion
    (23) varExpresion -> varExpresion . ^ varExpresion
    (26) varExpresion -> varExpresion . ? varExpresion : varExpresion
    (27) varExpresion -> varExpresion . AND varExpresion
    (29) varExpresion -> varExpresion . OR varExpresion
    (30) varExpresion -> varExpresion . EQEQ varExpresion
    (31) varExpresion -> varExpresion . DISTINTO varExpresion
    (32) varExpresion -> varExpresion . > varExpresion
    (33) varExpresion -> varExpresion . < varExpresion

    )               shift and go to state 157
    +               shift and go to state 100
    -               shift and go to state 102
    *               shift and go to state 101
    /               shift and go to state 103
    %               shift and go to state 97
    ^               shift and go to state 108
    ?               shift and go to state 107
    AND             shift and go to state 96
    OR              shift and go to state 106
    EQEQ            shift and go to state 105
    DISTINTO        shift and go to state 98
    >               shift and go to state 99
    <               shift and go to state 104


state 129

    (27) varExpresion -> varExpresion AND varExpresion .
    (18) varExpresion -> varExpresion . + varExpresion
    (19) varExpresion -> varExpresion . - varExpresion
    (20) varExpresion -> varExpresion . * varExpresion
    (21) varExpresion -> varExpresion . / varExpresion
    (22) varExpresion -> varExpresion . % varExpresion
    (23) varExpresion -> varExpresion . ^ varExpresion
    (26) varExpresion -> varExpresion . ? varExpresion : varExpresion
    (27) varExpresion -> varExpresion . AND varExpresion
    (29) varExpresion -> varExpresion . OR varExpresion
    (30) varExpresion -> varExpresion . EQEQ varExpresion
    (31) varExpresion -> varExpresion . DISTINTO varExpresion
    (32) varExpresion -> varExpresion . > varExpresion
    (33) varExpresion -> varExpresion . < varExpresion

    ?               reduce using rule 27 (varExpresion -> varExpresion AND varExpresion .)
    AND             reduce using rule 27 (varExpresion -> varExpresion AND varExpresion .)
    OR              reduce using rule 27 (varExpresion -> varExpresion AND varExpresion .)
    >               reduce using rule 27 (varExpresion -> varExpresion AND varExpresion .)
    <               reduce using rule 27 (varExpresion -> varExpresion AND varExpresion .)
    ;               reduce using rule 27 (varExpresion -> varExpresion AND varExpresion .)
    )               reduce using rule 27 (varExpresion -> varExpresion AND varExpresion .)
    ,               reduce using rule 27 (varExpresion -> varExpresion AND varExpresion .)
    ]               reduce using rule 27 (varExpresion -> varExpresion AND varExpresion .)
    :               reduce using rule 27 (varExpresion -> varExpresion AND varExpresion .)
    }               reduce using rule 27 (varExpresion -> varExpresion AND varExpresion .)
    +               shift and go to state 100
    -               shift and go to state 102
    *               shift and go to state 101
    /               shift and go to state 103
    %               shift and go to state 97
    ^               shift and go to state 108
    EQEQ            shift and go to state 105
    DISTINTO        shift and go to state 98

  ! +               [ reduce using rule 27 (varExpresion -> varExpresion AND varExpresion .) ]
  ! -               [ reduce using rule 27 (varExpresion -> varExpresion AND varExpresion .) ]
  ! *               [ reduce using rule 27 (varExpresion -> varExpresion AND varExpresion .) ]
  ! /               [ reduce using rule 27 (varExpresion -> varExpresion AND varExpresion .) ]
  ! %               [ reduce using rule 27 (varExpresion -> varExpresion AND varExpresion .) ]
  ! ^               [ reduce using rule 27 (varExpresion -> varExpresion AND varExpresion .) ]
  ! EQEQ            [ reduce using rule 27 (varExpresion -> varExpresion AND varExpresion .) ]
  ! DISTINTO        [ reduce using rule 27 (varExpresion -> varExpresion AND varExpresion .) ]
  ! ?               [ shift and go to state 107 ]
  ! AND             [ shift and go to state 96 ]
  ! OR              [ shift and go to state 106 ]
  ! >               [ shift and go to state 99 ]
  ! <               [ shift and go to state 104 ]


state 130

    (22) varExpresion -> varExpresion % varExpresion .
    (18) varExpresion -> varExpresion . + varExpresion
    (19) varExpresion -> varExpresion . - varExpresion
    (20) varExpresion -> varExpresion . * varExpresion
    (21) varExpresion -> varExpresion . / varExpresion
    (22) varExpresion -> varExpresion . % varExpresion
    (23) varExpresion -> varExpresion . ^ varExpresion
    (26) varExpresion -> varExpresion . ? varExpresion : varExpresion
    (27) varExpresion -> varExpresion . AND varExpresion
    (29) varExpresion -> varExpresion . OR varExpresion
    (30) varExpresion -> varExpresion . EQEQ varExpresion
    (31) varExpresion -> varExpresion . DISTINTO varExpresion
    (32) varExpresion -> varExpresion . > varExpresion
    (33) varExpresion -> varExpresion . < varExpresion

    +               reduce using rule 22 (varExpresion -> varExpresion % varExpresion .)
    -               reduce using rule 22 (varExpresion -> varExpresion % varExpresion .)
    *               reduce using rule 22 (varExpresion -> varExpresion % varExpresion .)
    /               reduce using rule 22 (varExpresion -> varExpresion % varExpresion .)
    %               reduce using rule 22 (varExpresion -> varExpresion % varExpresion .)
    ?               reduce using rule 22 (varExpresion -> varExpresion % varExpresion .)
    AND             reduce using rule 22 (varExpresion -> varExpresion % varExpresion .)
    OR              reduce using rule 22 (varExpresion -> varExpresion % varExpresion .)
    EQEQ            reduce using rule 22 (varExpresion -> varExpresion % varExpresion .)
    DISTINTO        reduce using rule 22 (varExpresion -> varExpresion % varExpresion .)
    >               reduce using rule 22 (varExpresion -> varExpresion % varExpresion .)
    <               reduce using rule 22 (varExpresion -> varExpresion % varExpresion .)
    ;               reduce using rule 22 (varExpresion -> varExpresion % varExpresion .)
    )               reduce using rule 22 (varExpresion -> varExpresion % varExpresion .)
    ,               reduce using rule 22 (varExpresion -> varExpresion % varExpresion .)
    ]               reduce using rule 22 (varExpresion -> varExpresion % varExpresion .)
    :               reduce using rule 22 (varExpresion -> varExpresion % varExpresion .)
    }               reduce using rule 22 (varExpresion -> varExpresion % varExpresion .)
    ^               shift and go to state 108

  ! ^               [ reduce using rule 22 (varExpresion -> varExpresion % varExpresion .) ]
  ! +               [ shift and go to state 100 ]
  ! -               [ shift and go to state 102 ]
  ! *               [ shift and go to state 101 ]
  ! /               [ shift and go to state 103 ]
  ! %               [ shift and go to state 97 ]
  ! ?               [ shift and go to state 107 ]
  ! AND             [ shift and go to state 96 ]
  ! OR              [ shift and go to state 106 ]
  ! EQEQ            [ shift and go to state 105 ]
  ! DISTINTO        [ shift and go to state 98 ]
  ! >               [ shift and go to state 99 ]
  ! <               [ shift and go to state 104 ]


state 131

    (31) varExpresion -> varExpresion DISTINTO varExpresion .
    (18) varExpresion -> varExpresion . + varExpresion
    (19) varExpresion -> varExpresion . - varExpresion
    (20) varExpresion -> varExpresion . * varExpresion
    (21) varExpresion -> varExpresion . / varExpresion
    (22) varExpresion -> varExpresion . % varExpresion
    (23) varExpresion -> varExpresion . ^ varExpresion
    (26) varExpresion -> varExpresion . ? varExpresion : varExpresion
    (27) varExpresion -> varExpresion . AND varExpresion
    (29) varExpresion -> varExpresion . OR varExpresion
    (30) varExpresion -> varExpresion . EQEQ varExpresion
    (31) varExpresion -> varExpresion . DISTINTO varExpresion
    (32) varExpresion -> varExpresion . > varExpresion
    (33) varExpresion -> varExpresion . < varExpresion

    ?               reduce using rule 31 (varExpresion -> varExpresion DISTINTO varExpresion .)
    AND             reduce using rule 31 (varExpresion -> varExpresion DISTINTO varExpresion .)
    OR              reduce using rule 31 (varExpresion -> varExpresion DISTINTO varExpresion .)
    EQEQ            reduce using rule 31 (varExpresion -> varExpresion DISTINTO varExpresion .)
    DISTINTO        reduce using rule 31 (varExpresion -> varExpresion DISTINTO varExpresion .)
    >               reduce using rule 31 (varExpresion -> varExpresion DISTINTO varExpresion .)
    <               reduce using rule 31 (varExpresion -> varExpresion DISTINTO varExpresion .)
    ;               reduce using rule 31 (varExpresion -> varExpresion DISTINTO varExpresion .)
    )               reduce using rule 31 (varExpresion -> varExpresion DISTINTO varExpresion .)
    ,               reduce using rule 31 (varExpresion -> varExpresion DISTINTO varExpresion .)
    ]               reduce using rule 31 (varExpresion -> varExpresion DISTINTO varExpresion .)
    :               reduce using rule 31 (varExpresion -> varExpresion DISTINTO varExpresion .)
    }               reduce using rule 31 (varExpresion -> varExpresion DISTINTO varExpresion .)
    +               shift and go to state 100
    -               shift and go to state 102
    *               shift and go to state 101
    /               shift and go to state 103
    %               shift and go to state 97
    ^               shift and go to state 108

  ! +               [ reduce using rule 31 (varExpresion -> varExpresion DISTINTO varExpresion .) ]
  ! -               [ reduce using rule 31 (varExpresion -> varExpresion DISTINTO varExpresion .) ]
  ! *               [ reduce using rule 31 (varExpresion -> varExpresion DISTINTO varExpresion .) ]
  ! /               [ reduce using rule 31 (varExpresion -> varExpresion DISTINTO varExpresion .) ]
  ! %               [ reduce using rule 31 (varExpresion -> varExpresion DISTINTO varExpresion .) ]
  ! ^               [ reduce using rule 31 (varExpresion -> varExpresion DISTINTO varExpresion .) ]
  ! ?               [ shift and go to state 107 ]
  ! AND             [ shift and go to state 96 ]
  ! OR              [ shift and go to state 106 ]
  ! EQEQ            [ shift and go to state 105 ]
  ! DISTINTO        [ shift and go to state 98 ]
  ! >               [ shift and go to state 99 ]
  ! <               [ shift and go to state 104 ]


state 132

    (32) varExpresion -> varExpresion > varExpresion .
    (18) varExpresion -> varExpresion . + varExpresion
    (19) varExpresion -> varExpresion . - varExpresion
    (20) varExpresion -> varExpresion . * varExpresion
    (21) varExpresion -> varExpresion . / varExpresion
    (22) varExpresion -> varExpresion . % varExpresion
    (23) varExpresion -> varExpresion . ^ varExpresion
    (26) varExpresion -> varExpresion . ? varExpresion : varExpresion
    (27) varExpresion -> varExpresion . AND varExpresion
    (29) varExpresion -> varExpresion . OR varExpresion
    (30) varExpresion -> varExpresion . EQEQ varExpresion
    (31) varExpresion -> varExpresion . DISTINTO varExpresion
    (32) varExpresion -> varExpresion . > varExpresion
    (33) varExpresion -> varExpresion . < varExpresion

  ! shift/reduce conflict for + resolved as shift
  ! shift/reduce conflict for - resolved as shift
  ! shift/reduce conflict for * resolved as shift
  ! shift/reduce conflict for / resolved as shift
  ! shift/reduce conflict for % resolved as shift
  ! shift/reduce conflict for ^ resolved as shift
  ! shift/reduce conflict for ? resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for EQEQ resolved as shift
  ! shift/reduce conflict for DISTINTO resolved as shift
  ! shift/reduce conflict for > resolved as shift
  ! shift/reduce conflict for < resolved as shift
    ;               reduce using rule 32 (varExpresion -> varExpresion > varExpresion .)
    )               reduce using rule 32 (varExpresion -> varExpresion > varExpresion .)
    ,               reduce using rule 32 (varExpresion -> varExpresion > varExpresion .)
    ]               reduce using rule 32 (varExpresion -> varExpresion > varExpresion .)
    :               reduce using rule 32 (varExpresion -> varExpresion > varExpresion .)
    }               reduce using rule 32 (varExpresion -> varExpresion > varExpresion .)
    +               shift and go to state 100
    -               shift and go to state 102
    *               shift and go to state 101
    /               shift and go to state 103
    %               shift and go to state 97
    ^               shift and go to state 108
    ?               shift and go to state 107
    AND             shift and go to state 96
    OR              shift and go to state 106
    EQEQ            shift and go to state 105
    DISTINTO        shift and go to state 98
    >               shift and go to state 99
    <               shift and go to state 104

  ! +               [ reduce using rule 32 (varExpresion -> varExpresion > varExpresion .) ]
  ! -               [ reduce using rule 32 (varExpresion -> varExpresion > varExpresion .) ]
  ! *               [ reduce using rule 32 (varExpresion -> varExpresion > varExpresion .) ]
  ! /               [ reduce using rule 32 (varExpresion -> varExpresion > varExpresion .) ]
  ! %               [ reduce using rule 32 (varExpresion -> varExpresion > varExpresion .) ]
  ! ^               [ reduce using rule 32 (varExpresion -> varExpresion > varExpresion .) ]
  ! ?               [ reduce using rule 32 (varExpresion -> varExpresion > varExpresion .) ]
  ! AND             [ reduce using rule 32 (varExpresion -> varExpresion > varExpresion .) ]
  ! OR              [ reduce using rule 32 (varExpresion -> varExpresion > varExpresion .) ]
  ! EQEQ            [ reduce using rule 32 (varExpresion -> varExpresion > varExpresion .) ]
  ! DISTINTO        [ reduce using rule 32 (varExpresion -> varExpresion > varExpresion .) ]
  ! >               [ reduce using rule 32 (varExpresion -> varExpresion > varExpresion .) ]
  ! <               [ reduce using rule 32 (varExpresion -> varExpresion > varExpresion .) ]


state 133

    (18) varExpresion -> varExpresion + varExpresion .
    (18) varExpresion -> varExpresion . + varExpresion
    (19) varExpresion -> varExpresion . - varExpresion
    (20) varExpresion -> varExpresion . * varExpresion
    (21) varExpresion -> varExpresion . / varExpresion
    (22) varExpresion -> varExpresion . % varExpresion
    (23) varExpresion -> varExpresion . ^ varExpresion
    (26) varExpresion -> varExpresion . ? varExpresion : varExpresion
    (27) varExpresion -> varExpresion . AND varExpresion
    (29) varExpresion -> varExpresion . OR varExpresion
    (30) varExpresion -> varExpresion . EQEQ varExpresion
    (31) varExpresion -> varExpresion . DISTINTO varExpresion
    (32) varExpresion -> varExpresion . > varExpresion
    (33) varExpresion -> varExpresion . < varExpresion

    +               reduce using rule 18 (varExpresion -> varExpresion + varExpresion .)
    -               reduce using rule 18 (varExpresion -> varExpresion + varExpresion .)
    ?               reduce using rule 18 (varExpresion -> varExpresion + varExpresion .)
    AND             reduce using rule 18 (varExpresion -> varExpresion + varExpresion .)
    OR              reduce using rule 18 (varExpresion -> varExpresion + varExpresion .)
    EQEQ            reduce using rule 18 (varExpresion -> varExpresion + varExpresion .)
    DISTINTO        reduce using rule 18 (varExpresion -> varExpresion + varExpresion .)
    >               reduce using rule 18 (varExpresion -> varExpresion + varExpresion .)
    <               reduce using rule 18 (varExpresion -> varExpresion + varExpresion .)
    ;               reduce using rule 18 (varExpresion -> varExpresion + varExpresion .)
    )               reduce using rule 18 (varExpresion -> varExpresion + varExpresion .)
    ,               reduce using rule 18 (varExpresion -> varExpresion + varExpresion .)
    ]               reduce using rule 18 (varExpresion -> varExpresion + varExpresion .)
    :               reduce using rule 18 (varExpresion -> varExpresion + varExpresion .)
    }               reduce using rule 18 (varExpresion -> varExpresion + varExpresion .)
    *               shift and go to state 101
    /               shift and go to state 103
    %               shift and go to state 97
    ^               shift and go to state 108

  ! *               [ reduce using rule 18 (varExpresion -> varExpresion + varExpresion .) ]
  ! /               [ reduce using rule 18 (varExpresion -> varExpresion + varExpresion .) ]
  ! %               [ reduce using rule 18 (varExpresion -> varExpresion + varExpresion .) ]
  ! ^               [ reduce using rule 18 (varExpresion -> varExpresion + varExpresion .) ]
  ! +               [ shift and go to state 100 ]
  ! -               [ shift and go to state 102 ]
  ! ?               [ shift and go to state 107 ]
  ! AND             [ shift and go to state 96 ]
  ! OR              [ shift and go to state 106 ]
  ! EQEQ            [ shift and go to state 105 ]
  ! DISTINTO        [ shift and go to state 98 ]
  ! >               [ shift and go to state 99 ]
  ! <               [ shift and go to state 104 ]


state 134

    (20) varExpresion -> varExpresion * varExpresion .
    (18) varExpresion -> varExpresion . + varExpresion
    (19) varExpresion -> varExpresion . - varExpresion
    (20) varExpresion -> varExpresion . * varExpresion
    (21) varExpresion -> varExpresion . / varExpresion
    (22) varExpresion -> varExpresion . % varExpresion
    (23) varExpresion -> varExpresion . ^ varExpresion
    (26) varExpresion -> varExpresion . ? varExpresion : varExpresion
    (27) varExpresion -> varExpresion . AND varExpresion
    (29) varExpresion -> varExpresion . OR varExpresion
    (30) varExpresion -> varExpresion . EQEQ varExpresion
    (31) varExpresion -> varExpresion . DISTINTO varExpresion
    (32) varExpresion -> varExpresion . > varExpresion
    (33) varExpresion -> varExpresion . < varExpresion

    +               reduce using rule 20 (varExpresion -> varExpresion * varExpresion .)
    -               reduce using rule 20 (varExpresion -> varExpresion * varExpresion .)
    *               reduce using rule 20 (varExpresion -> varExpresion * varExpresion .)
    /               reduce using rule 20 (varExpresion -> varExpresion * varExpresion .)
    %               reduce using rule 20 (varExpresion -> varExpresion * varExpresion .)
    ?               reduce using rule 20 (varExpresion -> varExpresion * varExpresion .)
    AND             reduce using rule 20 (varExpresion -> varExpresion * varExpresion .)
    OR              reduce using rule 20 (varExpresion -> varExpresion * varExpresion .)
    EQEQ            reduce using rule 20 (varExpresion -> varExpresion * varExpresion .)
    DISTINTO        reduce using rule 20 (varExpresion -> varExpresion * varExpresion .)
    >               reduce using rule 20 (varExpresion -> varExpresion * varExpresion .)
    <               reduce using rule 20 (varExpresion -> varExpresion * varExpresion .)
    ;               reduce using rule 20 (varExpresion -> varExpresion * varExpresion .)
    )               reduce using rule 20 (varExpresion -> varExpresion * varExpresion .)
    ,               reduce using rule 20 (varExpresion -> varExpresion * varExpresion .)
    ]               reduce using rule 20 (varExpresion -> varExpresion * varExpresion .)
    :               reduce using rule 20 (varExpresion -> varExpresion * varExpresion .)
    }               reduce using rule 20 (varExpresion -> varExpresion * varExpresion .)
    ^               shift and go to state 108

  ! ^               [ reduce using rule 20 (varExpresion -> varExpresion * varExpresion .) ]
  ! +               [ shift and go to state 100 ]
  ! -               [ shift and go to state 102 ]
  ! *               [ shift and go to state 101 ]
  ! /               [ shift and go to state 103 ]
  ! %               [ shift and go to state 97 ]
  ! ?               [ shift and go to state 107 ]
  ! AND             [ shift and go to state 96 ]
  ! OR              [ shift and go to state 106 ]
  ! EQEQ            [ shift and go to state 105 ]
  ! DISTINTO        [ shift and go to state 98 ]
  ! >               [ shift and go to state 99 ]
  ! <               [ shift and go to state 104 ]


state 135

    (19) varExpresion -> varExpresion - varExpresion .
    (18) varExpresion -> varExpresion . + varExpresion
    (19) varExpresion -> varExpresion . - varExpresion
    (20) varExpresion -> varExpresion . * varExpresion
    (21) varExpresion -> varExpresion . / varExpresion
    (22) varExpresion -> varExpresion . % varExpresion
    (23) varExpresion -> varExpresion . ^ varExpresion
    (26) varExpresion -> varExpresion . ? varExpresion : varExpresion
    (27) varExpresion -> varExpresion . AND varExpresion
    (29) varExpresion -> varExpresion . OR varExpresion
    (30) varExpresion -> varExpresion . EQEQ varExpresion
    (31) varExpresion -> varExpresion . DISTINTO varExpresion
    (32) varExpresion -> varExpresion . > varExpresion
    (33) varExpresion -> varExpresion . < varExpresion

    +               reduce using rule 19 (varExpresion -> varExpresion - varExpresion .)
    -               reduce using rule 19 (varExpresion -> varExpresion - varExpresion .)
    ?               reduce using rule 19 (varExpresion -> varExpresion - varExpresion .)
    AND             reduce using rule 19 (varExpresion -> varExpresion - varExpresion .)
    OR              reduce using rule 19 (varExpresion -> varExpresion - varExpresion .)
    EQEQ            reduce using rule 19 (varExpresion -> varExpresion - varExpresion .)
    DISTINTO        reduce using rule 19 (varExpresion -> varExpresion - varExpresion .)
    >               reduce using rule 19 (varExpresion -> varExpresion - varExpresion .)
    <               reduce using rule 19 (varExpresion -> varExpresion - varExpresion .)
    ;               reduce using rule 19 (varExpresion -> varExpresion - varExpresion .)
    )               reduce using rule 19 (varExpresion -> varExpresion - varExpresion .)
    ,               reduce using rule 19 (varExpresion -> varExpresion - varExpresion .)
    ]               reduce using rule 19 (varExpresion -> varExpresion - varExpresion .)
    :               reduce using rule 19 (varExpresion -> varExpresion - varExpresion .)
    }               reduce using rule 19 (varExpresion -> varExpresion - varExpresion .)
    *               shift and go to state 101
    /               shift and go to state 103
    %               shift and go to state 97
    ^               shift and go to state 108

  ! *               [ reduce using rule 19 (varExpresion -> varExpresion - varExpresion .) ]
  ! /               [ reduce using rule 19 (varExpresion -> varExpresion - varExpresion .) ]
  ! %               [ reduce using rule 19 (varExpresion -> varExpresion - varExpresion .) ]
  ! ^               [ reduce using rule 19 (varExpresion -> varExpresion - varExpresion .) ]
  ! +               [ shift and go to state 100 ]
  ! -               [ shift and go to state 102 ]
  ! ?               [ shift and go to state 107 ]
  ! AND             [ shift and go to state 96 ]
  ! OR              [ shift and go to state 106 ]
  ! EQEQ            [ shift and go to state 105 ]
  ! DISTINTO        [ shift and go to state 98 ]
  ! >               [ shift and go to state 99 ]
  ! <               [ shift and go to state 104 ]


state 136

    (21) varExpresion -> varExpresion / varExpresion .
    (18) varExpresion -> varExpresion . + varExpresion
    (19) varExpresion -> varExpresion . - varExpresion
    (20) varExpresion -> varExpresion . * varExpresion
    (21) varExpresion -> varExpresion . / varExpresion
    (22) varExpresion -> varExpresion . % varExpresion
    (23) varExpresion -> varExpresion . ^ varExpresion
    (26) varExpresion -> varExpresion . ? varExpresion : varExpresion
    (27) varExpresion -> varExpresion . AND varExpresion
    (29) varExpresion -> varExpresion . OR varExpresion
    (30) varExpresion -> varExpresion . EQEQ varExpresion
    (31) varExpresion -> varExpresion . DISTINTO varExpresion
    (32) varExpresion -> varExpresion . > varExpresion
    (33) varExpresion -> varExpresion . < varExpresion

    +               reduce using rule 21 (varExpresion -> varExpresion / varExpresion .)
    -               reduce using rule 21 (varExpresion -> varExpresion / varExpresion .)
    *               reduce using rule 21 (varExpresion -> varExpresion / varExpresion .)
    /               reduce using rule 21 (varExpresion -> varExpresion / varExpresion .)
    %               reduce using rule 21 (varExpresion -> varExpresion / varExpresion .)
    ?               reduce using rule 21 (varExpresion -> varExpresion / varExpresion .)
    AND             reduce using rule 21 (varExpresion -> varExpresion / varExpresion .)
    OR              reduce using rule 21 (varExpresion -> varExpresion / varExpresion .)
    EQEQ            reduce using rule 21 (varExpresion -> varExpresion / varExpresion .)
    DISTINTO        reduce using rule 21 (varExpresion -> varExpresion / varExpresion .)
    >               reduce using rule 21 (varExpresion -> varExpresion / varExpresion .)
    <               reduce using rule 21 (varExpresion -> varExpresion / varExpresion .)
    ;               reduce using rule 21 (varExpresion -> varExpresion / varExpresion .)
    )               reduce using rule 21 (varExpresion -> varExpresion / varExpresion .)
    ,               reduce using rule 21 (varExpresion -> varExpresion / varExpresion .)
    ]               reduce using rule 21 (varExpresion -> varExpresion / varExpresion .)
    :               reduce using rule 21 (varExpresion -> varExpresion / varExpresion .)
    }               reduce using rule 21 (varExpresion -> varExpresion / varExpresion .)
    ^               shift and go to state 108

  ! ^               [ reduce using rule 21 (varExpresion -> varExpresion / varExpresion .) ]
  ! +               [ shift and go to state 100 ]
  ! -               [ shift and go to state 102 ]
  ! *               [ shift and go to state 101 ]
  ! /               [ shift and go to state 103 ]
  ! %               [ shift and go to state 97 ]
  ! ?               [ shift and go to state 107 ]
  ! AND             [ shift and go to state 96 ]
  ! OR              [ shift and go to state 106 ]
  ! EQEQ            [ shift and go to state 105 ]
  ! DISTINTO        [ shift and go to state 98 ]
  ! >               [ shift and go to state 99 ]
  ! <               [ shift and go to state 104 ]


state 137

    (33) varExpresion -> varExpresion < varExpresion .
    (18) varExpresion -> varExpresion . + varExpresion
    (19) varExpresion -> varExpresion . - varExpresion
    (20) varExpresion -> varExpresion . * varExpresion
    (21) varExpresion -> varExpresion . / varExpresion
    (22) varExpresion -> varExpresion . % varExpresion
    (23) varExpresion -> varExpresion . ^ varExpresion
    (26) varExpresion -> varExpresion . ? varExpresion : varExpresion
    (27) varExpresion -> varExpresion . AND varExpresion
    (29) varExpresion -> varExpresion . OR varExpresion
    (30) varExpresion -> varExpresion . EQEQ varExpresion
    (31) varExpresion -> varExpresion . DISTINTO varExpresion
    (32) varExpresion -> varExpresion . > varExpresion
    (33) varExpresion -> varExpresion . < varExpresion

  ! shift/reduce conflict for + resolved as shift
  ! shift/reduce conflict for - resolved as shift
  ! shift/reduce conflict for * resolved as shift
  ! shift/reduce conflict for / resolved as shift
  ! shift/reduce conflict for % resolved as shift
  ! shift/reduce conflict for ^ resolved as shift
  ! shift/reduce conflict for ? resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for EQEQ resolved as shift
  ! shift/reduce conflict for DISTINTO resolved as shift
  ! shift/reduce conflict for > resolved as shift
  ! shift/reduce conflict for < resolved as shift
    ;               reduce using rule 33 (varExpresion -> varExpresion < varExpresion .)
    )               reduce using rule 33 (varExpresion -> varExpresion < varExpresion .)
    ,               reduce using rule 33 (varExpresion -> varExpresion < varExpresion .)
    ]               reduce using rule 33 (varExpresion -> varExpresion < varExpresion .)
    :               reduce using rule 33 (varExpresion -> varExpresion < varExpresion .)
    }               reduce using rule 33 (varExpresion -> varExpresion < varExpresion .)
    +               shift and go to state 100
    -               shift and go to state 102
    *               shift and go to state 101
    /               shift and go to state 103
    %               shift and go to state 97
    ^               shift and go to state 108
    ?               shift and go to state 107
    AND             shift and go to state 96
    OR              shift and go to state 106
    EQEQ            shift and go to state 105
    DISTINTO        shift and go to state 98
    >               shift and go to state 99
    <               shift and go to state 104

  ! +               [ reduce using rule 33 (varExpresion -> varExpresion < varExpresion .) ]
  ! -               [ reduce using rule 33 (varExpresion -> varExpresion < varExpresion .) ]
  ! *               [ reduce using rule 33 (varExpresion -> varExpresion < varExpresion .) ]
  ! /               [ reduce using rule 33 (varExpresion -> varExpresion < varExpresion .) ]
  ! %               [ reduce using rule 33 (varExpresion -> varExpresion < varExpresion .) ]
  ! ^               [ reduce using rule 33 (varExpresion -> varExpresion < varExpresion .) ]
  ! ?               [ reduce using rule 33 (varExpresion -> varExpresion < varExpresion .) ]
  ! AND             [ reduce using rule 33 (varExpresion -> varExpresion < varExpresion .) ]
  ! OR              [ reduce using rule 33 (varExpresion -> varExpresion < varExpresion .) ]
  ! EQEQ            [ reduce using rule 33 (varExpresion -> varExpresion < varExpresion .) ]
  ! DISTINTO        [ reduce using rule 33 (varExpresion -> varExpresion < varExpresion .) ]
  ! >               [ reduce using rule 33 (varExpresion -> varExpresion < varExpresion .) ]
  ! <               [ reduce using rule 33 (varExpresion -> varExpresion < varExpresion .) ]


state 138

    (30) varExpresion -> varExpresion EQEQ varExpresion .
    (18) varExpresion -> varExpresion . + varExpresion
    (19) varExpresion -> varExpresion . - varExpresion
    (20) varExpresion -> varExpresion . * varExpresion
    (21) varExpresion -> varExpresion . / varExpresion
    (22) varExpresion -> varExpresion . % varExpresion
    (23) varExpresion -> varExpresion . ^ varExpresion
    (26) varExpresion -> varExpresion . ? varExpresion : varExpresion
    (27) varExpresion -> varExpresion . AND varExpresion
    (29) varExpresion -> varExpresion . OR varExpresion
    (30) varExpresion -> varExpresion . EQEQ varExpresion
    (31) varExpresion -> varExpresion . DISTINTO varExpresion
    (32) varExpresion -> varExpresion . > varExpresion
    (33) varExpresion -> varExpresion . < varExpresion

    ?               reduce using rule 30 (varExpresion -> varExpresion EQEQ varExpresion .)
    AND             reduce using rule 30 (varExpresion -> varExpresion EQEQ varExpresion .)
    OR              reduce using rule 30 (varExpresion -> varExpresion EQEQ varExpresion .)
    EQEQ            reduce using rule 30 (varExpresion -> varExpresion EQEQ varExpresion .)
    DISTINTO        reduce using rule 30 (varExpresion -> varExpresion EQEQ varExpresion .)
    >               reduce using rule 30 (varExpresion -> varExpresion EQEQ varExpresion .)
    <               reduce using rule 30 (varExpresion -> varExpresion EQEQ varExpresion .)
    ;               reduce using rule 30 (varExpresion -> varExpresion EQEQ varExpresion .)
    )               reduce using rule 30 (varExpresion -> varExpresion EQEQ varExpresion .)
    ,               reduce using rule 30 (varExpresion -> varExpresion EQEQ varExpresion .)
    ]               reduce using rule 30 (varExpresion -> varExpresion EQEQ varExpresion .)
    :               reduce using rule 30 (varExpresion -> varExpresion EQEQ varExpresion .)
    }               reduce using rule 30 (varExpresion -> varExpresion EQEQ varExpresion .)
    +               shift and go to state 100
    -               shift and go to state 102
    *               shift and go to state 101
    /               shift and go to state 103
    %               shift and go to state 97
    ^               shift and go to state 108

  ! +               [ reduce using rule 30 (varExpresion -> varExpresion EQEQ varExpresion .) ]
  ! -               [ reduce using rule 30 (varExpresion -> varExpresion EQEQ varExpresion .) ]
  ! *               [ reduce using rule 30 (varExpresion -> varExpresion EQEQ varExpresion .) ]
  ! /               [ reduce using rule 30 (varExpresion -> varExpresion EQEQ varExpresion .) ]
  ! %               [ reduce using rule 30 (varExpresion -> varExpresion EQEQ varExpresion .) ]
  ! ^               [ reduce using rule 30 (varExpresion -> varExpresion EQEQ varExpresion .) ]
  ! ?               [ shift and go to state 107 ]
  ! AND             [ shift and go to state 96 ]
  ! OR              [ shift and go to state 106 ]
  ! EQEQ            [ shift and go to state 105 ]
  ! DISTINTO        [ shift and go to state 98 ]
  ! >               [ shift and go to state 99 ]
  ! <               [ shift and go to state 104 ]


state 139

    (29) varExpresion -> varExpresion OR varExpresion .
    (18) varExpresion -> varExpresion . + varExpresion
    (19) varExpresion -> varExpresion . - varExpresion
    (20) varExpresion -> varExpresion . * varExpresion
    (21) varExpresion -> varExpresion . / varExpresion
    (22) varExpresion -> varExpresion . % varExpresion
    (23) varExpresion -> varExpresion . ^ varExpresion
    (26) varExpresion -> varExpresion . ? varExpresion : varExpresion
    (27) varExpresion -> varExpresion . AND varExpresion
    (29) varExpresion -> varExpresion . OR varExpresion
    (30) varExpresion -> varExpresion . EQEQ varExpresion
    (31) varExpresion -> varExpresion . DISTINTO varExpresion
    (32) varExpresion -> varExpresion . > varExpresion
    (33) varExpresion -> varExpresion . < varExpresion

    ?               reduce using rule 29 (varExpresion -> varExpresion OR varExpresion .)
    OR              reduce using rule 29 (varExpresion -> varExpresion OR varExpresion .)
    >               reduce using rule 29 (varExpresion -> varExpresion OR varExpresion .)
    <               reduce using rule 29 (varExpresion -> varExpresion OR varExpresion .)
    ;               reduce using rule 29 (varExpresion -> varExpresion OR varExpresion .)
    )               reduce using rule 29 (varExpresion -> varExpresion OR varExpresion .)
    ,               reduce using rule 29 (varExpresion -> varExpresion OR varExpresion .)
    ]               reduce using rule 29 (varExpresion -> varExpresion OR varExpresion .)
    :               reduce using rule 29 (varExpresion -> varExpresion OR varExpresion .)
    }               reduce using rule 29 (varExpresion -> varExpresion OR varExpresion .)
    +               shift and go to state 100
    -               shift and go to state 102
    *               shift and go to state 101
    /               shift and go to state 103
    %               shift and go to state 97
    ^               shift and go to state 108
    AND             shift and go to state 96
    EQEQ            shift and go to state 105
    DISTINTO        shift and go to state 98

  ! +               [ reduce using rule 29 (varExpresion -> varExpresion OR varExpresion .) ]
  ! -               [ reduce using rule 29 (varExpresion -> varExpresion OR varExpresion .) ]
  ! *               [ reduce using rule 29 (varExpresion -> varExpresion OR varExpresion .) ]
  ! /               [ reduce using rule 29 (varExpresion -> varExpresion OR varExpresion .) ]
  ! %               [ reduce using rule 29 (varExpresion -> varExpresion OR varExpresion .) ]
  ! ^               [ reduce using rule 29 (varExpresion -> varExpresion OR varExpresion .) ]
  ! AND             [ reduce using rule 29 (varExpresion -> varExpresion OR varExpresion .) ]
  ! EQEQ            [ reduce using rule 29 (varExpresion -> varExpresion OR varExpresion .) ]
  ! DISTINTO        [ reduce using rule 29 (varExpresion -> varExpresion OR varExpresion .) ]
  ! ?               [ shift and go to state 107 ]
  ! OR              [ shift and go to state 106 ]
  ! >               [ shift and go to state 99 ]
  ! <               [ shift and go to state 104 ]


state 140

    (26) varExpresion -> varExpresion ? varExpresion . : varExpresion
    (18) varExpresion -> varExpresion . + varExpresion
    (19) varExpresion -> varExpresion . - varExpresion
    (20) varExpresion -> varExpresion . * varExpresion
    (21) varExpresion -> varExpresion . / varExpresion
    (22) varExpresion -> varExpresion . % varExpresion
    (23) varExpresion -> varExpresion . ^ varExpresion
    (26) varExpresion -> varExpresion . ? varExpresion : varExpresion
    (27) varExpresion -> varExpresion . AND varExpresion
    (29) varExpresion -> varExpresion . OR varExpresion
    (30) varExpresion -> varExpresion . EQEQ varExpresion
    (31) varExpresion -> varExpresion . DISTINTO varExpresion
    (32) varExpresion -> varExpresion . > varExpresion
    (33) varExpresion -> varExpresion . < varExpresion

    :               shift and go to state 158
    +               shift and go to state 100
    -               shift and go to state 102
    *               shift and go to state 101
    /               shift and go to state 103
    %               shift and go to state 97
    ^               shift and go to state 108
    ?               shift and go to state 107
    AND             shift and go to state 96
    OR              shift and go to state 106
    EQEQ            shift and go to state 105
    DISTINTO        shift and go to state 98
    >               shift and go to state 99
    <               shift and go to state 104


state 141

    (23) varExpresion -> varExpresion ^ varExpresion .
    (18) varExpresion -> varExpresion . + varExpresion
    (19) varExpresion -> varExpresion . - varExpresion
    (20) varExpresion -> varExpresion . * varExpresion
    (21) varExpresion -> varExpresion . / varExpresion
    (22) varExpresion -> varExpresion . % varExpresion
    (23) varExpresion -> varExpresion . ^ varExpresion
    (26) varExpresion -> varExpresion . ? varExpresion : varExpresion
    (27) varExpresion -> varExpresion . AND varExpresion
    (29) varExpresion -> varExpresion . OR varExpresion
    (30) varExpresion -> varExpresion . EQEQ varExpresion
    (31) varExpresion -> varExpresion . DISTINTO varExpresion
    (32) varExpresion -> varExpresion . > varExpresion
    (33) varExpresion -> varExpresion . < varExpresion

    +               reduce using rule 23 (varExpresion -> varExpresion ^ varExpresion .)
    -               reduce using rule 23 (varExpresion -> varExpresion ^ varExpresion .)
    *               reduce using rule 23 (varExpresion -> varExpresion ^ varExpresion .)
    /               reduce using rule 23 (varExpresion -> varExpresion ^ varExpresion .)
    %               reduce using rule 23 (varExpresion -> varExpresion ^ varExpresion .)
    ^               reduce using rule 23 (varExpresion -> varExpresion ^ varExpresion .)
    ?               reduce using rule 23 (varExpresion -> varExpresion ^ varExpresion .)
    AND             reduce using rule 23 (varExpresion -> varExpresion ^ varExpresion .)
    OR              reduce using rule 23 (varExpresion -> varExpresion ^ varExpresion .)
    EQEQ            reduce using rule 23 (varExpresion -> varExpresion ^ varExpresion .)
    DISTINTO        reduce using rule 23 (varExpresion -> varExpresion ^ varExpresion .)
    >               reduce using rule 23 (varExpresion -> varExpresion ^ varExpresion .)
    <               reduce using rule 23 (varExpresion -> varExpresion ^ varExpresion .)
    ;               reduce using rule 23 (varExpresion -> varExpresion ^ varExpresion .)
    )               reduce using rule 23 (varExpresion -> varExpresion ^ varExpresion .)
    ,               reduce using rule 23 (varExpresion -> varExpresion ^ varExpresion .)
    ]               reduce using rule 23 (varExpresion -> varExpresion ^ varExpresion .)
    :               reduce using rule 23 (varExpresion -> varExpresion ^ varExpresion .)
    }               reduce using rule 23 (varExpresion -> varExpresion ^ varExpresion .)

  ! +               [ shift and go to state 100 ]
  ! -               [ shift and go to state 102 ]
  ! *               [ shift and go to state 101 ]
  ! /               [ shift and go to state 103 ]
  ! %               [ shift and go to state 97 ]
  ! ^               [ shift and go to state 108 ]
  ! ?               [ shift and go to state 107 ]
  ! AND             [ shift and go to state 96 ]
  ! OR              [ shift and go to state 106 ]
  ! EQEQ            [ shift and go to state 105 ]
  ! DISTINTO        [ shift and go to state 98 ]
  ! >               [ shift and go to state 99 ]
  ! <               [ shift and go to state 104 ]


state 142

    (25) varExpresion -> ( + ( . varExpresion ) )
    (18) varExpresion -> . varExpresion + varExpresion
    (19) varExpresion -> . varExpresion - varExpresion
    (20) varExpresion -> . varExpresion * varExpresion
    (21) varExpresion -> . varExpresion / varExpresion
    (22) varExpresion -> . varExpresion % varExpresion
    (23) varExpresion -> . varExpresion ^ varExpresion
    (24) varExpresion -> . ( - ( varExpresion ) )
    (25) varExpresion -> . ( + ( varExpresion ) )
    (26) varExpresion -> . varExpresion ? varExpresion : varExpresion
    (27) varExpresion -> . varExpresion AND varExpresion
    (28) varExpresion -> . NOT varExpresion
    (29) varExpresion -> . varExpresion OR varExpresion
    (30) varExpresion -> . varExpresion EQEQ varExpresion
    (31) varExpresion -> . varExpresion DISTINTO varExpresion
    (32) varExpresion -> . varExpresion > varExpresion
    (33) varExpresion -> . varExpresion < varExpresion
    (34) varExpresion -> . ( varExpresion )
    (35) varExpresion -> . tipos
    (36) varExpresion -> . funcReturn
    (37) varExpresion -> . varOps
    (38) varExpresion -> . vec
    (39) varExpresion -> . reg
    (40) varExpresion -> . vars
    (41) tipos -> . INT
    (42) tipos -> . FLOAT
    (43) tipos -> . STRING
    (44) tipos -> . BOOL
    (61) funcReturn -> . funcInt
    (62) funcReturn -> . funcString
    (63) funcReturn -> . funcBool
    (55) varOps -> . MASMAS ID
    (56) varOps -> . MENOSMENOS ID
    (57) varOps -> . ID MASMAS
    (58) varOps -> . ID MENOSMENOS
    (45) vec -> . [ elem ]
    (46) vec -> . ID m
    (51) reg -> . { campos }
    (52) reg -> . ID . ID
    (82) vars -> . ID
    (83) vars -> . RES
    (64) funcInt -> . MULTIESCALAR ( varExpresion , varExpresion , param )
    (65) funcInt -> . LENGTH ( varExpresion )
    (66) funcString -> . CAPITALIZAR ( varExpresion )
    (67) funcBool -> . COLINEALES ( varExpresion , varExpresion )

    (               shift and go to state 63
    NOT             shift and go to state 73
    INT             shift and go to state 68
    FLOAT           shift and go to state 70
    STRING          shift and go to state 64
    BOOL            shift and go to state 72
    MASMAS          shift and go to state 27
    MENOSMENOS      shift and go to state 29
    ID              shift and go to state 85
    [               shift and go to state 65
    {               shift and go to state 74
    RES             shift and go to state 5
    MULTIESCALAR    shift and go to state 22
    LENGTH          shift and go to state 25
    CAPITALIZAR     shift and go to state 24
    COLINEALES      shift and go to state 14

    funcBool                       shift and go to state 11
    vars                           shift and go to state 83
    funcString                     shift and go to state 21
    varExpresion                   shift and go to state 159
    funcReturn                     shift and go to state 69
    varOps                         shift and go to state 58
    tipos                          shift and go to state 61
    vec                            shift and go to state 62
    funcInt                        shift and go to state 6
    reg                            shift and go to state 71

state 143

    (24) varExpresion -> ( - ( . varExpresion ) )
    (18) varExpresion -> . varExpresion + varExpresion
    (19) varExpresion -> . varExpresion - varExpresion
    (20) varExpresion -> . varExpresion * varExpresion
    (21) varExpresion -> . varExpresion / varExpresion
    (22) varExpresion -> . varExpresion % varExpresion
    (23) varExpresion -> . varExpresion ^ varExpresion
    (24) varExpresion -> . ( - ( varExpresion ) )
    (25) varExpresion -> . ( + ( varExpresion ) )
    (26) varExpresion -> . varExpresion ? varExpresion : varExpresion
    (27) varExpresion -> . varExpresion AND varExpresion
    (28) varExpresion -> . NOT varExpresion
    (29) varExpresion -> . varExpresion OR varExpresion
    (30) varExpresion -> . varExpresion EQEQ varExpresion
    (31) varExpresion -> . varExpresion DISTINTO varExpresion
    (32) varExpresion -> . varExpresion > varExpresion
    (33) varExpresion -> . varExpresion < varExpresion
    (34) varExpresion -> . ( varExpresion )
    (35) varExpresion -> . tipos
    (36) varExpresion -> . funcReturn
    (37) varExpresion -> . varOps
    (38) varExpresion -> . vec
    (39) varExpresion -> . reg
    (40) varExpresion -> . vars
    (41) tipos -> . INT
    (42) tipos -> . FLOAT
    (43) tipos -> . STRING
    (44) tipos -> . BOOL
    (61) funcReturn -> . funcInt
    (62) funcReturn -> . funcString
    (63) funcReturn -> . funcBool
    (55) varOps -> . MASMAS ID
    (56) varOps -> . MENOSMENOS ID
    (57) varOps -> . ID MASMAS
    (58) varOps -> . ID MENOSMENOS
    (45) vec -> . [ elem ]
    (46) vec -> . ID m
    (51) reg -> . { campos }
    (52) reg -> . ID . ID
    (82) vars -> . ID
    (83) vars -> . RES
    (64) funcInt -> . MULTIESCALAR ( varExpresion , varExpresion , param )
    (65) funcInt -> . LENGTH ( varExpresion )
    (66) funcString -> . CAPITALIZAR ( varExpresion )
    (67) funcBool -> . COLINEALES ( varExpresion , varExpresion )

    (               shift and go to state 63
    NOT             shift and go to state 73
    INT             shift and go to state 68
    FLOAT           shift and go to state 70
    STRING          shift and go to state 64
    BOOL            shift and go to state 72
    MASMAS          shift and go to state 27
    MENOSMENOS      shift and go to state 29
    ID              shift and go to state 85
    [               shift and go to state 65
    {               shift and go to state 74
    RES             shift and go to state 5
    MULTIESCALAR    shift and go to state 22
    LENGTH          shift and go to state 25
    CAPITALIZAR     shift and go to state 24
    COLINEALES      shift and go to state 14

    funcBool                       shift and go to state 11
    vars                           shift and go to state 83
    funcString                     shift and go to state 21
    varExpresion                   shift and go to state 160
    funcReturn                     shift and go to state 69
    varOps                         shift and go to state 58
    tipos                          shift and go to state 61
    vec                            shift and go to state 62
    funcInt                        shift and go to state 6
    reg                            shift and go to state 71

state 144

    (34) varExpresion -> ( varExpresion ) .

    +               reduce using rule 34 (varExpresion -> ( varExpresion ) .)
    -               reduce using rule 34 (varExpresion -> ( varExpresion ) .)
    *               reduce using rule 34 (varExpresion -> ( varExpresion ) .)
    /               reduce using rule 34 (varExpresion -> ( varExpresion ) .)
    %               reduce using rule 34 (varExpresion -> ( varExpresion ) .)
    ^               reduce using rule 34 (varExpresion -> ( varExpresion ) .)
    ?               reduce using rule 34 (varExpresion -> ( varExpresion ) .)
    AND             reduce using rule 34 (varExpresion -> ( varExpresion ) .)
    OR              reduce using rule 34 (varExpresion -> ( varExpresion ) .)
    EQEQ            reduce using rule 34 (varExpresion -> ( varExpresion ) .)
    DISTINTO        reduce using rule 34 (varExpresion -> ( varExpresion ) .)
    >               reduce using rule 34 (varExpresion -> ( varExpresion ) .)
    <               reduce using rule 34 (varExpresion -> ( varExpresion ) .)
    ;               reduce using rule 34 (varExpresion -> ( varExpresion ) .)
    )               reduce using rule 34 (varExpresion -> ( varExpresion ) .)
    ,               reduce using rule 34 (varExpresion -> ( varExpresion ) .)
    ]               reduce using rule 34 (varExpresion -> ( varExpresion ) .)
    :               reduce using rule 34 (varExpresion -> ( varExpresion ) .)
    }               reduce using rule 34 (varExpresion -> ( varExpresion ) .)


state 145

    (47) elem -> varExpresion , . elem
    (47) elem -> . varExpresion , elem
    (48) elem -> . varExpresion
    (18) varExpresion -> . varExpresion + varExpresion
    (19) varExpresion -> . varExpresion - varExpresion
    (20) varExpresion -> . varExpresion * varExpresion
    (21) varExpresion -> . varExpresion / varExpresion
    (22) varExpresion -> . varExpresion % varExpresion
    (23) varExpresion -> . varExpresion ^ varExpresion
    (24) varExpresion -> . ( - ( varExpresion ) )
    (25) varExpresion -> . ( + ( varExpresion ) )
    (26) varExpresion -> . varExpresion ? varExpresion : varExpresion
    (27) varExpresion -> . varExpresion AND varExpresion
    (28) varExpresion -> . NOT varExpresion
    (29) varExpresion -> . varExpresion OR varExpresion
    (30) varExpresion -> . varExpresion EQEQ varExpresion
    (31) varExpresion -> . varExpresion DISTINTO varExpresion
    (32) varExpresion -> . varExpresion > varExpresion
    (33) varExpresion -> . varExpresion < varExpresion
    (34) varExpresion -> . ( varExpresion )
    (35) varExpresion -> . tipos
    (36) varExpresion -> . funcReturn
    (37) varExpresion -> . varOps
    (38) varExpresion -> . vec
    (39) varExpresion -> . reg
    (40) varExpresion -> . vars
    (41) tipos -> . INT
    (42) tipos -> . FLOAT
    (43) tipos -> . STRING
    (44) tipos -> . BOOL
    (61) funcReturn -> . funcInt
    (62) funcReturn -> . funcString
    (63) funcReturn -> . funcBool
    (55) varOps -> . MASMAS ID
    (56) varOps -> . MENOSMENOS ID
    (57) varOps -> . ID MASMAS
    (58) varOps -> . ID MENOSMENOS
    (45) vec -> . [ elem ]
    (46) vec -> . ID m
    (51) reg -> . { campos }
    (52) reg -> . ID . ID
    (82) vars -> . ID
    (83) vars -> . RES
    (64) funcInt -> . MULTIESCALAR ( varExpresion , varExpresion , param )
    (65) funcInt -> . LENGTH ( varExpresion )
    (66) funcString -> . CAPITALIZAR ( varExpresion )
    (67) funcBool -> . COLINEALES ( varExpresion , varExpresion )

    (               shift and go to state 63
    NOT             shift and go to state 73
    INT             shift and go to state 68
    FLOAT           shift and go to state 70
    STRING          shift and go to state 64
    BOOL            shift and go to state 72
    MASMAS          shift and go to state 27
    MENOSMENOS      shift and go to state 29
    ID              shift and go to state 85
    [               shift and go to state 65
    {               shift and go to state 74
    RES             shift and go to state 5
    MULTIESCALAR    shift and go to state 22
    LENGTH          shift and go to state 25
    CAPITALIZAR     shift and go to state 24
    COLINEALES      shift and go to state 14

    funcBool                       shift and go to state 11
    vars                           shift and go to state 83
    funcString                     shift and go to state 21
    varExpresion                   shift and go to state 112
    funcReturn                     shift and go to state 69
    varOps                         shift and go to state 58
    elem                           shift and go to state 161
    tipos                          shift and go to state 61
    vec                            shift and go to state 62
    funcInt                        shift and go to state 6
    reg                            shift and go to state 71

state 146

    (45) vec -> [ elem ] .

    )               reduce using rule 45 (vec -> [ elem ] .)
    +               reduce using rule 45 (vec -> [ elem ] .)
    -               reduce using rule 45 (vec -> [ elem ] .)
    *               reduce using rule 45 (vec -> [ elem ] .)
    /               reduce using rule 45 (vec -> [ elem ] .)
    %               reduce using rule 45 (vec -> [ elem ] .)
    ^               reduce using rule 45 (vec -> [ elem ] .)
    ?               reduce using rule 45 (vec -> [ elem ] .)
    AND             reduce using rule 45 (vec -> [ elem ] .)
    OR              reduce using rule 45 (vec -> [ elem ] .)
    EQEQ            reduce using rule 45 (vec -> [ elem ] .)
    DISTINTO        reduce using rule 45 (vec -> [ elem ] .)
    >               reduce using rule 45 (vec -> [ elem ] .)
    <               reduce using rule 45 (vec -> [ elem ] .)
    ,               reduce using rule 45 (vec -> [ elem ] .)
    ;               reduce using rule 45 (vec -> [ elem ] .)
    ]               reduce using rule 45 (vec -> [ elem ] .)
    :               reduce using rule 45 (vec -> [ elem ] .)
    }               reduce using rule 45 (vec -> [ elem ] .)


state 147

    (50) m -> m [ . varExpresion ]
    (18) varExpresion -> . varExpresion + varExpresion
    (19) varExpresion -> . varExpresion - varExpresion
    (20) varExpresion -> . varExpresion * varExpresion
    (21) varExpresion -> . varExpresion / varExpresion
    (22) varExpresion -> . varExpresion % varExpresion
    (23) varExpresion -> . varExpresion ^ varExpresion
    (24) varExpresion -> . ( - ( varExpresion ) )
    (25) varExpresion -> . ( + ( varExpresion ) )
    (26) varExpresion -> . varExpresion ? varExpresion : varExpresion
    (27) varExpresion -> . varExpresion AND varExpresion
    (28) varExpresion -> . NOT varExpresion
    (29) varExpresion -> . varExpresion OR varExpresion
    (30) varExpresion -> . varExpresion EQEQ varExpresion
    (31) varExpresion -> . varExpresion DISTINTO varExpresion
    (32) varExpresion -> . varExpresion > varExpresion
    (33) varExpresion -> . varExpresion < varExpresion
    (34) varExpresion -> . ( varExpresion )
    (35) varExpresion -> . tipos
    (36) varExpresion -> . funcReturn
    (37) varExpresion -> . varOps
    (38) varExpresion -> . vec
    (39) varExpresion -> . reg
    (40) varExpresion -> . vars
    (41) tipos -> . INT
    (42) tipos -> . FLOAT
    (43) tipos -> . STRING
    (44) tipos -> . BOOL
    (61) funcReturn -> . funcInt
    (62) funcReturn -> . funcString
    (63) funcReturn -> . funcBool
    (55) varOps -> . MASMAS ID
    (56) varOps -> . MENOSMENOS ID
    (57) varOps -> . ID MASMAS
    (58) varOps -> . ID MENOSMENOS
    (45) vec -> . [ elem ]
    (46) vec -> . ID m
    (51) reg -> . { campos }
    (52) reg -> . ID . ID
    (82) vars -> . ID
    (83) vars -> . RES
    (64) funcInt -> . MULTIESCALAR ( varExpresion , varExpresion , param )
    (65) funcInt -> . LENGTH ( varExpresion )
    (66) funcString -> . CAPITALIZAR ( varExpresion )
    (67) funcBool -> . COLINEALES ( varExpresion , varExpresion )

    (               shift and go to state 63
    NOT             shift and go to state 73
    INT             shift and go to state 68
    FLOAT           shift and go to state 70
    STRING          shift and go to state 64
    BOOL            shift and go to state 72
    MASMAS          shift and go to state 27
    MENOSMENOS      shift and go to state 29
    ID              shift and go to state 85
    [               shift and go to state 65
    {               shift and go to state 74
    RES             shift and go to state 5
    MULTIESCALAR    shift and go to state 22
    LENGTH          shift and go to state 25
    CAPITALIZAR     shift and go to state 24
    COLINEALES      shift and go to state 14

    funcBool                       shift and go to state 11
    vars                           shift and go to state 83
    funcString                     shift and go to state 21
    varExpresion                   shift and go to state 162
    funcReturn                     shift and go to state 69
    varOps                         shift and go to state 58
    tipos                          shift and go to state 61
    vec                            shift and go to state 62
    funcInt                        shift and go to state 6
    reg                            shift and go to state 71

state 148

    (52) reg -> ID . ID .

    +               reduce using rule 52 (reg -> ID . ID .)
    -               reduce using rule 52 (reg -> ID . ID .)
    *               reduce using rule 52 (reg -> ID . ID .)
    /               reduce using rule 52 (reg -> ID . ID .)
    %               reduce using rule 52 (reg -> ID . ID .)
    ^               reduce using rule 52 (reg -> ID . ID .)
    ?               reduce using rule 52 (reg -> ID . ID .)
    AND             reduce using rule 52 (reg -> ID . ID .)
    OR              reduce using rule 52 (reg -> ID . ID .)
    EQEQ            reduce using rule 52 (reg -> ID . ID .)
    DISTINTO        reduce using rule 52 (reg -> ID . ID .)
    >               reduce using rule 52 (reg -> ID . ID .)
    <               reduce using rule 52 (reg -> ID . ID .)
    ;               reduce using rule 52 (reg -> ID . ID .)
    )               reduce using rule 52 (reg -> ID . ID .)
    ,               reduce using rule 52 (reg -> ID . ID .)
    ]               reduce using rule 52 (reg -> ID . ID .)
    :               reduce using rule 52 (reg -> ID . ID .)
    }               reduce using rule 52 (reg -> ID . ID .)


state 149

    (49) m -> [ varExpresion . ]
    (18) varExpresion -> varExpresion . + varExpresion
    (19) varExpresion -> varExpresion . - varExpresion
    (20) varExpresion -> varExpresion . * varExpresion
    (21) varExpresion -> varExpresion . / varExpresion
    (22) varExpresion -> varExpresion . % varExpresion
    (23) varExpresion -> varExpresion . ^ varExpresion
    (26) varExpresion -> varExpresion . ? varExpresion : varExpresion
    (27) varExpresion -> varExpresion . AND varExpresion
    (29) varExpresion -> varExpresion . OR varExpresion
    (30) varExpresion -> varExpresion . EQEQ varExpresion
    (31) varExpresion -> varExpresion . DISTINTO varExpresion
    (32) varExpresion -> varExpresion . > varExpresion
    (33) varExpresion -> varExpresion . < varExpresion

    ]               shift and go to state 163
    +               shift and go to state 100
    -               shift and go to state 102
    *               shift and go to state 101
    /               shift and go to state 103
    %               shift and go to state 97
    ^               shift and go to state 108
    ?               shift and go to state 107
    AND             shift and go to state 96
    OR              shift and go to state 106
    EQEQ            shift and go to state 105
    DISTINTO        shift and go to state 98
    >               shift and go to state 99
    <               shift and go to state 104


state 150

    (51) reg -> { campos } .

    +               reduce using rule 51 (reg -> { campos } .)
    -               reduce using rule 51 (reg -> { campos } .)
    *               reduce using rule 51 (reg -> { campos } .)
    /               reduce using rule 51 (reg -> { campos } .)
    %               reduce using rule 51 (reg -> { campos } .)
    ^               reduce using rule 51 (reg -> { campos } .)
    ?               reduce using rule 51 (reg -> { campos } .)
    AND             reduce using rule 51 (reg -> { campos } .)
    OR              reduce using rule 51 (reg -> { campos } .)
    EQEQ            reduce using rule 51 (reg -> { campos } .)
    DISTINTO        reduce using rule 51 (reg -> { campos } .)
    >               reduce using rule 51 (reg -> { campos } .)
    <               reduce using rule 51 (reg -> { campos } .)
    ;               reduce using rule 51 (reg -> { campos } .)
    )               reduce using rule 51 (reg -> { campos } .)
    ,               reduce using rule 51 (reg -> { campos } .)
    ]               reduce using rule 51 (reg -> { campos } .)
    :               reduce using rule 51 (reg -> { campos } .)
    }               reduce using rule 51 (reg -> { campos } .)


state 151

    (53) campos -> ID : . varExpresion , campos
    (54) campos -> ID : . varExpresion
    (18) varExpresion -> . varExpresion + varExpresion
    (19) varExpresion -> . varExpresion - varExpresion
    (20) varExpresion -> . varExpresion * varExpresion
    (21) varExpresion -> . varExpresion / varExpresion
    (22) varExpresion -> . varExpresion % varExpresion
    (23) varExpresion -> . varExpresion ^ varExpresion
    (24) varExpresion -> . ( - ( varExpresion ) )
    (25) varExpresion -> . ( + ( varExpresion ) )
    (26) varExpresion -> . varExpresion ? varExpresion : varExpresion
    (27) varExpresion -> . varExpresion AND varExpresion
    (28) varExpresion -> . NOT varExpresion
    (29) varExpresion -> . varExpresion OR varExpresion
    (30) varExpresion -> . varExpresion EQEQ varExpresion
    (31) varExpresion -> . varExpresion DISTINTO varExpresion
    (32) varExpresion -> . varExpresion > varExpresion
    (33) varExpresion -> . varExpresion < varExpresion
    (34) varExpresion -> . ( varExpresion )
    (35) varExpresion -> . tipos
    (36) varExpresion -> . funcReturn
    (37) varExpresion -> . varOps
    (38) varExpresion -> . vec
    (39) varExpresion -> . reg
    (40) varExpresion -> . vars
    (41) tipos -> . INT
    (42) tipos -> . FLOAT
    (43) tipos -> . STRING
    (44) tipos -> . BOOL
    (61) funcReturn -> . funcInt
    (62) funcReturn -> . funcString
    (63) funcReturn -> . funcBool
    (55) varOps -> . MASMAS ID
    (56) varOps -> . MENOSMENOS ID
    (57) varOps -> . ID MASMAS
    (58) varOps -> . ID MENOSMENOS
    (45) vec -> . [ elem ]
    (46) vec -> . ID m
    (51) reg -> . { campos }
    (52) reg -> . ID . ID
    (82) vars -> . ID
    (83) vars -> . RES
    (64) funcInt -> . MULTIESCALAR ( varExpresion , varExpresion , param )
    (65) funcInt -> . LENGTH ( varExpresion )
    (66) funcString -> . CAPITALIZAR ( varExpresion )
    (67) funcBool -> . COLINEALES ( varExpresion , varExpresion )

    (               shift and go to state 63
    NOT             shift and go to state 73
    INT             shift and go to state 68
    FLOAT           shift and go to state 70
    STRING          shift and go to state 64
    BOOL            shift and go to state 72
    MASMAS          shift and go to state 27
    MENOSMENOS      shift and go to state 29
    ID              shift and go to state 85
    [               shift and go to state 65
    {               shift and go to state 74
    RES             shift and go to state 5
    MULTIESCALAR    shift and go to state 22
    LENGTH          shift and go to state 25
    CAPITALIZAR     shift and go to state 24
    COLINEALES      shift and go to state 14

    funcBool                       shift and go to state 11
    vars                           shift and go to state 83
    funcString                     shift and go to state 21
    varExpresion                   shift and go to state 164
    funcReturn                     shift and go to state 69
    varOps                         shift and go to state 58
    tipos                          shift and go to state 61
    vec                            shift and go to state 62
    funcInt                        shift and go to state 6
    reg                            shift and go to state 71

state 152

    (10) loop -> WHILE ( varExpresion ) bloque .

    RETURN          reduce using rule 10 (loop -> WHILE ( varExpresion ) bloque .)
    MASMAS          reduce using rule 10 (loop -> WHILE ( varExpresion ) bloque .)
    MENOSMENOS      reduce using rule 10 (loop -> WHILE ( varExpresion ) bloque .)
    ID              reduce using rule 10 (loop -> WHILE ( varExpresion ) bloque .)
    IF              reduce using rule 10 (loop -> WHILE ( varExpresion ) bloque .)
    WHILE           reduce using rule 10 (loop -> WHILE ( varExpresion ) bloque .)
    DO              reduce using rule 10 (loop -> WHILE ( varExpresion ) bloque .)
    FOR             reduce using rule 10 (loop -> WHILE ( varExpresion ) bloque .)
    PRINT           reduce using rule 10 (loop -> WHILE ( varExpresion ) bloque .)
    RES             reduce using rule 10 (loop -> WHILE ( varExpresion ) bloque .)
    MULTIESCALAR    reduce using rule 10 (loop -> WHILE ( varExpresion ) bloque .)
    LENGTH          reduce using rule 10 (loop -> WHILE ( varExpresion ) bloque .)
    CAPITALIZAR     reduce using rule 10 (loop -> WHILE ( varExpresion ) bloque .)
    COLINEALES      reduce using rule 10 (loop -> WHILE ( varExpresion ) bloque .)
    }               reduce using rule 10 (loop -> WHILE ( varExpresion ) bloque .)
    $end            reduce using rule 10 (loop -> WHILE ( varExpresion ) bloque .)


state 153

    (67) funcBool -> COLINEALES ( varExpresion , varExpresion . )
    (18) varExpresion -> varExpresion . + varExpresion
    (19) varExpresion -> varExpresion . - varExpresion
    (20) varExpresion -> varExpresion . * varExpresion
    (21) varExpresion -> varExpresion . / varExpresion
    (22) varExpresion -> varExpresion . % varExpresion
    (23) varExpresion -> varExpresion . ^ varExpresion
    (26) varExpresion -> varExpresion . ? varExpresion : varExpresion
    (27) varExpresion -> varExpresion . AND varExpresion
    (29) varExpresion -> varExpresion . OR varExpresion
    (30) varExpresion -> varExpresion . EQEQ varExpresion
    (31) varExpresion -> varExpresion . DISTINTO varExpresion
    (32) varExpresion -> varExpresion . > varExpresion
    (33) varExpresion -> varExpresion . < varExpresion

    )               shift and go to state 165
    +               shift and go to state 100
    -               shift and go to state 102
    *               shift and go to state 101
    /               shift and go to state 103
    %               shift and go to state 97
    ^               shift and go to state 108
    ?               shift and go to state 107
    AND             shift and go to state 96
    OR              shift and go to state 106
    EQEQ            shift and go to state 105
    DISTINTO        shift and go to state 98
    >               shift and go to state 99
    <               shift and go to state 104


state 154

    (12) loop -> FOR ( varAsig ; varExpresion . ; varOps ) bloque
    (18) varExpresion -> varExpresion . + varExpresion
    (19) varExpresion -> varExpresion . - varExpresion
    (20) varExpresion -> varExpresion . * varExpresion
    (21) varExpresion -> varExpresion . / varExpresion
    (22) varExpresion -> varExpresion . % varExpresion
    (23) varExpresion -> varExpresion . ^ varExpresion
    (26) varExpresion -> varExpresion . ? varExpresion : varExpresion
    (27) varExpresion -> varExpresion . AND varExpresion
    (29) varExpresion -> varExpresion . OR varExpresion
    (30) varExpresion -> varExpresion . EQEQ varExpresion
    (31) varExpresion -> varExpresion . DISTINTO varExpresion
    (32) varExpresion -> varExpresion . > varExpresion
    (33) varExpresion -> varExpresion . < varExpresion

    ;               shift and go to state 166
    +               shift and go to state 100
    -               shift and go to state 102
    *               shift and go to state 101
    /               shift and go to state 103
    %               shift and go to state 97
    ^               shift and go to state 108
    ?               shift and go to state 107
    AND             shift and go to state 96
    OR              shift and go to state 106
    EQEQ            shift and go to state 105
    DISTINTO        shift and go to state 98
    >               shift and go to state 99
    <               shift and go to state 104


state 155

    (13) if -> IF ( varExpresion ) THEN . bloque else
    (16) bloque -> . sentencia
    (17) bloque -> . { g }
    (4) sentencia -> . varOps ;
    (5) sentencia -> . func ;
    (6) sentencia -> . varAsig ;
    (7) sentencia -> . RETURN ;
    (55) varOps -> . MASMAS ID
    (56) varOps -> . MENOSMENOS ID
    (57) varOps -> . ID MASMAS
    (58) varOps -> . ID MENOSMENOS
    (59) func -> . funcReturn
    (60) func -> . funcVoid
    (72) varAsig -> . vars MENOSEQ varAsig
    (73) varAsig -> . vars MASEQ varAsig
    (74) varAsig -> . vars MULEQ varAsig
    (75) varAsig -> . vars DIVEQ varAsig
    (76) varAsig -> . vars = varAsig
    (77) varAsig -> . vars MASEQ varExpresion
    (78) varAsig -> . vars MENOSEQ varExpresion
    (79) varAsig -> . vars MULEQ varExpresion
    (80) varAsig -> . vars DIVEQ varExpresion
    (81) varAsig -> . vars = varExpresion
    (61) funcReturn -> . funcInt
    (62) funcReturn -> . funcString
    (63) funcReturn -> . funcBool
    (68) funcVoid -> . PRINT ( varExpresion )
    (82) vars -> . ID
    (83) vars -> . RES
    (64) funcInt -> . MULTIESCALAR ( varExpresion , varExpresion , param )
    (65) funcInt -> . LENGTH ( varExpresion )
    (66) funcString -> . CAPITALIZAR ( varExpresion )
    (67) funcBool -> . COLINEALES ( varExpresion , varExpresion )

    {               shift and go to state 32
    RETURN          shift and go to state 2
    MASMAS          shift and go to state 27
    MENOSMENOS      shift and go to state 29
    ID              shift and go to state 17
    PRINT           shift and go to state 8
    RES             shift and go to state 5
    MULTIESCALAR    shift and go to state 22
    LENGTH          shift and go to state 25
    CAPITALIZAR     shift and go to state 24
    COLINEALES      shift and go to state 14

    varAsig                        shift and go to state 19
    sentencia                      shift and go to state 31
    vars                           shift and go to state 3
    funcString                     shift and go to state 21
    funcReturn                     shift and go to state 23
    varOps                         shift and go to state 12
    funcBool                       shift and go to state 11
    funcVoid                       shift and go to state 13
    func                           shift and go to state 16
    bloque                         shift and go to state 167
    funcInt                        shift and go to state 6

state 156

    (64) funcInt -> MULTIESCALAR ( varExpresion , varExpresion . , param )
    (18) varExpresion -> varExpresion . + varExpresion
    (19) varExpresion -> varExpresion . - varExpresion
    (20) varExpresion -> varExpresion . * varExpresion
    (21) varExpresion -> varExpresion . / varExpresion
    (22) varExpresion -> varExpresion . % varExpresion
    (23) varExpresion -> varExpresion . ^ varExpresion
    (26) varExpresion -> varExpresion . ? varExpresion : varExpresion
    (27) varExpresion -> varExpresion . AND varExpresion
    (29) varExpresion -> varExpresion . OR varExpresion
    (30) varExpresion -> varExpresion . EQEQ varExpresion
    (31) varExpresion -> varExpresion . DISTINTO varExpresion
    (32) varExpresion -> varExpresion . > varExpresion
    (33) varExpresion -> varExpresion . < varExpresion

    ,               shift and go to state 168
    +               shift and go to state 100
    -               shift and go to state 102
    *               shift and go to state 101
    /               shift and go to state 103
    %               shift and go to state 97
    ^               shift and go to state 108
    ?               shift and go to state 107
    AND             shift and go to state 96
    OR              shift and go to state 106
    EQEQ            shift and go to state 105
    DISTINTO        shift and go to state 98
    >               shift and go to state 99
    <               shift and go to state 104


state 157

    (11) loop -> DO bloque WHILE ( varExpresion ) . ;

    ;               shift and go to state 169


state 158

    (26) varExpresion -> varExpresion ? varExpresion : . varExpresion
    (18) varExpresion -> . varExpresion + varExpresion
    (19) varExpresion -> . varExpresion - varExpresion
    (20) varExpresion -> . varExpresion * varExpresion
    (21) varExpresion -> . varExpresion / varExpresion
    (22) varExpresion -> . varExpresion % varExpresion
    (23) varExpresion -> . varExpresion ^ varExpresion
    (24) varExpresion -> . ( - ( varExpresion ) )
    (25) varExpresion -> . ( + ( varExpresion ) )
    (26) varExpresion -> . varExpresion ? varExpresion : varExpresion
    (27) varExpresion -> . varExpresion AND varExpresion
    (28) varExpresion -> . NOT varExpresion
    (29) varExpresion -> . varExpresion OR varExpresion
    (30) varExpresion -> . varExpresion EQEQ varExpresion
    (31) varExpresion -> . varExpresion DISTINTO varExpresion
    (32) varExpresion -> . varExpresion > varExpresion
    (33) varExpresion -> . varExpresion < varExpresion
    (34) varExpresion -> . ( varExpresion )
    (35) varExpresion -> . tipos
    (36) varExpresion -> . funcReturn
    (37) varExpresion -> . varOps
    (38) varExpresion -> . vec
    (39) varExpresion -> . reg
    (40) varExpresion -> . vars
    (41) tipos -> . INT
    (42) tipos -> . FLOAT
    (43) tipos -> . STRING
    (44) tipos -> . BOOL
    (61) funcReturn -> . funcInt
    (62) funcReturn -> . funcString
    (63) funcReturn -> . funcBool
    (55) varOps -> . MASMAS ID
    (56) varOps -> . MENOSMENOS ID
    (57) varOps -> . ID MASMAS
    (58) varOps -> . ID MENOSMENOS
    (45) vec -> . [ elem ]
    (46) vec -> . ID m
    (51) reg -> . { campos }
    (52) reg -> . ID . ID
    (82) vars -> . ID
    (83) vars -> . RES
    (64) funcInt -> . MULTIESCALAR ( varExpresion , varExpresion , param )
    (65) funcInt -> . LENGTH ( varExpresion )
    (66) funcString -> . CAPITALIZAR ( varExpresion )
    (67) funcBool -> . COLINEALES ( varExpresion , varExpresion )

    (               shift and go to state 63
    NOT             shift and go to state 73
    INT             shift and go to state 68
    FLOAT           shift and go to state 70
    STRING          shift and go to state 64
    BOOL            shift and go to state 72
    MASMAS          shift and go to state 27
    MENOSMENOS      shift and go to state 29
    ID              shift and go to state 85
    [               shift and go to state 65
    {               shift and go to state 74
    RES             shift and go to state 5
    MULTIESCALAR    shift and go to state 22
    LENGTH          shift and go to state 25
    CAPITALIZAR     shift and go to state 24
    COLINEALES      shift and go to state 14

    funcBool                       shift and go to state 11
    vars                           shift and go to state 83
    funcString                     shift and go to state 21
    varExpresion                   shift and go to state 170
    funcReturn                     shift and go to state 69
    varOps                         shift and go to state 58
    tipos                          shift and go to state 61
    vec                            shift and go to state 62
    funcInt                        shift and go to state 6
    reg                            shift and go to state 71

state 159

    (25) varExpresion -> ( + ( varExpresion . ) )
    (18) varExpresion -> varExpresion . + varExpresion
    (19) varExpresion -> varExpresion . - varExpresion
    (20) varExpresion -> varExpresion . * varExpresion
    (21) varExpresion -> varExpresion . / varExpresion
    (22) varExpresion -> varExpresion . % varExpresion
    (23) varExpresion -> varExpresion . ^ varExpresion
    (26) varExpresion -> varExpresion . ? varExpresion : varExpresion
    (27) varExpresion -> varExpresion . AND varExpresion
    (29) varExpresion -> varExpresion . OR varExpresion
    (30) varExpresion -> varExpresion . EQEQ varExpresion
    (31) varExpresion -> varExpresion . DISTINTO varExpresion
    (32) varExpresion -> varExpresion . > varExpresion
    (33) varExpresion -> varExpresion . < varExpresion

    )               shift and go to state 171
    +               shift and go to state 100
    -               shift and go to state 102
    *               shift and go to state 101
    /               shift and go to state 103
    %               shift and go to state 97
    ^               shift and go to state 108
    ?               shift and go to state 107
    AND             shift and go to state 96
    OR              shift and go to state 106
    EQEQ            shift and go to state 105
    DISTINTO        shift and go to state 98
    >               shift and go to state 99
    <               shift and go to state 104


state 160

    (24) varExpresion -> ( - ( varExpresion . ) )
    (18) varExpresion -> varExpresion . + varExpresion
    (19) varExpresion -> varExpresion . - varExpresion
    (20) varExpresion -> varExpresion . * varExpresion
    (21) varExpresion -> varExpresion . / varExpresion
    (22) varExpresion -> varExpresion . % varExpresion
    (23) varExpresion -> varExpresion . ^ varExpresion
    (26) varExpresion -> varExpresion . ? varExpresion : varExpresion
    (27) varExpresion -> varExpresion . AND varExpresion
    (29) varExpresion -> varExpresion . OR varExpresion
    (30) varExpresion -> varExpresion . EQEQ varExpresion
    (31) varExpresion -> varExpresion . DISTINTO varExpresion
    (32) varExpresion -> varExpresion . > varExpresion
    (33) varExpresion -> varExpresion . < varExpresion

    )               shift and go to state 172
    +               shift and go to state 100
    -               shift and go to state 102
    *               shift and go to state 101
    /               shift and go to state 103
    %               shift and go to state 97
    ^               shift and go to state 108
    ?               shift and go to state 107
    AND             shift and go to state 96
    OR              shift and go to state 106
    EQEQ            shift and go to state 105
    DISTINTO        shift and go to state 98
    >               shift and go to state 99
    <               shift and go to state 104


state 161

    (47) elem -> varExpresion , elem .

    ]               reduce using rule 47 (elem -> varExpresion , elem .)


state 162

    (50) m -> m [ varExpresion . ]
    (18) varExpresion -> varExpresion . + varExpresion
    (19) varExpresion -> varExpresion . - varExpresion
    (20) varExpresion -> varExpresion . * varExpresion
    (21) varExpresion -> varExpresion . / varExpresion
    (22) varExpresion -> varExpresion . % varExpresion
    (23) varExpresion -> varExpresion . ^ varExpresion
    (26) varExpresion -> varExpresion . ? varExpresion : varExpresion
    (27) varExpresion -> varExpresion . AND varExpresion
    (29) varExpresion -> varExpresion . OR varExpresion
    (30) varExpresion -> varExpresion . EQEQ varExpresion
    (31) varExpresion -> varExpresion . DISTINTO varExpresion
    (32) varExpresion -> varExpresion . > varExpresion
    (33) varExpresion -> varExpresion . < varExpresion

    ]               shift and go to state 173
    +               shift and go to state 100
    -               shift and go to state 102
    *               shift and go to state 101
    /               shift and go to state 103
    %               shift and go to state 97
    ^               shift and go to state 108
    ?               shift and go to state 107
    AND             shift and go to state 96
    OR              shift and go to state 106
    EQEQ            shift and go to state 105
    DISTINTO        shift and go to state 98
    >               shift and go to state 99
    <               shift and go to state 104


state 163

    (49) m -> [ varExpresion ] .

    [               reduce using rule 49 (m -> [ varExpresion ] .)
    +               reduce using rule 49 (m -> [ varExpresion ] .)
    -               reduce using rule 49 (m -> [ varExpresion ] .)
    *               reduce using rule 49 (m -> [ varExpresion ] .)
    /               reduce using rule 49 (m -> [ varExpresion ] .)
    %               reduce using rule 49 (m -> [ varExpresion ] .)
    ^               reduce using rule 49 (m -> [ varExpresion ] .)
    ?               reduce using rule 49 (m -> [ varExpresion ] .)
    AND             reduce using rule 49 (m -> [ varExpresion ] .)
    OR              reduce using rule 49 (m -> [ varExpresion ] .)
    EQEQ            reduce using rule 49 (m -> [ varExpresion ] .)
    DISTINTO        reduce using rule 49 (m -> [ varExpresion ] .)
    >               reduce using rule 49 (m -> [ varExpresion ] .)
    <               reduce using rule 49 (m -> [ varExpresion ] .)
    ;               reduce using rule 49 (m -> [ varExpresion ] .)
    )               reduce using rule 49 (m -> [ varExpresion ] .)
    ,               reduce using rule 49 (m -> [ varExpresion ] .)
    ]               reduce using rule 49 (m -> [ varExpresion ] .)
    :               reduce using rule 49 (m -> [ varExpresion ] .)
    }               reduce using rule 49 (m -> [ varExpresion ] .)


state 164

    (53) campos -> ID : varExpresion . , campos
    (54) campos -> ID : varExpresion .
    (18) varExpresion -> varExpresion . + varExpresion
    (19) varExpresion -> varExpresion . - varExpresion
    (20) varExpresion -> varExpresion . * varExpresion
    (21) varExpresion -> varExpresion . / varExpresion
    (22) varExpresion -> varExpresion . % varExpresion
    (23) varExpresion -> varExpresion . ^ varExpresion
    (26) varExpresion -> varExpresion . ? varExpresion : varExpresion
    (27) varExpresion -> varExpresion . AND varExpresion
    (29) varExpresion -> varExpresion . OR varExpresion
    (30) varExpresion -> varExpresion . EQEQ varExpresion
    (31) varExpresion -> varExpresion . DISTINTO varExpresion
    (32) varExpresion -> varExpresion . > varExpresion
    (33) varExpresion -> varExpresion . < varExpresion

    ,               shift and go to state 174
    }               reduce using rule 54 (campos -> ID : varExpresion .)
    +               shift and go to state 100
    -               shift and go to state 102
    *               shift and go to state 101
    /               shift and go to state 103
    %               shift and go to state 97
    ^               shift and go to state 108
    ?               shift and go to state 107
    AND             shift and go to state 96
    OR              shift and go to state 106
    EQEQ            shift and go to state 105
    DISTINTO        shift and go to state 98
    >               shift and go to state 99
    <               shift and go to state 104


state 165

    (67) funcBool -> COLINEALES ( varExpresion , varExpresion ) .

    :               reduce using rule 67 (funcBool -> COLINEALES ( varExpresion , varExpresion ) .)
    +               reduce using rule 67 (funcBool -> COLINEALES ( varExpresion , varExpresion ) .)
    -               reduce using rule 67 (funcBool -> COLINEALES ( varExpresion , varExpresion ) .)
    *               reduce using rule 67 (funcBool -> COLINEALES ( varExpresion , varExpresion ) .)
    /               reduce using rule 67 (funcBool -> COLINEALES ( varExpresion , varExpresion ) .)
    %               reduce using rule 67 (funcBool -> COLINEALES ( varExpresion , varExpresion ) .)
    ^               reduce using rule 67 (funcBool -> COLINEALES ( varExpresion , varExpresion ) .)
    ?               reduce using rule 67 (funcBool -> COLINEALES ( varExpresion , varExpresion ) .)
    AND             reduce using rule 67 (funcBool -> COLINEALES ( varExpresion , varExpresion ) .)
    OR              reduce using rule 67 (funcBool -> COLINEALES ( varExpresion , varExpresion ) .)
    EQEQ            reduce using rule 67 (funcBool -> COLINEALES ( varExpresion , varExpresion ) .)
    DISTINTO        reduce using rule 67 (funcBool -> COLINEALES ( varExpresion , varExpresion ) .)
    >               reduce using rule 67 (funcBool -> COLINEALES ( varExpresion , varExpresion ) .)
    <               reduce using rule 67 (funcBool -> COLINEALES ( varExpresion , varExpresion ) .)
    )               reduce using rule 67 (funcBool -> COLINEALES ( varExpresion , varExpresion ) .)
    ;               reduce using rule 67 (funcBool -> COLINEALES ( varExpresion , varExpresion ) .)
    ,               reduce using rule 67 (funcBool -> COLINEALES ( varExpresion , varExpresion ) .)
    ]               reduce using rule 67 (funcBool -> COLINEALES ( varExpresion , varExpresion ) .)
    }               reduce using rule 67 (funcBool -> COLINEALES ( varExpresion , varExpresion ) .)


state 166

    (12) loop -> FOR ( varAsig ; varExpresion ; . varOps ) bloque
    (55) varOps -> . MASMAS ID
    (56) varOps -> . MENOSMENOS ID
    (57) varOps -> . ID MASMAS
    (58) varOps -> . ID MENOSMENOS

    MASMAS          shift and go to state 27
    MENOSMENOS      shift and go to state 29
    ID              shift and go to state 176

    varOps                         shift and go to state 175

state 167

    (13) if -> IF ( varExpresion ) THEN bloque . else
    (14) else -> . ELSE bloque
    (15) else -> . empty
    (71) empty -> .

    ELSE            shift and go to state 178
    RETURN          reduce using rule 71 (empty -> .)
    MASMAS          reduce using rule 71 (empty -> .)
    MENOSMENOS      reduce using rule 71 (empty -> .)
    ID              reduce using rule 71 (empty -> .)
    IF              reduce using rule 71 (empty -> .)
    WHILE           reduce using rule 71 (empty -> .)
    DO              reduce using rule 71 (empty -> .)
    FOR             reduce using rule 71 (empty -> .)
    PRINT           reduce using rule 71 (empty -> .)
    RES             reduce using rule 71 (empty -> .)
    MULTIESCALAR    reduce using rule 71 (empty -> .)
    LENGTH          reduce using rule 71 (empty -> .)
    CAPITALIZAR     reduce using rule 71 (empty -> .)
    COLINEALES      reduce using rule 71 (empty -> .)
    $end            reduce using rule 71 (empty -> .)
    }               reduce using rule 71 (empty -> .)

    empty                          shift and go to state 179
    else                           shift and go to state 177

state 168

    (64) funcInt -> MULTIESCALAR ( varExpresion , varExpresion , . param )
    (69) param -> . varExpresion
    (70) param -> . empty
    (18) varExpresion -> . varExpresion + varExpresion
    (19) varExpresion -> . varExpresion - varExpresion
    (20) varExpresion -> . varExpresion * varExpresion
    (21) varExpresion -> . varExpresion / varExpresion
    (22) varExpresion -> . varExpresion % varExpresion
    (23) varExpresion -> . varExpresion ^ varExpresion
    (24) varExpresion -> . ( - ( varExpresion ) )
    (25) varExpresion -> . ( + ( varExpresion ) )
    (26) varExpresion -> . varExpresion ? varExpresion : varExpresion
    (27) varExpresion -> . varExpresion AND varExpresion
    (28) varExpresion -> . NOT varExpresion
    (29) varExpresion -> . varExpresion OR varExpresion
    (30) varExpresion -> . varExpresion EQEQ varExpresion
    (31) varExpresion -> . varExpresion DISTINTO varExpresion
    (32) varExpresion -> . varExpresion > varExpresion
    (33) varExpresion -> . varExpresion < varExpresion
    (34) varExpresion -> . ( varExpresion )
    (35) varExpresion -> . tipos
    (36) varExpresion -> . funcReturn
    (37) varExpresion -> . varOps
    (38) varExpresion -> . vec
    (39) varExpresion -> . reg
    (40) varExpresion -> . vars
    (71) empty -> .
    (41) tipos -> . INT
    (42) tipos -> . FLOAT
    (43) tipos -> . STRING
    (44) tipos -> . BOOL
    (61) funcReturn -> . funcInt
    (62) funcReturn -> . funcString
    (63) funcReturn -> . funcBool
    (55) varOps -> . MASMAS ID
    (56) varOps -> . MENOSMENOS ID
    (57) varOps -> . ID MASMAS
    (58) varOps -> . ID MENOSMENOS
    (45) vec -> . [ elem ]
    (46) vec -> . ID m
    (51) reg -> . { campos }
    (52) reg -> . ID . ID
    (82) vars -> . ID
    (83) vars -> . RES
    (64) funcInt -> . MULTIESCALAR ( varExpresion , varExpresion , param )
    (65) funcInt -> . LENGTH ( varExpresion )
    (66) funcString -> . CAPITALIZAR ( varExpresion )
    (67) funcBool -> . COLINEALES ( varExpresion , varExpresion )

    (               shift and go to state 63
    NOT             shift and go to state 73
    )               reduce using rule 71 (empty -> .)
    INT             shift and go to state 68
    FLOAT           shift and go to state 70
    STRING          shift and go to state 64
    BOOL            shift and go to state 72
    MASMAS          shift and go to state 27
    MENOSMENOS      shift and go to state 29
    ID              shift and go to state 85
    [               shift and go to state 65
    {               shift and go to state 74
    RES             shift and go to state 5
    MULTIESCALAR    shift and go to state 22
    LENGTH          shift and go to state 25
    CAPITALIZAR     shift and go to state 24
    COLINEALES      shift and go to state 14

    funcBool                       shift and go to state 11
    vars                           shift and go to state 83
    funcString                     shift and go to state 21
    varExpresion                   shift and go to state 181
    funcReturn                     shift and go to state 69
    varOps                         shift and go to state 58
    param                          shift and go to state 180
    tipos                          shift and go to state 61
    vec                            shift and go to state 62
    funcInt                        shift and go to state 6
    reg                            shift and go to state 71
    empty                          shift and go to state 182

state 169

    (11) loop -> DO bloque WHILE ( varExpresion ) ; .

    RETURN          reduce using rule 11 (loop -> DO bloque WHILE ( varExpresion ) ; .)
    MASMAS          reduce using rule 11 (loop -> DO bloque WHILE ( varExpresion ) ; .)
    MENOSMENOS      reduce using rule 11 (loop -> DO bloque WHILE ( varExpresion ) ; .)
    ID              reduce using rule 11 (loop -> DO bloque WHILE ( varExpresion ) ; .)
    IF              reduce using rule 11 (loop -> DO bloque WHILE ( varExpresion ) ; .)
    WHILE           reduce using rule 11 (loop -> DO bloque WHILE ( varExpresion ) ; .)
    DO              reduce using rule 11 (loop -> DO bloque WHILE ( varExpresion ) ; .)
    FOR             reduce using rule 11 (loop -> DO bloque WHILE ( varExpresion ) ; .)
    PRINT           reduce using rule 11 (loop -> DO bloque WHILE ( varExpresion ) ; .)
    RES             reduce using rule 11 (loop -> DO bloque WHILE ( varExpresion ) ; .)
    MULTIESCALAR    reduce using rule 11 (loop -> DO bloque WHILE ( varExpresion ) ; .)
    LENGTH          reduce using rule 11 (loop -> DO bloque WHILE ( varExpresion ) ; .)
    CAPITALIZAR     reduce using rule 11 (loop -> DO bloque WHILE ( varExpresion ) ; .)
    COLINEALES      reduce using rule 11 (loop -> DO bloque WHILE ( varExpresion ) ; .)
    }               reduce using rule 11 (loop -> DO bloque WHILE ( varExpresion ) ; .)
    $end            reduce using rule 11 (loop -> DO bloque WHILE ( varExpresion ) ; .)


state 170

    (26) varExpresion -> varExpresion ? varExpresion : varExpresion .
    (18) varExpresion -> varExpresion . + varExpresion
    (19) varExpresion -> varExpresion . - varExpresion
    (20) varExpresion -> varExpresion . * varExpresion
    (21) varExpresion -> varExpresion . / varExpresion
    (22) varExpresion -> varExpresion . % varExpresion
    (23) varExpresion -> varExpresion . ^ varExpresion
    (26) varExpresion -> varExpresion . ? varExpresion : varExpresion
    (27) varExpresion -> varExpresion . AND varExpresion
    (29) varExpresion -> varExpresion . OR varExpresion
    (30) varExpresion -> varExpresion . EQEQ varExpresion
    (31) varExpresion -> varExpresion . DISTINTO varExpresion
    (32) varExpresion -> varExpresion . > varExpresion
    (33) varExpresion -> varExpresion . < varExpresion

  ! shift/reduce conflict for + resolved as shift
  ! shift/reduce conflict for - resolved as shift
  ! shift/reduce conflict for * resolved as shift
  ! shift/reduce conflict for / resolved as shift
  ! shift/reduce conflict for % resolved as shift
  ! shift/reduce conflict for ^ resolved as shift
  ! shift/reduce conflict for ? resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for EQEQ resolved as shift
  ! shift/reduce conflict for DISTINTO resolved as shift
  ! shift/reduce conflict for > resolved as shift
  ! shift/reduce conflict for < resolved as shift
    ;               reduce using rule 26 (varExpresion -> varExpresion ? varExpresion : varExpresion .)
    )               reduce using rule 26 (varExpresion -> varExpresion ? varExpresion : varExpresion .)
    ,               reduce using rule 26 (varExpresion -> varExpresion ? varExpresion : varExpresion .)
    ]               reduce using rule 26 (varExpresion -> varExpresion ? varExpresion : varExpresion .)
    :               reduce using rule 26 (varExpresion -> varExpresion ? varExpresion : varExpresion .)
    }               reduce using rule 26 (varExpresion -> varExpresion ? varExpresion : varExpresion .)
    +               shift and go to state 100
    -               shift and go to state 102
    *               shift and go to state 101
    /               shift and go to state 103
    %               shift and go to state 97
    ^               shift and go to state 108
    ?               shift and go to state 107
    AND             shift and go to state 96
    OR              shift and go to state 106
    EQEQ            shift and go to state 105
    DISTINTO        shift and go to state 98
    >               shift and go to state 99
    <               shift and go to state 104

  ! +               [ reduce using rule 26 (varExpresion -> varExpresion ? varExpresion : varExpresion .) ]
  ! -               [ reduce using rule 26 (varExpresion -> varExpresion ? varExpresion : varExpresion .) ]
  ! *               [ reduce using rule 26 (varExpresion -> varExpresion ? varExpresion : varExpresion .) ]
  ! /               [ reduce using rule 26 (varExpresion -> varExpresion ? varExpresion : varExpresion .) ]
  ! %               [ reduce using rule 26 (varExpresion -> varExpresion ? varExpresion : varExpresion .) ]
  ! ^               [ reduce using rule 26 (varExpresion -> varExpresion ? varExpresion : varExpresion .) ]
  ! ?               [ reduce using rule 26 (varExpresion -> varExpresion ? varExpresion : varExpresion .) ]
  ! AND             [ reduce using rule 26 (varExpresion -> varExpresion ? varExpresion : varExpresion .) ]
  ! OR              [ reduce using rule 26 (varExpresion -> varExpresion ? varExpresion : varExpresion .) ]
  ! EQEQ            [ reduce using rule 26 (varExpresion -> varExpresion ? varExpresion : varExpresion .) ]
  ! DISTINTO        [ reduce using rule 26 (varExpresion -> varExpresion ? varExpresion : varExpresion .) ]
  ! >               [ reduce using rule 26 (varExpresion -> varExpresion ? varExpresion : varExpresion .) ]
  ! <               [ reduce using rule 26 (varExpresion -> varExpresion ? varExpresion : varExpresion .) ]


state 171

    (25) varExpresion -> ( + ( varExpresion ) . )

    )               shift and go to state 183


state 172

    (24) varExpresion -> ( - ( varExpresion ) . )

    )               shift and go to state 184


state 173

    (50) m -> m [ varExpresion ] .

    [               reduce using rule 50 (m -> m [ varExpresion ] .)
    +               reduce using rule 50 (m -> m [ varExpresion ] .)
    -               reduce using rule 50 (m -> m [ varExpresion ] .)
    *               reduce using rule 50 (m -> m [ varExpresion ] .)
    /               reduce using rule 50 (m -> m [ varExpresion ] .)
    %               reduce using rule 50 (m -> m [ varExpresion ] .)
    ^               reduce using rule 50 (m -> m [ varExpresion ] .)
    ?               reduce using rule 50 (m -> m [ varExpresion ] .)
    AND             reduce using rule 50 (m -> m [ varExpresion ] .)
    OR              reduce using rule 50 (m -> m [ varExpresion ] .)
    EQEQ            reduce using rule 50 (m -> m [ varExpresion ] .)
    DISTINTO        reduce using rule 50 (m -> m [ varExpresion ] .)
    >               reduce using rule 50 (m -> m [ varExpresion ] .)
    <               reduce using rule 50 (m -> m [ varExpresion ] .)
    ;               reduce using rule 50 (m -> m [ varExpresion ] .)
    )               reduce using rule 50 (m -> m [ varExpresion ] .)
    ,               reduce using rule 50 (m -> m [ varExpresion ] .)
    ]               reduce using rule 50 (m -> m [ varExpresion ] .)
    :               reduce using rule 50 (m -> m [ varExpresion ] .)
    }               reduce using rule 50 (m -> m [ varExpresion ] .)


state 174

    (53) campos -> ID : varExpresion , . campos
    (53) campos -> . ID : varExpresion , campos
    (54) campos -> . ID : varExpresion

    ID              shift and go to state 119

    campos                         shift and go to state 185

state 175

    (12) loop -> FOR ( varAsig ; varExpresion ; varOps . ) bloque

    )               shift and go to state 186


state 176

    (57) varOps -> ID . MASMAS
    (58) varOps -> ID . MENOSMENOS

    MASMAS          shift and go to state 47
    MENOSMENOS      shift and go to state 48


state 177

    (13) if -> IF ( varExpresion ) THEN bloque else .

    RETURN          reduce using rule 13 (if -> IF ( varExpresion ) THEN bloque else .)
    MASMAS          reduce using rule 13 (if -> IF ( varExpresion ) THEN bloque else .)
    MENOSMENOS      reduce using rule 13 (if -> IF ( varExpresion ) THEN bloque else .)
    ID              reduce using rule 13 (if -> IF ( varExpresion ) THEN bloque else .)
    IF              reduce using rule 13 (if -> IF ( varExpresion ) THEN bloque else .)
    WHILE           reduce using rule 13 (if -> IF ( varExpresion ) THEN bloque else .)
    DO              reduce using rule 13 (if -> IF ( varExpresion ) THEN bloque else .)
    FOR             reduce using rule 13 (if -> IF ( varExpresion ) THEN bloque else .)
    PRINT           reduce using rule 13 (if -> IF ( varExpresion ) THEN bloque else .)
    RES             reduce using rule 13 (if -> IF ( varExpresion ) THEN bloque else .)
    MULTIESCALAR    reduce using rule 13 (if -> IF ( varExpresion ) THEN bloque else .)
    LENGTH          reduce using rule 13 (if -> IF ( varExpresion ) THEN bloque else .)
    CAPITALIZAR     reduce using rule 13 (if -> IF ( varExpresion ) THEN bloque else .)
    COLINEALES      reduce using rule 13 (if -> IF ( varExpresion ) THEN bloque else .)
    }               reduce using rule 13 (if -> IF ( varExpresion ) THEN bloque else .)
    $end            reduce using rule 13 (if -> IF ( varExpresion ) THEN bloque else .)


state 178

    (14) else -> ELSE . bloque
    (16) bloque -> . sentencia
    (17) bloque -> . { g }
    (4) sentencia -> . varOps ;
    (5) sentencia -> . func ;
    (6) sentencia -> . varAsig ;
    (7) sentencia -> . RETURN ;
    (55) varOps -> . MASMAS ID
    (56) varOps -> . MENOSMENOS ID
    (57) varOps -> . ID MASMAS
    (58) varOps -> . ID MENOSMENOS
    (59) func -> . funcReturn
    (60) func -> . funcVoid
    (72) varAsig -> . vars MENOSEQ varAsig
    (73) varAsig -> . vars MASEQ varAsig
    (74) varAsig -> . vars MULEQ varAsig
    (75) varAsig -> . vars DIVEQ varAsig
    (76) varAsig -> . vars = varAsig
    (77) varAsig -> . vars MASEQ varExpresion
    (78) varAsig -> . vars MENOSEQ varExpresion
    (79) varAsig -> . vars MULEQ varExpresion
    (80) varAsig -> . vars DIVEQ varExpresion
    (81) varAsig -> . vars = varExpresion
    (61) funcReturn -> . funcInt
    (62) funcReturn -> . funcString
    (63) funcReturn -> . funcBool
    (68) funcVoid -> . PRINT ( varExpresion )
    (82) vars -> . ID
    (83) vars -> . RES
    (64) funcInt -> . MULTIESCALAR ( varExpresion , varExpresion , param )
    (65) funcInt -> . LENGTH ( varExpresion )
    (66) funcString -> . CAPITALIZAR ( varExpresion )
    (67) funcBool -> . COLINEALES ( varExpresion , varExpresion )

    {               shift and go to state 32
    RETURN          shift and go to state 2
    MASMAS          shift and go to state 27
    MENOSMENOS      shift and go to state 29
    ID              shift and go to state 17
    PRINT           shift and go to state 8
    RES             shift and go to state 5
    MULTIESCALAR    shift and go to state 22
    LENGTH          shift and go to state 25
    CAPITALIZAR     shift and go to state 24
    COLINEALES      shift and go to state 14

    varAsig                        shift and go to state 19
    sentencia                      shift and go to state 31
    vars                           shift and go to state 3
    funcString                     shift and go to state 21
    funcReturn                     shift and go to state 23
    varOps                         shift and go to state 12
    funcBool                       shift and go to state 11
    funcVoid                       shift and go to state 13
    func                           shift and go to state 16
    bloque                         shift and go to state 187
    funcInt                        shift and go to state 6

state 179

    (15) else -> empty .

    RETURN          reduce using rule 15 (else -> empty .)
    MASMAS          reduce using rule 15 (else -> empty .)
    MENOSMENOS      reduce using rule 15 (else -> empty .)
    ID              reduce using rule 15 (else -> empty .)
    IF              reduce using rule 15 (else -> empty .)
    WHILE           reduce using rule 15 (else -> empty .)
    DO              reduce using rule 15 (else -> empty .)
    FOR             reduce using rule 15 (else -> empty .)
    PRINT           reduce using rule 15 (else -> empty .)
    RES             reduce using rule 15 (else -> empty .)
    MULTIESCALAR    reduce using rule 15 (else -> empty .)
    LENGTH          reduce using rule 15 (else -> empty .)
    CAPITALIZAR     reduce using rule 15 (else -> empty .)
    COLINEALES      reduce using rule 15 (else -> empty .)
    $end            reduce using rule 15 (else -> empty .)
    }               reduce using rule 15 (else -> empty .)


state 180

    (64) funcInt -> MULTIESCALAR ( varExpresion , varExpresion , param . )

    )               shift and go to state 188


state 181

    (69) param -> varExpresion .
    (18) varExpresion -> varExpresion . + varExpresion
    (19) varExpresion -> varExpresion . - varExpresion
    (20) varExpresion -> varExpresion . * varExpresion
    (21) varExpresion -> varExpresion . / varExpresion
    (22) varExpresion -> varExpresion . % varExpresion
    (23) varExpresion -> varExpresion . ^ varExpresion
    (26) varExpresion -> varExpresion . ? varExpresion : varExpresion
    (27) varExpresion -> varExpresion . AND varExpresion
    (29) varExpresion -> varExpresion . OR varExpresion
    (30) varExpresion -> varExpresion . EQEQ varExpresion
    (31) varExpresion -> varExpresion . DISTINTO varExpresion
    (32) varExpresion -> varExpresion . > varExpresion
    (33) varExpresion -> varExpresion . < varExpresion

    )               reduce using rule 69 (param -> varExpresion .)
    +               shift and go to state 100
    -               shift and go to state 102
    *               shift and go to state 101
    /               shift and go to state 103
    %               shift and go to state 97
    ^               shift and go to state 108
    ?               shift and go to state 107
    AND             shift and go to state 96
    OR              shift and go to state 106
    EQEQ            shift and go to state 105
    DISTINTO        shift and go to state 98
    >               shift and go to state 99
    <               shift and go to state 104


state 182

    (70) param -> empty .

    )               reduce using rule 70 (param -> empty .)


state 183

    (25) varExpresion -> ( + ( varExpresion ) ) .

    +               reduce using rule 25 (varExpresion -> ( + ( varExpresion ) ) .)
    -               reduce using rule 25 (varExpresion -> ( + ( varExpresion ) ) .)
    *               reduce using rule 25 (varExpresion -> ( + ( varExpresion ) ) .)
    /               reduce using rule 25 (varExpresion -> ( + ( varExpresion ) ) .)
    %               reduce using rule 25 (varExpresion -> ( + ( varExpresion ) ) .)
    ^               reduce using rule 25 (varExpresion -> ( + ( varExpresion ) ) .)
    ?               reduce using rule 25 (varExpresion -> ( + ( varExpresion ) ) .)
    AND             reduce using rule 25 (varExpresion -> ( + ( varExpresion ) ) .)
    OR              reduce using rule 25 (varExpresion -> ( + ( varExpresion ) ) .)
    EQEQ            reduce using rule 25 (varExpresion -> ( + ( varExpresion ) ) .)
    DISTINTO        reduce using rule 25 (varExpresion -> ( + ( varExpresion ) ) .)
    >               reduce using rule 25 (varExpresion -> ( + ( varExpresion ) ) .)
    <               reduce using rule 25 (varExpresion -> ( + ( varExpresion ) ) .)
    ;               reduce using rule 25 (varExpresion -> ( + ( varExpresion ) ) .)
    )               reduce using rule 25 (varExpresion -> ( + ( varExpresion ) ) .)
    ,               reduce using rule 25 (varExpresion -> ( + ( varExpresion ) ) .)
    ]               reduce using rule 25 (varExpresion -> ( + ( varExpresion ) ) .)
    :               reduce using rule 25 (varExpresion -> ( + ( varExpresion ) ) .)
    }               reduce using rule 25 (varExpresion -> ( + ( varExpresion ) ) .)


state 184

    (24) varExpresion -> ( - ( varExpresion ) ) .

    +               reduce using rule 24 (varExpresion -> ( - ( varExpresion ) ) .)
    -               reduce using rule 24 (varExpresion -> ( - ( varExpresion ) ) .)
    *               reduce using rule 24 (varExpresion -> ( - ( varExpresion ) ) .)
    /               reduce using rule 24 (varExpresion -> ( - ( varExpresion ) ) .)
    %               reduce using rule 24 (varExpresion -> ( - ( varExpresion ) ) .)
    ^               reduce using rule 24 (varExpresion -> ( - ( varExpresion ) ) .)
    ?               reduce using rule 24 (varExpresion -> ( - ( varExpresion ) ) .)
    AND             reduce using rule 24 (varExpresion -> ( - ( varExpresion ) ) .)
    OR              reduce using rule 24 (varExpresion -> ( - ( varExpresion ) ) .)
    EQEQ            reduce using rule 24 (varExpresion -> ( - ( varExpresion ) ) .)
    DISTINTO        reduce using rule 24 (varExpresion -> ( - ( varExpresion ) ) .)
    >               reduce using rule 24 (varExpresion -> ( - ( varExpresion ) ) .)
    <               reduce using rule 24 (varExpresion -> ( - ( varExpresion ) ) .)
    ;               reduce using rule 24 (varExpresion -> ( - ( varExpresion ) ) .)
    )               reduce using rule 24 (varExpresion -> ( - ( varExpresion ) ) .)
    ,               reduce using rule 24 (varExpresion -> ( - ( varExpresion ) ) .)
    ]               reduce using rule 24 (varExpresion -> ( - ( varExpresion ) ) .)
    :               reduce using rule 24 (varExpresion -> ( - ( varExpresion ) ) .)
    }               reduce using rule 24 (varExpresion -> ( - ( varExpresion ) ) .)


state 185

    (53) campos -> ID : varExpresion , campos .

    }               reduce using rule 53 (campos -> ID : varExpresion , campos .)


state 186

    (12) loop -> FOR ( varAsig ; varExpresion ; varOps ) . bloque
    (16) bloque -> . sentencia
    (17) bloque -> . { g }
    (4) sentencia -> . varOps ;
    (5) sentencia -> . func ;
    (6) sentencia -> . varAsig ;
    (7) sentencia -> . RETURN ;
    (55) varOps -> . MASMAS ID
    (56) varOps -> . MENOSMENOS ID
    (57) varOps -> . ID MASMAS
    (58) varOps -> . ID MENOSMENOS
    (59) func -> . funcReturn
    (60) func -> . funcVoid
    (72) varAsig -> . vars MENOSEQ varAsig
    (73) varAsig -> . vars MASEQ varAsig
    (74) varAsig -> . vars MULEQ varAsig
    (75) varAsig -> . vars DIVEQ varAsig
    (76) varAsig -> . vars = varAsig
    (77) varAsig -> . vars MASEQ varExpresion
    (78) varAsig -> . vars MENOSEQ varExpresion
    (79) varAsig -> . vars MULEQ varExpresion
    (80) varAsig -> . vars DIVEQ varExpresion
    (81) varAsig -> . vars = varExpresion
    (61) funcReturn -> . funcInt
    (62) funcReturn -> . funcString
    (63) funcReturn -> . funcBool
    (68) funcVoid -> . PRINT ( varExpresion )
    (82) vars -> . ID
    (83) vars -> . RES
    (64) funcInt -> . MULTIESCALAR ( varExpresion , varExpresion , param )
    (65) funcInt -> . LENGTH ( varExpresion )
    (66) funcString -> . CAPITALIZAR ( varExpresion )
    (67) funcBool -> . COLINEALES ( varExpresion , varExpresion )

    {               shift and go to state 32
    RETURN          shift and go to state 2
    MASMAS          shift and go to state 27
    MENOSMENOS      shift and go to state 29
    ID              shift and go to state 17
    PRINT           shift and go to state 8
    RES             shift and go to state 5
    MULTIESCALAR    shift and go to state 22
    LENGTH          shift and go to state 25
    CAPITALIZAR     shift and go to state 24
    COLINEALES      shift and go to state 14

    varAsig                        shift and go to state 19
    sentencia                      shift and go to state 31
    vars                           shift and go to state 3
    funcString                     shift and go to state 21
    funcReturn                     shift and go to state 23
    varOps                         shift and go to state 12
    funcBool                       shift and go to state 11
    funcVoid                       shift and go to state 13
    func                           shift and go to state 16
    bloque                         shift and go to state 189
    funcInt                        shift and go to state 6

state 187

    (14) else -> ELSE bloque .

    RETURN          reduce using rule 14 (else -> ELSE bloque .)
    MASMAS          reduce using rule 14 (else -> ELSE bloque .)
    MENOSMENOS      reduce using rule 14 (else -> ELSE bloque .)
    ID              reduce using rule 14 (else -> ELSE bloque .)
    IF              reduce using rule 14 (else -> ELSE bloque .)
    WHILE           reduce using rule 14 (else -> ELSE bloque .)
    DO              reduce using rule 14 (else -> ELSE bloque .)
    FOR             reduce using rule 14 (else -> ELSE bloque .)
    PRINT           reduce using rule 14 (else -> ELSE bloque .)
    RES             reduce using rule 14 (else -> ELSE bloque .)
    MULTIESCALAR    reduce using rule 14 (else -> ELSE bloque .)
    LENGTH          reduce using rule 14 (else -> ELSE bloque .)
    CAPITALIZAR     reduce using rule 14 (else -> ELSE bloque .)
    COLINEALES      reduce using rule 14 (else -> ELSE bloque .)
    $end            reduce using rule 14 (else -> ELSE bloque .)
    }               reduce using rule 14 (else -> ELSE bloque .)


state 188

    (64) funcInt -> MULTIESCALAR ( varExpresion , varExpresion , param ) .

    ;               reduce using rule 64 (funcInt -> MULTIESCALAR ( varExpresion , varExpresion , param ) .)
    +               reduce using rule 64 (funcInt -> MULTIESCALAR ( varExpresion , varExpresion , param ) .)
    -               reduce using rule 64 (funcInt -> MULTIESCALAR ( varExpresion , varExpresion , param ) .)
    *               reduce using rule 64 (funcInt -> MULTIESCALAR ( varExpresion , varExpresion , param ) .)
    /               reduce using rule 64 (funcInt -> MULTIESCALAR ( varExpresion , varExpresion , param ) .)
    %               reduce using rule 64 (funcInt -> MULTIESCALAR ( varExpresion , varExpresion , param ) .)
    ^               reduce using rule 64 (funcInt -> MULTIESCALAR ( varExpresion , varExpresion , param ) .)
    ?               reduce using rule 64 (funcInt -> MULTIESCALAR ( varExpresion , varExpresion , param ) .)
    AND             reduce using rule 64 (funcInt -> MULTIESCALAR ( varExpresion , varExpresion , param ) .)
    OR              reduce using rule 64 (funcInt -> MULTIESCALAR ( varExpresion , varExpresion , param ) .)
    EQEQ            reduce using rule 64 (funcInt -> MULTIESCALAR ( varExpresion , varExpresion , param ) .)
    DISTINTO        reduce using rule 64 (funcInt -> MULTIESCALAR ( varExpresion , varExpresion , param ) .)
    >               reduce using rule 64 (funcInt -> MULTIESCALAR ( varExpresion , varExpresion , param ) .)
    <               reduce using rule 64 (funcInt -> MULTIESCALAR ( varExpresion , varExpresion , param ) .)
    )               reduce using rule 64 (funcInt -> MULTIESCALAR ( varExpresion , varExpresion , param ) .)
    ,               reduce using rule 64 (funcInt -> MULTIESCALAR ( varExpresion , varExpresion , param ) .)
    ]               reduce using rule 64 (funcInt -> MULTIESCALAR ( varExpresion , varExpresion , param ) .)
    :               reduce using rule 64 (funcInt -> MULTIESCALAR ( varExpresion , varExpresion , param ) .)
    }               reduce using rule 64 (funcInt -> MULTIESCALAR ( varExpresion , varExpresion , param ) .)


state 189

    (12) loop -> FOR ( varAsig ; varExpresion ; varOps ) bloque .

    RETURN          reduce using rule 12 (loop -> FOR ( varAsig ; varExpresion ; varOps ) bloque .)
    MASMAS          reduce using rule 12 (loop -> FOR ( varAsig ; varExpresion ; varOps ) bloque .)
    MENOSMENOS      reduce using rule 12 (loop -> FOR ( varAsig ; varExpresion ; varOps ) bloque .)
    ID              reduce using rule 12 (loop -> FOR ( varAsig ; varExpresion ; varOps ) bloque .)
    IF              reduce using rule 12 (loop -> FOR ( varAsig ; varExpresion ; varOps ) bloque .)
    WHILE           reduce using rule 12 (loop -> FOR ( varAsig ; varExpresion ; varOps ) bloque .)
    DO              reduce using rule 12 (loop -> FOR ( varAsig ; varExpresion ; varOps ) bloque .)
    FOR             reduce using rule 12 (loop -> FOR ( varAsig ; varExpresion ; varOps ) bloque .)
    PRINT           reduce using rule 12 (loop -> FOR ( varAsig ; varExpresion ; varOps ) bloque .)
    RES             reduce using rule 12 (loop -> FOR ( varAsig ; varExpresion ; varOps ) bloque .)
    MULTIESCALAR    reduce using rule 12 (loop -> FOR ( varAsig ; varExpresion ; varOps ) bloque .)
    LENGTH          reduce using rule 12 (loop -> FOR ( varAsig ; varExpresion ; varOps ) bloque .)
    CAPITALIZAR     reduce using rule 12 (loop -> FOR ( varAsig ; varExpresion ; varOps ) bloque .)
    COLINEALES      reduce using rule 12 (loop -> FOR ( varAsig ; varExpresion ; varOps ) bloque .)
    }               reduce using rule 12 (loop -> FOR ( varAsig ; varExpresion ; varOps ) bloque .)
    $end            reduce using rule 12 (loop -> FOR ( varAsig ; varExpresion ; varOps ) bloque .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for + in state 132 resolved as shift
WARNING: shift/reduce conflict for - in state 132 resolved as shift
WARNING: shift/reduce conflict for * in state 132 resolved as shift
WARNING: shift/reduce conflict for / in state 132 resolved as shift
WARNING: shift/reduce conflict for % in state 132 resolved as shift
WARNING: shift/reduce conflict for ^ in state 132 resolved as shift
WARNING: shift/reduce conflict for ? in state 132 resolved as shift
WARNING: shift/reduce conflict for AND in state 132 resolved as shift
WARNING: shift/reduce conflict for OR in state 132 resolved as shift
WARNING: shift/reduce conflict for EQEQ in state 132 resolved as shift
WARNING: shift/reduce conflict for DISTINTO in state 132 resolved as shift
WARNING: shift/reduce conflict for > in state 132 resolved as shift
WARNING: shift/reduce conflict for < in state 132 resolved as shift
WARNING: shift/reduce conflict for + in state 137 resolved as shift
WARNING: shift/reduce conflict for - in state 137 resolved as shift
WARNING: shift/reduce conflict for * in state 137 resolved as shift
WARNING: shift/reduce conflict for / in state 137 resolved as shift
WARNING: shift/reduce conflict for % in state 137 resolved as shift
WARNING: shift/reduce conflict for ^ in state 137 resolved as shift
WARNING: shift/reduce conflict for ? in state 137 resolved as shift
WARNING: shift/reduce conflict for AND in state 137 resolved as shift
WARNING: shift/reduce conflict for OR in state 137 resolved as shift
WARNING: shift/reduce conflict for EQEQ in state 137 resolved as shift
WARNING: shift/reduce conflict for DISTINTO in state 137 resolved as shift
WARNING: shift/reduce conflict for > in state 137 resolved as shift
WARNING: shift/reduce conflict for < in state 137 resolved as shift
WARNING: shift/reduce conflict for + in state 170 resolved as shift
WARNING: shift/reduce conflict for - in state 170 resolved as shift
WARNING: shift/reduce conflict for * in state 170 resolved as shift
WARNING: shift/reduce conflict for / in state 170 resolved as shift
WARNING: shift/reduce conflict for % in state 170 resolved as shift
WARNING: shift/reduce conflict for ^ in state 170 resolved as shift
WARNING: shift/reduce conflict for ? in state 170 resolved as shift
WARNING: shift/reduce conflict for AND in state 170 resolved as shift
WARNING: shift/reduce conflict for OR in state 170 resolved as shift
WARNING: shift/reduce conflict for EQEQ in state 170 resolved as shift
WARNING: shift/reduce conflict for DISTINTO in state 170 resolved as shift
WARNING: shift/reduce conflict for > in state 170 resolved as shift
WARNING: shift/reduce conflict for < in state 170 resolved as shift
