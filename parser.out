Created by PLY version 3.8 (http://www.dabeaz.com/ply)

Unused terminals:

    RES
    COMMENT
    BEGIN
    MASEQ
    DIVEQ
    END
    MENOSEQ

Grammar

Rule 0     S' -> g
Rule 1     g -> sentencia
Rule 2     g -> ctrl g
Rule 3     g -> empty
Rule 4     sentencia -> varsOps ;
Rule 5     sentencia -> func ;
Rule 6     sentencia -> varAsig ;
Rule 7     sentencia -> RETURN ;
Rule 8     ctrl -> if
Rule 9     ctrl -> loop
Rule 10    loop -> WHILE ( expBool ) bloque
Rule 11    loop -> DO bloque WHILE ( expBool ) ;
Rule 12    loop -> FOR ( varAsig ; expBool ; varsOps ) bloque
Rule 13    if -> IF ( expBool ) bloque else
Rule 14    else -> ELSE bloque
Rule 15    else -> empty
Rule 16    bloque -> sentencia ;
Rule 17    bloque -> { g }
Rule 18    func -> funcReturn
Rule 19    func -> funcVoid
Rule 20    funcReturn -> funcInt
Rule 21    funcReturn -> funcString
Rule 22    funcReturn -> funcBool
Rule 23    funcInt -> MULTIESCALAR ( vec , eMat , param )
Rule 24    funcInt -> LENGTH ( vec )
Rule 25    funcString -> CAPITALIZAR ( expString )
Rule 26    funcBool -> COLINEALES ( vec , vec )
Rule 27    funcVoid -> PRINT ( valores )
Rule 28    param -> expBool
Rule 29    param -> empty
Rule 30    empty -> <empty>
Rule 31    vec -> [ elem ]
Rule 32    elem -> valores , elem
Rule 33    elem -> valores
Rule 34    valores -> eMat
Rule 35    valores -> expBool
Rule 36    valores -> expString
Rule 37    valores -> varYVals
Rule 38    valores -> funcReturn
Rule 39    valores -> reg
Rule 40    valores -> ID . ID
Rule 41    varYVals -> ID
Rule 42    varYVals -> vecVal
Rule 43    vecVal -> ID m
Rule 44    m -> [ INT ]
Rule 45    m -> [ INT ] m
Rule 46    reg -> { campos }
Rule 47    campos -> ID : valores , campos
Rule 48    campos -> valores
Rule 49    varsOps -> MENOSMENOS varYVals
Rule 50    varsOps -> MASMAS varYVals
Rule 51    varsOps -> varYVals MASMAS
Rule 52    varsOps -> varYVals MENOSMENOS
Rule 53    varAsig -> ID MULEQ varAsig
Rule 54    varAsig -> asig MULEQ varAsig
Rule 55    varAsig -> ID MULEQ valores
Rule 56    varAsig -> asig
Rule 57    asig -> ID = asig
Rule 58    asig -> ID = valores
Rule 59    eMat -> eMat + p
Rule 60    eMat -> eMat - p
Rule 61    eMat -> p
Rule 62    p -> p * exp
Rule 63    p -> p / exp
Rule 64    p -> p % exp
Rule 65    p -> exp
Rule 66    exp -> exp ^ iSing
Rule 67    exp -> iSing
Rule 68    iSing -> - paren
Rule 69    iSing -> + paren
Rule 70    iSing -> paren
Rule 71    paren -> ( eMat )
Rule 72    paren -> INT
Rule 73    paren -> varYVals
Rule 74    paren -> FLOAT
Rule 75    paren -> varsOps
Rule 76    paren -> funcInt
Rule 77    expString -> expString + STRING
Rule 78    expString -> STRING
Rule 79    expString -> varYVals
Rule 80    expString -> funcString
Rule 81    expBool -> or ? expBool : expBool
Rule 82    expBool -> or
Rule 83    or -> or OR and
Rule 84    or -> and
Rule 85    and -> and AND eq
Rule 86    and -> eq
Rule 87    eq -> eq EQEQ tBool
Rule 88    eq -> eq DISTINTO tBool
Rule 89    eq -> mayor
Rule 90    mayor -> tCompare > tCompare
Rule 91    mayor -> menor
Rule 92    menor -> tCompare < tCompare
Rule 93    menor -> not
Rule 94    not -> NOT not
Rule 95    not -> tBool
Rule 96    tBool -> ( expBool )
Rule 97    tBool -> BOOL
Rule 98    tBool -> varYVals
Rule 99    tBool -> funcBool
Rule 100   tCompare -> eMat
Rule 101   tCompare -> varsOps
Rule 102   tCompare -> varYVals

Terminals, with rules where they appear

%                    : 64
(                    : 10 11 12 13 23 24 25 26 27 71 96
)                    : 10 11 12 13 23 24 25 26 27 71 96
*                    : 62
+                    : 59 69 77
,                    : 23 23 26 32 47
-                    : 60 68
.                    : 40
/                    : 63
:                    : 47 81
;                    : 4 5 6 7 11 12 12 16
<                    : 92
=                    : 57 58
>                    : 90
?                    : 81
AND                  : 85
BEGIN                : 
BOOL                 : 97
CAPITALIZAR          : 25
COLINEALES           : 26
COMMENT              : 
DISTINTO             : 88
DIVEQ                : 
DO                   : 11
ELSE                 : 14
END                  : 
EQEQ                 : 87
FLOAT                : 74
FOR                  : 12
ID                   : 40 40 41 43 47 53 55 57 58
IF                   : 13
INT                  : 44 45 72
LENGTH               : 24
MASEQ                : 
MASMAS               : 50 51
MENOSEQ              : 
MENOSMENOS           : 49 52
MULEQ                : 53 54 55
MULTIESCALAR         : 23
NOT                  : 94
OR                   : 83
PRINT                : 27
RES                  : 
RETURN               : 7
STRING               : 77 78
WHILE                : 10 11
[                    : 31 44 45
]                    : 31 44 45
^                    : 66
error                : 
{                    : 17 46
}                    : 17 46

Nonterminals, with rules where they appear

and                  : 83 84 85
asig                 : 54 56 57
bloque               : 10 11 12 13 14
campos               : 46 47
ctrl                 : 2
eMat                 : 23 34 59 60 71 100
elem                 : 31 32
else                 : 13
empty                : 3 15 29
eq                   : 85 86 87 88
exp                  : 62 63 64 65 66
expBool              : 10 11 12 13 28 35 81 81 96
expString            : 25 36 77
func                 : 5
funcBool             : 22 99
funcInt              : 20 76
funcReturn           : 18 38
funcString           : 21 80
funcVoid             : 19
g                    : 2 17 0
iSing                : 66 67
if                   : 8
loop                 : 9
m                    : 43 45
mayor                : 89
menor                : 91
not                  : 93 94
or                   : 81 82 83
p                    : 59 60 61 62 63 64
param                : 23
paren                : 68 69 70
reg                  : 39
sentencia            : 1 16
tBool                : 87 88 95
tCompare             : 90 90 92 92
valores              : 27 32 33 47 48 55 58
varAsig              : 6 12 53 54
varYVals             : 37 49 50 51 52 73 79 98 102
varsOps              : 4 12 75 101
vec                  : 23 24 26 26
vecVal               : 42

Parsing method: LALR

state 0

    (0) S' -> . g
    (1) g -> . sentencia
    (2) g -> . ctrl g
    (3) g -> . empty
    (4) sentencia -> . varsOps ;
    (5) sentencia -> . func ;
    (6) sentencia -> . varAsig ;
    (7) sentencia -> . RETURN ;
    (8) ctrl -> . if
    (9) ctrl -> . loop
    (30) empty -> .
    (49) varsOps -> . MENOSMENOS varYVals
    (50) varsOps -> . MASMAS varYVals
    (51) varsOps -> . varYVals MASMAS
    (52) varsOps -> . varYVals MENOSMENOS
    (18) func -> . funcReturn
    (19) func -> . funcVoid
    (53) varAsig -> . ID MULEQ varAsig
    (54) varAsig -> . asig MULEQ varAsig
    (55) varAsig -> . ID MULEQ valores
    (56) varAsig -> . asig
    (13) if -> . IF ( expBool ) bloque else
    (10) loop -> . WHILE ( expBool ) bloque
    (11) loop -> . DO bloque WHILE ( expBool ) ;
    (12) loop -> . FOR ( varAsig ; expBool ; varsOps ) bloque
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (20) funcReturn -> . funcInt
    (21) funcReturn -> . funcString
    (22) funcReturn -> . funcBool
    (27) funcVoid -> . PRINT ( valores )
    (57) asig -> . ID = asig
    (58) asig -> . ID = valores
    (43) vecVal -> . ID m
    (23) funcInt -> . MULTIESCALAR ( vec , eMat , param )
    (24) funcInt -> . LENGTH ( vec )
    (25) funcString -> . CAPITALIZAR ( expString )
    (26) funcBool -> . COLINEALES ( vec , vec )

    RETURN          shift and go to state 2
    $end            reduce using rule 30 (empty -> .)
    MENOSMENOS      shift and go to state 30
    MASMAS          shift and go to state 27
    ID              shift and go to state 18
    IF              shift and go to state 19
    WHILE           shift and go to state 6
    DO              shift and go to state 1
    FOR             shift and go to state 16
    PRINT           shift and go to state 8
    MULTIESCALAR    shift and go to state 23
    LENGTH          shift and go to state 26
    CAPITALIZAR     shift and go to state 25
    COLINEALES      shift and go to state 15

    funcBool                       shift and go to state 3
    ctrl                           shift and go to state 4
    funcInt                        shift and go to state 5
    loop                           shift and go to state 7
    vecVal                         shift and go to state 9
    if                             shift and go to state 10
    sentencia                      shift and go to state 11
    asig                           shift and go to state 12
    empty                          shift and go to state 13
    funcVoid                       shift and go to state 14
    func                           shift and go to state 17
    varAsig                        shift and go to state 20
    g                              shift and go to state 21
    funcString                     shift and go to state 22
    funcReturn                     shift and go to state 24
    varsOps                        shift and go to state 28
    varYVals                       shift and go to state 29

state 1

    (11) loop -> DO . bloque WHILE ( expBool ) ;
    (16) bloque -> . sentencia ;
    (17) bloque -> . { g }
    (4) sentencia -> . varsOps ;
    (5) sentencia -> . func ;
    (6) sentencia -> . varAsig ;
    (7) sentencia -> . RETURN ;
    (49) varsOps -> . MENOSMENOS varYVals
    (50) varsOps -> . MASMAS varYVals
    (51) varsOps -> . varYVals MASMAS
    (52) varsOps -> . varYVals MENOSMENOS
    (18) func -> . funcReturn
    (19) func -> . funcVoid
    (53) varAsig -> . ID MULEQ varAsig
    (54) varAsig -> . asig MULEQ varAsig
    (55) varAsig -> . ID MULEQ valores
    (56) varAsig -> . asig
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (20) funcReturn -> . funcInt
    (21) funcReturn -> . funcString
    (22) funcReturn -> . funcBool
    (27) funcVoid -> . PRINT ( valores )
    (57) asig -> . ID = asig
    (58) asig -> . ID = valores
    (43) vecVal -> . ID m
    (23) funcInt -> . MULTIESCALAR ( vec , eMat , param )
    (24) funcInt -> . LENGTH ( vec )
    (25) funcString -> . CAPITALIZAR ( expString )
    (26) funcBool -> . COLINEALES ( vec , vec )

    {               shift and go to state 33
    RETURN          shift and go to state 2
    MENOSMENOS      shift and go to state 30
    MASMAS          shift and go to state 27
    ID              shift and go to state 18
    PRINT           shift and go to state 8
    MULTIESCALAR    shift and go to state 23
    LENGTH          shift and go to state 26
    CAPITALIZAR     shift and go to state 25
    COLINEALES      shift and go to state 15

    varAsig                        shift and go to state 20
    sentencia                      shift and go to state 32
    funcInt                        shift and go to state 5
    funcBool                       shift and go to state 3
    funcString                     shift and go to state 22
    asig                           shift and go to state 12
    funcVoid                       shift and go to state 14
    funcReturn                     shift and go to state 24
    varsOps                        shift and go to state 28
    func                           shift and go to state 17
    bloque                         shift and go to state 31
    varYVals                       shift and go to state 29
    vecVal                         shift and go to state 9

state 2

    (7) sentencia -> RETURN . ;

    ;               shift and go to state 34


state 3

    (22) funcReturn -> funcBool .

    ;               reduce using rule 22 (funcReturn -> funcBool .)


state 4

    (2) g -> ctrl . g
    (1) g -> . sentencia
    (2) g -> . ctrl g
    (3) g -> . empty
    (4) sentencia -> . varsOps ;
    (5) sentencia -> . func ;
    (6) sentencia -> . varAsig ;
    (7) sentencia -> . RETURN ;
    (8) ctrl -> . if
    (9) ctrl -> . loop
    (30) empty -> .
    (49) varsOps -> . MENOSMENOS varYVals
    (50) varsOps -> . MASMAS varYVals
    (51) varsOps -> . varYVals MASMAS
    (52) varsOps -> . varYVals MENOSMENOS
    (18) func -> . funcReturn
    (19) func -> . funcVoid
    (53) varAsig -> . ID MULEQ varAsig
    (54) varAsig -> . asig MULEQ varAsig
    (55) varAsig -> . ID MULEQ valores
    (56) varAsig -> . asig
    (13) if -> . IF ( expBool ) bloque else
    (10) loop -> . WHILE ( expBool ) bloque
    (11) loop -> . DO bloque WHILE ( expBool ) ;
    (12) loop -> . FOR ( varAsig ; expBool ; varsOps ) bloque
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (20) funcReturn -> . funcInt
    (21) funcReturn -> . funcString
    (22) funcReturn -> . funcBool
    (27) funcVoid -> . PRINT ( valores )
    (57) asig -> . ID = asig
    (58) asig -> . ID = valores
    (43) vecVal -> . ID m
    (23) funcInt -> . MULTIESCALAR ( vec , eMat , param )
    (24) funcInt -> . LENGTH ( vec )
    (25) funcString -> . CAPITALIZAR ( expString )
    (26) funcBool -> . COLINEALES ( vec , vec )

    RETURN          shift and go to state 2
    $end            reduce using rule 30 (empty -> .)
    }               reduce using rule 30 (empty -> .)
    MENOSMENOS      shift and go to state 30
    MASMAS          shift and go to state 27
    ID              shift and go to state 18
    IF              shift and go to state 19
    WHILE           shift and go to state 6
    DO              shift and go to state 1
    FOR             shift and go to state 16
    PRINT           shift and go to state 8
    MULTIESCALAR    shift and go to state 23
    LENGTH          shift and go to state 26
    CAPITALIZAR     shift and go to state 25
    COLINEALES      shift and go to state 15

    funcBool                       shift and go to state 3
    ctrl                           shift and go to state 4
    funcInt                        shift and go to state 5
    loop                           shift and go to state 7
    vecVal                         shift and go to state 9
    if                             shift and go to state 10
    sentencia                      shift and go to state 11
    asig                           shift and go to state 12
    empty                          shift and go to state 13
    funcVoid                       shift and go to state 14
    func                           shift and go to state 17
    varAsig                        shift and go to state 20
    g                              shift and go to state 35
    funcString                     shift and go to state 22
    funcReturn                     shift and go to state 24
    varsOps                        shift and go to state 28
    varYVals                       shift and go to state 29

state 5

    (20) funcReturn -> funcInt .

    ;               reduce using rule 20 (funcReturn -> funcInt .)


state 6

    (10) loop -> WHILE . ( expBool ) bloque

    (               shift and go to state 36


state 7

    (9) ctrl -> loop .

    RETURN          reduce using rule 9 (ctrl -> loop .)
    MENOSMENOS      reduce using rule 9 (ctrl -> loop .)
    MASMAS          reduce using rule 9 (ctrl -> loop .)
    ID              reduce using rule 9 (ctrl -> loop .)
    IF              reduce using rule 9 (ctrl -> loop .)
    WHILE           reduce using rule 9 (ctrl -> loop .)
    DO              reduce using rule 9 (ctrl -> loop .)
    FOR             reduce using rule 9 (ctrl -> loop .)
    PRINT           reduce using rule 9 (ctrl -> loop .)
    MULTIESCALAR    reduce using rule 9 (ctrl -> loop .)
    LENGTH          reduce using rule 9 (ctrl -> loop .)
    CAPITALIZAR     reduce using rule 9 (ctrl -> loop .)
    COLINEALES      reduce using rule 9 (ctrl -> loop .)
    }               reduce using rule 9 (ctrl -> loop .)
    $end            reduce using rule 9 (ctrl -> loop .)


state 8

    (27) funcVoid -> PRINT . ( valores )

    (               shift and go to state 37


state 9

    (42) varYVals -> vecVal .

    MASMAS          reduce using rule 42 (varYVals -> vecVal .)
    MENOSMENOS      reduce using rule 42 (varYVals -> vecVal .)
    ;               reduce using rule 42 (varYVals -> vecVal .)
    +               reduce using rule 42 (varYVals -> vecVal .)
    ^               reduce using rule 42 (varYVals -> vecVal .)
    *               reduce using rule 42 (varYVals -> vecVal .)
    /               reduce using rule 42 (varYVals -> vecVal .)
    %               reduce using rule 42 (varYVals -> vecVal .)
    -               reduce using rule 42 (varYVals -> vecVal .)
    >               reduce using rule 42 (varYVals -> vecVal .)
    <               reduce using rule 42 (varYVals -> vecVal .)
    EQEQ            reduce using rule 42 (varYVals -> vecVal .)
    DISTINTO        reduce using rule 42 (varYVals -> vecVal .)
    AND             reduce using rule 42 (varYVals -> vecVal .)
    ?               reduce using rule 42 (varYVals -> vecVal .)
    OR              reduce using rule 42 (varYVals -> vecVal .)
    )               reduce using rule 42 (varYVals -> vecVal .)
    MULEQ           reduce using rule 42 (varYVals -> vecVal .)
    }               reduce using rule 42 (varYVals -> vecVal .)
    ,               reduce using rule 42 (varYVals -> vecVal .)
    ]               reduce using rule 42 (varYVals -> vecVal .)
    :               reduce using rule 42 (varYVals -> vecVal .)


state 10

    (8) ctrl -> if .

    RETURN          reduce using rule 8 (ctrl -> if .)
    MENOSMENOS      reduce using rule 8 (ctrl -> if .)
    MASMAS          reduce using rule 8 (ctrl -> if .)
    ID              reduce using rule 8 (ctrl -> if .)
    IF              reduce using rule 8 (ctrl -> if .)
    WHILE           reduce using rule 8 (ctrl -> if .)
    DO              reduce using rule 8 (ctrl -> if .)
    FOR             reduce using rule 8 (ctrl -> if .)
    PRINT           reduce using rule 8 (ctrl -> if .)
    MULTIESCALAR    reduce using rule 8 (ctrl -> if .)
    LENGTH          reduce using rule 8 (ctrl -> if .)
    CAPITALIZAR     reduce using rule 8 (ctrl -> if .)
    COLINEALES      reduce using rule 8 (ctrl -> if .)
    }               reduce using rule 8 (ctrl -> if .)
    $end            reduce using rule 8 (ctrl -> if .)


state 11

    (1) g -> sentencia .

    }               reduce using rule 1 (g -> sentencia .)
    $end            reduce using rule 1 (g -> sentencia .)


state 12

    (54) varAsig -> asig . MULEQ varAsig
    (56) varAsig -> asig .

    MULEQ           shift and go to state 38
    ;               reduce using rule 56 (varAsig -> asig .)


state 13

    (3) g -> empty .

    }               reduce using rule 3 (g -> empty .)
    $end            reduce using rule 3 (g -> empty .)


state 14

    (19) func -> funcVoid .

    ;               reduce using rule 19 (func -> funcVoid .)


state 15

    (26) funcBool -> COLINEALES . ( vec , vec )

    (               shift and go to state 39


state 16

    (12) loop -> FOR . ( varAsig ; expBool ; varsOps ) bloque

    (               shift and go to state 40


state 17

    (5) sentencia -> func . ;

    ;               shift and go to state 41


state 18

    (53) varAsig -> ID . MULEQ varAsig
    (55) varAsig -> ID . MULEQ valores
    (41) varYVals -> ID .
    (57) asig -> ID . = asig
    (58) asig -> ID . = valores
    (43) vecVal -> ID . m
    (44) m -> . [ INT ]
    (45) m -> . [ INT ] m

    MULEQ           shift and go to state 43
    MASMAS          reduce using rule 41 (varYVals -> ID .)
    MENOSMENOS      reduce using rule 41 (varYVals -> ID .)
    =               shift and go to state 45
    [               shift and go to state 44

    m                              shift and go to state 42

state 19

    (13) if -> IF . ( expBool ) bloque else

    (               shift and go to state 46


state 20

    (6) sentencia -> varAsig . ;

    ;               shift and go to state 47


state 21

    (0) S' -> g .



state 22

    (21) funcReturn -> funcString .

    ;               reduce using rule 21 (funcReturn -> funcString .)


state 23

    (23) funcInt -> MULTIESCALAR . ( vec , eMat , param )

    (               shift and go to state 48


state 24

    (18) func -> funcReturn .

    ;               reduce using rule 18 (func -> funcReturn .)


state 25

    (25) funcString -> CAPITALIZAR . ( expString )

    (               shift and go to state 49


state 26

    (24) funcInt -> LENGTH . ( vec )

    (               shift and go to state 50


state 27

    (50) varsOps -> MASMAS . varYVals
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (43) vecVal -> . ID m

    ID              shift and go to state 52

    varYVals                       shift and go to state 51
    vecVal                         shift and go to state 9

state 28

    (4) sentencia -> varsOps . ;

    ;               shift and go to state 53


state 29

    (51) varsOps -> varYVals . MASMAS
    (52) varsOps -> varYVals . MENOSMENOS

    MASMAS          shift and go to state 54
    MENOSMENOS      shift and go to state 55


state 30

    (49) varsOps -> MENOSMENOS . varYVals
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (43) vecVal -> . ID m

    ID              shift and go to state 52

    varYVals                       shift and go to state 56
    vecVal                         shift and go to state 9

state 31

    (11) loop -> DO bloque . WHILE ( expBool ) ;

    WHILE           shift and go to state 57


state 32

    (16) bloque -> sentencia . ;

    ;               shift and go to state 58


state 33

    (17) bloque -> { . g }
    (1) g -> . sentencia
    (2) g -> . ctrl g
    (3) g -> . empty
    (4) sentencia -> . varsOps ;
    (5) sentencia -> . func ;
    (6) sentencia -> . varAsig ;
    (7) sentencia -> . RETURN ;
    (8) ctrl -> . if
    (9) ctrl -> . loop
    (30) empty -> .
    (49) varsOps -> . MENOSMENOS varYVals
    (50) varsOps -> . MASMAS varYVals
    (51) varsOps -> . varYVals MASMAS
    (52) varsOps -> . varYVals MENOSMENOS
    (18) func -> . funcReturn
    (19) func -> . funcVoid
    (53) varAsig -> . ID MULEQ varAsig
    (54) varAsig -> . asig MULEQ varAsig
    (55) varAsig -> . ID MULEQ valores
    (56) varAsig -> . asig
    (13) if -> . IF ( expBool ) bloque else
    (10) loop -> . WHILE ( expBool ) bloque
    (11) loop -> . DO bloque WHILE ( expBool ) ;
    (12) loop -> . FOR ( varAsig ; expBool ; varsOps ) bloque
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (20) funcReturn -> . funcInt
    (21) funcReturn -> . funcString
    (22) funcReturn -> . funcBool
    (27) funcVoid -> . PRINT ( valores )
    (57) asig -> . ID = asig
    (58) asig -> . ID = valores
    (43) vecVal -> . ID m
    (23) funcInt -> . MULTIESCALAR ( vec , eMat , param )
    (24) funcInt -> . LENGTH ( vec )
    (25) funcString -> . CAPITALIZAR ( expString )
    (26) funcBool -> . COLINEALES ( vec , vec )

    RETURN          shift and go to state 2
    }               reduce using rule 30 (empty -> .)
    MENOSMENOS      shift and go to state 30
    MASMAS          shift and go to state 27
    ID              shift and go to state 18
    IF              shift and go to state 19
    WHILE           shift and go to state 6
    DO              shift and go to state 1
    FOR             shift and go to state 16
    PRINT           shift and go to state 8
    MULTIESCALAR    shift and go to state 23
    LENGTH          shift and go to state 26
    CAPITALIZAR     shift and go to state 25
    COLINEALES      shift and go to state 15

    funcBool                       shift and go to state 3
    ctrl                           shift and go to state 4
    funcInt                        shift and go to state 5
    loop                           shift and go to state 7
    vecVal                         shift and go to state 9
    if                             shift and go to state 10
    sentencia                      shift and go to state 11
    asig                           shift and go to state 12
    empty                          shift and go to state 13
    funcVoid                       shift and go to state 14
    func                           shift and go to state 17
    varAsig                        shift and go to state 20
    g                              shift and go to state 59
    funcString                     shift and go to state 22
    funcReturn                     shift and go to state 24
    varsOps                        shift and go to state 28
    varYVals                       shift and go to state 29

state 34

    (7) sentencia -> RETURN ; .

    $end            reduce using rule 7 (sentencia -> RETURN ; .)
    ;               reduce using rule 7 (sentencia -> RETURN ; .)
    }               reduce using rule 7 (sentencia -> RETURN ; .)


state 35

    (2) g -> ctrl g .

    }               reduce using rule 2 (g -> ctrl g .)
    $end            reduce using rule 2 (g -> ctrl g .)


state 36

    (10) loop -> WHILE ( . expBool ) bloque
    (81) expBool -> . or ? expBool : expBool
    (82) expBool -> . or
    (83) or -> . or OR and
    (84) or -> . and
    (85) and -> . and AND eq
    (86) and -> . eq
    (87) eq -> . eq EQEQ tBool
    (88) eq -> . eq DISTINTO tBool
    (89) eq -> . mayor
    (90) mayor -> . tCompare > tCompare
    (91) mayor -> . menor
    (100) tCompare -> . eMat
    (101) tCompare -> . varsOps
    (102) tCompare -> . varYVals
    (92) menor -> . tCompare < tCompare
    (93) menor -> . not
    (59) eMat -> . eMat + p
    (60) eMat -> . eMat - p
    (61) eMat -> . p
    (49) varsOps -> . MENOSMENOS varYVals
    (50) varsOps -> . MASMAS varYVals
    (51) varsOps -> . varYVals MASMAS
    (52) varsOps -> . varYVals MENOSMENOS
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (94) not -> . NOT not
    (95) not -> . tBool
    (62) p -> . p * exp
    (63) p -> . p / exp
    (64) p -> . p % exp
    (65) p -> . exp
    (43) vecVal -> . ID m
    (96) tBool -> . ( expBool )
    (97) tBool -> . BOOL
    (98) tBool -> . varYVals
    (99) tBool -> . funcBool
    (66) exp -> . exp ^ iSing
    (67) exp -> . iSing
    (26) funcBool -> . COLINEALES ( vec , vec )
    (68) iSing -> . - paren
    (69) iSing -> . + paren
    (70) iSing -> . paren
    (71) paren -> . ( eMat )
    (72) paren -> . INT
    (73) paren -> . varYVals
    (74) paren -> . FLOAT
    (75) paren -> . varsOps
    (76) paren -> . funcInt
    (23) funcInt -> . MULTIESCALAR ( vec , eMat , param )
    (24) funcInt -> . LENGTH ( vec )

    MENOSMENOS      shift and go to state 30
    MASMAS          shift and go to state 27
    ID              shift and go to state 52
    NOT             shift and go to state 81
    (               shift and go to state 67
    BOOL            shift and go to state 70
    COLINEALES      shift and go to state 15
    -               shift and go to state 69
    +               shift and go to state 68
    INT             shift and go to state 75
    FLOAT           shift and go to state 76
    MULTIESCALAR    shift and go to state 23
    LENGTH          shift and go to state 26

    and                            shift and go to state 60
    funcBool                       shift and go to state 61
    funcInt                        shift and go to state 62
    menor                          shift and go to state 63
    eq                             shift and go to state 64
    mayor                          shift and go to state 65
    eMat                           shift and go to state 66
    vecVal                         shift and go to state 9
    paren                          shift and go to state 73
    iSing                          shift and go to state 71
    tCompare                       shift and go to state 72
    not                            shift and go to state 74
    p                              shift and go to state 78
    varsOps                        shift and go to state 79
    exp                            shift and go to state 80
    tBool                          shift and go to state 82
    varYVals                       shift and go to state 83
    or                             shift and go to state 77
    expBool                        shift and go to state 84

state 37

    (27) funcVoid -> PRINT ( . valores )
    (34) valores -> . eMat
    (35) valores -> . expBool
    (36) valores -> . expString
    (37) valores -> . varYVals
    (38) valores -> . funcReturn
    (39) valores -> . reg
    (40) valores -> . ID . ID
    (59) eMat -> . eMat + p
    (60) eMat -> . eMat - p
    (61) eMat -> . p
    (81) expBool -> . or ? expBool : expBool
    (82) expBool -> . or
    (77) expString -> . expString + STRING
    (78) expString -> . STRING
    (79) expString -> . varYVals
    (80) expString -> . funcString
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (20) funcReturn -> . funcInt
    (21) funcReturn -> . funcString
    (22) funcReturn -> . funcBool
    (46) reg -> . { campos }
    (62) p -> . p * exp
    (63) p -> . p / exp
    (64) p -> . p % exp
    (65) p -> . exp
    (83) or -> . or OR and
    (84) or -> . and
    (25) funcString -> . CAPITALIZAR ( expString )
    (43) vecVal -> . ID m
    (23) funcInt -> . MULTIESCALAR ( vec , eMat , param )
    (24) funcInt -> . LENGTH ( vec )
    (26) funcBool -> . COLINEALES ( vec , vec )
    (66) exp -> . exp ^ iSing
    (67) exp -> . iSing
    (85) and -> . and AND eq
    (86) and -> . eq
    (68) iSing -> . - paren
    (69) iSing -> . + paren
    (70) iSing -> . paren
    (87) eq -> . eq EQEQ tBool
    (88) eq -> . eq DISTINTO tBool
    (89) eq -> . mayor
    (71) paren -> . ( eMat )
    (72) paren -> . INT
    (73) paren -> . varYVals
    (74) paren -> . FLOAT
    (75) paren -> . varsOps
    (76) paren -> . funcInt
    (90) mayor -> . tCompare > tCompare
    (91) mayor -> . menor
    (49) varsOps -> . MENOSMENOS varYVals
    (50) varsOps -> . MASMAS varYVals
    (51) varsOps -> . varYVals MASMAS
    (52) varsOps -> . varYVals MENOSMENOS
    (100) tCompare -> . eMat
    (101) tCompare -> . varsOps
    (102) tCompare -> . varYVals
    (92) menor -> . tCompare < tCompare
    (93) menor -> . not
    (94) not -> . NOT not
    (95) not -> . tBool
    (96) tBool -> . ( expBool )
    (97) tBool -> . BOOL
    (98) tBool -> . varYVals
    (99) tBool -> . funcBool

    ID              shift and go to state 93
    STRING          shift and go to state 91
    {               shift and go to state 97
    CAPITALIZAR     shift and go to state 25
    MULTIESCALAR    shift and go to state 23
    LENGTH          shift and go to state 26
    COLINEALES      shift and go to state 15
    -               shift and go to state 69
    +               shift and go to state 68
    (               shift and go to state 88
    INT             shift and go to state 75
    FLOAT           shift and go to state 76
    MENOSMENOS      shift and go to state 30
    MASMAS          shift and go to state 27
    NOT             shift and go to state 81
    BOOL            shift and go to state 70

    and                            shift and go to state 60
    funcBool                       shift and go to state 85
    funcInt                        shift and go to state 86
    menor                          shift and go to state 63
    eq                             shift and go to state 64
    vecVal                         shift and go to state 9
    eMat                           shift and go to state 87
    mayor                          shift and go to state 65
    paren                          shift and go to state 73
    reg                            shift and go to state 89
    varsOps                        shift and go to state 90
    expString                      shift and go to state 92
    tCompare                       shift and go to state 72
    not                            shift and go to state 74
    funcString                     shift and go to state 94
    funcReturn                     shift and go to state 95
    valores                        shift and go to state 96
    p                              shift and go to state 78
    iSing                          shift and go to state 71
    exp                            shift and go to state 80
    tBool                          shift and go to state 82
    varYVals                       shift and go to state 98
    or                             shift and go to state 77
    expBool                        shift and go to state 99

state 38

    (54) varAsig -> asig MULEQ . varAsig
    (53) varAsig -> . ID MULEQ varAsig
    (54) varAsig -> . asig MULEQ varAsig
    (55) varAsig -> . ID MULEQ valores
    (56) varAsig -> . asig
    (57) asig -> . ID = asig
    (58) asig -> . ID = valores

    ID              shift and go to state 101

    asig                           shift and go to state 12
    varAsig                        shift and go to state 100

state 39

    (26) funcBool -> COLINEALES ( . vec , vec )
    (31) vec -> . [ elem ]

    [               shift and go to state 103

    vec                            shift and go to state 102

state 40

    (12) loop -> FOR ( . varAsig ; expBool ; varsOps ) bloque
    (53) varAsig -> . ID MULEQ varAsig
    (54) varAsig -> . asig MULEQ varAsig
    (55) varAsig -> . ID MULEQ valores
    (56) varAsig -> . asig
    (57) asig -> . ID = asig
    (58) asig -> . ID = valores

    ID              shift and go to state 101

    varAsig                        shift and go to state 104
    asig                           shift and go to state 12

state 41

    (5) sentencia -> func ; .

    $end            reduce using rule 5 (sentencia -> func ; .)
    ;               reduce using rule 5 (sentencia -> func ; .)
    }               reduce using rule 5 (sentencia -> func ; .)


state 42

    (43) vecVal -> ID m .

    MASMAS          reduce using rule 43 (vecVal -> ID m .)
    MENOSMENOS      reduce using rule 43 (vecVal -> ID m .)
    >               reduce using rule 43 (vecVal -> ID m .)
    <               reduce using rule 43 (vecVal -> ID m .)
    EQEQ            reduce using rule 43 (vecVal -> ID m .)
    DISTINTO        reduce using rule 43 (vecVal -> ID m .)
    AND             reduce using rule 43 (vecVal -> ID m .)
    ?               reduce using rule 43 (vecVal -> ID m .)
    OR              reduce using rule 43 (vecVal -> ID m .)
    )               reduce using rule 43 (vecVal -> ID m .)
    ^               reduce using rule 43 (vecVal -> ID m .)
    *               reduce using rule 43 (vecVal -> ID m .)
    /               reduce using rule 43 (vecVal -> ID m .)
    %               reduce using rule 43 (vecVal -> ID m .)
    +               reduce using rule 43 (vecVal -> ID m .)
    -               reduce using rule 43 (vecVal -> ID m .)
    ;               reduce using rule 43 (vecVal -> ID m .)
    MULEQ           reduce using rule 43 (vecVal -> ID m .)
    }               reduce using rule 43 (vecVal -> ID m .)
    ,               reduce using rule 43 (vecVal -> ID m .)
    ]               reduce using rule 43 (vecVal -> ID m .)
    :               reduce using rule 43 (vecVal -> ID m .)


state 43

    (53) varAsig -> ID MULEQ . varAsig
    (55) varAsig -> ID MULEQ . valores
    (53) varAsig -> . ID MULEQ varAsig
    (54) varAsig -> . asig MULEQ varAsig
    (55) varAsig -> . ID MULEQ valores
    (56) varAsig -> . asig
    (34) valores -> . eMat
    (35) valores -> . expBool
    (36) valores -> . expString
    (37) valores -> . varYVals
    (38) valores -> . funcReturn
    (39) valores -> . reg
    (40) valores -> . ID . ID
    (57) asig -> . ID = asig
    (58) asig -> . ID = valores
    (59) eMat -> . eMat + p
    (60) eMat -> . eMat - p
    (61) eMat -> . p
    (81) expBool -> . or ? expBool : expBool
    (82) expBool -> . or
    (77) expString -> . expString + STRING
    (78) expString -> . STRING
    (79) expString -> . varYVals
    (80) expString -> . funcString
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (20) funcReturn -> . funcInt
    (21) funcReturn -> . funcString
    (22) funcReturn -> . funcBool
    (46) reg -> . { campos }
    (62) p -> . p * exp
    (63) p -> . p / exp
    (64) p -> . p % exp
    (65) p -> . exp
    (83) or -> . or OR and
    (84) or -> . and
    (25) funcString -> . CAPITALIZAR ( expString )
    (43) vecVal -> . ID m
    (23) funcInt -> . MULTIESCALAR ( vec , eMat , param )
    (24) funcInt -> . LENGTH ( vec )
    (26) funcBool -> . COLINEALES ( vec , vec )
    (66) exp -> . exp ^ iSing
    (67) exp -> . iSing
    (85) and -> . and AND eq
    (86) and -> . eq
    (68) iSing -> . - paren
    (69) iSing -> . + paren
    (70) iSing -> . paren
    (87) eq -> . eq EQEQ tBool
    (88) eq -> . eq DISTINTO tBool
    (89) eq -> . mayor
    (71) paren -> . ( eMat )
    (72) paren -> . INT
    (73) paren -> . varYVals
    (74) paren -> . FLOAT
    (75) paren -> . varsOps
    (76) paren -> . funcInt
    (90) mayor -> . tCompare > tCompare
    (91) mayor -> . menor
    (49) varsOps -> . MENOSMENOS varYVals
    (50) varsOps -> . MASMAS varYVals
    (51) varsOps -> . varYVals MASMAS
    (52) varsOps -> . varYVals MENOSMENOS
    (100) tCompare -> . eMat
    (101) tCompare -> . varsOps
    (102) tCompare -> . varYVals
    (92) menor -> . tCompare < tCompare
    (93) menor -> . not
    (94) not -> . NOT not
    (95) not -> . tBool
    (96) tBool -> . ( expBool )
    (97) tBool -> . BOOL
    (98) tBool -> . varYVals
    (99) tBool -> . funcBool

    ID              shift and go to state 105
    STRING          shift and go to state 91
    {               shift and go to state 97
    CAPITALIZAR     shift and go to state 25
    MULTIESCALAR    shift and go to state 23
    LENGTH          shift and go to state 26
    COLINEALES      shift and go to state 15
    -               shift and go to state 69
    +               shift and go to state 68
    (               shift and go to state 88
    INT             shift and go to state 75
    FLOAT           shift and go to state 76
    MENOSMENOS      shift and go to state 30
    MASMAS          shift and go to state 27
    NOT             shift and go to state 81
    BOOL            shift and go to state 70

    and                            shift and go to state 60
    funcBool                       shift and go to state 85
    funcInt                        shift and go to state 86
    menor                          shift and go to state 63
    eq                             shift and go to state 64
    vecVal                         shift and go to state 9
    eMat                           shift and go to state 87
    asig                           shift and go to state 12
    mayor                          shift and go to state 65
    paren                          shift and go to state 73
    reg                            shift and go to state 89
    varsOps                        shift and go to state 90
    expString                      shift and go to state 92
    tCompare                       shift and go to state 72
    not                            shift and go to state 74
    varAsig                        shift and go to state 106
    funcString                     shift and go to state 94
    funcReturn                     shift and go to state 95
    valores                        shift and go to state 107
    p                              shift and go to state 78
    iSing                          shift and go to state 71
    exp                            shift and go to state 80
    tBool                          shift and go to state 82
    varYVals                       shift and go to state 98
    or                             shift and go to state 77
    expBool                        shift and go to state 99

state 44

    (44) m -> [ . INT ]
    (45) m -> [ . INT ] m

    INT             shift and go to state 108


state 45

    (57) asig -> ID = . asig
    (58) asig -> ID = . valores
    (57) asig -> . ID = asig
    (58) asig -> . ID = valores
    (34) valores -> . eMat
    (35) valores -> . expBool
    (36) valores -> . expString
    (37) valores -> . varYVals
    (38) valores -> . funcReturn
    (39) valores -> . reg
    (40) valores -> . ID . ID
    (59) eMat -> . eMat + p
    (60) eMat -> . eMat - p
    (61) eMat -> . p
    (81) expBool -> . or ? expBool : expBool
    (82) expBool -> . or
    (77) expString -> . expString + STRING
    (78) expString -> . STRING
    (79) expString -> . varYVals
    (80) expString -> . funcString
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (20) funcReturn -> . funcInt
    (21) funcReturn -> . funcString
    (22) funcReturn -> . funcBool
    (46) reg -> . { campos }
    (62) p -> . p * exp
    (63) p -> . p / exp
    (64) p -> . p % exp
    (65) p -> . exp
    (83) or -> . or OR and
    (84) or -> . and
    (25) funcString -> . CAPITALIZAR ( expString )
    (43) vecVal -> . ID m
    (23) funcInt -> . MULTIESCALAR ( vec , eMat , param )
    (24) funcInt -> . LENGTH ( vec )
    (26) funcBool -> . COLINEALES ( vec , vec )
    (66) exp -> . exp ^ iSing
    (67) exp -> . iSing
    (85) and -> . and AND eq
    (86) and -> . eq
    (68) iSing -> . - paren
    (69) iSing -> . + paren
    (70) iSing -> . paren
    (87) eq -> . eq EQEQ tBool
    (88) eq -> . eq DISTINTO tBool
    (89) eq -> . mayor
    (71) paren -> . ( eMat )
    (72) paren -> . INT
    (73) paren -> . varYVals
    (74) paren -> . FLOAT
    (75) paren -> . varsOps
    (76) paren -> . funcInt
    (90) mayor -> . tCompare > tCompare
    (91) mayor -> . menor
    (49) varsOps -> . MENOSMENOS varYVals
    (50) varsOps -> . MASMAS varYVals
    (51) varsOps -> . varYVals MASMAS
    (52) varsOps -> . varYVals MENOSMENOS
    (100) tCompare -> . eMat
    (101) tCompare -> . varsOps
    (102) tCompare -> . varYVals
    (92) menor -> . tCompare < tCompare
    (93) menor -> . not
    (94) not -> . NOT not
    (95) not -> . tBool
    (96) tBool -> . ( expBool )
    (97) tBool -> . BOOL
    (98) tBool -> . varYVals
    (99) tBool -> . funcBool

    ID              shift and go to state 110
    STRING          shift and go to state 91
    {               shift and go to state 97
    CAPITALIZAR     shift and go to state 25
    MULTIESCALAR    shift and go to state 23
    LENGTH          shift and go to state 26
    COLINEALES      shift and go to state 15
    -               shift and go to state 69
    +               shift and go to state 68
    (               shift and go to state 88
    INT             shift and go to state 75
    FLOAT           shift and go to state 76
    MENOSMENOS      shift and go to state 30
    MASMAS          shift and go to state 27
    NOT             shift and go to state 81
    BOOL            shift and go to state 70

    and                            shift and go to state 60
    funcBool                       shift and go to state 85
    funcInt                        shift and go to state 86
    menor                          shift and go to state 63
    eq                             shift and go to state 64
    vecVal                         shift and go to state 9
    eMat                           shift and go to state 87
    asig                           shift and go to state 109
    mayor                          shift and go to state 65
    paren                          shift and go to state 73
    reg                            shift and go to state 89
    varsOps                        shift and go to state 90
    expString                      shift and go to state 92
    tCompare                       shift and go to state 72
    not                            shift and go to state 74
    funcString                     shift and go to state 94
    funcReturn                     shift and go to state 95
    valores                        shift and go to state 111
    p                              shift and go to state 78
    iSing                          shift and go to state 71
    exp                            shift and go to state 80
    tBool                          shift and go to state 82
    varYVals                       shift and go to state 98
    or                             shift and go to state 77
    expBool                        shift and go to state 99

state 46

    (13) if -> IF ( . expBool ) bloque else
    (81) expBool -> . or ? expBool : expBool
    (82) expBool -> . or
    (83) or -> . or OR and
    (84) or -> . and
    (85) and -> . and AND eq
    (86) and -> . eq
    (87) eq -> . eq EQEQ tBool
    (88) eq -> . eq DISTINTO tBool
    (89) eq -> . mayor
    (90) mayor -> . tCompare > tCompare
    (91) mayor -> . menor
    (100) tCompare -> . eMat
    (101) tCompare -> . varsOps
    (102) tCompare -> . varYVals
    (92) menor -> . tCompare < tCompare
    (93) menor -> . not
    (59) eMat -> . eMat + p
    (60) eMat -> . eMat - p
    (61) eMat -> . p
    (49) varsOps -> . MENOSMENOS varYVals
    (50) varsOps -> . MASMAS varYVals
    (51) varsOps -> . varYVals MASMAS
    (52) varsOps -> . varYVals MENOSMENOS
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (94) not -> . NOT not
    (95) not -> . tBool
    (62) p -> . p * exp
    (63) p -> . p / exp
    (64) p -> . p % exp
    (65) p -> . exp
    (43) vecVal -> . ID m
    (96) tBool -> . ( expBool )
    (97) tBool -> . BOOL
    (98) tBool -> . varYVals
    (99) tBool -> . funcBool
    (66) exp -> . exp ^ iSing
    (67) exp -> . iSing
    (26) funcBool -> . COLINEALES ( vec , vec )
    (68) iSing -> . - paren
    (69) iSing -> . + paren
    (70) iSing -> . paren
    (71) paren -> . ( eMat )
    (72) paren -> . INT
    (73) paren -> . varYVals
    (74) paren -> . FLOAT
    (75) paren -> . varsOps
    (76) paren -> . funcInt
    (23) funcInt -> . MULTIESCALAR ( vec , eMat , param )
    (24) funcInt -> . LENGTH ( vec )

    MENOSMENOS      shift and go to state 30
    MASMAS          shift and go to state 27
    ID              shift and go to state 52
    NOT             shift and go to state 81
    (               shift and go to state 67
    BOOL            shift and go to state 70
    COLINEALES      shift and go to state 15
    -               shift and go to state 69
    +               shift and go to state 68
    INT             shift and go to state 75
    FLOAT           shift and go to state 76
    MULTIESCALAR    shift and go to state 23
    LENGTH          shift and go to state 26

    and                            shift and go to state 60
    funcBool                       shift and go to state 61
    funcInt                        shift and go to state 62
    menor                          shift and go to state 63
    eq                             shift and go to state 64
    mayor                          shift and go to state 65
    eMat                           shift and go to state 66
    vecVal                         shift and go to state 9
    paren                          shift and go to state 73
    varsOps                        shift and go to state 79
    tCompare                       shift and go to state 72
    not                            shift and go to state 74
    p                              shift and go to state 78
    iSing                          shift and go to state 71
    exp                            shift and go to state 80
    tBool                          shift and go to state 82
    varYVals                       shift and go to state 83
    or                             shift and go to state 77
    expBool                        shift and go to state 112

state 47

    (6) sentencia -> varAsig ; .

    $end            reduce using rule 6 (sentencia -> varAsig ; .)
    ;               reduce using rule 6 (sentencia -> varAsig ; .)
    }               reduce using rule 6 (sentencia -> varAsig ; .)


state 48

    (23) funcInt -> MULTIESCALAR ( . vec , eMat , param )
    (31) vec -> . [ elem ]

    [               shift and go to state 103

    vec                            shift and go to state 113

state 49

    (25) funcString -> CAPITALIZAR ( . expString )
    (77) expString -> . expString + STRING
    (78) expString -> . STRING
    (79) expString -> . varYVals
    (80) expString -> . funcString
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (25) funcString -> . CAPITALIZAR ( expString )
    (43) vecVal -> . ID m

    STRING          shift and go to state 91
    ID              shift and go to state 52
    CAPITALIZAR     shift and go to state 25

    funcString                     shift and go to state 115
    varYVals                       shift and go to state 116
    vecVal                         shift and go to state 9
    expString                      shift and go to state 114

state 50

    (24) funcInt -> LENGTH ( . vec )
    (31) vec -> . [ elem ]

    [               shift and go to state 103

    vec                            shift and go to state 117

state 51

    (50) varsOps -> MASMAS varYVals .

    >               reduce using rule 50 (varsOps -> MASMAS varYVals .)
    <               reduce using rule 50 (varsOps -> MASMAS varYVals .)
    ^               reduce using rule 50 (varsOps -> MASMAS varYVals .)
    *               reduce using rule 50 (varsOps -> MASMAS varYVals .)
    /               reduce using rule 50 (varsOps -> MASMAS varYVals .)
    %               reduce using rule 50 (varsOps -> MASMAS varYVals .)
    +               reduce using rule 50 (varsOps -> MASMAS varYVals .)
    -               reduce using rule 50 (varsOps -> MASMAS varYVals .)
    )               reduce using rule 50 (varsOps -> MASMAS varYVals .)
    ;               reduce using rule 50 (varsOps -> MASMAS varYVals .)
    MULEQ           reduce using rule 50 (varsOps -> MASMAS varYVals .)
    }               reduce using rule 50 (varsOps -> MASMAS varYVals .)
    ,               reduce using rule 50 (varsOps -> MASMAS varYVals .)
    ]               reduce using rule 50 (varsOps -> MASMAS varYVals .)
    EQEQ            reduce using rule 50 (varsOps -> MASMAS varYVals .)
    DISTINTO        reduce using rule 50 (varsOps -> MASMAS varYVals .)
    AND             reduce using rule 50 (varsOps -> MASMAS varYVals .)
    ?               reduce using rule 50 (varsOps -> MASMAS varYVals .)
    OR              reduce using rule 50 (varsOps -> MASMAS varYVals .)
    :               reduce using rule 50 (varsOps -> MASMAS varYVals .)


state 52

    (41) varYVals -> ID .
    (43) vecVal -> ID . m
    (44) m -> . [ INT ]
    (45) m -> . [ INT ] m

    ;               reduce using rule 41 (varYVals -> ID .)
    >               reduce using rule 41 (varYVals -> ID .)
    <               reduce using rule 41 (varYVals -> ID .)
    ^               reduce using rule 41 (varYVals -> ID .)
    *               reduce using rule 41 (varYVals -> ID .)
    /               reduce using rule 41 (varYVals -> ID .)
    %               reduce using rule 41 (varYVals -> ID .)
    +               reduce using rule 41 (varYVals -> ID .)
    -               reduce using rule 41 (varYVals -> ID .)
    )               reduce using rule 41 (varYVals -> ID .)
    MULEQ           reduce using rule 41 (varYVals -> ID .)
    }               reduce using rule 41 (varYVals -> ID .)
    ,               reduce using rule 41 (varYVals -> ID .)
    ]               reduce using rule 41 (varYVals -> ID .)
    EQEQ            reduce using rule 41 (varYVals -> ID .)
    DISTINTO        reduce using rule 41 (varYVals -> ID .)
    AND             reduce using rule 41 (varYVals -> ID .)
    ?               reduce using rule 41 (varYVals -> ID .)
    OR              reduce using rule 41 (varYVals -> ID .)
    :               reduce using rule 41 (varYVals -> ID .)
    MASMAS          reduce using rule 41 (varYVals -> ID .)
    MENOSMENOS      reduce using rule 41 (varYVals -> ID .)
    [               shift and go to state 44

    m                              shift and go to state 42

state 53

    (4) sentencia -> varsOps ; .

    $end            reduce using rule 4 (sentencia -> varsOps ; .)
    ;               reduce using rule 4 (sentencia -> varsOps ; .)
    }               reduce using rule 4 (sentencia -> varsOps ; .)


state 54

    (51) varsOps -> varYVals MASMAS .

    >               reduce using rule 51 (varsOps -> varYVals MASMAS .)
    <               reduce using rule 51 (varsOps -> varYVals MASMAS .)
    ^               reduce using rule 51 (varsOps -> varYVals MASMAS .)
    *               reduce using rule 51 (varsOps -> varYVals MASMAS .)
    /               reduce using rule 51 (varsOps -> varYVals MASMAS .)
    %               reduce using rule 51 (varsOps -> varYVals MASMAS .)
    +               reduce using rule 51 (varsOps -> varYVals MASMAS .)
    -               reduce using rule 51 (varsOps -> varYVals MASMAS .)
    )               reduce using rule 51 (varsOps -> varYVals MASMAS .)
    ;               reduce using rule 51 (varsOps -> varYVals MASMAS .)
    MULEQ           reduce using rule 51 (varsOps -> varYVals MASMAS .)
    }               reduce using rule 51 (varsOps -> varYVals MASMAS .)
    ,               reduce using rule 51 (varsOps -> varYVals MASMAS .)
    ]               reduce using rule 51 (varsOps -> varYVals MASMAS .)
    EQEQ            reduce using rule 51 (varsOps -> varYVals MASMAS .)
    DISTINTO        reduce using rule 51 (varsOps -> varYVals MASMAS .)
    AND             reduce using rule 51 (varsOps -> varYVals MASMAS .)
    ?               reduce using rule 51 (varsOps -> varYVals MASMAS .)
    OR              reduce using rule 51 (varsOps -> varYVals MASMAS .)
    :               reduce using rule 51 (varsOps -> varYVals MASMAS .)


state 55

    (52) varsOps -> varYVals MENOSMENOS .

    >               reduce using rule 52 (varsOps -> varYVals MENOSMENOS .)
    <               reduce using rule 52 (varsOps -> varYVals MENOSMENOS .)
    ^               reduce using rule 52 (varsOps -> varYVals MENOSMENOS .)
    *               reduce using rule 52 (varsOps -> varYVals MENOSMENOS .)
    /               reduce using rule 52 (varsOps -> varYVals MENOSMENOS .)
    %               reduce using rule 52 (varsOps -> varYVals MENOSMENOS .)
    +               reduce using rule 52 (varsOps -> varYVals MENOSMENOS .)
    -               reduce using rule 52 (varsOps -> varYVals MENOSMENOS .)
    )               reduce using rule 52 (varsOps -> varYVals MENOSMENOS .)
    ;               reduce using rule 52 (varsOps -> varYVals MENOSMENOS .)
    MULEQ           reduce using rule 52 (varsOps -> varYVals MENOSMENOS .)
    }               reduce using rule 52 (varsOps -> varYVals MENOSMENOS .)
    ,               reduce using rule 52 (varsOps -> varYVals MENOSMENOS .)
    ]               reduce using rule 52 (varsOps -> varYVals MENOSMENOS .)
    EQEQ            reduce using rule 52 (varsOps -> varYVals MENOSMENOS .)
    DISTINTO        reduce using rule 52 (varsOps -> varYVals MENOSMENOS .)
    AND             reduce using rule 52 (varsOps -> varYVals MENOSMENOS .)
    ?               reduce using rule 52 (varsOps -> varYVals MENOSMENOS .)
    OR              reduce using rule 52 (varsOps -> varYVals MENOSMENOS .)
    :               reduce using rule 52 (varsOps -> varYVals MENOSMENOS .)


state 56

    (49) varsOps -> MENOSMENOS varYVals .

    >               reduce using rule 49 (varsOps -> MENOSMENOS varYVals .)
    <               reduce using rule 49 (varsOps -> MENOSMENOS varYVals .)
    ^               reduce using rule 49 (varsOps -> MENOSMENOS varYVals .)
    *               reduce using rule 49 (varsOps -> MENOSMENOS varYVals .)
    /               reduce using rule 49 (varsOps -> MENOSMENOS varYVals .)
    %               reduce using rule 49 (varsOps -> MENOSMENOS varYVals .)
    +               reduce using rule 49 (varsOps -> MENOSMENOS varYVals .)
    -               reduce using rule 49 (varsOps -> MENOSMENOS varYVals .)
    )               reduce using rule 49 (varsOps -> MENOSMENOS varYVals .)
    ;               reduce using rule 49 (varsOps -> MENOSMENOS varYVals .)
    MULEQ           reduce using rule 49 (varsOps -> MENOSMENOS varYVals .)
    }               reduce using rule 49 (varsOps -> MENOSMENOS varYVals .)
    ,               reduce using rule 49 (varsOps -> MENOSMENOS varYVals .)
    ]               reduce using rule 49 (varsOps -> MENOSMENOS varYVals .)
    EQEQ            reduce using rule 49 (varsOps -> MENOSMENOS varYVals .)
    DISTINTO        reduce using rule 49 (varsOps -> MENOSMENOS varYVals .)
    AND             reduce using rule 49 (varsOps -> MENOSMENOS varYVals .)
    ?               reduce using rule 49 (varsOps -> MENOSMENOS varYVals .)
    OR              reduce using rule 49 (varsOps -> MENOSMENOS varYVals .)
    :               reduce using rule 49 (varsOps -> MENOSMENOS varYVals .)


state 57

    (11) loop -> DO bloque WHILE . ( expBool ) ;

    (               shift and go to state 118


state 58

    (16) bloque -> sentencia ; .

    RETURN          reduce using rule 16 (bloque -> sentencia ; .)
    MENOSMENOS      reduce using rule 16 (bloque -> sentencia ; .)
    MASMAS          reduce using rule 16 (bloque -> sentencia ; .)
    ID              reduce using rule 16 (bloque -> sentencia ; .)
    IF              reduce using rule 16 (bloque -> sentencia ; .)
    WHILE           reduce using rule 16 (bloque -> sentencia ; .)
    DO              reduce using rule 16 (bloque -> sentencia ; .)
    FOR             reduce using rule 16 (bloque -> sentencia ; .)
    PRINT           reduce using rule 16 (bloque -> sentencia ; .)
    MULTIESCALAR    reduce using rule 16 (bloque -> sentencia ; .)
    LENGTH          reduce using rule 16 (bloque -> sentencia ; .)
    CAPITALIZAR     reduce using rule 16 (bloque -> sentencia ; .)
    COLINEALES      reduce using rule 16 (bloque -> sentencia ; .)
    $end            reduce using rule 16 (bloque -> sentencia ; .)
    }               reduce using rule 16 (bloque -> sentencia ; .)
    ELSE            reduce using rule 16 (bloque -> sentencia ; .)


state 59

    (17) bloque -> { g . }

    }               shift and go to state 119


state 60

    (84) or -> and .
    (85) and -> and . AND eq

    ?               reduce using rule 84 (or -> and .)
    OR              reduce using rule 84 (or -> and .)
    )               reduce using rule 84 (or -> and .)
    }               reduce using rule 84 (or -> and .)
    :               reduce using rule 84 (or -> and .)
    ,               reduce using rule 84 (or -> and .)
    ]               reduce using rule 84 (or -> and .)
    ;               reduce using rule 84 (or -> and .)
    MULEQ           reduce using rule 84 (or -> and .)
    AND             shift and go to state 120


state 61

    (99) tBool -> funcBool .

    EQEQ            reduce using rule 99 (tBool -> funcBool .)
    DISTINTO        reduce using rule 99 (tBool -> funcBool .)
    AND             reduce using rule 99 (tBool -> funcBool .)
    ?               reduce using rule 99 (tBool -> funcBool .)
    OR              reduce using rule 99 (tBool -> funcBool .)
    )               reduce using rule 99 (tBool -> funcBool .)
    ;               reduce using rule 99 (tBool -> funcBool .)
    MULEQ           reduce using rule 99 (tBool -> funcBool .)
    }               reduce using rule 99 (tBool -> funcBool .)
    ,               reduce using rule 99 (tBool -> funcBool .)
    ]               reduce using rule 99 (tBool -> funcBool .)
    :               reduce using rule 99 (tBool -> funcBool .)


state 62

    (76) paren -> funcInt .

    ^               reduce using rule 76 (paren -> funcInt .)
    *               reduce using rule 76 (paren -> funcInt .)
    /               reduce using rule 76 (paren -> funcInt .)
    %               reduce using rule 76 (paren -> funcInt .)
    )               reduce using rule 76 (paren -> funcInt .)
    +               reduce using rule 76 (paren -> funcInt .)
    -               reduce using rule 76 (paren -> funcInt .)
    >               reduce using rule 76 (paren -> funcInt .)
    <               reduce using rule 76 (paren -> funcInt .)
    ,               reduce using rule 76 (paren -> funcInt .)
    ;               reduce using rule 76 (paren -> funcInt .)
    MULEQ           reduce using rule 76 (paren -> funcInt .)
    }               reduce using rule 76 (paren -> funcInt .)
    ]               reduce using rule 76 (paren -> funcInt .)
    EQEQ            reduce using rule 76 (paren -> funcInt .)
    DISTINTO        reduce using rule 76 (paren -> funcInt .)
    AND             reduce using rule 76 (paren -> funcInt .)
    ?               reduce using rule 76 (paren -> funcInt .)
    OR              reduce using rule 76 (paren -> funcInt .)
    :               reduce using rule 76 (paren -> funcInt .)


state 63

    (91) mayor -> menor .

    EQEQ            reduce using rule 91 (mayor -> menor .)
    DISTINTO        reduce using rule 91 (mayor -> menor .)
    AND             reduce using rule 91 (mayor -> menor .)
    ?               reduce using rule 91 (mayor -> menor .)
    OR              reduce using rule 91 (mayor -> menor .)
    )               reduce using rule 91 (mayor -> menor .)
    :               reduce using rule 91 (mayor -> menor .)
    }               reduce using rule 91 (mayor -> menor .)
    ;               reduce using rule 91 (mayor -> menor .)
    MULEQ           reduce using rule 91 (mayor -> menor .)
    ,               reduce using rule 91 (mayor -> menor .)
    ]               reduce using rule 91 (mayor -> menor .)


state 64

    (86) and -> eq .
    (87) eq -> eq . EQEQ tBool
    (88) eq -> eq . DISTINTO tBool

    AND             reduce using rule 86 (and -> eq .)
    ?               reduce using rule 86 (and -> eq .)
    OR              reduce using rule 86 (and -> eq .)
    ,               reduce using rule 86 (and -> eq .)
    ]               reduce using rule 86 (and -> eq .)
    }               reduce using rule 86 (and -> eq .)
    )               reduce using rule 86 (and -> eq .)
    ;               reduce using rule 86 (and -> eq .)
    MULEQ           reduce using rule 86 (and -> eq .)
    :               reduce using rule 86 (and -> eq .)
    EQEQ            shift and go to state 121
    DISTINTO        shift and go to state 122


state 65

    (89) eq -> mayor .

    EQEQ            reduce using rule 89 (eq -> mayor .)
    DISTINTO        reduce using rule 89 (eq -> mayor .)
    AND             reduce using rule 89 (eq -> mayor .)
    ?               reduce using rule 89 (eq -> mayor .)
    OR              reduce using rule 89 (eq -> mayor .)
    )               reduce using rule 89 (eq -> mayor .)
    ,               reduce using rule 89 (eq -> mayor .)
    :               reduce using rule 89 (eq -> mayor .)
    ]               reduce using rule 89 (eq -> mayor .)
    ;               reduce using rule 89 (eq -> mayor .)
    MULEQ           reduce using rule 89 (eq -> mayor .)
    }               reduce using rule 89 (eq -> mayor .)


state 66

    (100) tCompare -> eMat .
    (59) eMat -> eMat . + p
    (60) eMat -> eMat . - p

    EQEQ            reduce using rule 100 (tCompare -> eMat .)
    DISTINTO        reduce using rule 100 (tCompare -> eMat .)
    AND             reduce using rule 100 (tCompare -> eMat .)
    ?               reduce using rule 100 (tCompare -> eMat .)
    OR              reduce using rule 100 (tCompare -> eMat .)
    )               reduce using rule 100 (tCompare -> eMat .)
    ;               reduce using rule 100 (tCompare -> eMat .)
    MULEQ           reduce using rule 100 (tCompare -> eMat .)
    }               reduce using rule 100 (tCompare -> eMat .)
    ,               reduce using rule 100 (tCompare -> eMat .)
    ]               reduce using rule 100 (tCompare -> eMat .)
    :               reduce using rule 100 (tCompare -> eMat .)
    >               reduce using rule 100 (tCompare -> eMat .)
    <               reduce using rule 100 (tCompare -> eMat .)
    +               shift and go to state 123
    -               shift and go to state 124


state 67

    (96) tBool -> ( . expBool )
    (71) paren -> ( . eMat )
    (81) expBool -> . or ? expBool : expBool
    (82) expBool -> . or
    (59) eMat -> . eMat + p
    (60) eMat -> . eMat - p
    (61) eMat -> . p
    (83) or -> . or OR and
    (84) or -> . and
    (62) p -> . p * exp
    (63) p -> . p / exp
    (64) p -> . p % exp
    (65) p -> . exp
    (85) and -> . and AND eq
    (86) and -> . eq
    (66) exp -> . exp ^ iSing
    (67) exp -> . iSing
    (87) eq -> . eq EQEQ tBool
    (88) eq -> . eq DISTINTO tBool
    (89) eq -> . mayor
    (68) iSing -> . - paren
    (69) iSing -> . + paren
    (70) iSing -> . paren
    (90) mayor -> . tCompare > tCompare
    (91) mayor -> . menor
    (71) paren -> . ( eMat )
    (72) paren -> . INT
    (73) paren -> . varYVals
    (74) paren -> . FLOAT
    (75) paren -> . varsOps
    (76) paren -> . funcInt
    (100) tCompare -> . eMat
    (101) tCompare -> . varsOps
    (102) tCompare -> . varYVals
    (92) menor -> . tCompare < tCompare
    (93) menor -> . not
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (49) varsOps -> . MENOSMENOS varYVals
    (50) varsOps -> . MASMAS varYVals
    (51) varsOps -> . varYVals MASMAS
    (52) varsOps -> . varYVals MENOSMENOS
    (23) funcInt -> . MULTIESCALAR ( vec , eMat , param )
    (24) funcInt -> . LENGTH ( vec )
    (94) not -> . NOT not
    (95) not -> . tBool
    (43) vecVal -> . ID m
    (96) tBool -> . ( expBool )
    (97) tBool -> . BOOL
    (98) tBool -> . varYVals
    (99) tBool -> . funcBool
    (26) funcBool -> . COLINEALES ( vec , vec )

    -               shift and go to state 69
    +               shift and go to state 68
    (               shift and go to state 88
    INT             shift and go to state 75
    FLOAT           shift and go to state 76
    ID              shift and go to state 52
    MENOSMENOS      shift and go to state 30
    MASMAS          shift and go to state 27
    MULTIESCALAR    shift and go to state 23
    LENGTH          shift and go to state 26
    NOT             shift and go to state 81
    BOOL            shift and go to state 70
    COLINEALES      shift and go to state 15

    and                            shift and go to state 60
    funcBool                       shift and go to state 61
    funcInt                        shift and go to state 62
    menor                          shift and go to state 63
    eq                             shift and go to state 64
    mayor                          shift and go to state 65
    eMat                           shift and go to state 125
    vecVal                         shift and go to state 9
    paren                          shift and go to state 73
    varsOps                        shift and go to state 90
    tCompare                       shift and go to state 72
    not                            shift and go to state 74
    p                              shift and go to state 78
    iSing                          shift and go to state 71
    exp                            shift and go to state 80
    tBool                          shift and go to state 82
    varYVals                       shift and go to state 126
    or                             shift and go to state 77
    expBool                        shift and go to state 127

state 68

    (69) iSing -> + . paren
    (71) paren -> . ( eMat )
    (72) paren -> . INT
    (73) paren -> . varYVals
    (74) paren -> . FLOAT
    (75) paren -> . varsOps
    (76) paren -> . funcInt
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (49) varsOps -> . MENOSMENOS varYVals
    (50) varsOps -> . MASMAS varYVals
    (51) varsOps -> . varYVals MASMAS
    (52) varsOps -> . varYVals MENOSMENOS
    (23) funcInt -> . MULTIESCALAR ( vec , eMat , param )
    (24) funcInt -> . LENGTH ( vec )
    (43) vecVal -> . ID m

    (               shift and go to state 128
    INT             shift and go to state 75
    FLOAT           shift and go to state 76
    ID              shift and go to state 52
    MENOSMENOS      shift and go to state 30
    MASMAS          shift and go to state 27
    MULTIESCALAR    shift and go to state 23
    LENGTH          shift and go to state 26

    funcInt                        shift and go to state 62
    varsOps                        shift and go to state 129
    paren                          shift and go to state 130
    varYVals                       shift and go to state 131
    vecVal                         shift and go to state 9

state 69

    (68) iSing -> - . paren
    (71) paren -> . ( eMat )
    (72) paren -> . INT
    (73) paren -> . varYVals
    (74) paren -> . FLOAT
    (75) paren -> . varsOps
    (76) paren -> . funcInt
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (49) varsOps -> . MENOSMENOS varYVals
    (50) varsOps -> . MASMAS varYVals
    (51) varsOps -> . varYVals MASMAS
    (52) varsOps -> . varYVals MENOSMENOS
    (23) funcInt -> . MULTIESCALAR ( vec , eMat , param )
    (24) funcInt -> . LENGTH ( vec )
    (43) vecVal -> . ID m

    (               shift and go to state 128
    INT             shift and go to state 75
    FLOAT           shift and go to state 76
    ID              shift and go to state 52
    MENOSMENOS      shift and go to state 30
    MASMAS          shift and go to state 27
    MULTIESCALAR    shift and go to state 23
    LENGTH          shift and go to state 26

    funcInt                        shift and go to state 62
    varsOps                        shift and go to state 129
    paren                          shift and go to state 132
    varYVals                       shift and go to state 131
    vecVal                         shift and go to state 9

state 70

    (97) tBool -> BOOL .

    EQEQ            reduce using rule 97 (tBool -> BOOL .)
    DISTINTO        reduce using rule 97 (tBool -> BOOL .)
    AND             reduce using rule 97 (tBool -> BOOL .)
    ?               reduce using rule 97 (tBool -> BOOL .)
    OR              reduce using rule 97 (tBool -> BOOL .)
    ,               reduce using rule 97 (tBool -> BOOL .)
    )               reduce using rule 97 (tBool -> BOOL .)
    ;               reduce using rule 97 (tBool -> BOOL .)
    MULEQ           reduce using rule 97 (tBool -> BOOL .)
    }               reduce using rule 97 (tBool -> BOOL .)
    ]               reduce using rule 97 (tBool -> BOOL .)
    :               reduce using rule 97 (tBool -> BOOL .)


state 71

    (67) exp -> iSing .

    ^               reduce using rule 67 (exp -> iSing .)
    *               reduce using rule 67 (exp -> iSing .)
    /               reduce using rule 67 (exp -> iSing .)
    %               reduce using rule 67 (exp -> iSing .)
    +               reduce using rule 67 (exp -> iSing .)
    -               reduce using rule 67 (exp -> iSing .)
    ,               reduce using rule 67 (exp -> iSing .)
    ]               reduce using rule 67 (exp -> iSing .)
    >               reduce using rule 67 (exp -> iSing .)
    <               reduce using rule 67 (exp -> iSing .)
    }               reduce using rule 67 (exp -> iSing .)
    )               reduce using rule 67 (exp -> iSing .)
    ;               reduce using rule 67 (exp -> iSing .)
    MULEQ           reduce using rule 67 (exp -> iSing .)
    EQEQ            reduce using rule 67 (exp -> iSing .)
    DISTINTO        reduce using rule 67 (exp -> iSing .)
    AND             reduce using rule 67 (exp -> iSing .)
    ?               reduce using rule 67 (exp -> iSing .)
    OR              reduce using rule 67 (exp -> iSing .)
    :               reduce using rule 67 (exp -> iSing .)


state 72

    (90) mayor -> tCompare . > tCompare
    (92) menor -> tCompare . < tCompare

    >               shift and go to state 134
    <               shift and go to state 133


state 73

    (70) iSing -> paren .

    ^               reduce using rule 70 (iSing -> paren .)
    *               reduce using rule 70 (iSing -> paren .)
    /               reduce using rule 70 (iSing -> paren .)
    %               reduce using rule 70 (iSing -> paren .)
    +               reduce using rule 70 (iSing -> paren .)
    -               reduce using rule 70 (iSing -> paren .)
    >               reduce using rule 70 (iSing -> paren .)
    <               reduce using rule 70 (iSing -> paren .)
    )               reduce using rule 70 (iSing -> paren .)
    ;               reduce using rule 70 (iSing -> paren .)
    MULEQ           reduce using rule 70 (iSing -> paren .)
    }               reduce using rule 70 (iSing -> paren .)
    ,               reduce using rule 70 (iSing -> paren .)
    ]               reduce using rule 70 (iSing -> paren .)
    EQEQ            reduce using rule 70 (iSing -> paren .)
    DISTINTO        reduce using rule 70 (iSing -> paren .)
    AND             reduce using rule 70 (iSing -> paren .)
    ?               reduce using rule 70 (iSing -> paren .)
    OR              reduce using rule 70 (iSing -> paren .)
    :               reduce using rule 70 (iSing -> paren .)


state 74

    (93) menor -> not .

    EQEQ            reduce using rule 93 (menor -> not .)
    DISTINTO        reduce using rule 93 (menor -> not .)
    AND             reduce using rule 93 (menor -> not .)
    ?               reduce using rule 93 (menor -> not .)
    OR              reduce using rule 93 (menor -> not .)
    }               reduce using rule 93 (menor -> not .)
    )               reduce using rule 93 (menor -> not .)
    ;               reduce using rule 93 (menor -> not .)
    MULEQ           reduce using rule 93 (menor -> not .)
    ,               reduce using rule 93 (menor -> not .)
    ]               reduce using rule 93 (menor -> not .)
    :               reduce using rule 93 (menor -> not .)


state 75

    (72) paren -> INT .

    ^               reduce using rule 72 (paren -> INT .)
    *               reduce using rule 72 (paren -> INT .)
    /               reduce using rule 72 (paren -> INT .)
    %               reduce using rule 72 (paren -> INT .)
    )               reduce using rule 72 (paren -> INT .)
    +               reduce using rule 72 (paren -> INT .)
    -               reduce using rule 72 (paren -> INT .)
    >               reduce using rule 72 (paren -> INT .)
    <               reduce using rule 72 (paren -> INT .)
    ,               reduce using rule 72 (paren -> INT .)
    ;               reduce using rule 72 (paren -> INT .)
    MULEQ           reduce using rule 72 (paren -> INT .)
    }               reduce using rule 72 (paren -> INT .)
    ]               reduce using rule 72 (paren -> INT .)
    EQEQ            reduce using rule 72 (paren -> INT .)
    DISTINTO        reduce using rule 72 (paren -> INT .)
    AND             reduce using rule 72 (paren -> INT .)
    ?               reduce using rule 72 (paren -> INT .)
    OR              reduce using rule 72 (paren -> INT .)
    :               reduce using rule 72 (paren -> INT .)


state 76

    (74) paren -> FLOAT .

    ^               reduce using rule 74 (paren -> FLOAT .)
    *               reduce using rule 74 (paren -> FLOAT .)
    /               reduce using rule 74 (paren -> FLOAT .)
    %               reduce using rule 74 (paren -> FLOAT .)
    )               reduce using rule 74 (paren -> FLOAT .)
    +               reduce using rule 74 (paren -> FLOAT .)
    -               reduce using rule 74 (paren -> FLOAT .)
    >               reduce using rule 74 (paren -> FLOAT .)
    <               reduce using rule 74 (paren -> FLOAT .)
    ,               reduce using rule 74 (paren -> FLOAT .)
    ;               reduce using rule 74 (paren -> FLOAT .)
    MULEQ           reduce using rule 74 (paren -> FLOAT .)
    }               reduce using rule 74 (paren -> FLOAT .)
    ]               reduce using rule 74 (paren -> FLOAT .)
    EQEQ            reduce using rule 74 (paren -> FLOAT .)
    DISTINTO        reduce using rule 74 (paren -> FLOAT .)
    AND             reduce using rule 74 (paren -> FLOAT .)
    ?               reduce using rule 74 (paren -> FLOAT .)
    OR              reduce using rule 74 (paren -> FLOAT .)
    :               reduce using rule 74 (paren -> FLOAT .)


state 77

    (81) expBool -> or . ? expBool : expBool
    (82) expBool -> or .
    (83) or -> or . OR and

    ?               shift and go to state 136
    }               reduce using rule 82 (expBool -> or .)
    )               reduce using rule 82 (expBool -> or .)
    ,               reduce using rule 82 (expBool -> or .)
    ]               reduce using rule 82 (expBool -> or .)
    ;               reduce using rule 82 (expBool -> or .)
    MULEQ           reduce using rule 82 (expBool -> or .)
    :               reduce using rule 82 (expBool -> or .)
    OR              shift and go to state 135


state 78

    (61) eMat -> p .
    (62) p -> p . * exp
    (63) p -> p . / exp
    (64) p -> p . % exp

    +               reduce using rule 61 (eMat -> p .)
    -               reduce using rule 61 (eMat -> p .)
    ,               reduce using rule 61 (eMat -> p .)
    >               reduce using rule 61 (eMat -> p .)
    <               reduce using rule 61 (eMat -> p .)
    MULEQ           reduce using rule 61 (eMat -> p .)
    ;               reduce using rule 61 (eMat -> p .)
    )               reduce using rule 61 (eMat -> p .)
    EQEQ            reduce using rule 61 (eMat -> p .)
    DISTINTO        reduce using rule 61 (eMat -> p .)
    AND             reduce using rule 61 (eMat -> p .)
    ?               reduce using rule 61 (eMat -> p .)
    OR              reduce using rule 61 (eMat -> p .)
    }               reduce using rule 61 (eMat -> p .)
    ]               reduce using rule 61 (eMat -> p .)
    :               reduce using rule 61 (eMat -> p .)
    *               shift and go to state 137
    /               shift and go to state 139
    %               shift and go to state 138


state 79

    (101) tCompare -> varsOps .
    (75) paren -> varsOps .

  ! reduce/reduce conflict for > resolved using rule 75 (paren -> varsOps .)
  ! reduce/reduce conflict for < resolved using rule 75 (paren -> varsOps .)
  ! reduce/reduce conflict for EQEQ resolved using rule 75 (paren -> varsOps .)
  ! reduce/reduce conflict for DISTINTO resolved using rule 75 (paren -> varsOps .)
  ! reduce/reduce conflict for AND resolved using rule 75 (paren -> varsOps .)
  ! reduce/reduce conflict for ? resolved using rule 75 (paren -> varsOps .)
  ! reduce/reduce conflict for OR resolved using rule 75 (paren -> varsOps .)
  ! reduce/reduce conflict for ) resolved using rule 75 (paren -> varsOps .)
  ! reduce/reduce conflict for ; resolved using rule 75 (paren -> varsOps .)
  ! reduce/reduce conflict for MULEQ resolved using rule 75 (paren -> varsOps .)
  ! reduce/reduce conflict for } resolved using rule 75 (paren -> varsOps .)
  ! reduce/reduce conflict for , resolved using rule 75 (paren -> varsOps .)
  ! reduce/reduce conflict for ] resolved using rule 75 (paren -> varsOps .)
  ! reduce/reduce conflict for : resolved using rule 75 (paren -> varsOps .)
    ^               reduce using rule 75 (paren -> varsOps .)
    *               reduce using rule 75 (paren -> varsOps .)
    /               reduce using rule 75 (paren -> varsOps .)
    %               reduce using rule 75 (paren -> varsOps .)
    +               reduce using rule 75 (paren -> varsOps .)
    -               reduce using rule 75 (paren -> varsOps .)
    >               reduce using rule 75 (paren -> varsOps .)
    <               reduce using rule 75 (paren -> varsOps .)
    EQEQ            reduce using rule 75 (paren -> varsOps .)
    DISTINTO        reduce using rule 75 (paren -> varsOps .)
    AND             reduce using rule 75 (paren -> varsOps .)
    ?               reduce using rule 75 (paren -> varsOps .)
    OR              reduce using rule 75 (paren -> varsOps .)
    )               reduce using rule 75 (paren -> varsOps .)
    ;               reduce using rule 75 (paren -> varsOps .)
    MULEQ           reduce using rule 75 (paren -> varsOps .)
    }               reduce using rule 75 (paren -> varsOps .)
    ,               reduce using rule 75 (paren -> varsOps .)
    ]               reduce using rule 75 (paren -> varsOps .)
    :               reduce using rule 75 (paren -> varsOps .)

  ! EQEQ            [ reduce using rule 101 (tCompare -> varsOps .) ]
  ! DISTINTO        [ reduce using rule 101 (tCompare -> varsOps .) ]
  ! AND             [ reduce using rule 101 (tCompare -> varsOps .) ]
  ! ?               [ reduce using rule 101 (tCompare -> varsOps .) ]
  ! OR              [ reduce using rule 101 (tCompare -> varsOps .) ]
  ! )               [ reduce using rule 101 (tCompare -> varsOps .) ]
  ! ;               [ reduce using rule 101 (tCompare -> varsOps .) ]
  ! MULEQ           [ reduce using rule 101 (tCompare -> varsOps .) ]
  ! }               [ reduce using rule 101 (tCompare -> varsOps .) ]
  ! ,               [ reduce using rule 101 (tCompare -> varsOps .) ]
  ! ]               [ reduce using rule 101 (tCompare -> varsOps .) ]
  ! :               [ reduce using rule 101 (tCompare -> varsOps .) ]
  ! >               [ reduce using rule 101 (tCompare -> varsOps .) ]
  ! <               [ reduce using rule 101 (tCompare -> varsOps .) ]


state 80

    (65) p -> exp .
    (66) exp -> exp . ^ iSing

    *               reduce using rule 65 (p -> exp .)
    /               reduce using rule 65 (p -> exp .)
    %               reduce using rule 65 (p -> exp .)
    +               reduce using rule 65 (p -> exp .)
    -               reduce using rule 65 (p -> exp .)
    >               reduce using rule 65 (p -> exp .)
    <               reduce using rule 65 (p -> exp .)
    )               reduce using rule 65 (p -> exp .)
    ;               reduce using rule 65 (p -> exp .)
    }               reduce using rule 65 (p -> exp .)
    ,               reduce using rule 65 (p -> exp .)
    MULEQ           reduce using rule 65 (p -> exp .)
    ]               reduce using rule 65 (p -> exp .)
    EQEQ            reduce using rule 65 (p -> exp .)
    DISTINTO        reduce using rule 65 (p -> exp .)
    AND             reduce using rule 65 (p -> exp .)
    ?               reduce using rule 65 (p -> exp .)
    OR              reduce using rule 65 (p -> exp .)
    :               reduce using rule 65 (p -> exp .)
    ^               shift and go to state 140


state 81

    (94) not -> NOT . not
    (94) not -> . NOT not
    (95) not -> . tBool
    (96) tBool -> . ( expBool )
    (97) tBool -> . BOOL
    (98) tBool -> . varYVals
    (99) tBool -> . funcBool
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (26) funcBool -> . COLINEALES ( vec , vec )
    (43) vecVal -> . ID m

    NOT             shift and go to state 81
    (               shift and go to state 141
    BOOL            shift and go to state 70
    ID              shift and go to state 52
    COLINEALES      shift and go to state 15

    funcBool                       shift and go to state 61
    not                            shift and go to state 142
    tBool                          shift and go to state 82
    varYVals                       shift and go to state 143
    vecVal                         shift and go to state 9

state 82

    (95) not -> tBool .

    EQEQ            reduce using rule 95 (not -> tBool .)
    DISTINTO        reduce using rule 95 (not -> tBool .)
    AND             reduce using rule 95 (not -> tBool .)
    ?               reduce using rule 95 (not -> tBool .)
    OR              reduce using rule 95 (not -> tBool .)
    MULEQ           reduce using rule 95 (not -> tBool .)
    ;               reduce using rule 95 (not -> tBool .)
    )               reduce using rule 95 (not -> tBool .)
    }               reduce using rule 95 (not -> tBool .)
    ,               reduce using rule 95 (not -> tBool .)
    ]               reduce using rule 95 (not -> tBool .)
    :               reduce using rule 95 (not -> tBool .)


state 83

    (102) tCompare -> varYVals .
    (51) varsOps -> varYVals . MASMAS
    (52) varsOps -> varYVals . MENOSMENOS
    (98) tBool -> varYVals .
    (73) paren -> varYVals .

  ! reduce/reduce conflict for > resolved using rule 73 (paren -> varYVals .)
  ! reduce/reduce conflict for < resolved using rule 73 (paren -> varYVals .)
    MASMAS          shift and go to state 54
    MENOSMENOS      shift and go to state 55
    EQEQ            reduce using rule 98 (tBool -> varYVals .)
    DISTINTO        reduce using rule 98 (tBool -> varYVals .)
    AND             reduce using rule 98 (tBool -> varYVals .)
    ?               reduce using rule 98 (tBool -> varYVals .)
    OR              reduce using rule 98 (tBool -> varYVals .)
    )               reduce using rule 98 (tBool -> varYVals .)
    ;               reduce using rule 98 (tBool -> varYVals .)
    MULEQ           reduce using rule 98 (tBool -> varYVals .)
    }               reduce using rule 98 (tBool -> varYVals .)
    ,               reduce using rule 98 (tBool -> varYVals .)
    ]               reduce using rule 98 (tBool -> varYVals .)
    :               reduce using rule 98 (tBool -> varYVals .)
    ^               reduce using rule 73 (paren -> varYVals .)
    *               reduce using rule 73 (paren -> varYVals .)
    /               reduce using rule 73 (paren -> varYVals .)
    %               reduce using rule 73 (paren -> varYVals .)
    +               reduce using rule 73 (paren -> varYVals .)
    -               reduce using rule 73 (paren -> varYVals .)
    >               reduce using rule 73 (paren -> varYVals .)
    <               reduce using rule 73 (paren -> varYVals .)

  ! >               [ reduce using rule 102 (tCompare -> varYVals .) ]
  ! <               [ reduce using rule 102 (tCompare -> varYVals .) ]


state 84

    (10) loop -> WHILE ( expBool . ) bloque

    )               shift and go to state 144


state 85

    (22) funcReturn -> funcBool .
    (99) tBool -> funcBool .

  ! reduce/reduce conflict for , resolved using rule 22 (funcReturn -> funcBool .)
  ! reduce/reduce conflict for ] resolved using rule 22 (funcReturn -> funcBool .)
  ! reduce/reduce conflict for } resolved using rule 22 (funcReturn -> funcBool .)
  ! reduce/reduce conflict for ) resolved using rule 22 (funcReturn -> funcBool .)
  ! reduce/reduce conflict for MULEQ resolved using rule 22 (funcReturn -> funcBool .)
  ! reduce/reduce conflict for ; resolved using rule 22 (funcReturn -> funcBool .)
    ;               reduce using rule 22 (funcReturn -> funcBool .)
    )               reduce using rule 22 (funcReturn -> funcBool .)
    MULEQ           reduce using rule 22 (funcReturn -> funcBool .)
    }               reduce using rule 22 (funcReturn -> funcBool .)
    ,               reduce using rule 22 (funcReturn -> funcBool .)
    ]               reduce using rule 22 (funcReturn -> funcBool .)
    EQEQ            reduce using rule 99 (tBool -> funcBool .)
    DISTINTO        reduce using rule 99 (tBool -> funcBool .)
    AND             reduce using rule 99 (tBool -> funcBool .)
    ?               reduce using rule 99 (tBool -> funcBool .)
    OR              reduce using rule 99 (tBool -> funcBool .)

  ! ,               [ reduce using rule 99 (tBool -> funcBool .) ]
  ! ]               [ reduce using rule 99 (tBool -> funcBool .) ]
  ! }               [ reduce using rule 99 (tBool -> funcBool .) ]
  ! )               [ reduce using rule 99 (tBool -> funcBool .) ]
  ! MULEQ           [ reduce using rule 99 (tBool -> funcBool .) ]
  ! ;               [ reduce using rule 99 (tBool -> funcBool .) ]


state 86

    (20) funcReturn -> funcInt .
    (76) paren -> funcInt .

  ! reduce/reduce conflict for MULEQ resolved using rule 20 (funcReturn -> funcInt .)
  ! reduce/reduce conflict for ; resolved using rule 20 (funcReturn -> funcInt .)
  ! reduce/reduce conflict for } resolved using rule 20 (funcReturn -> funcInt .)
  ! reduce/reduce conflict for , resolved using rule 20 (funcReturn -> funcInt .)
  ! reduce/reduce conflict for ] resolved using rule 20 (funcReturn -> funcInt .)
  ! reduce/reduce conflict for ) resolved using rule 20 (funcReturn -> funcInt .)
    ;               reduce using rule 20 (funcReturn -> funcInt .)
    )               reduce using rule 20 (funcReturn -> funcInt .)
    MULEQ           reduce using rule 20 (funcReturn -> funcInt .)
    }               reduce using rule 20 (funcReturn -> funcInt .)
    ,               reduce using rule 20 (funcReturn -> funcInt .)
    ]               reduce using rule 20 (funcReturn -> funcInt .)
    ^               reduce using rule 76 (paren -> funcInt .)
    *               reduce using rule 76 (paren -> funcInt .)
    /               reduce using rule 76 (paren -> funcInt .)
    %               reduce using rule 76 (paren -> funcInt .)
    +               reduce using rule 76 (paren -> funcInt .)
    -               reduce using rule 76 (paren -> funcInt .)
    >               reduce using rule 76 (paren -> funcInt .)
    <               reduce using rule 76 (paren -> funcInt .)

  ! MULEQ           [ reduce using rule 76 (paren -> funcInt .) ]
  ! ;               [ reduce using rule 76 (paren -> funcInt .) ]
  ! }               [ reduce using rule 76 (paren -> funcInt .) ]
  ! ,               [ reduce using rule 76 (paren -> funcInt .) ]
  ! ]               [ reduce using rule 76 (paren -> funcInt .) ]
  ! )               [ reduce using rule 76 (paren -> funcInt .) ]


state 87

    (34) valores -> eMat .
    (59) eMat -> eMat . + p
    (60) eMat -> eMat . - p
    (100) tCompare -> eMat .

    }               reduce using rule 34 (valores -> eMat .)
    )               reduce using rule 34 (valores -> eMat .)
    ,               reduce using rule 34 (valores -> eMat .)
    ]               reduce using rule 34 (valores -> eMat .)
    ;               reduce using rule 34 (valores -> eMat .)
    MULEQ           reduce using rule 34 (valores -> eMat .)
    +               shift and go to state 123
    -               shift and go to state 124
    >               reduce using rule 100 (tCompare -> eMat .)
    <               reduce using rule 100 (tCompare -> eMat .)


state 88

    (71) paren -> ( . eMat )
    (96) tBool -> ( . expBool )
    (59) eMat -> . eMat + p
    (60) eMat -> . eMat - p
    (61) eMat -> . p
    (81) expBool -> . or ? expBool : expBool
    (82) expBool -> . or
    (62) p -> . p * exp
    (63) p -> . p / exp
    (64) p -> . p % exp
    (65) p -> . exp
    (83) or -> . or OR and
    (84) or -> . and
    (66) exp -> . exp ^ iSing
    (67) exp -> . iSing
    (85) and -> . and AND eq
    (86) and -> . eq
    (68) iSing -> . - paren
    (69) iSing -> . + paren
    (70) iSing -> . paren
    (87) eq -> . eq EQEQ tBool
    (88) eq -> . eq DISTINTO tBool
    (89) eq -> . mayor
    (71) paren -> . ( eMat )
    (72) paren -> . INT
    (73) paren -> . varYVals
    (74) paren -> . FLOAT
    (75) paren -> . varsOps
    (76) paren -> . funcInt
    (90) mayor -> . tCompare > tCompare
    (91) mayor -> . menor
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (49) varsOps -> . MENOSMENOS varYVals
    (50) varsOps -> . MASMAS varYVals
    (51) varsOps -> . varYVals MASMAS
    (52) varsOps -> . varYVals MENOSMENOS
    (23) funcInt -> . MULTIESCALAR ( vec , eMat , param )
    (24) funcInt -> . LENGTH ( vec )
    (100) tCompare -> . eMat
    (101) tCompare -> . varsOps
    (102) tCompare -> . varYVals
    (92) menor -> . tCompare < tCompare
    (93) menor -> . not
    (43) vecVal -> . ID m
    (94) not -> . NOT not
    (95) not -> . tBool
    (96) tBool -> . ( expBool )
    (97) tBool -> . BOOL
    (98) tBool -> . varYVals
    (99) tBool -> . funcBool
    (26) funcBool -> . COLINEALES ( vec , vec )

    -               shift and go to state 69
    +               shift and go to state 68
    (               shift and go to state 88
    INT             shift and go to state 75
    FLOAT           shift and go to state 76
    ID              shift and go to state 52
    MENOSMENOS      shift and go to state 30
    MASMAS          shift and go to state 27
    MULTIESCALAR    shift and go to state 23
    LENGTH          shift and go to state 26
    NOT             shift and go to state 81
    BOOL            shift and go to state 70
    COLINEALES      shift and go to state 15

    and                            shift and go to state 60
    funcBool                       shift and go to state 61
    funcInt                        shift and go to state 62
    menor                          shift and go to state 63
    eq                             shift and go to state 64
    mayor                          shift and go to state 65
    eMat                           shift and go to state 125
    vecVal                         shift and go to state 9
    paren                          shift and go to state 73
    varsOps                        shift and go to state 90
    tCompare                       shift and go to state 72
    not                            shift and go to state 74
    p                              shift and go to state 78
    iSing                          shift and go to state 71
    exp                            shift and go to state 80
    tBool                          shift and go to state 82
    varYVals                       shift and go to state 145
    or                             shift and go to state 77
    expBool                        shift and go to state 127

state 89

    (39) valores -> reg .

    }               reduce using rule 39 (valores -> reg .)
    )               reduce using rule 39 (valores -> reg .)
    ,               reduce using rule 39 (valores -> reg .)
    ]               reduce using rule 39 (valores -> reg .)
    ;               reduce using rule 39 (valores -> reg .)
    MULEQ           reduce using rule 39 (valores -> reg .)


state 90

    (75) paren -> varsOps .
    (101) tCompare -> varsOps .

  ! reduce/reduce conflict for > resolved using rule 75 (paren -> varsOps .)
  ! reduce/reduce conflict for < resolved using rule 75 (paren -> varsOps .)
    ^               reduce using rule 75 (paren -> varsOps .)
    *               reduce using rule 75 (paren -> varsOps .)
    /               reduce using rule 75 (paren -> varsOps .)
    %               reduce using rule 75 (paren -> varsOps .)
    )               reduce using rule 75 (paren -> varsOps .)
    +               reduce using rule 75 (paren -> varsOps .)
    -               reduce using rule 75 (paren -> varsOps .)
    >               reduce using rule 75 (paren -> varsOps .)
    <               reduce using rule 75 (paren -> varsOps .)
    MULEQ           reduce using rule 75 (paren -> varsOps .)
    ;               reduce using rule 75 (paren -> varsOps .)
    }               reduce using rule 75 (paren -> varsOps .)
    ,               reduce using rule 75 (paren -> varsOps .)
    ]               reduce using rule 75 (paren -> varsOps .)

  ! >               [ reduce using rule 101 (tCompare -> varsOps .) ]
  ! <               [ reduce using rule 101 (tCompare -> varsOps .) ]


state 91

    (78) expString -> STRING .

    +               reduce using rule 78 (expString -> STRING .)
    ,               reduce using rule 78 (expString -> STRING .)
    ]               reduce using rule 78 (expString -> STRING .)
    )               reduce using rule 78 (expString -> STRING .)
    }               reduce using rule 78 (expString -> STRING .)
    MULEQ           reduce using rule 78 (expString -> STRING .)
    ;               reduce using rule 78 (expString -> STRING .)


state 92

    (36) valores -> expString .
    (77) expString -> expString . + STRING

    }               reduce using rule 36 (valores -> expString .)
    )               reduce using rule 36 (valores -> expString .)
    ,               reduce using rule 36 (valores -> expString .)
    ]               reduce using rule 36 (valores -> expString .)
    ;               reduce using rule 36 (valores -> expString .)
    MULEQ           reduce using rule 36 (valores -> expString .)
    +               shift and go to state 146


state 93

    (40) valores -> ID . . ID
    (41) varYVals -> ID .
    (43) vecVal -> ID . m
    (44) m -> . [ INT ]
    (45) m -> . [ INT ] m

    .               shift and go to state 147
    MASMAS          reduce using rule 41 (varYVals -> ID .)
    MENOSMENOS      reduce using rule 41 (varYVals -> ID .)
    )               reduce using rule 41 (varYVals -> ID .)
    +               reduce using rule 41 (varYVals -> ID .)
    ^               reduce using rule 41 (varYVals -> ID .)
    *               reduce using rule 41 (varYVals -> ID .)
    /               reduce using rule 41 (varYVals -> ID .)
    %               reduce using rule 41 (varYVals -> ID .)
    -               reduce using rule 41 (varYVals -> ID .)
    >               reduce using rule 41 (varYVals -> ID .)
    <               reduce using rule 41 (varYVals -> ID .)
    EQEQ            reduce using rule 41 (varYVals -> ID .)
    DISTINTO        reduce using rule 41 (varYVals -> ID .)
    AND             reduce using rule 41 (varYVals -> ID .)
    ?               reduce using rule 41 (varYVals -> ID .)
    OR              reduce using rule 41 (varYVals -> ID .)
    ,               reduce using rule 41 (varYVals -> ID .)
    ]               reduce using rule 41 (varYVals -> ID .)
    [               shift and go to state 44

    m                              shift and go to state 42

state 94

    (80) expString -> funcString .
    (21) funcReturn -> funcString .

  ! reduce/reduce conflict for ; resolved using rule 21 (funcReturn -> funcString .)
  ! reduce/reduce conflict for ) resolved using rule 21 (funcReturn -> funcString .)
  ! reduce/reduce conflict for MULEQ resolved using rule 21 (funcReturn -> funcString .)
  ! reduce/reduce conflict for } resolved using rule 21 (funcReturn -> funcString .)
  ! reduce/reduce conflict for , resolved using rule 21 (funcReturn -> funcString .)
  ! reduce/reduce conflict for ] resolved using rule 21 (funcReturn -> funcString .)
    +               reduce using rule 80 (expString -> funcString .)
    ;               reduce using rule 21 (funcReturn -> funcString .)
    )               reduce using rule 21 (funcReturn -> funcString .)
    MULEQ           reduce using rule 21 (funcReturn -> funcString .)
    }               reduce using rule 21 (funcReturn -> funcString .)
    ,               reduce using rule 21 (funcReturn -> funcString .)
    ]               reduce using rule 21 (funcReturn -> funcString .)

  ! ,               [ reduce using rule 80 (expString -> funcString .) ]
  ! ]               [ reduce using rule 80 (expString -> funcString .) ]
  ! )               [ reduce using rule 80 (expString -> funcString .) ]
  ! }               [ reduce using rule 80 (expString -> funcString .) ]
  ! MULEQ           [ reduce using rule 80 (expString -> funcString .) ]
  ! ;               [ reduce using rule 80 (expString -> funcString .) ]


state 95

    (38) valores -> funcReturn .

    }               reduce using rule 38 (valores -> funcReturn .)
    )               reduce using rule 38 (valores -> funcReturn .)
    ,               reduce using rule 38 (valores -> funcReturn .)
    ]               reduce using rule 38 (valores -> funcReturn .)
    ;               reduce using rule 38 (valores -> funcReturn .)
    MULEQ           reduce using rule 38 (valores -> funcReturn .)


state 96

    (27) funcVoid -> PRINT ( valores . )

    )               shift and go to state 148


state 97

    (46) reg -> { . campos }
    (47) campos -> . ID : valores , campos
    (48) campos -> . valores
    (34) valores -> . eMat
    (35) valores -> . expBool
    (36) valores -> . expString
    (37) valores -> . varYVals
    (38) valores -> . funcReturn
    (39) valores -> . reg
    (40) valores -> . ID . ID
    (59) eMat -> . eMat + p
    (60) eMat -> . eMat - p
    (61) eMat -> . p
    (81) expBool -> . or ? expBool : expBool
    (82) expBool -> . or
    (77) expString -> . expString + STRING
    (78) expString -> . STRING
    (79) expString -> . varYVals
    (80) expString -> . funcString
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (20) funcReturn -> . funcInt
    (21) funcReturn -> . funcString
    (22) funcReturn -> . funcBool
    (46) reg -> . { campos }
    (62) p -> . p * exp
    (63) p -> . p / exp
    (64) p -> . p % exp
    (65) p -> . exp
    (83) or -> . or OR and
    (84) or -> . and
    (25) funcString -> . CAPITALIZAR ( expString )
    (43) vecVal -> . ID m
    (23) funcInt -> . MULTIESCALAR ( vec , eMat , param )
    (24) funcInt -> . LENGTH ( vec )
    (26) funcBool -> . COLINEALES ( vec , vec )
    (66) exp -> . exp ^ iSing
    (67) exp -> . iSing
    (85) and -> . and AND eq
    (86) and -> . eq
    (68) iSing -> . - paren
    (69) iSing -> . + paren
    (70) iSing -> . paren
    (87) eq -> . eq EQEQ tBool
    (88) eq -> . eq DISTINTO tBool
    (89) eq -> . mayor
    (71) paren -> . ( eMat )
    (72) paren -> . INT
    (73) paren -> . varYVals
    (74) paren -> . FLOAT
    (75) paren -> . varsOps
    (76) paren -> . funcInt
    (90) mayor -> . tCompare > tCompare
    (91) mayor -> . menor
    (49) varsOps -> . MENOSMENOS varYVals
    (50) varsOps -> . MASMAS varYVals
    (51) varsOps -> . varYVals MASMAS
    (52) varsOps -> . varYVals MENOSMENOS
    (100) tCompare -> . eMat
    (101) tCompare -> . varsOps
    (102) tCompare -> . varYVals
    (92) menor -> . tCompare < tCompare
    (93) menor -> . not
    (94) not -> . NOT not
    (95) not -> . tBool
    (96) tBool -> . ( expBool )
    (97) tBool -> . BOOL
    (98) tBool -> . varYVals
    (99) tBool -> . funcBool

    ID              shift and go to state 150
    STRING          shift and go to state 91
    {               shift and go to state 97
    CAPITALIZAR     shift and go to state 25
    MULTIESCALAR    shift and go to state 23
    LENGTH          shift and go to state 26
    COLINEALES      shift and go to state 15
    -               shift and go to state 69
    +               shift and go to state 68
    (               shift and go to state 88
    INT             shift and go to state 75
    FLOAT           shift and go to state 76
    MENOSMENOS      shift and go to state 30
    MASMAS          shift and go to state 27
    NOT             shift and go to state 81
    BOOL            shift and go to state 70

    and                            shift and go to state 60
    funcBool                       shift and go to state 85
    funcInt                        shift and go to state 86
    menor                          shift and go to state 63
    eq                             shift and go to state 64
    vecVal                         shift and go to state 9
    eMat                           shift and go to state 87
    mayor                          shift and go to state 65
    paren                          shift and go to state 73
    reg                            shift and go to state 89
    varsOps                        shift and go to state 90
    expString                      shift and go to state 92
    tCompare                       shift and go to state 72
    campos                         shift and go to state 149
    not                            shift and go to state 74
    funcString                     shift and go to state 94
    funcReturn                     shift and go to state 95
    valores                        shift and go to state 151
    p                              shift and go to state 78
    iSing                          shift and go to state 71
    exp                            shift and go to state 80
    tBool                          shift and go to state 82
    varYVals                       shift and go to state 98
    or                             shift and go to state 77
    expBool                        shift and go to state 99

state 98

    (37) valores -> varYVals .
    (79) expString -> varYVals .
    (73) paren -> varYVals .
    (51) varsOps -> varYVals . MASMAS
    (52) varsOps -> varYVals . MENOSMENOS
    (102) tCompare -> varYVals .
    (98) tBool -> varYVals .

  ! reduce/reduce conflict for , resolved using rule 37 (valores -> varYVals .)
  ! reduce/reduce conflict for ] resolved using rule 37 (valores -> varYVals .)
  ! reduce/reduce conflict for ) resolved using rule 37 (valores -> varYVals .)
  ! reduce/reduce conflict for } resolved using rule 37 (valores -> varYVals .)
  ! reduce/reduce conflict for MULEQ resolved using rule 37 (valores -> varYVals .)
  ! reduce/reduce conflict for ; resolved using rule 37 (valores -> varYVals .)
  ! reduce/reduce conflict for + resolved using rule 73 (paren -> varYVals .)
  ! reduce/reduce conflict for MULEQ resolved using rule 37 (valores -> varYVals .)
  ! reduce/reduce conflict for ; resolved using rule 37 (valores -> varYVals .)
  ! reduce/reduce conflict for } resolved using rule 37 (valores -> varYVals .)
  ! reduce/reduce conflict for , resolved using rule 37 (valores -> varYVals .)
  ! reduce/reduce conflict for ] resolved using rule 37 (valores -> varYVals .)
  ! reduce/reduce conflict for ) resolved using rule 37 (valores -> varYVals .)
  ! reduce/reduce conflict for > resolved using rule 73 (paren -> varYVals .)
  ! reduce/reduce conflict for < resolved using rule 73 (paren -> varYVals .)
  ! reduce/reduce conflict for , resolved using rule 37 (valores -> varYVals .)
  ! reduce/reduce conflict for ] resolved using rule 37 (valores -> varYVals .)
  ! reduce/reduce conflict for } resolved using rule 37 (valores -> varYVals .)
  ! reduce/reduce conflict for ) resolved using rule 37 (valores -> varYVals .)
  ! reduce/reduce conflict for MULEQ resolved using rule 37 (valores -> varYVals .)
  ! reduce/reduce conflict for ; resolved using rule 37 (valores -> varYVals .)
    }               reduce using rule 37 (valores -> varYVals .)
    )               reduce using rule 37 (valores -> varYVals .)
    ,               reduce using rule 37 (valores -> varYVals .)
    ]               reduce using rule 37 (valores -> varYVals .)
    ;               reduce using rule 37 (valores -> varYVals .)
    MULEQ           reduce using rule 37 (valores -> varYVals .)
    ^               reduce using rule 73 (paren -> varYVals .)
    *               reduce using rule 73 (paren -> varYVals .)
    /               reduce using rule 73 (paren -> varYVals .)
    %               reduce using rule 73 (paren -> varYVals .)
    +               reduce using rule 73 (paren -> varYVals .)
    -               reduce using rule 73 (paren -> varYVals .)
    >               reduce using rule 73 (paren -> varYVals .)
    <               reduce using rule 73 (paren -> varYVals .)
    MASMAS          shift and go to state 54
    MENOSMENOS      shift and go to state 55
    EQEQ            reduce using rule 98 (tBool -> varYVals .)
    DISTINTO        reduce using rule 98 (tBool -> varYVals .)
    AND             reduce using rule 98 (tBool -> varYVals .)
    ?               reduce using rule 98 (tBool -> varYVals .)
    OR              reduce using rule 98 (tBool -> varYVals .)

  ! +               [ reduce using rule 79 (expString -> varYVals .) ]
  ! ,               [ reduce using rule 79 (expString -> varYVals .) ]
  ! ]               [ reduce using rule 79 (expString -> varYVals .) ]
  ! )               [ reduce using rule 79 (expString -> varYVals .) ]
  ! }               [ reduce using rule 79 (expString -> varYVals .) ]
  ! MULEQ           [ reduce using rule 79 (expString -> varYVals .) ]
  ! ;               [ reduce using rule 79 (expString -> varYVals .) ]
  ! MULEQ           [ reduce using rule 73 (paren -> varYVals .) ]
  ! ;               [ reduce using rule 73 (paren -> varYVals .) ]
  ! }               [ reduce using rule 73 (paren -> varYVals .) ]
  ! ,               [ reduce using rule 73 (paren -> varYVals .) ]
  ! ]               [ reduce using rule 73 (paren -> varYVals .) ]
  ! )               [ reduce using rule 73 (paren -> varYVals .) ]
  ! >               [ reduce using rule 102 (tCompare -> varYVals .) ]
  ! <               [ reduce using rule 102 (tCompare -> varYVals .) ]
  ! ,               [ reduce using rule 98 (tBool -> varYVals .) ]
  ! ]               [ reduce using rule 98 (tBool -> varYVals .) ]
  ! }               [ reduce using rule 98 (tBool -> varYVals .) ]
  ! )               [ reduce using rule 98 (tBool -> varYVals .) ]
  ! MULEQ           [ reduce using rule 98 (tBool -> varYVals .) ]
  ! ;               [ reduce using rule 98 (tBool -> varYVals .) ]


state 99

    (35) valores -> expBool .

    }               reduce using rule 35 (valores -> expBool .)
    )               reduce using rule 35 (valores -> expBool .)
    ,               reduce using rule 35 (valores -> expBool .)
    ]               reduce using rule 35 (valores -> expBool .)
    ;               reduce using rule 35 (valores -> expBool .)
    MULEQ           reduce using rule 35 (valores -> expBool .)


state 100

    (54) varAsig -> asig MULEQ varAsig .

    ;               reduce using rule 54 (varAsig -> asig MULEQ varAsig .)


state 101

    (53) varAsig -> ID . MULEQ varAsig
    (55) varAsig -> ID . MULEQ valores
    (57) asig -> ID . = asig
    (58) asig -> ID . = valores

    MULEQ           shift and go to state 43
    =               shift and go to state 45


state 102

    (26) funcBool -> COLINEALES ( vec . , vec )

    ,               shift and go to state 152


state 103

    (31) vec -> [ . elem ]
    (32) elem -> . valores , elem
    (33) elem -> . valores
    (34) valores -> . eMat
    (35) valores -> . expBool
    (36) valores -> . expString
    (37) valores -> . varYVals
    (38) valores -> . funcReturn
    (39) valores -> . reg
    (40) valores -> . ID . ID
    (59) eMat -> . eMat + p
    (60) eMat -> . eMat - p
    (61) eMat -> . p
    (81) expBool -> . or ? expBool : expBool
    (82) expBool -> . or
    (77) expString -> . expString + STRING
    (78) expString -> . STRING
    (79) expString -> . varYVals
    (80) expString -> . funcString
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (20) funcReturn -> . funcInt
    (21) funcReturn -> . funcString
    (22) funcReturn -> . funcBool
    (46) reg -> . { campos }
    (62) p -> . p * exp
    (63) p -> . p / exp
    (64) p -> . p % exp
    (65) p -> . exp
    (83) or -> . or OR and
    (84) or -> . and
    (25) funcString -> . CAPITALIZAR ( expString )
    (43) vecVal -> . ID m
    (23) funcInt -> . MULTIESCALAR ( vec , eMat , param )
    (24) funcInt -> . LENGTH ( vec )
    (26) funcBool -> . COLINEALES ( vec , vec )
    (66) exp -> . exp ^ iSing
    (67) exp -> . iSing
    (85) and -> . and AND eq
    (86) and -> . eq
    (68) iSing -> . - paren
    (69) iSing -> . + paren
    (70) iSing -> . paren
    (87) eq -> . eq EQEQ tBool
    (88) eq -> . eq DISTINTO tBool
    (89) eq -> . mayor
    (71) paren -> . ( eMat )
    (72) paren -> . INT
    (73) paren -> . varYVals
    (74) paren -> . FLOAT
    (75) paren -> . varsOps
    (76) paren -> . funcInt
    (90) mayor -> . tCompare > tCompare
    (91) mayor -> . menor
    (49) varsOps -> . MENOSMENOS varYVals
    (50) varsOps -> . MASMAS varYVals
    (51) varsOps -> . varYVals MASMAS
    (52) varsOps -> . varYVals MENOSMENOS
    (100) tCompare -> . eMat
    (101) tCompare -> . varsOps
    (102) tCompare -> . varYVals
    (92) menor -> . tCompare < tCompare
    (93) menor -> . not
    (94) not -> . NOT not
    (95) not -> . tBool
    (96) tBool -> . ( expBool )
    (97) tBool -> . BOOL
    (98) tBool -> . varYVals
    (99) tBool -> . funcBool

    ID              shift and go to state 93
    STRING          shift and go to state 91
    {               shift and go to state 97
    CAPITALIZAR     shift and go to state 25
    MULTIESCALAR    shift and go to state 23
    LENGTH          shift and go to state 26
    COLINEALES      shift and go to state 15
    -               shift and go to state 69
    +               shift and go to state 68
    (               shift and go to state 88
    INT             shift and go to state 75
    FLOAT           shift and go to state 76
    MENOSMENOS      shift and go to state 30
    MASMAS          shift and go to state 27
    NOT             shift and go to state 81
    BOOL            shift and go to state 70

    and                            shift and go to state 60
    funcBool                       shift and go to state 85
    funcInt                        shift and go to state 86
    valores                        shift and go to state 153
    menor                          shift and go to state 63
    eq                             shift and go to state 64
    vecVal                         shift and go to state 9
    eMat                           shift and go to state 87
    mayor                          shift and go to state 65
    paren                          shift and go to state 73
    reg                            shift and go to state 89
    varsOps                        shift and go to state 90
    expString                      shift and go to state 92
    tCompare                       shift and go to state 72
    not                            shift and go to state 74
    funcString                     shift and go to state 94
    funcReturn                     shift and go to state 95
    elem                           shift and go to state 154
    p                              shift and go to state 78
    iSing                          shift and go to state 71
    exp                            shift and go to state 80
    tBool                          shift and go to state 82
    varYVals                       shift and go to state 98
    or                             shift and go to state 77
    expBool                        shift and go to state 99

state 104

    (12) loop -> FOR ( varAsig . ; expBool ; varsOps ) bloque

    ;               shift and go to state 155


state 105

    (53) varAsig -> ID . MULEQ varAsig
    (55) varAsig -> ID . MULEQ valores
    (40) valores -> ID . . ID
    (57) asig -> ID . = asig
    (58) asig -> ID . = valores
    (41) varYVals -> ID .
    (43) vecVal -> ID . m
    (44) m -> . [ INT ]
    (45) m -> . [ INT ] m

    MULEQ           shift and go to state 43
    .               shift and go to state 147
    =               shift and go to state 45
    MASMAS          reduce using rule 41 (varYVals -> ID .)
    MENOSMENOS      reduce using rule 41 (varYVals -> ID .)
    ;               reduce using rule 41 (varYVals -> ID .)
    +               reduce using rule 41 (varYVals -> ID .)
    ^               reduce using rule 41 (varYVals -> ID .)
    *               reduce using rule 41 (varYVals -> ID .)
    /               reduce using rule 41 (varYVals -> ID .)
    %               reduce using rule 41 (varYVals -> ID .)
    -               reduce using rule 41 (varYVals -> ID .)
    >               reduce using rule 41 (varYVals -> ID .)
    <               reduce using rule 41 (varYVals -> ID .)
    EQEQ            reduce using rule 41 (varYVals -> ID .)
    DISTINTO        reduce using rule 41 (varYVals -> ID .)
    AND             reduce using rule 41 (varYVals -> ID .)
    ?               reduce using rule 41 (varYVals -> ID .)
    OR              reduce using rule 41 (varYVals -> ID .)
    [               shift and go to state 44

    m                              shift and go to state 42

state 106

    (53) varAsig -> ID MULEQ varAsig .

    ;               reduce using rule 53 (varAsig -> ID MULEQ varAsig .)


state 107

    (55) varAsig -> ID MULEQ valores .

    ;               reduce using rule 55 (varAsig -> ID MULEQ valores .)


state 108

    (44) m -> [ INT . ]
    (45) m -> [ INT . ] m

    ]               shift and go to state 156


state 109

    (57) asig -> ID = asig .

    MULEQ           reduce using rule 57 (asig -> ID = asig .)
    ;               reduce using rule 57 (asig -> ID = asig .)


state 110

    (57) asig -> ID . = asig
    (58) asig -> ID . = valores
    (40) valores -> ID . . ID
    (41) varYVals -> ID .
    (43) vecVal -> ID . m
    (44) m -> . [ INT ]
    (45) m -> . [ INT ] m

    =               shift and go to state 45
    .               shift and go to state 147
    MASMAS          reduce using rule 41 (varYVals -> ID .)
    MENOSMENOS      reduce using rule 41 (varYVals -> ID .)
    MULEQ           reduce using rule 41 (varYVals -> ID .)
    ;               reduce using rule 41 (varYVals -> ID .)
    +               reduce using rule 41 (varYVals -> ID .)
    ^               reduce using rule 41 (varYVals -> ID .)
    *               reduce using rule 41 (varYVals -> ID .)
    /               reduce using rule 41 (varYVals -> ID .)
    %               reduce using rule 41 (varYVals -> ID .)
    -               reduce using rule 41 (varYVals -> ID .)
    >               reduce using rule 41 (varYVals -> ID .)
    <               reduce using rule 41 (varYVals -> ID .)
    EQEQ            reduce using rule 41 (varYVals -> ID .)
    DISTINTO        reduce using rule 41 (varYVals -> ID .)
    AND             reduce using rule 41 (varYVals -> ID .)
    ?               reduce using rule 41 (varYVals -> ID .)
    OR              reduce using rule 41 (varYVals -> ID .)
    [               shift and go to state 44

    m                              shift and go to state 42

state 111

    (58) asig -> ID = valores .

    MULEQ           reduce using rule 58 (asig -> ID = valores .)
    ;               reduce using rule 58 (asig -> ID = valores .)


state 112

    (13) if -> IF ( expBool . ) bloque else

    )               shift and go to state 157


state 113

    (23) funcInt -> MULTIESCALAR ( vec . , eMat , param )

    ,               shift and go to state 158


state 114

    (25) funcString -> CAPITALIZAR ( expString . )
    (77) expString -> expString . + STRING

    )               shift and go to state 159
    +               shift and go to state 146


state 115

    (80) expString -> funcString .

    )               reduce using rule 80 (expString -> funcString .)
    +               reduce using rule 80 (expString -> funcString .)


state 116

    (79) expString -> varYVals .

    )               reduce using rule 79 (expString -> varYVals .)
    +               reduce using rule 79 (expString -> varYVals .)


state 117

    (24) funcInt -> LENGTH ( vec . )

    )               shift and go to state 160


state 118

    (11) loop -> DO bloque WHILE ( . expBool ) ;
    (81) expBool -> . or ? expBool : expBool
    (82) expBool -> . or
    (83) or -> . or OR and
    (84) or -> . and
    (85) and -> . and AND eq
    (86) and -> . eq
    (87) eq -> . eq EQEQ tBool
    (88) eq -> . eq DISTINTO tBool
    (89) eq -> . mayor
    (90) mayor -> . tCompare > tCompare
    (91) mayor -> . menor
    (100) tCompare -> . eMat
    (101) tCompare -> . varsOps
    (102) tCompare -> . varYVals
    (92) menor -> . tCompare < tCompare
    (93) menor -> . not
    (59) eMat -> . eMat + p
    (60) eMat -> . eMat - p
    (61) eMat -> . p
    (49) varsOps -> . MENOSMENOS varYVals
    (50) varsOps -> . MASMAS varYVals
    (51) varsOps -> . varYVals MASMAS
    (52) varsOps -> . varYVals MENOSMENOS
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (94) not -> . NOT not
    (95) not -> . tBool
    (62) p -> . p * exp
    (63) p -> . p / exp
    (64) p -> . p % exp
    (65) p -> . exp
    (43) vecVal -> . ID m
    (96) tBool -> . ( expBool )
    (97) tBool -> . BOOL
    (98) tBool -> . varYVals
    (99) tBool -> . funcBool
    (66) exp -> . exp ^ iSing
    (67) exp -> . iSing
    (26) funcBool -> . COLINEALES ( vec , vec )
    (68) iSing -> . - paren
    (69) iSing -> . + paren
    (70) iSing -> . paren
    (71) paren -> . ( eMat )
    (72) paren -> . INT
    (73) paren -> . varYVals
    (74) paren -> . FLOAT
    (75) paren -> . varsOps
    (76) paren -> . funcInt
    (23) funcInt -> . MULTIESCALAR ( vec , eMat , param )
    (24) funcInt -> . LENGTH ( vec )

    MENOSMENOS      shift and go to state 30
    MASMAS          shift and go to state 27
    ID              shift and go to state 52
    NOT             shift and go to state 81
    (               shift and go to state 67
    BOOL            shift and go to state 70
    COLINEALES      shift and go to state 15
    -               shift and go to state 69
    +               shift and go to state 68
    INT             shift and go to state 75
    FLOAT           shift and go to state 76
    MULTIESCALAR    shift and go to state 23
    LENGTH          shift and go to state 26

    and                            shift and go to state 60
    funcBool                       shift and go to state 61
    funcInt                        shift and go to state 62
    menor                          shift and go to state 63
    eq                             shift and go to state 64
    mayor                          shift and go to state 65
    eMat                           shift and go to state 66
    vecVal                         shift and go to state 9
    paren                          shift and go to state 73
    iSing                          shift and go to state 71
    tCompare                       shift and go to state 72
    not                            shift and go to state 74
    p                              shift and go to state 78
    varsOps                        shift and go to state 79
    exp                            shift and go to state 80
    tBool                          shift and go to state 82
    varYVals                       shift and go to state 83
    or                             shift and go to state 77
    expBool                        shift and go to state 161

state 119

    (17) bloque -> { g } .

    RETURN          reduce using rule 17 (bloque -> { g } .)
    MENOSMENOS      reduce using rule 17 (bloque -> { g } .)
    MASMAS          reduce using rule 17 (bloque -> { g } .)
    ID              reduce using rule 17 (bloque -> { g } .)
    IF              reduce using rule 17 (bloque -> { g } .)
    WHILE           reduce using rule 17 (bloque -> { g } .)
    DO              reduce using rule 17 (bloque -> { g } .)
    FOR             reduce using rule 17 (bloque -> { g } .)
    PRINT           reduce using rule 17 (bloque -> { g } .)
    MULTIESCALAR    reduce using rule 17 (bloque -> { g } .)
    LENGTH          reduce using rule 17 (bloque -> { g } .)
    CAPITALIZAR     reduce using rule 17 (bloque -> { g } .)
    COLINEALES      reduce using rule 17 (bloque -> { g } .)
    $end            reduce using rule 17 (bloque -> { g } .)
    }               reduce using rule 17 (bloque -> { g } .)
    ELSE            reduce using rule 17 (bloque -> { g } .)


state 120

    (85) and -> and AND . eq
    (87) eq -> . eq EQEQ tBool
    (88) eq -> . eq DISTINTO tBool
    (89) eq -> . mayor
    (90) mayor -> . tCompare > tCompare
    (91) mayor -> . menor
    (100) tCompare -> . eMat
    (101) tCompare -> . varsOps
    (102) tCompare -> . varYVals
    (92) menor -> . tCompare < tCompare
    (93) menor -> . not
    (59) eMat -> . eMat + p
    (60) eMat -> . eMat - p
    (61) eMat -> . p
    (49) varsOps -> . MENOSMENOS varYVals
    (50) varsOps -> . MASMAS varYVals
    (51) varsOps -> . varYVals MASMAS
    (52) varsOps -> . varYVals MENOSMENOS
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (94) not -> . NOT not
    (95) not -> . tBool
    (62) p -> . p * exp
    (63) p -> . p / exp
    (64) p -> . p % exp
    (65) p -> . exp
    (43) vecVal -> . ID m
    (96) tBool -> . ( expBool )
    (97) tBool -> . BOOL
    (98) tBool -> . varYVals
    (99) tBool -> . funcBool
    (66) exp -> . exp ^ iSing
    (67) exp -> . iSing
    (26) funcBool -> . COLINEALES ( vec , vec )
    (68) iSing -> . - paren
    (69) iSing -> . + paren
    (70) iSing -> . paren
    (71) paren -> . ( eMat )
    (72) paren -> . INT
    (73) paren -> . varYVals
    (74) paren -> . FLOAT
    (75) paren -> . varsOps
    (76) paren -> . funcInt
    (23) funcInt -> . MULTIESCALAR ( vec , eMat , param )
    (24) funcInt -> . LENGTH ( vec )

    MENOSMENOS      shift and go to state 30
    MASMAS          shift and go to state 27
    ID              shift and go to state 52
    NOT             shift and go to state 81
    (               shift and go to state 67
    BOOL            shift and go to state 70
    COLINEALES      shift and go to state 15
    -               shift and go to state 69
    +               shift and go to state 68
    INT             shift and go to state 75
    FLOAT           shift and go to state 76
    MULTIESCALAR    shift and go to state 23
    LENGTH          shift and go to state 26

    eMat                           shift and go to state 66
    funcBool                       shift and go to state 61
    p                              shift and go to state 78
    varYVals                       shift and go to state 83
    funcInt                        shift and go to state 62
    vecVal                         shift and go to state 9
    tCompare                       shift and go to state 72
    menor                          shift and go to state 63
    varsOps                        shift and go to state 79
    exp                            shift and go to state 80
    paren                          shift and go to state 73
    not                            shift and go to state 74
    tBool                          shift and go to state 82
    eq                             shift and go to state 162
    mayor                          shift and go to state 65
    iSing                          shift and go to state 71

state 121

    (87) eq -> eq EQEQ . tBool
    (96) tBool -> . ( expBool )
    (97) tBool -> . BOOL
    (98) tBool -> . varYVals
    (99) tBool -> . funcBool
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (26) funcBool -> . COLINEALES ( vec , vec )
    (43) vecVal -> . ID m

    (               shift and go to state 141
    BOOL            shift and go to state 70
    ID              shift and go to state 52
    COLINEALES      shift and go to state 15

    funcBool                       shift and go to state 61
    varYVals                       shift and go to state 143
    tBool                          shift and go to state 163
    vecVal                         shift and go to state 9

state 122

    (88) eq -> eq DISTINTO . tBool
    (96) tBool -> . ( expBool )
    (97) tBool -> . BOOL
    (98) tBool -> . varYVals
    (99) tBool -> . funcBool
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (26) funcBool -> . COLINEALES ( vec , vec )
    (43) vecVal -> . ID m

    (               shift and go to state 141
    BOOL            shift and go to state 70
    ID              shift and go to state 52
    COLINEALES      shift and go to state 15

    funcBool                       shift and go to state 61
    varYVals                       shift and go to state 143
    tBool                          shift and go to state 164
    vecVal                         shift and go to state 9

state 123

    (59) eMat -> eMat + . p
    (62) p -> . p * exp
    (63) p -> . p / exp
    (64) p -> . p % exp
    (65) p -> . exp
    (66) exp -> . exp ^ iSing
    (67) exp -> . iSing
    (68) iSing -> . - paren
    (69) iSing -> . + paren
    (70) iSing -> . paren
    (71) paren -> . ( eMat )
    (72) paren -> . INT
    (73) paren -> . varYVals
    (74) paren -> . FLOAT
    (75) paren -> . varsOps
    (76) paren -> . funcInt
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (49) varsOps -> . MENOSMENOS varYVals
    (50) varsOps -> . MASMAS varYVals
    (51) varsOps -> . varYVals MASMAS
    (52) varsOps -> . varYVals MENOSMENOS
    (23) funcInt -> . MULTIESCALAR ( vec , eMat , param )
    (24) funcInt -> . LENGTH ( vec )
    (43) vecVal -> . ID m

    -               shift and go to state 69
    +               shift and go to state 68
    (               shift and go to state 128
    INT             shift and go to state 75
    FLOAT           shift and go to state 76
    ID              shift and go to state 52
    MENOSMENOS      shift and go to state 30
    MASMAS          shift and go to state 27
    MULTIESCALAR    shift and go to state 23
    LENGTH          shift and go to state 26

    funcInt                        shift and go to state 62
    p                              shift and go to state 165
    iSing                          shift and go to state 71
    exp                            shift and go to state 80
    paren                          shift and go to state 73
    varYVals                       shift and go to state 131
    vecVal                         shift and go to state 9
    varsOps                        shift and go to state 129

state 124

    (60) eMat -> eMat - . p
    (62) p -> . p * exp
    (63) p -> . p / exp
    (64) p -> . p % exp
    (65) p -> . exp
    (66) exp -> . exp ^ iSing
    (67) exp -> . iSing
    (68) iSing -> . - paren
    (69) iSing -> . + paren
    (70) iSing -> . paren
    (71) paren -> . ( eMat )
    (72) paren -> . INT
    (73) paren -> . varYVals
    (74) paren -> . FLOAT
    (75) paren -> . varsOps
    (76) paren -> . funcInt
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (49) varsOps -> . MENOSMENOS varYVals
    (50) varsOps -> . MASMAS varYVals
    (51) varsOps -> . varYVals MASMAS
    (52) varsOps -> . varYVals MENOSMENOS
    (23) funcInt -> . MULTIESCALAR ( vec , eMat , param )
    (24) funcInt -> . LENGTH ( vec )
    (43) vecVal -> . ID m

    -               shift and go to state 69
    +               shift and go to state 68
    (               shift and go to state 128
    INT             shift and go to state 75
    FLOAT           shift and go to state 76
    ID              shift and go to state 52
    MENOSMENOS      shift and go to state 30
    MASMAS          shift and go to state 27
    MULTIESCALAR    shift and go to state 23
    LENGTH          shift and go to state 26

    funcInt                        shift and go to state 62
    p                              shift and go to state 166
    iSing                          shift and go to state 71
    exp                            shift and go to state 80
    paren                          shift and go to state 73
    varYVals                       shift and go to state 131
    vecVal                         shift and go to state 9
    varsOps                        shift and go to state 129

state 125

    (71) paren -> ( eMat . )
    (59) eMat -> eMat . + p
    (60) eMat -> eMat . - p
    (100) tCompare -> eMat .

    )               shift and go to state 167
    +               shift and go to state 123
    -               shift and go to state 124
    >               reduce using rule 100 (tCompare -> eMat .)
    <               reduce using rule 100 (tCompare -> eMat .)


state 126

    (73) paren -> varYVals .
    (102) tCompare -> varYVals .
    (51) varsOps -> varYVals . MASMAS
    (52) varsOps -> varYVals . MENOSMENOS
    (98) tBool -> varYVals .

  ! reduce/reduce conflict for > resolved using rule 73 (paren -> varYVals .)
  ! reduce/reduce conflict for < resolved using rule 73 (paren -> varYVals .)
  ! reduce/reduce conflict for ) resolved using rule 73 (paren -> varYVals .)
    ^               reduce using rule 73 (paren -> varYVals .)
    *               reduce using rule 73 (paren -> varYVals .)
    /               reduce using rule 73 (paren -> varYVals .)
    %               reduce using rule 73 (paren -> varYVals .)
    )               reduce using rule 73 (paren -> varYVals .)
    +               reduce using rule 73 (paren -> varYVals .)
    -               reduce using rule 73 (paren -> varYVals .)
    >               reduce using rule 73 (paren -> varYVals .)
    <               reduce using rule 73 (paren -> varYVals .)
    MASMAS          shift and go to state 54
    MENOSMENOS      shift and go to state 55
    EQEQ            reduce using rule 98 (tBool -> varYVals .)
    DISTINTO        reduce using rule 98 (tBool -> varYVals .)
    AND             reduce using rule 98 (tBool -> varYVals .)
    ?               reduce using rule 98 (tBool -> varYVals .)
    OR              reduce using rule 98 (tBool -> varYVals .)

  ! >               [ reduce using rule 102 (tCompare -> varYVals .) ]
  ! <               [ reduce using rule 102 (tCompare -> varYVals .) ]
  ! )               [ reduce using rule 98 (tBool -> varYVals .) ]


state 127

    (96) tBool -> ( expBool . )

    )               shift and go to state 168


state 128

    (71) paren -> ( . eMat )
    (59) eMat -> . eMat + p
    (60) eMat -> . eMat - p
    (61) eMat -> . p
    (62) p -> . p * exp
    (63) p -> . p / exp
    (64) p -> . p % exp
    (65) p -> . exp
    (66) exp -> . exp ^ iSing
    (67) exp -> . iSing
    (68) iSing -> . - paren
    (69) iSing -> . + paren
    (70) iSing -> . paren
    (71) paren -> . ( eMat )
    (72) paren -> . INT
    (73) paren -> . varYVals
    (74) paren -> . FLOAT
    (75) paren -> . varsOps
    (76) paren -> . funcInt
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (49) varsOps -> . MENOSMENOS varYVals
    (50) varsOps -> . MASMAS varYVals
    (51) varsOps -> . varYVals MASMAS
    (52) varsOps -> . varYVals MENOSMENOS
    (23) funcInt -> . MULTIESCALAR ( vec , eMat , param )
    (24) funcInt -> . LENGTH ( vec )
    (43) vecVal -> . ID m

    -               shift and go to state 69
    +               shift and go to state 68
    (               shift and go to state 128
    INT             shift and go to state 75
    FLOAT           shift and go to state 76
    ID              shift and go to state 52
    MENOSMENOS      shift and go to state 30
    MASMAS          shift and go to state 27
    MULTIESCALAR    shift and go to state 23
    LENGTH          shift and go to state 26

    eMat                           shift and go to state 169
    funcInt                        shift and go to state 62
    p                              shift and go to state 78
    iSing                          shift and go to state 71
    exp                            shift and go to state 80
    paren                          shift and go to state 73
    varYVals                       shift and go to state 131
    vecVal                         shift and go to state 9
    varsOps                        shift and go to state 129

state 129

    (75) paren -> varsOps .

    ^               reduce using rule 75 (paren -> varsOps .)
    *               reduce using rule 75 (paren -> varsOps .)
    /               reduce using rule 75 (paren -> varsOps .)
    %               reduce using rule 75 (paren -> varsOps .)
    ,               reduce using rule 75 (paren -> varsOps .)
    +               reduce using rule 75 (paren -> varsOps .)
    -               reduce using rule 75 (paren -> varsOps .)
    >               reduce using rule 75 (paren -> varsOps .)
    <               reduce using rule 75 (paren -> varsOps .)
    )               reduce using rule 75 (paren -> varsOps .)
    ;               reduce using rule 75 (paren -> varsOps .)
    MULEQ           reduce using rule 75 (paren -> varsOps .)
    }               reduce using rule 75 (paren -> varsOps .)
    ]               reduce using rule 75 (paren -> varsOps .)
    EQEQ            reduce using rule 75 (paren -> varsOps .)
    DISTINTO        reduce using rule 75 (paren -> varsOps .)
    AND             reduce using rule 75 (paren -> varsOps .)
    ?               reduce using rule 75 (paren -> varsOps .)
    OR              reduce using rule 75 (paren -> varsOps .)
    :               reduce using rule 75 (paren -> varsOps .)


state 130

    (69) iSing -> + paren .

    ^               reduce using rule 69 (iSing -> + paren .)
    *               reduce using rule 69 (iSing -> + paren .)
    /               reduce using rule 69 (iSing -> + paren .)
    %               reduce using rule 69 (iSing -> + paren .)
    +               reduce using rule 69 (iSing -> + paren .)
    -               reduce using rule 69 (iSing -> + paren .)
    >               reduce using rule 69 (iSing -> + paren .)
    <               reduce using rule 69 (iSing -> + paren .)
    )               reduce using rule 69 (iSing -> + paren .)
    ;               reduce using rule 69 (iSing -> + paren .)
    MULEQ           reduce using rule 69 (iSing -> + paren .)
    }               reduce using rule 69 (iSing -> + paren .)
    ,               reduce using rule 69 (iSing -> + paren .)
    ]               reduce using rule 69 (iSing -> + paren .)
    EQEQ            reduce using rule 69 (iSing -> + paren .)
    DISTINTO        reduce using rule 69 (iSing -> + paren .)
    AND             reduce using rule 69 (iSing -> + paren .)
    ?               reduce using rule 69 (iSing -> + paren .)
    OR              reduce using rule 69 (iSing -> + paren .)
    :               reduce using rule 69 (iSing -> + paren .)


state 131

    (73) paren -> varYVals .
    (51) varsOps -> varYVals . MASMAS
    (52) varsOps -> varYVals . MENOSMENOS

    ^               reduce using rule 73 (paren -> varYVals .)
    *               reduce using rule 73 (paren -> varYVals .)
    /               reduce using rule 73 (paren -> varYVals .)
    %               reduce using rule 73 (paren -> varYVals .)
    ,               reduce using rule 73 (paren -> varYVals .)
    +               reduce using rule 73 (paren -> varYVals .)
    -               reduce using rule 73 (paren -> varYVals .)
    >               reduce using rule 73 (paren -> varYVals .)
    <               reduce using rule 73 (paren -> varYVals .)
    )               reduce using rule 73 (paren -> varYVals .)
    ;               reduce using rule 73 (paren -> varYVals .)
    MULEQ           reduce using rule 73 (paren -> varYVals .)
    }               reduce using rule 73 (paren -> varYVals .)
    ]               reduce using rule 73 (paren -> varYVals .)
    EQEQ            reduce using rule 73 (paren -> varYVals .)
    DISTINTO        reduce using rule 73 (paren -> varYVals .)
    AND             reduce using rule 73 (paren -> varYVals .)
    ?               reduce using rule 73 (paren -> varYVals .)
    OR              reduce using rule 73 (paren -> varYVals .)
    :               reduce using rule 73 (paren -> varYVals .)
    MASMAS          shift and go to state 54
    MENOSMENOS      shift and go to state 55


state 132

    (68) iSing -> - paren .

    ^               reduce using rule 68 (iSing -> - paren .)
    *               reduce using rule 68 (iSing -> - paren .)
    /               reduce using rule 68 (iSing -> - paren .)
    %               reduce using rule 68 (iSing -> - paren .)
    +               reduce using rule 68 (iSing -> - paren .)
    -               reduce using rule 68 (iSing -> - paren .)
    >               reduce using rule 68 (iSing -> - paren .)
    <               reduce using rule 68 (iSing -> - paren .)
    )               reduce using rule 68 (iSing -> - paren .)
    ;               reduce using rule 68 (iSing -> - paren .)
    MULEQ           reduce using rule 68 (iSing -> - paren .)
    }               reduce using rule 68 (iSing -> - paren .)
    ,               reduce using rule 68 (iSing -> - paren .)
    ]               reduce using rule 68 (iSing -> - paren .)
    EQEQ            reduce using rule 68 (iSing -> - paren .)
    DISTINTO        reduce using rule 68 (iSing -> - paren .)
    AND             reduce using rule 68 (iSing -> - paren .)
    ?               reduce using rule 68 (iSing -> - paren .)
    OR              reduce using rule 68 (iSing -> - paren .)
    :               reduce using rule 68 (iSing -> - paren .)


state 133

    (92) menor -> tCompare < . tCompare
    (100) tCompare -> . eMat
    (101) tCompare -> . varsOps
    (102) tCompare -> . varYVals
    (59) eMat -> . eMat + p
    (60) eMat -> . eMat - p
    (61) eMat -> . p
    (49) varsOps -> . MENOSMENOS varYVals
    (50) varsOps -> . MASMAS varYVals
    (51) varsOps -> . varYVals MASMAS
    (52) varsOps -> . varYVals MENOSMENOS
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (62) p -> . p * exp
    (63) p -> . p / exp
    (64) p -> . p % exp
    (65) p -> . exp
    (43) vecVal -> . ID m
    (66) exp -> . exp ^ iSing
    (67) exp -> . iSing
    (68) iSing -> . - paren
    (69) iSing -> . + paren
    (70) iSing -> . paren
    (71) paren -> . ( eMat )
    (72) paren -> . INT
    (73) paren -> . varYVals
    (74) paren -> . FLOAT
    (75) paren -> . varsOps
    (76) paren -> . funcInt
    (23) funcInt -> . MULTIESCALAR ( vec , eMat , param )
    (24) funcInt -> . LENGTH ( vec )

    MENOSMENOS      shift and go to state 30
    MASMAS          shift and go to state 27
    ID              shift and go to state 52
    -               shift and go to state 69
    +               shift and go to state 68
    (               shift and go to state 128
    INT             shift and go to state 75
    FLOAT           shift and go to state 76
    MULTIESCALAR    shift and go to state 23
    LENGTH          shift and go to state 26

    eMat                           shift and go to state 66
    p                              shift and go to state 78
    funcInt                        shift and go to state 62
    tCompare                       shift and go to state 170
    varsOps                        shift and go to state 79
    exp                            shift and go to state 80
    paren                          shift and go to state 73
    varYVals                       shift and go to state 171
    vecVal                         shift and go to state 9
    iSing                          shift and go to state 71

state 134

    (90) mayor -> tCompare > . tCompare
    (100) tCompare -> . eMat
    (101) tCompare -> . varsOps
    (102) tCompare -> . varYVals
    (59) eMat -> . eMat + p
    (60) eMat -> . eMat - p
    (61) eMat -> . p
    (49) varsOps -> . MENOSMENOS varYVals
    (50) varsOps -> . MASMAS varYVals
    (51) varsOps -> . varYVals MASMAS
    (52) varsOps -> . varYVals MENOSMENOS
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (62) p -> . p * exp
    (63) p -> . p / exp
    (64) p -> . p % exp
    (65) p -> . exp
    (43) vecVal -> . ID m
    (66) exp -> . exp ^ iSing
    (67) exp -> . iSing
    (68) iSing -> . - paren
    (69) iSing -> . + paren
    (70) iSing -> . paren
    (71) paren -> . ( eMat )
    (72) paren -> . INT
    (73) paren -> . varYVals
    (74) paren -> . FLOAT
    (75) paren -> . varsOps
    (76) paren -> . funcInt
    (23) funcInt -> . MULTIESCALAR ( vec , eMat , param )
    (24) funcInt -> . LENGTH ( vec )

    MENOSMENOS      shift and go to state 30
    MASMAS          shift and go to state 27
    ID              shift and go to state 52
    -               shift and go to state 69
    +               shift and go to state 68
    (               shift and go to state 128
    INT             shift and go to state 75
    FLOAT           shift and go to state 76
    MULTIESCALAR    shift and go to state 23
    LENGTH          shift and go to state 26

    eMat                           shift and go to state 66
    p                              shift and go to state 78
    funcInt                        shift and go to state 62
    tCompare                       shift and go to state 172
    varsOps                        shift and go to state 79
    exp                            shift and go to state 80
    paren                          shift and go to state 73
    varYVals                       shift and go to state 171
    vecVal                         shift and go to state 9
    iSing                          shift and go to state 71

state 135

    (83) or -> or OR . and
    (85) and -> . and AND eq
    (86) and -> . eq
    (87) eq -> . eq EQEQ tBool
    (88) eq -> . eq DISTINTO tBool
    (89) eq -> . mayor
    (90) mayor -> . tCompare > tCompare
    (91) mayor -> . menor
    (100) tCompare -> . eMat
    (101) tCompare -> . varsOps
    (102) tCompare -> . varYVals
    (92) menor -> . tCompare < tCompare
    (93) menor -> . not
    (59) eMat -> . eMat + p
    (60) eMat -> . eMat - p
    (61) eMat -> . p
    (49) varsOps -> . MENOSMENOS varYVals
    (50) varsOps -> . MASMAS varYVals
    (51) varsOps -> . varYVals MASMAS
    (52) varsOps -> . varYVals MENOSMENOS
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (94) not -> . NOT not
    (95) not -> . tBool
    (62) p -> . p * exp
    (63) p -> . p / exp
    (64) p -> . p % exp
    (65) p -> . exp
    (43) vecVal -> . ID m
    (96) tBool -> . ( expBool )
    (97) tBool -> . BOOL
    (98) tBool -> . varYVals
    (99) tBool -> . funcBool
    (66) exp -> . exp ^ iSing
    (67) exp -> . iSing
    (26) funcBool -> . COLINEALES ( vec , vec )
    (68) iSing -> . - paren
    (69) iSing -> . + paren
    (70) iSing -> . paren
    (71) paren -> . ( eMat )
    (72) paren -> . INT
    (73) paren -> . varYVals
    (74) paren -> . FLOAT
    (75) paren -> . varsOps
    (76) paren -> . funcInt
    (23) funcInt -> . MULTIESCALAR ( vec , eMat , param )
    (24) funcInt -> . LENGTH ( vec )

    MENOSMENOS      shift and go to state 30
    MASMAS          shift and go to state 27
    ID              shift and go to state 52
    NOT             shift and go to state 81
    (               shift and go to state 67
    BOOL            shift and go to state 70
    COLINEALES      shift and go to state 15
    -               shift and go to state 69
    +               shift and go to state 68
    INT             shift and go to state 75
    FLOAT           shift and go to state 76
    MULTIESCALAR    shift and go to state 23
    LENGTH          shift and go to state 26

    and                            shift and go to state 173
    funcBool                       shift and go to state 61
    funcInt                        shift and go to state 62
    menor                          shift and go to state 63
    eq                             shift and go to state 64
    mayor                          shift and go to state 65
    eMat                           shift and go to state 66
    vecVal                         shift and go to state 9
    paren                          shift and go to state 73
    iSing                          shift and go to state 71
    tCompare                       shift and go to state 72
    not                            shift and go to state 74
    p                              shift and go to state 78
    varsOps                        shift and go to state 79
    exp                            shift and go to state 80
    tBool                          shift and go to state 82
    varYVals                       shift and go to state 83

state 136

    (81) expBool -> or ? . expBool : expBool
    (81) expBool -> . or ? expBool : expBool
    (82) expBool -> . or
    (83) or -> . or OR and
    (84) or -> . and
    (85) and -> . and AND eq
    (86) and -> . eq
    (87) eq -> . eq EQEQ tBool
    (88) eq -> . eq DISTINTO tBool
    (89) eq -> . mayor
    (90) mayor -> . tCompare > tCompare
    (91) mayor -> . menor
    (100) tCompare -> . eMat
    (101) tCompare -> . varsOps
    (102) tCompare -> . varYVals
    (92) menor -> . tCompare < tCompare
    (93) menor -> . not
    (59) eMat -> . eMat + p
    (60) eMat -> . eMat - p
    (61) eMat -> . p
    (49) varsOps -> . MENOSMENOS varYVals
    (50) varsOps -> . MASMAS varYVals
    (51) varsOps -> . varYVals MASMAS
    (52) varsOps -> . varYVals MENOSMENOS
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (94) not -> . NOT not
    (95) not -> . tBool
    (62) p -> . p * exp
    (63) p -> . p / exp
    (64) p -> . p % exp
    (65) p -> . exp
    (43) vecVal -> . ID m
    (96) tBool -> . ( expBool )
    (97) tBool -> . BOOL
    (98) tBool -> . varYVals
    (99) tBool -> . funcBool
    (66) exp -> . exp ^ iSing
    (67) exp -> . iSing
    (26) funcBool -> . COLINEALES ( vec , vec )
    (68) iSing -> . - paren
    (69) iSing -> . + paren
    (70) iSing -> . paren
    (71) paren -> . ( eMat )
    (72) paren -> . INT
    (73) paren -> . varYVals
    (74) paren -> . FLOAT
    (75) paren -> . varsOps
    (76) paren -> . funcInt
    (23) funcInt -> . MULTIESCALAR ( vec , eMat , param )
    (24) funcInt -> . LENGTH ( vec )

    MENOSMENOS      shift and go to state 30
    MASMAS          shift and go to state 27
    ID              shift and go to state 52
    NOT             shift and go to state 81
    (               shift and go to state 67
    BOOL            shift and go to state 70
    COLINEALES      shift and go to state 15
    -               shift and go to state 69
    +               shift and go to state 68
    INT             shift and go to state 75
    FLOAT           shift and go to state 76
    MULTIESCALAR    shift and go to state 23
    LENGTH          shift and go to state 26

    and                            shift and go to state 60
    funcBool                       shift and go to state 61
    funcInt                        shift and go to state 62
    menor                          shift and go to state 63
    eq                             shift and go to state 64
    mayor                          shift and go to state 65
    eMat                           shift and go to state 66
    vecVal                         shift and go to state 9
    paren                          shift and go to state 73
    iSing                          shift and go to state 71
    tCompare                       shift and go to state 72
    not                            shift and go to state 74
    p                              shift and go to state 78
    varsOps                        shift and go to state 79
    exp                            shift and go to state 80
    tBool                          shift and go to state 82
    varYVals                       shift and go to state 83
    or                             shift and go to state 77
    expBool                        shift and go to state 174

state 137

    (62) p -> p * . exp
    (66) exp -> . exp ^ iSing
    (67) exp -> . iSing
    (68) iSing -> . - paren
    (69) iSing -> . + paren
    (70) iSing -> . paren
    (71) paren -> . ( eMat )
    (72) paren -> . INT
    (73) paren -> . varYVals
    (74) paren -> . FLOAT
    (75) paren -> . varsOps
    (76) paren -> . funcInt
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (49) varsOps -> . MENOSMENOS varYVals
    (50) varsOps -> . MASMAS varYVals
    (51) varsOps -> . varYVals MASMAS
    (52) varsOps -> . varYVals MENOSMENOS
    (23) funcInt -> . MULTIESCALAR ( vec , eMat , param )
    (24) funcInt -> . LENGTH ( vec )
    (43) vecVal -> . ID m

    -               shift and go to state 69
    +               shift and go to state 68
    (               shift and go to state 128
    INT             shift and go to state 75
    FLOAT           shift and go to state 76
    ID              shift and go to state 52
    MENOSMENOS      shift and go to state 30
    MASMAS          shift and go to state 27
    MULTIESCALAR    shift and go to state 23
    LENGTH          shift and go to state 26

    funcInt                        shift and go to state 62
    iSing                          shift and go to state 71
    exp                            shift and go to state 175
    paren                          shift and go to state 73
    varYVals                       shift and go to state 131
    vecVal                         shift and go to state 9
    varsOps                        shift and go to state 129

state 138

    (64) p -> p % . exp
    (66) exp -> . exp ^ iSing
    (67) exp -> . iSing
    (68) iSing -> . - paren
    (69) iSing -> . + paren
    (70) iSing -> . paren
    (71) paren -> . ( eMat )
    (72) paren -> . INT
    (73) paren -> . varYVals
    (74) paren -> . FLOAT
    (75) paren -> . varsOps
    (76) paren -> . funcInt
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (49) varsOps -> . MENOSMENOS varYVals
    (50) varsOps -> . MASMAS varYVals
    (51) varsOps -> . varYVals MASMAS
    (52) varsOps -> . varYVals MENOSMENOS
    (23) funcInt -> . MULTIESCALAR ( vec , eMat , param )
    (24) funcInt -> . LENGTH ( vec )
    (43) vecVal -> . ID m

    -               shift and go to state 69
    +               shift and go to state 68
    (               shift and go to state 128
    INT             shift and go to state 75
    FLOAT           shift and go to state 76
    ID              shift and go to state 52
    MENOSMENOS      shift and go to state 30
    MASMAS          shift and go to state 27
    MULTIESCALAR    shift and go to state 23
    LENGTH          shift and go to state 26

    funcInt                        shift and go to state 62
    iSing                          shift and go to state 71
    exp                            shift and go to state 176
    paren                          shift and go to state 73
    varYVals                       shift and go to state 131
    vecVal                         shift and go to state 9
    varsOps                        shift and go to state 129

state 139

    (63) p -> p / . exp
    (66) exp -> . exp ^ iSing
    (67) exp -> . iSing
    (68) iSing -> . - paren
    (69) iSing -> . + paren
    (70) iSing -> . paren
    (71) paren -> . ( eMat )
    (72) paren -> . INT
    (73) paren -> . varYVals
    (74) paren -> . FLOAT
    (75) paren -> . varsOps
    (76) paren -> . funcInt
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (49) varsOps -> . MENOSMENOS varYVals
    (50) varsOps -> . MASMAS varYVals
    (51) varsOps -> . varYVals MASMAS
    (52) varsOps -> . varYVals MENOSMENOS
    (23) funcInt -> . MULTIESCALAR ( vec , eMat , param )
    (24) funcInt -> . LENGTH ( vec )
    (43) vecVal -> . ID m

    -               shift and go to state 69
    +               shift and go to state 68
    (               shift and go to state 128
    INT             shift and go to state 75
    FLOAT           shift and go to state 76
    ID              shift and go to state 52
    MENOSMENOS      shift and go to state 30
    MASMAS          shift and go to state 27
    MULTIESCALAR    shift and go to state 23
    LENGTH          shift and go to state 26

    funcInt                        shift and go to state 62
    iSing                          shift and go to state 71
    exp                            shift and go to state 177
    paren                          shift and go to state 73
    varYVals                       shift and go to state 131
    vecVal                         shift and go to state 9
    varsOps                        shift and go to state 129

state 140

    (66) exp -> exp ^ . iSing
    (68) iSing -> . - paren
    (69) iSing -> . + paren
    (70) iSing -> . paren
    (71) paren -> . ( eMat )
    (72) paren -> . INT
    (73) paren -> . varYVals
    (74) paren -> . FLOAT
    (75) paren -> . varsOps
    (76) paren -> . funcInt
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (49) varsOps -> . MENOSMENOS varYVals
    (50) varsOps -> . MASMAS varYVals
    (51) varsOps -> . varYVals MASMAS
    (52) varsOps -> . varYVals MENOSMENOS
    (23) funcInt -> . MULTIESCALAR ( vec , eMat , param )
    (24) funcInt -> . LENGTH ( vec )
    (43) vecVal -> . ID m

    -               shift and go to state 69
    +               shift and go to state 68
    (               shift and go to state 128
    INT             shift and go to state 75
    FLOAT           shift and go to state 76
    ID              shift and go to state 52
    MENOSMENOS      shift and go to state 30
    MASMAS          shift and go to state 27
    MULTIESCALAR    shift and go to state 23
    LENGTH          shift and go to state 26

    funcInt                        shift and go to state 62
    varsOps                        shift and go to state 129
    paren                          shift and go to state 73
    varYVals                       shift and go to state 131
    vecVal                         shift and go to state 9
    iSing                          shift and go to state 178

state 141

    (96) tBool -> ( . expBool )
    (81) expBool -> . or ? expBool : expBool
    (82) expBool -> . or
    (83) or -> . or OR and
    (84) or -> . and
    (85) and -> . and AND eq
    (86) and -> . eq
    (87) eq -> . eq EQEQ tBool
    (88) eq -> . eq DISTINTO tBool
    (89) eq -> . mayor
    (90) mayor -> . tCompare > tCompare
    (91) mayor -> . menor
    (100) tCompare -> . eMat
    (101) tCompare -> . varsOps
    (102) tCompare -> . varYVals
    (92) menor -> . tCompare < tCompare
    (93) menor -> . not
    (59) eMat -> . eMat + p
    (60) eMat -> . eMat - p
    (61) eMat -> . p
    (49) varsOps -> . MENOSMENOS varYVals
    (50) varsOps -> . MASMAS varYVals
    (51) varsOps -> . varYVals MASMAS
    (52) varsOps -> . varYVals MENOSMENOS
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (94) not -> . NOT not
    (95) not -> . tBool
    (62) p -> . p * exp
    (63) p -> . p / exp
    (64) p -> . p % exp
    (65) p -> . exp
    (43) vecVal -> . ID m
    (96) tBool -> . ( expBool )
    (97) tBool -> . BOOL
    (98) tBool -> . varYVals
    (99) tBool -> . funcBool
    (66) exp -> . exp ^ iSing
    (67) exp -> . iSing
    (26) funcBool -> . COLINEALES ( vec , vec )
    (68) iSing -> . - paren
    (69) iSing -> . + paren
    (70) iSing -> . paren
    (71) paren -> . ( eMat )
    (72) paren -> . INT
    (73) paren -> . varYVals
    (74) paren -> . FLOAT
    (75) paren -> . varsOps
    (76) paren -> . funcInt
    (23) funcInt -> . MULTIESCALAR ( vec , eMat , param )
    (24) funcInt -> . LENGTH ( vec )

    MENOSMENOS      shift and go to state 30
    MASMAS          shift and go to state 27
    ID              shift and go to state 52
    NOT             shift and go to state 81
    (               shift and go to state 67
    BOOL            shift and go to state 70
    COLINEALES      shift and go to state 15
    -               shift and go to state 69
    +               shift and go to state 68
    INT             shift and go to state 75
    FLOAT           shift and go to state 76
    MULTIESCALAR    shift and go to state 23
    LENGTH          shift and go to state 26

    and                            shift and go to state 60
    funcBool                       shift and go to state 61
    funcInt                        shift and go to state 62
    menor                          shift and go to state 63
    eq                             shift and go to state 64
    mayor                          shift and go to state 65
    eMat                           shift and go to state 66
    vecVal                         shift and go to state 9
    paren                          shift and go to state 73
    iSing                          shift and go to state 71
    tCompare                       shift and go to state 72
    not                            shift and go to state 74
    p                              shift and go to state 78
    varsOps                        shift and go to state 79
    exp                            shift and go to state 80
    tBool                          shift and go to state 82
    varYVals                       shift and go to state 83
    or                             shift and go to state 77
    expBool                        shift and go to state 127

state 142

    (94) not -> NOT not .

    EQEQ            reduce using rule 94 (not -> NOT not .)
    DISTINTO        reduce using rule 94 (not -> NOT not .)
    AND             reduce using rule 94 (not -> NOT not .)
    ?               reduce using rule 94 (not -> NOT not .)
    OR              reduce using rule 94 (not -> NOT not .)
    MULEQ           reduce using rule 94 (not -> NOT not .)
    ;               reduce using rule 94 (not -> NOT not .)
    )               reduce using rule 94 (not -> NOT not .)
    }               reduce using rule 94 (not -> NOT not .)
    ,               reduce using rule 94 (not -> NOT not .)
    ]               reduce using rule 94 (not -> NOT not .)
    :               reduce using rule 94 (not -> NOT not .)


state 143

    (98) tBool -> varYVals .

    EQEQ            reduce using rule 98 (tBool -> varYVals .)
    DISTINTO        reduce using rule 98 (tBool -> varYVals .)
    AND             reduce using rule 98 (tBool -> varYVals .)
    ?               reduce using rule 98 (tBool -> varYVals .)
    OR              reduce using rule 98 (tBool -> varYVals .)
    )               reduce using rule 98 (tBool -> varYVals .)
    ;               reduce using rule 98 (tBool -> varYVals .)
    MULEQ           reduce using rule 98 (tBool -> varYVals .)
    }               reduce using rule 98 (tBool -> varYVals .)
    ,               reduce using rule 98 (tBool -> varYVals .)
    ]               reduce using rule 98 (tBool -> varYVals .)
    :               reduce using rule 98 (tBool -> varYVals .)


state 144

    (10) loop -> WHILE ( expBool ) . bloque
    (16) bloque -> . sentencia ;
    (17) bloque -> . { g }
    (4) sentencia -> . varsOps ;
    (5) sentencia -> . func ;
    (6) sentencia -> . varAsig ;
    (7) sentencia -> . RETURN ;
    (49) varsOps -> . MENOSMENOS varYVals
    (50) varsOps -> . MASMAS varYVals
    (51) varsOps -> . varYVals MASMAS
    (52) varsOps -> . varYVals MENOSMENOS
    (18) func -> . funcReturn
    (19) func -> . funcVoid
    (53) varAsig -> . ID MULEQ varAsig
    (54) varAsig -> . asig MULEQ varAsig
    (55) varAsig -> . ID MULEQ valores
    (56) varAsig -> . asig
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (20) funcReturn -> . funcInt
    (21) funcReturn -> . funcString
    (22) funcReturn -> . funcBool
    (27) funcVoid -> . PRINT ( valores )
    (57) asig -> . ID = asig
    (58) asig -> . ID = valores
    (43) vecVal -> . ID m
    (23) funcInt -> . MULTIESCALAR ( vec , eMat , param )
    (24) funcInt -> . LENGTH ( vec )
    (25) funcString -> . CAPITALIZAR ( expString )
    (26) funcBool -> . COLINEALES ( vec , vec )

    {               shift and go to state 33
    RETURN          shift and go to state 2
    MENOSMENOS      shift and go to state 30
    MASMAS          shift and go to state 27
    ID              shift and go to state 18
    PRINT           shift and go to state 8
    MULTIESCALAR    shift and go to state 23
    LENGTH          shift and go to state 26
    CAPITALIZAR     shift and go to state 25
    COLINEALES      shift and go to state 15

    varAsig                        shift and go to state 20
    sentencia                      shift and go to state 32
    funcInt                        shift and go to state 5
    funcBool                       shift and go to state 3
    funcString                     shift and go to state 22
    asig                           shift and go to state 12
    funcVoid                       shift and go to state 14
    funcReturn                     shift and go to state 24
    varsOps                        shift and go to state 28
    func                           shift and go to state 17
    bloque                         shift and go to state 179
    varYVals                       shift and go to state 29
    vecVal                         shift and go to state 9

state 145

    (73) paren -> varYVals .
    (51) varsOps -> varYVals . MASMAS
    (52) varsOps -> varYVals . MENOSMENOS
    (102) tCompare -> varYVals .
    (98) tBool -> varYVals .

  ! reduce/reduce conflict for > resolved using rule 73 (paren -> varYVals .)
  ! reduce/reduce conflict for < resolved using rule 73 (paren -> varYVals .)
  ! reduce/reduce conflict for ) resolved using rule 73 (paren -> varYVals .)
    ^               reduce using rule 73 (paren -> varYVals .)
    *               reduce using rule 73 (paren -> varYVals .)
    /               reduce using rule 73 (paren -> varYVals .)
    %               reduce using rule 73 (paren -> varYVals .)
    )               reduce using rule 73 (paren -> varYVals .)
    +               reduce using rule 73 (paren -> varYVals .)
    -               reduce using rule 73 (paren -> varYVals .)
    >               reduce using rule 73 (paren -> varYVals .)
    <               reduce using rule 73 (paren -> varYVals .)
    MASMAS          shift and go to state 54
    MENOSMENOS      shift and go to state 55
    EQEQ            reduce using rule 98 (tBool -> varYVals .)
    DISTINTO        reduce using rule 98 (tBool -> varYVals .)
    AND             reduce using rule 98 (tBool -> varYVals .)
    ?               reduce using rule 98 (tBool -> varYVals .)
    OR              reduce using rule 98 (tBool -> varYVals .)

  ! >               [ reduce using rule 102 (tCompare -> varYVals .) ]
  ! <               [ reduce using rule 102 (tCompare -> varYVals .) ]
  ! )               [ reduce using rule 98 (tBool -> varYVals .) ]


state 146

    (77) expString -> expString + . STRING

    STRING          shift and go to state 180


state 147

    (40) valores -> ID . . ID

    ID              shift and go to state 181


state 148

    (27) funcVoid -> PRINT ( valores ) .

    ;               reduce using rule 27 (funcVoid -> PRINT ( valores ) .)


state 149

    (46) reg -> { campos . }

    }               shift and go to state 182


state 150

    (47) campos -> ID . : valores , campos
    (40) valores -> ID . . ID
    (41) varYVals -> ID .
    (43) vecVal -> ID . m
    (44) m -> . [ INT ]
    (45) m -> . [ INT ] m

    :               shift and go to state 183
    .               shift and go to state 147
    MASMAS          reduce using rule 41 (varYVals -> ID .)
    MENOSMENOS      reduce using rule 41 (varYVals -> ID .)
    }               reduce using rule 41 (varYVals -> ID .)
    +               reduce using rule 41 (varYVals -> ID .)
    ^               reduce using rule 41 (varYVals -> ID .)
    *               reduce using rule 41 (varYVals -> ID .)
    /               reduce using rule 41 (varYVals -> ID .)
    %               reduce using rule 41 (varYVals -> ID .)
    -               reduce using rule 41 (varYVals -> ID .)
    >               reduce using rule 41 (varYVals -> ID .)
    <               reduce using rule 41 (varYVals -> ID .)
    EQEQ            reduce using rule 41 (varYVals -> ID .)
    DISTINTO        reduce using rule 41 (varYVals -> ID .)
    AND             reduce using rule 41 (varYVals -> ID .)
    ?               reduce using rule 41 (varYVals -> ID .)
    OR              reduce using rule 41 (varYVals -> ID .)
    [               shift and go to state 44

    m                              shift and go to state 42

state 151

    (48) campos -> valores .

    }               reduce using rule 48 (campos -> valores .)


state 152

    (26) funcBool -> COLINEALES ( vec , . vec )
    (31) vec -> . [ elem ]

    [               shift and go to state 103

    vec                            shift and go to state 184

state 153

    (32) elem -> valores . , elem
    (33) elem -> valores .

    ,               shift and go to state 185
    ]               reduce using rule 33 (elem -> valores .)


state 154

    (31) vec -> [ elem . ]

    ]               shift and go to state 186


state 155

    (12) loop -> FOR ( varAsig ; . expBool ; varsOps ) bloque
    (81) expBool -> . or ? expBool : expBool
    (82) expBool -> . or
    (83) or -> . or OR and
    (84) or -> . and
    (85) and -> . and AND eq
    (86) and -> . eq
    (87) eq -> . eq EQEQ tBool
    (88) eq -> . eq DISTINTO tBool
    (89) eq -> . mayor
    (90) mayor -> . tCompare > tCompare
    (91) mayor -> . menor
    (100) tCompare -> . eMat
    (101) tCompare -> . varsOps
    (102) tCompare -> . varYVals
    (92) menor -> . tCompare < tCompare
    (93) menor -> . not
    (59) eMat -> . eMat + p
    (60) eMat -> . eMat - p
    (61) eMat -> . p
    (49) varsOps -> . MENOSMENOS varYVals
    (50) varsOps -> . MASMAS varYVals
    (51) varsOps -> . varYVals MASMAS
    (52) varsOps -> . varYVals MENOSMENOS
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (94) not -> . NOT not
    (95) not -> . tBool
    (62) p -> . p * exp
    (63) p -> . p / exp
    (64) p -> . p % exp
    (65) p -> . exp
    (43) vecVal -> . ID m
    (96) tBool -> . ( expBool )
    (97) tBool -> . BOOL
    (98) tBool -> . varYVals
    (99) tBool -> . funcBool
    (66) exp -> . exp ^ iSing
    (67) exp -> . iSing
    (26) funcBool -> . COLINEALES ( vec , vec )
    (68) iSing -> . - paren
    (69) iSing -> . + paren
    (70) iSing -> . paren
    (71) paren -> . ( eMat )
    (72) paren -> . INT
    (73) paren -> . varYVals
    (74) paren -> . FLOAT
    (75) paren -> . varsOps
    (76) paren -> . funcInt
    (23) funcInt -> . MULTIESCALAR ( vec , eMat , param )
    (24) funcInt -> . LENGTH ( vec )

    MENOSMENOS      shift and go to state 30
    MASMAS          shift and go to state 27
    ID              shift and go to state 52
    NOT             shift and go to state 81
    (               shift and go to state 67
    BOOL            shift and go to state 70
    COLINEALES      shift and go to state 15
    -               shift and go to state 69
    +               shift and go to state 68
    INT             shift and go to state 75
    FLOAT           shift and go to state 76
    MULTIESCALAR    shift and go to state 23
    LENGTH          shift and go to state 26

    and                            shift and go to state 60
    funcBool                       shift and go to state 61
    funcInt                        shift and go to state 62
    menor                          shift and go to state 63
    eq                             shift and go to state 64
    mayor                          shift and go to state 65
    eMat                           shift and go to state 66
    vecVal                         shift and go to state 9
    paren                          shift and go to state 73
    iSing                          shift and go to state 71
    tCompare                       shift and go to state 72
    not                            shift and go to state 74
    p                              shift and go to state 78
    varsOps                        shift and go to state 79
    exp                            shift and go to state 80
    tBool                          shift and go to state 82
    varYVals                       shift and go to state 83
    or                             shift and go to state 77
    expBool                        shift and go to state 187

state 156

    (44) m -> [ INT ] .
    (45) m -> [ INT ] . m
    (44) m -> . [ INT ]
    (45) m -> . [ INT ] m

    MASMAS          reduce using rule 44 (m -> [ INT ] .)
    MENOSMENOS      reduce using rule 44 (m -> [ INT ] .)
    )               reduce using rule 44 (m -> [ INT ] .)
    +               reduce using rule 44 (m -> [ INT ] .)
    ^               reduce using rule 44 (m -> [ INT ] .)
    *               reduce using rule 44 (m -> [ INT ] .)
    /               reduce using rule 44 (m -> [ INT ] .)
    %               reduce using rule 44 (m -> [ INT ] .)
    -               reduce using rule 44 (m -> [ INT ] .)
    >               reduce using rule 44 (m -> [ INT ] .)
    <               reduce using rule 44 (m -> [ INT ] .)
    EQEQ            reduce using rule 44 (m -> [ INT ] .)
    DISTINTO        reduce using rule 44 (m -> [ INT ] .)
    AND             reduce using rule 44 (m -> [ INT ] .)
    ?               reduce using rule 44 (m -> [ INT ] .)
    OR              reduce using rule 44 (m -> [ INT ] .)
    ,               reduce using rule 44 (m -> [ INT ] .)
    ]               reduce using rule 44 (m -> [ INT ] .)
    MULEQ           reduce using rule 44 (m -> [ INT ] .)
    ;               reduce using rule 44 (m -> [ INT ] .)
    }               reduce using rule 44 (m -> [ INT ] .)
    :               reduce using rule 44 (m -> [ INT ] .)
    [               shift and go to state 44

    m                              shift and go to state 188

state 157

    (13) if -> IF ( expBool ) . bloque else
    (16) bloque -> . sentencia ;
    (17) bloque -> . { g }
    (4) sentencia -> . varsOps ;
    (5) sentencia -> . func ;
    (6) sentencia -> . varAsig ;
    (7) sentencia -> . RETURN ;
    (49) varsOps -> . MENOSMENOS varYVals
    (50) varsOps -> . MASMAS varYVals
    (51) varsOps -> . varYVals MASMAS
    (52) varsOps -> . varYVals MENOSMENOS
    (18) func -> . funcReturn
    (19) func -> . funcVoid
    (53) varAsig -> . ID MULEQ varAsig
    (54) varAsig -> . asig MULEQ varAsig
    (55) varAsig -> . ID MULEQ valores
    (56) varAsig -> . asig
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (20) funcReturn -> . funcInt
    (21) funcReturn -> . funcString
    (22) funcReturn -> . funcBool
    (27) funcVoid -> . PRINT ( valores )
    (57) asig -> . ID = asig
    (58) asig -> . ID = valores
    (43) vecVal -> . ID m
    (23) funcInt -> . MULTIESCALAR ( vec , eMat , param )
    (24) funcInt -> . LENGTH ( vec )
    (25) funcString -> . CAPITALIZAR ( expString )
    (26) funcBool -> . COLINEALES ( vec , vec )

    {               shift and go to state 33
    RETURN          shift and go to state 2
    MENOSMENOS      shift and go to state 30
    MASMAS          shift and go to state 27
    ID              shift and go to state 18
    PRINT           shift and go to state 8
    MULTIESCALAR    shift and go to state 23
    LENGTH          shift and go to state 26
    CAPITALIZAR     shift and go to state 25
    COLINEALES      shift and go to state 15

    funcBool                       shift and go to state 3
    funcInt                        shift and go to state 5
    bloque                         shift and go to state 189
    vecVal                         shift and go to state 9
    sentencia                      shift and go to state 32
    asig                           shift and go to state 12
    funcVoid                       shift and go to state 14
    func                           shift and go to state 17
    varAsig                        shift and go to state 20
    funcString                     shift and go to state 22
    funcReturn                     shift and go to state 24
    varsOps                        shift and go to state 28
    varYVals                       shift and go to state 29

state 158

    (23) funcInt -> MULTIESCALAR ( vec , . eMat , param )
    (59) eMat -> . eMat + p
    (60) eMat -> . eMat - p
    (61) eMat -> . p
    (62) p -> . p * exp
    (63) p -> . p / exp
    (64) p -> . p % exp
    (65) p -> . exp
    (66) exp -> . exp ^ iSing
    (67) exp -> . iSing
    (68) iSing -> . - paren
    (69) iSing -> . + paren
    (70) iSing -> . paren
    (71) paren -> . ( eMat )
    (72) paren -> . INT
    (73) paren -> . varYVals
    (74) paren -> . FLOAT
    (75) paren -> . varsOps
    (76) paren -> . funcInt
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (49) varsOps -> . MENOSMENOS varYVals
    (50) varsOps -> . MASMAS varYVals
    (51) varsOps -> . varYVals MASMAS
    (52) varsOps -> . varYVals MENOSMENOS
    (23) funcInt -> . MULTIESCALAR ( vec , eMat , param )
    (24) funcInt -> . LENGTH ( vec )
    (43) vecVal -> . ID m

    -               shift and go to state 69
    +               shift and go to state 68
    (               shift and go to state 128
    INT             shift and go to state 75
    FLOAT           shift and go to state 76
    ID              shift and go to state 52
    MENOSMENOS      shift and go to state 30
    MASMAS          shift and go to state 27
    MULTIESCALAR    shift and go to state 23
    LENGTH          shift and go to state 26

    eMat                           shift and go to state 190
    funcInt                        shift and go to state 62
    p                              shift and go to state 78
    iSing                          shift and go to state 71
    exp                            shift and go to state 80
    paren                          shift and go to state 73
    varsOps                        shift and go to state 129
    varYVals                       shift and go to state 131
    vecVal                         shift and go to state 9

state 159

    (25) funcString -> CAPITALIZAR ( expString ) .

    +               reduce using rule 25 (funcString -> CAPITALIZAR ( expString ) .)
    ,               reduce using rule 25 (funcString -> CAPITALIZAR ( expString ) .)
    ]               reduce using rule 25 (funcString -> CAPITALIZAR ( expString ) .)
    ;               reduce using rule 25 (funcString -> CAPITALIZAR ( expString ) .)
    }               reduce using rule 25 (funcString -> CAPITALIZAR ( expString ) .)
    )               reduce using rule 25 (funcString -> CAPITALIZAR ( expString ) .)
    MULEQ           reduce using rule 25 (funcString -> CAPITALIZAR ( expString ) .)


state 160

    (24) funcInt -> LENGTH ( vec ) .

    ^               reduce using rule 24 (funcInt -> LENGTH ( vec ) .)
    *               reduce using rule 24 (funcInt -> LENGTH ( vec ) .)
    /               reduce using rule 24 (funcInt -> LENGTH ( vec ) .)
    %               reduce using rule 24 (funcInt -> LENGTH ( vec ) .)
    +               reduce using rule 24 (funcInt -> LENGTH ( vec ) .)
    -               reduce using rule 24 (funcInt -> LENGTH ( vec ) .)
    >               reduce using rule 24 (funcInt -> LENGTH ( vec ) .)
    <               reduce using rule 24 (funcInt -> LENGTH ( vec ) .)
    ;               reduce using rule 24 (funcInt -> LENGTH ( vec ) .)
    )               reduce using rule 24 (funcInt -> LENGTH ( vec ) .)
    MULEQ           reduce using rule 24 (funcInt -> LENGTH ( vec ) .)
    }               reduce using rule 24 (funcInt -> LENGTH ( vec ) .)
    ,               reduce using rule 24 (funcInt -> LENGTH ( vec ) .)
    ]               reduce using rule 24 (funcInt -> LENGTH ( vec ) .)
    EQEQ            reduce using rule 24 (funcInt -> LENGTH ( vec ) .)
    DISTINTO        reduce using rule 24 (funcInt -> LENGTH ( vec ) .)
    AND             reduce using rule 24 (funcInt -> LENGTH ( vec ) .)
    ?               reduce using rule 24 (funcInt -> LENGTH ( vec ) .)
    OR              reduce using rule 24 (funcInt -> LENGTH ( vec ) .)
    :               reduce using rule 24 (funcInt -> LENGTH ( vec ) .)


state 161

    (11) loop -> DO bloque WHILE ( expBool . ) ;

    )               shift and go to state 191


state 162

    (85) and -> and AND eq .
    (87) eq -> eq . EQEQ tBool
    (88) eq -> eq . DISTINTO tBool

    AND             reduce using rule 85 (and -> and AND eq .)
    ?               reduce using rule 85 (and -> and AND eq .)
    OR              reduce using rule 85 (and -> and AND eq .)
    ,               reduce using rule 85 (and -> and AND eq .)
    ]               reduce using rule 85 (and -> and AND eq .)
    }               reduce using rule 85 (and -> and AND eq .)
    )               reduce using rule 85 (and -> and AND eq .)
    ;               reduce using rule 85 (and -> and AND eq .)
    MULEQ           reduce using rule 85 (and -> and AND eq .)
    :               reduce using rule 85 (and -> and AND eq .)
    EQEQ            shift and go to state 121
    DISTINTO        shift and go to state 122


state 163

    (87) eq -> eq EQEQ tBool .

    EQEQ            reduce using rule 87 (eq -> eq EQEQ tBool .)
    DISTINTO        reduce using rule 87 (eq -> eq EQEQ tBool .)
    AND             reduce using rule 87 (eq -> eq EQEQ tBool .)
    ?               reduce using rule 87 (eq -> eq EQEQ tBool .)
    OR              reduce using rule 87 (eq -> eq EQEQ tBool .)
    )               reduce using rule 87 (eq -> eq EQEQ tBool .)
    ,               reduce using rule 87 (eq -> eq EQEQ tBool .)
    :               reduce using rule 87 (eq -> eq EQEQ tBool .)
    ]               reduce using rule 87 (eq -> eq EQEQ tBool .)
    ;               reduce using rule 87 (eq -> eq EQEQ tBool .)
    MULEQ           reduce using rule 87 (eq -> eq EQEQ tBool .)
    }               reduce using rule 87 (eq -> eq EQEQ tBool .)


state 164

    (88) eq -> eq DISTINTO tBool .

    EQEQ            reduce using rule 88 (eq -> eq DISTINTO tBool .)
    DISTINTO        reduce using rule 88 (eq -> eq DISTINTO tBool .)
    AND             reduce using rule 88 (eq -> eq DISTINTO tBool .)
    ?               reduce using rule 88 (eq -> eq DISTINTO tBool .)
    OR              reduce using rule 88 (eq -> eq DISTINTO tBool .)
    )               reduce using rule 88 (eq -> eq DISTINTO tBool .)
    ,               reduce using rule 88 (eq -> eq DISTINTO tBool .)
    :               reduce using rule 88 (eq -> eq DISTINTO tBool .)
    ]               reduce using rule 88 (eq -> eq DISTINTO tBool .)
    ;               reduce using rule 88 (eq -> eq DISTINTO tBool .)
    MULEQ           reduce using rule 88 (eq -> eq DISTINTO tBool .)
    }               reduce using rule 88 (eq -> eq DISTINTO tBool .)


state 165

    (59) eMat -> eMat + p .
    (62) p -> p . * exp
    (63) p -> p . / exp
    (64) p -> p . % exp

    +               reduce using rule 59 (eMat -> eMat + p .)
    -               reduce using rule 59 (eMat -> eMat + p .)
    ,               reduce using rule 59 (eMat -> eMat + p .)
    >               reduce using rule 59 (eMat -> eMat + p .)
    <               reduce using rule 59 (eMat -> eMat + p .)
    MULEQ           reduce using rule 59 (eMat -> eMat + p .)
    ;               reduce using rule 59 (eMat -> eMat + p .)
    )               reduce using rule 59 (eMat -> eMat + p .)
    EQEQ            reduce using rule 59 (eMat -> eMat + p .)
    DISTINTO        reduce using rule 59 (eMat -> eMat + p .)
    AND             reduce using rule 59 (eMat -> eMat + p .)
    ?               reduce using rule 59 (eMat -> eMat + p .)
    OR              reduce using rule 59 (eMat -> eMat + p .)
    }               reduce using rule 59 (eMat -> eMat + p .)
    ]               reduce using rule 59 (eMat -> eMat + p .)
    :               reduce using rule 59 (eMat -> eMat + p .)
    *               shift and go to state 137
    /               shift and go to state 139
    %               shift and go to state 138


state 166

    (60) eMat -> eMat - p .
    (62) p -> p . * exp
    (63) p -> p . / exp
    (64) p -> p . % exp

    +               reduce using rule 60 (eMat -> eMat - p .)
    -               reduce using rule 60 (eMat -> eMat - p .)
    ,               reduce using rule 60 (eMat -> eMat - p .)
    >               reduce using rule 60 (eMat -> eMat - p .)
    <               reduce using rule 60 (eMat -> eMat - p .)
    MULEQ           reduce using rule 60 (eMat -> eMat - p .)
    ;               reduce using rule 60 (eMat -> eMat - p .)
    )               reduce using rule 60 (eMat -> eMat - p .)
    EQEQ            reduce using rule 60 (eMat -> eMat - p .)
    DISTINTO        reduce using rule 60 (eMat -> eMat - p .)
    AND             reduce using rule 60 (eMat -> eMat - p .)
    ?               reduce using rule 60 (eMat -> eMat - p .)
    OR              reduce using rule 60 (eMat -> eMat - p .)
    }               reduce using rule 60 (eMat -> eMat - p .)
    ]               reduce using rule 60 (eMat -> eMat - p .)
    :               reduce using rule 60 (eMat -> eMat - p .)
    *               shift and go to state 137
    /               shift and go to state 139
    %               shift and go to state 138


state 167

    (71) paren -> ( eMat ) .

    ^               reduce using rule 71 (paren -> ( eMat ) .)
    *               reduce using rule 71 (paren -> ( eMat ) .)
    /               reduce using rule 71 (paren -> ( eMat ) .)
    %               reduce using rule 71 (paren -> ( eMat ) .)
    )               reduce using rule 71 (paren -> ( eMat ) .)
    +               reduce using rule 71 (paren -> ( eMat ) .)
    -               reduce using rule 71 (paren -> ( eMat ) .)
    >               reduce using rule 71 (paren -> ( eMat ) .)
    <               reduce using rule 71 (paren -> ( eMat ) .)
    ,               reduce using rule 71 (paren -> ( eMat ) .)
    ;               reduce using rule 71 (paren -> ( eMat ) .)
    MULEQ           reduce using rule 71 (paren -> ( eMat ) .)
    }               reduce using rule 71 (paren -> ( eMat ) .)
    ]               reduce using rule 71 (paren -> ( eMat ) .)
    EQEQ            reduce using rule 71 (paren -> ( eMat ) .)
    DISTINTO        reduce using rule 71 (paren -> ( eMat ) .)
    AND             reduce using rule 71 (paren -> ( eMat ) .)
    ?               reduce using rule 71 (paren -> ( eMat ) .)
    OR              reduce using rule 71 (paren -> ( eMat ) .)
    :               reduce using rule 71 (paren -> ( eMat ) .)


state 168

    (96) tBool -> ( expBool ) .

    EQEQ            reduce using rule 96 (tBool -> ( expBool ) .)
    DISTINTO        reduce using rule 96 (tBool -> ( expBool ) .)
    AND             reduce using rule 96 (tBool -> ( expBool ) .)
    ?               reduce using rule 96 (tBool -> ( expBool ) .)
    OR              reduce using rule 96 (tBool -> ( expBool ) .)
    ,               reduce using rule 96 (tBool -> ( expBool ) .)
    )               reduce using rule 96 (tBool -> ( expBool ) .)
    ;               reduce using rule 96 (tBool -> ( expBool ) .)
    MULEQ           reduce using rule 96 (tBool -> ( expBool ) .)
    }               reduce using rule 96 (tBool -> ( expBool ) .)
    ]               reduce using rule 96 (tBool -> ( expBool ) .)
    :               reduce using rule 96 (tBool -> ( expBool ) .)


state 169

    (71) paren -> ( eMat . )
    (59) eMat -> eMat . + p
    (60) eMat -> eMat . - p

    )               shift and go to state 167
    +               shift and go to state 123
    -               shift and go to state 124


state 170

    (92) menor -> tCompare < tCompare .

    EQEQ            reduce using rule 92 (menor -> tCompare < tCompare .)
    DISTINTO        reduce using rule 92 (menor -> tCompare < tCompare .)
    AND             reduce using rule 92 (menor -> tCompare < tCompare .)
    ?               reduce using rule 92 (menor -> tCompare < tCompare .)
    OR              reduce using rule 92 (menor -> tCompare < tCompare .)
    }               reduce using rule 92 (menor -> tCompare < tCompare .)
    )               reduce using rule 92 (menor -> tCompare < tCompare .)
    ;               reduce using rule 92 (menor -> tCompare < tCompare .)
    MULEQ           reduce using rule 92 (menor -> tCompare < tCompare .)
    ,               reduce using rule 92 (menor -> tCompare < tCompare .)
    ]               reduce using rule 92 (menor -> tCompare < tCompare .)
    :               reduce using rule 92 (menor -> tCompare < tCompare .)


state 171

    (102) tCompare -> varYVals .
    (51) varsOps -> varYVals . MASMAS
    (52) varsOps -> varYVals . MENOSMENOS
    (73) paren -> varYVals .

  ! reduce/reduce conflict for EQEQ resolved using rule 73 (paren -> varYVals .)
  ! reduce/reduce conflict for DISTINTO resolved using rule 73 (paren -> varYVals .)
  ! reduce/reduce conflict for AND resolved using rule 73 (paren -> varYVals .)
  ! reduce/reduce conflict for ? resolved using rule 73 (paren -> varYVals .)
  ! reduce/reduce conflict for OR resolved using rule 73 (paren -> varYVals .)
  ! reduce/reduce conflict for ) resolved using rule 73 (paren -> varYVals .)
  ! reduce/reduce conflict for ; resolved using rule 73 (paren -> varYVals .)
  ! reduce/reduce conflict for MULEQ resolved using rule 73 (paren -> varYVals .)
  ! reduce/reduce conflict for } resolved using rule 73 (paren -> varYVals .)
  ! reduce/reduce conflict for , resolved using rule 73 (paren -> varYVals .)
  ! reduce/reduce conflict for ] resolved using rule 73 (paren -> varYVals .)
  ! reduce/reduce conflict for : resolved using rule 73 (paren -> varYVals .)
    MASMAS          shift and go to state 54
    MENOSMENOS      shift and go to state 55
    ^               reduce using rule 73 (paren -> varYVals .)
    *               reduce using rule 73 (paren -> varYVals .)
    /               reduce using rule 73 (paren -> varYVals .)
    %               reduce using rule 73 (paren -> varYVals .)
    +               reduce using rule 73 (paren -> varYVals .)
    -               reduce using rule 73 (paren -> varYVals .)
    EQEQ            reduce using rule 73 (paren -> varYVals .)
    DISTINTO        reduce using rule 73 (paren -> varYVals .)
    AND             reduce using rule 73 (paren -> varYVals .)
    ?               reduce using rule 73 (paren -> varYVals .)
    OR              reduce using rule 73 (paren -> varYVals .)
    )               reduce using rule 73 (paren -> varYVals .)
    ;               reduce using rule 73 (paren -> varYVals .)
    MULEQ           reduce using rule 73 (paren -> varYVals .)
    }               reduce using rule 73 (paren -> varYVals .)
    ,               reduce using rule 73 (paren -> varYVals .)
    ]               reduce using rule 73 (paren -> varYVals .)
    :               reduce using rule 73 (paren -> varYVals .)

  ! EQEQ            [ reduce using rule 102 (tCompare -> varYVals .) ]
  ! DISTINTO        [ reduce using rule 102 (tCompare -> varYVals .) ]
  ! AND             [ reduce using rule 102 (tCompare -> varYVals .) ]
  ! ?               [ reduce using rule 102 (tCompare -> varYVals .) ]
  ! OR              [ reduce using rule 102 (tCompare -> varYVals .) ]
  ! )               [ reduce using rule 102 (tCompare -> varYVals .) ]
  ! ;               [ reduce using rule 102 (tCompare -> varYVals .) ]
  ! MULEQ           [ reduce using rule 102 (tCompare -> varYVals .) ]
  ! }               [ reduce using rule 102 (tCompare -> varYVals .) ]
  ! ,               [ reduce using rule 102 (tCompare -> varYVals .) ]
  ! ]               [ reduce using rule 102 (tCompare -> varYVals .) ]
  ! :               [ reduce using rule 102 (tCompare -> varYVals .) ]


state 172

    (90) mayor -> tCompare > tCompare .

    EQEQ            reduce using rule 90 (mayor -> tCompare > tCompare .)
    DISTINTO        reduce using rule 90 (mayor -> tCompare > tCompare .)
    AND             reduce using rule 90 (mayor -> tCompare > tCompare .)
    ?               reduce using rule 90 (mayor -> tCompare > tCompare .)
    OR              reduce using rule 90 (mayor -> tCompare > tCompare .)
    )               reduce using rule 90 (mayor -> tCompare > tCompare .)
    :               reduce using rule 90 (mayor -> tCompare > tCompare .)
    }               reduce using rule 90 (mayor -> tCompare > tCompare .)
    ;               reduce using rule 90 (mayor -> tCompare > tCompare .)
    MULEQ           reduce using rule 90 (mayor -> tCompare > tCompare .)
    ,               reduce using rule 90 (mayor -> tCompare > tCompare .)
    ]               reduce using rule 90 (mayor -> tCompare > tCompare .)


state 173

    (83) or -> or OR and .
    (85) and -> and . AND eq

    ?               reduce using rule 83 (or -> or OR and .)
    OR              reduce using rule 83 (or -> or OR and .)
    )               reduce using rule 83 (or -> or OR and .)
    }               reduce using rule 83 (or -> or OR and .)
    :               reduce using rule 83 (or -> or OR and .)
    ,               reduce using rule 83 (or -> or OR and .)
    ]               reduce using rule 83 (or -> or OR and .)
    ;               reduce using rule 83 (or -> or OR and .)
    MULEQ           reduce using rule 83 (or -> or OR and .)
    AND             shift and go to state 120


state 174

    (81) expBool -> or ? expBool . : expBool

    :               shift and go to state 192


state 175

    (62) p -> p * exp .
    (66) exp -> exp . ^ iSing

    *               reduce using rule 62 (p -> p * exp .)
    /               reduce using rule 62 (p -> p * exp .)
    %               reduce using rule 62 (p -> p * exp .)
    +               reduce using rule 62 (p -> p * exp .)
    -               reduce using rule 62 (p -> p * exp .)
    >               reduce using rule 62 (p -> p * exp .)
    <               reduce using rule 62 (p -> p * exp .)
    )               reduce using rule 62 (p -> p * exp .)
    ;               reduce using rule 62 (p -> p * exp .)
    }               reduce using rule 62 (p -> p * exp .)
    ,               reduce using rule 62 (p -> p * exp .)
    MULEQ           reduce using rule 62 (p -> p * exp .)
    ]               reduce using rule 62 (p -> p * exp .)
    EQEQ            reduce using rule 62 (p -> p * exp .)
    DISTINTO        reduce using rule 62 (p -> p * exp .)
    AND             reduce using rule 62 (p -> p * exp .)
    ?               reduce using rule 62 (p -> p * exp .)
    OR              reduce using rule 62 (p -> p * exp .)
    :               reduce using rule 62 (p -> p * exp .)
    ^               shift and go to state 140


state 176

    (64) p -> p % exp .
    (66) exp -> exp . ^ iSing

    *               reduce using rule 64 (p -> p % exp .)
    /               reduce using rule 64 (p -> p % exp .)
    %               reduce using rule 64 (p -> p % exp .)
    +               reduce using rule 64 (p -> p % exp .)
    -               reduce using rule 64 (p -> p % exp .)
    >               reduce using rule 64 (p -> p % exp .)
    <               reduce using rule 64 (p -> p % exp .)
    )               reduce using rule 64 (p -> p % exp .)
    ;               reduce using rule 64 (p -> p % exp .)
    }               reduce using rule 64 (p -> p % exp .)
    ,               reduce using rule 64 (p -> p % exp .)
    MULEQ           reduce using rule 64 (p -> p % exp .)
    ]               reduce using rule 64 (p -> p % exp .)
    EQEQ            reduce using rule 64 (p -> p % exp .)
    DISTINTO        reduce using rule 64 (p -> p % exp .)
    AND             reduce using rule 64 (p -> p % exp .)
    ?               reduce using rule 64 (p -> p % exp .)
    OR              reduce using rule 64 (p -> p % exp .)
    :               reduce using rule 64 (p -> p % exp .)
    ^               shift and go to state 140


state 177

    (63) p -> p / exp .
    (66) exp -> exp . ^ iSing

    *               reduce using rule 63 (p -> p / exp .)
    /               reduce using rule 63 (p -> p / exp .)
    %               reduce using rule 63 (p -> p / exp .)
    +               reduce using rule 63 (p -> p / exp .)
    -               reduce using rule 63 (p -> p / exp .)
    >               reduce using rule 63 (p -> p / exp .)
    <               reduce using rule 63 (p -> p / exp .)
    )               reduce using rule 63 (p -> p / exp .)
    ;               reduce using rule 63 (p -> p / exp .)
    }               reduce using rule 63 (p -> p / exp .)
    ,               reduce using rule 63 (p -> p / exp .)
    MULEQ           reduce using rule 63 (p -> p / exp .)
    ]               reduce using rule 63 (p -> p / exp .)
    EQEQ            reduce using rule 63 (p -> p / exp .)
    DISTINTO        reduce using rule 63 (p -> p / exp .)
    AND             reduce using rule 63 (p -> p / exp .)
    ?               reduce using rule 63 (p -> p / exp .)
    OR              reduce using rule 63 (p -> p / exp .)
    :               reduce using rule 63 (p -> p / exp .)
    ^               shift and go to state 140


state 178

    (66) exp -> exp ^ iSing .

    ^               reduce using rule 66 (exp -> exp ^ iSing .)
    *               reduce using rule 66 (exp -> exp ^ iSing .)
    /               reduce using rule 66 (exp -> exp ^ iSing .)
    %               reduce using rule 66 (exp -> exp ^ iSing .)
    +               reduce using rule 66 (exp -> exp ^ iSing .)
    -               reduce using rule 66 (exp -> exp ^ iSing .)
    ,               reduce using rule 66 (exp -> exp ^ iSing .)
    ]               reduce using rule 66 (exp -> exp ^ iSing .)
    >               reduce using rule 66 (exp -> exp ^ iSing .)
    <               reduce using rule 66 (exp -> exp ^ iSing .)
    }               reduce using rule 66 (exp -> exp ^ iSing .)
    )               reduce using rule 66 (exp -> exp ^ iSing .)
    ;               reduce using rule 66 (exp -> exp ^ iSing .)
    MULEQ           reduce using rule 66 (exp -> exp ^ iSing .)
    EQEQ            reduce using rule 66 (exp -> exp ^ iSing .)
    DISTINTO        reduce using rule 66 (exp -> exp ^ iSing .)
    AND             reduce using rule 66 (exp -> exp ^ iSing .)
    ?               reduce using rule 66 (exp -> exp ^ iSing .)
    OR              reduce using rule 66 (exp -> exp ^ iSing .)
    :               reduce using rule 66 (exp -> exp ^ iSing .)


state 179

    (10) loop -> WHILE ( expBool ) bloque .

    RETURN          reduce using rule 10 (loop -> WHILE ( expBool ) bloque .)
    MENOSMENOS      reduce using rule 10 (loop -> WHILE ( expBool ) bloque .)
    MASMAS          reduce using rule 10 (loop -> WHILE ( expBool ) bloque .)
    ID              reduce using rule 10 (loop -> WHILE ( expBool ) bloque .)
    IF              reduce using rule 10 (loop -> WHILE ( expBool ) bloque .)
    WHILE           reduce using rule 10 (loop -> WHILE ( expBool ) bloque .)
    DO              reduce using rule 10 (loop -> WHILE ( expBool ) bloque .)
    FOR             reduce using rule 10 (loop -> WHILE ( expBool ) bloque .)
    PRINT           reduce using rule 10 (loop -> WHILE ( expBool ) bloque .)
    MULTIESCALAR    reduce using rule 10 (loop -> WHILE ( expBool ) bloque .)
    LENGTH          reduce using rule 10 (loop -> WHILE ( expBool ) bloque .)
    CAPITALIZAR     reduce using rule 10 (loop -> WHILE ( expBool ) bloque .)
    COLINEALES      reduce using rule 10 (loop -> WHILE ( expBool ) bloque .)
    $end            reduce using rule 10 (loop -> WHILE ( expBool ) bloque .)
    }               reduce using rule 10 (loop -> WHILE ( expBool ) bloque .)


state 180

    (77) expString -> expString + STRING .

    +               reduce using rule 77 (expString -> expString + STRING .)
    ,               reduce using rule 77 (expString -> expString + STRING .)
    ]               reduce using rule 77 (expString -> expString + STRING .)
    )               reduce using rule 77 (expString -> expString + STRING .)
    }               reduce using rule 77 (expString -> expString + STRING .)
    MULEQ           reduce using rule 77 (expString -> expString + STRING .)
    ;               reduce using rule 77 (expString -> expString + STRING .)


state 181

    (40) valores -> ID . ID .

    }               reduce using rule 40 (valores -> ID . ID .)
    )               reduce using rule 40 (valores -> ID . ID .)
    ,               reduce using rule 40 (valores -> ID . ID .)
    ]               reduce using rule 40 (valores -> ID . ID .)
    ;               reduce using rule 40 (valores -> ID . ID .)
    MULEQ           reduce using rule 40 (valores -> ID . ID .)


state 182

    (46) reg -> { campos } .

    ,               reduce using rule 46 (reg -> { campos } .)
    ]               reduce using rule 46 (reg -> { campos } .)
    ;               reduce using rule 46 (reg -> { campos } .)
    )               reduce using rule 46 (reg -> { campos } .)
    MULEQ           reduce using rule 46 (reg -> { campos } .)
    }               reduce using rule 46 (reg -> { campos } .)


state 183

    (47) campos -> ID : . valores , campos
    (34) valores -> . eMat
    (35) valores -> . expBool
    (36) valores -> . expString
    (37) valores -> . varYVals
    (38) valores -> . funcReturn
    (39) valores -> . reg
    (40) valores -> . ID . ID
    (59) eMat -> . eMat + p
    (60) eMat -> . eMat - p
    (61) eMat -> . p
    (81) expBool -> . or ? expBool : expBool
    (82) expBool -> . or
    (77) expString -> . expString + STRING
    (78) expString -> . STRING
    (79) expString -> . varYVals
    (80) expString -> . funcString
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (20) funcReturn -> . funcInt
    (21) funcReturn -> . funcString
    (22) funcReturn -> . funcBool
    (46) reg -> . { campos }
    (62) p -> . p * exp
    (63) p -> . p / exp
    (64) p -> . p % exp
    (65) p -> . exp
    (83) or -> . or OR and
    (84) or -> . and
    (25) funcString -> . CAPITALIZAR ( expString )
    (43) vecVal -> . ID m
    (23) funcInt -> . MULTIESCALAR ( vec , eMat , param )
    (24) funcInt -> . LENGTH ( vec )
    (26) funcBool -> . COLINEALES ( vec , vec )
    (66) exp -> . exp ^ iSing
    (67) exp -> . iSing
    (85) and -> . and AND eq
    (86) and -> . eq
    (68) iSing -> . - paren
    (69) iSing -> . + paren
    (70) iSing -> . paren
    (87) eq -> . eq EQEQ tBool
    (88) eq -> . eq DISTINTO tBool
    (89) eq -> . mayor
    (71) paren -> . ( eMat )
    (72) paren -> . INT
    (73) paren -> . varYVals
    (74) paren -> . FLOAT
    (75) paren -> . varsOps
    (76) paren -> . funcInt
    (90) mayor -> . tCompare > tCompare
    (91) mayor -> . menor
    (49) varsOps -> . MENOSMENOS varYVals
    (50) varsOps -> . MASMAS varYVals
    (51) varsOps -> . varYVals MASMAS
    (52) varsOps -> . varYVals MENOSMENOS
    (100) tCompare -> . eMat
    (101) tCompare -> . varsOps
    (102) tCompare -> . varYVals
    (92) menor -> . tCompare < tCompare
    (93) menor -> . not
    (94) not -> . NOT not
    (95) not -> . tBool
    (96) tBool -> . ( expBool )
    (97) tBool -> . BOOL
    (98) tBool -> . varYVals
    (99) tBool -> . funcBool

    ID              shift and go to state 93
    STRING          shift and go to state 91
    {               shift and go to state 97
    CAPITALIZAR     shift and go to state 25
    MULTIESCALAR    shift and go to state 23
    LENGTH          shift and go to state 26
    COLINEALES      shift and go to state 15
    -               shift and go to state 69
    +               shift and go to state 68
    (               shift and go to state 88
    INT             shift and go to state 75
    FLOAT           shift and go to state 76
    MENOSMENOS      shift and go to state 30
    MASMAS          shift and go to state 27
    NOT             shift and go to state 81
    BOOL            shift and go to state 70

    and                            shift and go to state 60
    funcBool                       shift and go to state 85
    funcInt                        shift and go to state 86
    menor                          shift and go to state 63
    eq                             shift and go to state 64
    vecVal                         shift and go to state 9
    eMat                           shift and go to state 87
    mayor                          shift and go to state 65
    paren                          shift and go to state 73
    reg                            shift and go to state 89
    varsOps                        shift and go to state 90
    expString                      shift and go to state 92
    tCompare                       shift and go to state 72
    not                            shift and go to state 74
    funcString                     shift and go to state 94
    funcReturn                     shift and go to state 95
    valores                        shift and go to state 193
    p                              shift and go to state 78
    iSing                          shift and go to state 71
    exp                            shift and go to state 80
    tBool                          shift and go to state 82
    varYVals                       shift and go to state 98
    or                             shift and go to state 77
    expBool                        shift and go to state 99

state 184

    (26) funcBool -> COLINEALES ( vec , vec . )

    )               shift and go to state 194


state 185

    (32) elem -> valores , . elem
    (32) elem -> . valores , elem
    (33) elem -> . valores
    (34) valores -> . eMat
    (35) valores -> . expBool
    (36) valores -> . expString
    (37) valores -> . varYVals
    (38) valores -> . funcReturn
    (39) valores -> . reg
    (40) valores -> . ID . ID
    (59) eMat -> . eMat + p
    (60) eMat -> . eMat - p
    (61) eMat -> . p
    (81) expBool -> . or ? expBool : expBool
    (82) expBool -> . or
    (77) expString -> . expString + STRING
    (78) expString -> . STRING
    (79) expString -> . varYVals
    (80) expString -> . funcString
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (20) funcReturn -> . funcInt
    (21) funcReturn -> . funcString
    (22) funcReturn -> . funcBool
    (46) reg -> . { campos }
    (62) p -> . p * exp
    (63) p -> . p / exp
    (64) p -> . p % exp
    (65) p -> . exp
    (83) or -> . or OR and
    (84) or -> . and
    (25) funcString -> . CAPITALIZAR ( expString )
    (43) vecVal -> . ID m
    (23) funcInt -> . MULTIESCALAR ( vec , eMat , param )
    (24) funcInt -> . LENGTH ( vec )
    (26) funcBool -> . COLINEALES ( vec , vec )
    (66) exp -> . exp ^ iSing
    (67) exp -> . iSing
    (85) and -> . and AND eq
    (86) and -> . eq
    (68) iSing -> . - paren
    (69) iSing -> . + paren
    (70) iSing -> . paren
    (87) eq -> . eq EQEQ tBool
    (88) eq -> . eq DISTINTO tBool
    (89) eq -> . mayor
    (71) paren -> . ( eMat )
    (72) paren -> . INT
    (73) paren -> . varYVals
    (74) paren -> . FLOAT
    (75) paren -> . varsOps
    (76) paren -> . funcInt
    (90) mayor -> . tCompare > tCompare
    (91) mayor -> . menor
    (49) varsOps -> . MENOSMENOS varYVals
    (50) varsOps -> . MASMAS varYVals
    (51) varsOps -> . varYVals MASMAS
    (52) varsOps -> . varYVals MENOSMENOS
    (100) tCompare -> . eMat
    (101) tCompare -> . varsOps
    (102) tCompare -> . varYVals
    (92) menor -> . tCompare < tCompare
    (93) menor -> . not
    (94) not -> . NOT not
    (95) not -> . tBool
    (96) tBool -> . ( expBool )
    (97) tBool -> . BOOL
    (98) tBool -> . varYVals
    (99) tBool -> . funcBool

    ID              shift and go to state 93
    STRING          shift and go to state 91
    {               shift and go to state 97
    CAPITALIZAR     shift and go to state 25
    MULTIESCALAR    shift and go to state 23
    LENGTH          shift and go to state 26
    COLINEALES      shift and go to state 15
    -               shift and go to state 69
    +               shift and go to state 68
    (               shift and go to state 88
    INT             shift and go to state 75
    FLOAT           shift and go to state 76
    MENOSMENOS      shift and go to state 30
    MASMAS          shift and go to state 27
    NOT             shift and go to state 81
    BOOL            shift and go to state 70

    and                            shift and go to state 60
    funcBool                       shift and go to state 85
    funcInt                        shift and go to state 86
    elem                           shift and go to state 195
    menor                          shift and go to state 63
    eq                             shift and go to state 64
    vecVal                         shift and go to state 9
    eMat                           shift and go to state 87
    mayor                          shift and go to state 65
    paren                          shift and go to state 73
    reg                            shift and go to state 89
    varsOps                        shift and go to state 90
    expString                      shift and go to state 92
    tCompare                       shift and go to state 72
    not                            shift and go to state 74
    funcString                     shift and go to state 94
    funcReturn                     shift and go to state 95
    valores                        shift and go to state 153
    p                              shift and go to state 78
    iSing                          shift and go to state 71
    exp                            shift and go to state 80
    tBool                          shift and go to state 82
    varYVals                       shift and go to state 98
    or                             shift and go to state 77
    expBool                        shift and go to state 99

state 186

    (31) vec -> [ elem ] .

    )               reduce using rule 31 (vec -> [ elem ] .)
    ,               reduce using rule 31 (vec -> [ elem ] .)


state 187

    (12) loop -> FOR ( varAsig ; expBool . ; varsOps ) bloque

    ;               shift and go to state 196


state 188

    (45) m -> [ INT ] m .

    MASMAS          reduce using rule 45 (m -> [ INT ] m .)
    MENOSMENOS      reduce using rule 45 (m -> [ INT ] m .)
    )               reduce using rule 45 (m -> [ INT ] m .)
    +               reduce using rule 45 (m -> [ INT ] m .)
    ^               reduce using rule 45 (m -> [ INT ] m .)
    *               reduce using rule 45 (m -> [ INT ] m .)
    /               reduce using rule 45 (m -> [ INT ] m .)
    %               reduce using rule 45 (m -> [ INT ] m .)
    -               reduce using rule 45 (m -> [ INT ] m .)
    >               reduce using rule 45 (m -> [ INT ] m .)
    <               reduce using rule 45 (m -> [ INT ] m .)
    EQEQ            reduce using rule 45 (m -> [ INT ] m .)
    DISTINTO        reduce using rule 45 (m -> [ INT ] m .)
    AND             reduce using rule 45 (m -> [ INT ] m .)
    ?               reduce using rule 45 (m -> [ INT ] m .)
    OR              reduce using rule 45 (m -> [ INT ] m .)
    ,               reduce using rule 45 (m -> [ INT ] m .)
    ]               reduce using rule 45 (m -> [ INT ] m .)
    MULEQ           reduce using rule 45 (m -> [ INT ] m .)
    ;               reduce using rule 45 (m -> [ INT ] m .)
    }               reduce using rule 45 (m -> [ INT ] m .)
    :               reduce using rule 45 (m -> [ INT ] m .)


state 189

    (13) if -> IF ( expBool ) bloque . else
    (14) else -> . ELSE bloque
    (15) else -> . empty
    (30) empty -> .

    ELSE            shift and go to state 199
    RETURN          reduce using rule 30 (empty -> .)
    MENOSMENOS      reduce using rule 30 (empty -> .)
    MASMAS          reduce using rule 30 (empty -> .)
    ID              reduce using rule 30 (empty -> .)
    IF              reduce using rule 30 (empty -> .)
    WHILE           reduce using rule 30 (empty -> .)
    DO              reduce using rule 30 (empty -> .)
    FOR             reduce using rule 30 (empty -> .)
    PRINT           reduce using rule 30 (empty -> .)
    MULTIESCALAR    reduce using rule 30 (empty -> .)
    LENGTH          reduce using rule 30 (empty -> .)
    CAPITALIZAR     reduce using rule 30 (empty -> .)
    COLINEALES      reduce using rule 30 (empty -> .)
    $end            reduce using rule 30 (empty -> .)
    }               reduce using rule 30 (empty -> .)

    empty                          shift and go to state 198
    else                           shift and go to state 197

state 190

    (23) funcInt -> MULTIESCALAR ( vec , eMat . , param )
    (59) eMat -> eMat . + p
    (60) eMat -> eMat . - p

    ,               shift and go to state 200
    +               shift and go to state 123
    -               shift and go to state 124


state 191

    (11) loop -> DO bloque WHILE ( expBool ) . ;

    ;               shift and go to state 201


state 192

    (81) expBool -> or ? expBool : . expBool
    (81) expBool -> . or ? expBool : expBool
    (82) expBool -> . or
    (83) or -> . or OR and
    (84) or -> . and
    (85) and -> . and AND eq
    (86) and -> . eq
    (87) eq -> . eq EQEQ tBool
    (88) eq -> . eq DISTINTO tBool
    (89) eq -> . mayor
    (90) mayor -> . tCompare > tCompare
    (91) mayor -> . menor
    (100) tCompare -> . eMat
    (101) tCompare -> . varsOps
    (102) tCompare -> . varYVals
    (92) menor -> . tCompare < tCompare
    (93) menor -> . not
    (59) eMat -> . eMat + p
    (60) eMat -> . eMat - p
    (61) eMat -> . p
    (49) varsOps -> . MENOSMENOS varYVals
    (50) varsOps -> . MASMAS varYVals
    (51) varsOps -> . varYVals MASMAS
    (52) varsOps -> . varYVals MENOSMENOS
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (94) not -> . NOT not
    (95) not -> . tBool
    (62) p -> . p * exp
    (63) p -> . p / exp
    (64) p -> . p % exp
    (65) p -> . exp
    (43) vecVal -> . ID m
    (96) tBool -> . ( expBool )
    (97) tBool -> . BOOL
    (98) tBool -> . varYVals
    (99) tBool -> . funcBool
    (66) exp -> . exp ^ iSing
    (67) exp -> . iSing
    (26) funcBool -> . COLINEALES ( vec , vec )
    (68) iSing -> . - paren
    (69) iSing -> . + paren
    (70) iSing -> . paren
    (71) paren -> . ( eMat )
    (72) paren -> . INT
    (73) paren -> . varYVals
    (74) paren -> . FLOAT
    (75) paren -> . varsOps
    (76) paren -> . funcInt
    (23) funcInt -> . MULTIESCALAR ( vec , eMat , param )
    (24) funcInt -> . LENGTH ( vec )

    MENOSMENOS      shift and go to state 30
    MASMAS          shift and go to state 27
    ID              shift and go to state 52
    NOT             shift and go to state 81
    (               shift and go to state 67
    BOOL            shift and go to state 70
    COLINEALES      shift and go to state 15
    -               shift and go to state 69
    +               shift and go to state 68
    INT             shift and go to state 75
    FLOAT           shift and go to state 76
    MULTIESCALAR    shift and go to state 23
    LENGTH          shift and go to state 26

    and                            shift and go to state 60
    funcBool                       shift and go to state 61
    funcInt                        shift and go to state 62
    menor                          shift and go to state 63
    eq                             shift and go to state 64
    mayor                          shift and go to state 65
    eMat                           shift and go to state 66
    vecVal                         shift and go to state 9
    paren                          shift and go to state 73
    iSing                          shift and go to state 71
    tCompare                       shift and go to state 72
    not                            shift and go to state 74
    p                              shift and go to state 78
    varsOps                        shift and go to state 79
    exp                            shift and go to state 80
    tBool                          shift and go to state 82
    varYVals                       shift and go to state 83
    or                             shift and go to state 77
    expBool                        shift and go to state 202

state 193

    (47) campos -> ID : valores . , campos

    ,               shift and go to state 203


state 194

    (26) funcBool -> COLINEALES ( vec , vec ) .

    ,               reduce using rule 26 (funcBool -> COLINEALES ( vec , vec ) .)
    EQEQ            reduce using rule 26 (funcBool -> COLINEALES ( vec , vec ) .)
    DISTINTO        reduce using rule 26 (funcBool -> COLINEALES ( vec , vec ) .)
    AND             reduce using rule 26 (funcBool -> COLINEALES ( vec , vec ) .)
    ?               reduce using rule 26 (funcBool -> COLINEALES ( vec , vec ) .)
    OR              reduce using rule 26 (funcBool -> COLINEALES ( vec , vec ) .)
    :               reduce using rule 26 (funcBool -> COLINEALES ( vec , vec ) .)
    ]               reduce using rule 26 (funcBool -> COLINEALES ( vec , vec ) .)
    ;               reduce using rule 26 (funcBool -> COLINEALES ( vec , vec ) .)
    }               reduce using rule 26 (funcBool -> COLINEALES ( vec , vec ) .)
    )               reduce using rule 26 (funcBool -> COLINEALES ( vec , vec ) .)
    MULEQ           reduce using rule 26 (funcBool -> COLINEALES ( vec , vec ) .)


state 195

    (32) elem -> valores , elem .

    ]               reduce using rule 32 (elem -> valores , elem .)


state 196

    (12) loop -> FOR ( varAsig ; expBool ; . varsOps ) bloque
    (49) varsOps -> . MENOSMENOS varYVals
    (50) varsOps -> . MASMAS varYVals
    (51) varsOps -> . varYVals MASMAS
    (52) varsOps -> . varYVals MENOSMENOS
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (43) vecVal -> . ID m

    MENOSMENOS      shift and go to state 30
    MASMAS          shift and go to state 27
    ID              shift and go to state 52

    varsOps                        shift and go to state 204
    varYVals                       shift and go to state 29
    vecVal                         shift and go to state 9

state 197

    (13) if -> IF ( expBool ) bloque else .

    RETURN          reduce using rule 13 (if -> IF ( expBool ) bloque else .)
    MENOSMENOS      reduce using rule 13 (if -> IF ( expBool ) bloque else .)
    MASMAS          reduce using rule 13 (if -> IF ( expBool ) bloque else .)
    ID              reduce using rule 13 (if -> IF ( expBool ) bloque else .)
    IF              reduce using rule 13 (if -> IF ( expBool ) bloque else .)
    WHILE           reduce using rule 13 (if -> IF ( expBool ) bloque else .)
    DO              reduce using rule 13 (if -> IF ( expBool ) bloque else .)
    FOR             reduce using rule 13 (if -> IF ( expBool ) bloque else .)
    PRINT           reduce using rule 13 (if -> IF ( expBool ) bloque else .)
    MULTIESCALAR    reduce using rule 13 (if -> IF ( expBool ) bloque else .)
    LENGTH          reduce using rule 13 (if -> IF ( expBool ) bloque else .)
    CAPITALIZAR     reduce using rule 13 (if -> IF ( expBool ) bloque else .)
    COLINEALES      reduce using rule 13 (if -> IF ( expBool ) bloque else .)
    $end            reduce using rule 13 (if -> IF ( expBool ) bloque else .)
    }               reduce using rule 13 (if -> IF ( expBool ) bloque else .)


state 198

    (15) else -> empty .

    RETURN          reduce using rule 15 (else -> empty .)
    MENOSMENOS      reduce using rule 15 (else -> empty .)
    MASMAS          reduce using rule 15 (else -> empty .)
    ID              reduce using rule 15 (else -> empty .)
    IF              reduce using rule 15 (else -> empty .)
    WHILE           reduce using rule 15 (else -> empty .)
    DO              reduce using rule 15 (else -> empty .)
    FOR             reduce using rule 15 (else -> empty .)
    PRINT           reduce using rule 15 (else -> empty .)
    MULTIESCALAR    reduce using rule 15 (else -> empty .)
    LENGTH          reduce using rule 15 (else -> empty .)
    CAPITALIZAR     reduce using rule 15 (else -> empty .)
    COLINEALES      reduce using rule 15 (else -> empty .)
    $end            reduce using rule 15 (else -> empty .)
    }               reduce using rule 15 (else -> empty .)


state 199

    (14) else -> ELSE . bloque
    (16) bloque -> . sentencia ;
    (17) bloque -> . { g }
    (4) sentencia -> . varsOps ;
    (5) sentencia -> . func ;
    (6) sentencia -> . varAsig ;
    (7) sentencia -> . RETURN ;
    (49) varsOps -> . MENOSMENOS varYVals
    (50) varsOps -> . MASMAS varYVals
    (51) varsOps -> . varYVals MASMAS
    (52) varsOps -> . varYVals MENOSMENOS
    (18) func -> . funcReturn
    (19) func -> . funcVoid
    (53) varAsig -> . ID MULEQ varAsig
    (54) varAsig -> . asig MULEQ varAsig
    (55) varAsig -> . ID MULEQ valores
    (56) varAsig -> . asig
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (20) funcReturn -> . funcInt
    (21) funcReturn -> . funcString
    (22) funcReturn -> . funcBool
    (27) funcVoid -> . PRINT ( valores )
    (57) asig -> . ID = asig
    (58) asig -> . ID = valores
    (43) vecVal -> . ID m
    (23) funcInt -> . MULTIESCALAR ( vec , eMat , param )
    (24) funcInt -> . LENGTH ( vec )
    (25) funcString -> . CAPITALIZAR ( expString )
    (26) funcBool -> . COLINEALES ( vec , vec )

    {               shift and go to state 33
    RETURN          shift and go to state 2
    MENOSMENOS      shift and go to state 30
    MASMAS          shift and go to state 27
    ID              shift and go to state 18
    PRINT           shift and go to state 8
    MULTIESCALAR    shift and go to state 23
    LENGTH          shift and go to state 26
    CAPITALIZAR     shift and go to state 25
    COLINEALES      shift and go to state 15

    varAsig                        shift and go to state 20
    sentencia                      shift and go to state 32
    funcInt                        shift and go to state 5
    funcBool                       shift and go to state 3
    funcString                     shift and go to state 22
    asig                           shift and go to state 12
    funcVoid                       shift and go to state 14
    funcReturn                     shift and go to state 24
    varsOps                        shift and go to state 28
    func                           shift and go to state 17
    bloque                         shift and go to state 205
    varYVals                       shift and go to state 29
    vecVal                         shift and go to state 9

state 200

    (23) funcInt -> MULTIESCALAR ( vec , eMat , . param )
    (28) param -> . expBool
    (29) param -> . empty
    (81) expBool -> . or ? expBool : expBool
    (82) expBool -> . or
    (30) empty -> .
    (83) or -> . or OR and
    (84) or -> . and
    (85) and -> . and AND eq
    (86) and -> . eq
    (87) eq -> . eq EQEQ tBool
    (88) eq -> . eq DISTINTO tBool
    (89) eq -> . mayor
    (90) mayor -> . tCompare > tCompare
    (91) mayor -> . menor
    (100) tCompare -> . eMat
    (101) tCompare -> . varsOps
    (102) tCompare -> . varYVals
    (92) menor -> . tCompare < tCompare
    (93) menor -> . not
    (59) eMat -> . eMat + p
    (60) eMat -> . eMat - p
    (61) eMat -> . p
    (49) varsOps -> . MENOSMENOS varYVals
    (50) varsOps -> . MASMAS varYVals
    (51) varsOps -> . varYVals MASMAS
    (52) varsOps -> . varYVals MENOSMENOS
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (94) not -> . NOT not
    (95) not -> . tBool
    (62) p -> . p * exp
    (63) p -> . p / exp
    (64) p -> . p % exp
    (65) p -> . exp
    (43) vecVal -> . ID m
    (96) tBool -> . ( expBool )
    (97) tBool -> . BOOL
    (98) tBool -> . varYVals
    (99) tBool -> . funcBool
    (66) exp -> . exp ^ iSing
    (67) exp -> . iSing
    (26) funcBool -> . COLINEALES ( vec , vec )
    (68) iSing -> . - paren
    (69) iSing -> . + paren
    (70) iSing -> . paren
    (71) paren -> . ( eMat )
    (72) paren -> . INT
    (73) paren -> . varYVals
    (74) paren -> . FLOAT
    (75) paren -> . varsOps
    (76) paren -> . funcInt
    (23) funcInt -> . MULTIESCALAR ( vec , eMat , param )
    (24) funcInt -> . LENGTH ( vec )

    )               reduce using rule 30 (empty -> .)
    MENOSMENOS      shift and go to state 30
    MASMAS          shift and go to state 27
    ID              shift and go to state 52
    NOT             shift and go to state 81
    (               shift and go to state 67
    BOOL            shift and go to state 70
    COLINEALES      shift and go to state 15
    -               shift and go to state 69
    +               shift and go to state 68
    INT             shift and go to state 75
    FLOAT           shift and go to state 76
    MULTIESCALAR    shift and go to state 23
    LENGTH          shift and go to state 26

    and                            shift and go to state 60
    funcBool                       shift and go to state 61
    funcInt                        shift and go to state 62
    menor                          shift and go to state 63
    eq                             shift and go to state 64
    mayor                          shift and go to state 65
    eMat                           shift and go to state 66
    param                          shift and go to state 206
    vecVal                         shift and go to state 9
    paren                          shift and go to state 73
    empty                          shift and go to state 207
    varsOps                        shift and go to state 79
    tCompare                       shift and go to state 72
    not                            shift and go to state 74
    p                              shift and go to state 78
    iSing                          shift and go to state 71
    exp                            shift and go to state 80
    tBool                          shift and go to state 82
    varYVals                       shift and go to state 83
    or                             shift and go to state 77
    expBool                        shift and go to state 208

state 201

    (11) loop -> DO bloque WHILE ( expBool ) ; .

    RETURN          reduce using rule 11 (loop -> DO bloque WHILE ( expBool ) ; .)
    MENOSMENOS      reduce using rule 11 (loop -> DO bloque WHILE ( expBool ) ; .)
    MASMAS          reduce using rule 11 (loop -> DO bloque WHILE ( expBool ) ; .)
    ID              reduce using rule 11 (loop -> DO bloque WHILE ( expBool ) ; .)
    IF              reduce using rule 11 (loop -> DO bloque WHILE ( expBool ) ; .)
    WHILE           reduce using rule 11 (loop -> DO bloque WHILE ( expBool ) ; .)
    DO              reduce using rule 11 (loop -> DO bloque WHILE ( expBool ) ; .)
    FOR             reduce using rule 11 (loop -> DO bloque WHILE ( expBool ) ; .)
    PRINT           reduce using rule 11 (loop -> DO bloque WHILE ( expBool ) ; .)
    MULTIESCALAR    reduce using rule 11 (loop -> DO bloque WHILE ( expBool ) ; .)
    LENGTH          reduce using rule 11 (loop -> DO bloque WHILE ( expBool ) ; .)
    CAPITALIZAR     reduce using rule 11 (loop -> DO bloque WHILE ( expBool ) ; .)
    COLINEALES      reduce using rule 11 (loop -> DO bloque WHILE ( expBool ) ; .)
    $end            reduce using rule 11 (loop -> DO bloque WHILE ( expBool ) ; .)
    }               reduce using rule 11 (loop -> DO bloque WHILE ( expBool ) ; .)


state 202

    (81) expBool -> or ? expBool : expBool .

    }               reduce using rule 81 (expBool -> or ? expBool : expBool .)
    )               reduce using rule 81 (expBool -> or ? expBool : expBool .)
    ,               reduce using rule 81 (expBool -> or ? expBool : expBool .)
    ]               reduce using rule 81 (expBool -> or ? expBool : expBool .)
    ;               reduce using rule 81 (expBool -> or ? expBool : expBool .)
    MULEQ           reduce using rule 81 (expBool -> or ? expBool : expBool .)
    :               reduce using rule 81 (expBool -> or ? expBool : expBool .)


state 203

    (47) campos -> ID : valores , . campos
    (47) campos -> . ID : valores , campos
    (48) campos -> . valores
    (34) valores -> . eMat
    (35) valores -> . expBool
    (36) valores -> . expString
    (37) valores -> . varYVals
    (38) valores -> . funcReturn
    (39) valores -> . reg
    (40) valores -> . ID . ID
    (59) eMat -> . eMat + p
    (60) eMat -> . eMat - p
    (61) eMat -> . p
    (81) expBool -> . or ? expBool : expBool
    (82) expBool -> . or
    (77) expString -> . expString + STRING
    (78) expString -> . STRING
    (79) expString -> . varYVals
    (80) expString -> . funcString
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (20) funcReturn -> . funcInt
    (21) funcReturn -> . funcString
    (22) funcReturn -> . funcBool
    (46) reg -> . { campos }
    (62) p -> . p * exp
    (63) p -> . p / exp
    (64) p -> . p % exp
    (65) p -> . exp
    (83) or -> . or OR and
    (84) or -> . and
    (25) funcString -> . CAPITALIZAR ( expString )
    (43) vecVal -> . ID m
    (23) funcInt -> . MULTIESCALAR ( vec , eMat , param )
    (24) funcInt -> . LENGTH ( vec )
    (26) funcBool -> . COLINEALES ( vec , vec )
    (66) exp -> . exp ^ iSing
    (67) exp -> . iSing
    (85) and -> . and AND eq
    (86) and -> . eq
    (68) iSing -> . - paren
    (69) iSing -> . + paren
    (70) iSing -> . paren
    (87) eq -> . eq EQEQ tBool
    (88) eq -> . eq DISTINTO tBool
    (89) eq -> . mayor
    (71) paren -> . ( eMat )
    (72) paren -> . INT
    (73) paren -> . varYVals
    (74) paren -> . FLOAT
    (75) paren -> . varsOps
    (76) paren -> . funcInt
    (90) mayor -> . tCompare > tCompare
    (91) mayor -> . menor
    (49) varsOps -> . MENOSMENOS varYVals
    (50) varsOps -> . MASMAS varYVals
    (51) varsOps -> . varYVals MASMAS
    (52) varsOps -> . varYVals MENOSMENOS
    (100) tCompare -> . eMat
    (101) tCompare -> . varsOps
    (102) tCompare -> . varYVals
    (92) menor -> . tCompare < tCompare
    (93) menor -> . not
    (94) not -> . NOT not
    (95) not -> . tBool
    (96) tBool -> . ( expBool )
    (97) tBool -> . BOOL
    (98) tBool -> . varYVals
    (99) tBool -> . funcBool

    ID              shift and go to state 150
    STRING          shift and go to state 91
    {               shift and go to state 97
    CAPITALIZAR     shift and go to state 25
    MULTIESCALAR    shift and go to state 23
    LENGTH          shift and go to state 26
    COLINEALES      shift and go to state 15
    -               shift and go to state 69
    +               shift and go to state 68
    (               shift and go to state 88
    INT             shift and go to state 75
    FLOAT           shift and go to state 76
    MENOSMENOS      shift and go to state 30
    MASMAS          shift and go to state 27
    NOT             shift and go to state 81
    BOOL            shift and go to state 70

    and                            shift and go to state 60
    funcBool                       shift and go to state 85
    funcInt                        shift and go to state 86
    menor                          shift and go to state 63
    eq                             shift and go to state 64
    vecVal                         shift and go to state 9
    eMat                           shift and go to state 87
    mayor                          shift and go to state 65
    paren                          shift and go to state 73
    reg                            shift and go to state 89
    varsOps                        shift and go to state 90
    expString                      shift and go to state 92
    tCompare                       shift and go to state 72
    campos                         shift and go to state 209
    not                            shift and go to state 74
    funcString                     shift and go to state 94
    funcReturn                     shift and go to state 95
    valores                        shift and go to state 151
    p                              shift and go to state 78
    iSing                          shift and go to state 71
    exp                            shift and go to state 80
    tBool                          shift and go to state 82
    varYVals                       shift and go to state 98
    or                             shift and go to state 77
    expBool                        shift and go to state 99

state 204

    (12) loop -> FOR ( varAsig ; expBool ; varsOps . ) bloque

    )               shift and go to state 210


state 205

    (14) else -> ELSE bloque .

    RETURN          reduce using rule 14 (else -> ELSE bloque .)
    MENOSMENOS      reduce using rule 14 (else -> ELSE bloque .)
    MASMAS          reduce using rule 14 (else -> ELSE bloque .)
    ID              reduce using rule 14 (else -> ELSE bloque .)
    IF              reduce using rule 14 (else -> ELSE bloque .)
    WHILE           reduce using rule 14 (else -> ELSE bloque .)
    DO              reduce using rule 14 (else -> ELSE bloque .)
    FOR             reduce using rule 14 (else -> ELSE bloque .)
    PRINT           reduce using rule 14 (else -> ELSE bloque .)
    MULTIESCALAR    reduce using rule 14 (else -> ELSE bloque .)
    LENGTH          reduce using rule 14 (else -> ELSE bloque .)
    CAPITALIZAR     reduce using rule 14 (else -> ELSE bloque .)
    COLINEALES      reduce using rule 14 (else -> ELSE bloque .)
    $end            reduce using rule 14 (else -> ELSE bloque .)
    }               reduce using rule 14 (else -> ELSE bloque .)


state 206

    (23) funcInt -> MULTIESCALAR ( vec , eMat , param . )

    )               shift and go to state 211


state 207

    (29) param -> empty .

    )               reduce using rule 29 (param -> empty .)


state 208

    (28) param -> expBool .

    )               reduce using rule 28 (param -> expBool .)


state 209

    (47) campos -> ID : valores , campos .

    }               reduce using rule 47 (campos -> ID : valores , campos .)


state 210

    (12) loop -> FOR ( varAsig ; expBool ; varsOps ) . bloque
    (16) bloque -> . sentencia ;
    (17) bloque -> . { g }
    (4) sentencia -> . varsOps ;
    (5) sentencia -> . func ;
    (6) sentencia -> . varAsig ;
    (7) sentencia -> . RETURN ;
    (49) varsOps -> . MENOSMENOS varYVals
    (50) varsOps -> . MASMAS varYVals
    (51) varsOps -> . varYVals MASMAS
    (52) varsOps -> . varYVals MENOSMENOS
    (18) func -> . funcReturn
    (19) func -> . funcVoid
    (53) varAsig -> . ID MULEQ varAsig
    (54) varAsig -> . asig MULEQ varAsig
    (55) varAsig -> . ID MULEQ valores
    (56) varAsig -> . asig
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (20) funcReturn -> . funcInt
    (21) funcReturn -> . funcString
    (22) funcReturn -> . funcBool
    (27) funcVoid -> . PRINT ( valores )
    (57) asig -> . ID = asig
    (58) asig -> . ID = valores
    (43) vecVal -> . ID m
    (23) funcInt -> . MULTIESCALAR ( vec , eMat , param )
    (24) funcInt -> . LENGTH ( vec )
    (25) funcString -> . CAPITALIZAR ( expString )
    (26) funcBool -> . COLINEALES ( vec , vec )

    {               shift and go to state 33
    RETURN          shift and go to state 2
    MENOSMENOS      shift and go to state 30
    MASMAS          shift and go to state 27
    ID              shift and go to state 18
    PRINT           shift and go to state 8
    MULTIESCALAR    shift and go to state 23
    LENGTH          shift and go to state 26
    CAPITALIZAR     shift and go to state 25
    COLINEALES      shift and go to state 15

    varAsig                        shift and go to state 20
    sentencia                      shift and go to state 32
    funcInt                        shift and go to state 5
    funcBool                       shift and go to state 3
    funcString                     shift and go to state 22
    asig                           shift and go to state 12
    funcVoid                       shift and go to state 14
    funcReturn                     shift and go to state 24
    varsOps                        shift and go to state 28
    func                           shift and go to state 17
    bloque                         shift and go to state 212
    varYVals                       shift and go to state 29
    vecVal                         shift and go to state 9

state 211

    (23) funcInt -> MULTIESCALAR ( vec , eMat , param ) .

    ^               reduce using rule 23 (funcInt -> MULTIESCALAR ( vec , eMat , param ) .)
    *               reduce using rule 23 (funcInt -> MULTIESCALAR ( vec , eMat , param ) .)
    /               reduce using rule 23 (funcInt -> MULTIESCALAR ( vec , eMat , param ) .)
    %               reduce using rule 23 (funcInt -> MULTIESCALAR ( vec , eMat , param ) .)
    +               reduce using rule 23 (funcInt -> MULTIESCALAR ( vec , eMat , param ) .)
    -               reduce using rule 23 (funcInt -> MULTIESCALAR ( vec , eMat , param ) .)
    >               reduce using rule 23 (funcInt -> MULTIESCALAR ( vec , eMat , param ) .)
    <               reduce using rule 23 (funcInt -> MULTIESCALAR ( vec , eMat , param ) .)
    ;               reduce using rule 23 (funcInt -> MULTIESCALAR ( vec , eMat , param ) .)
    )               reduce using rule 23 (funcInt -> MULTIESCALAR ( vec , eMat , param ) .)
    MULEQ           reduce using rule 23 (funcInt -> MULTIESCALAR ( vec , eMat , param ) .)
    }               reduce using rule 23 (funcInt -> MULTIESCALAR ( vec , eMat , param ) .)
    ,               reduce using rule 23 (funcInt -> MULTIESCALAR ( vec , eMat , param ) .)
    ]               reduce using rule 23 (funcInt -> MULTIESCALAR ( vec , eMat , param ) .)
    EQEQ            reduce using rule 23 (funcInt -> MULTIESCALAR ( vec , eMat , param ) .)
    DISTINTO        reduce using rule 23 (funcInt -> MULTIESCALAR ( vec , eMat , param ) .)
    AND             reduce using rule 23 (funcInt -> MULTIESCALAR ( vec , eMat , param ) .)
    ?               reduce using rule 23 (funcInt -> MULTIESCALAR ( vec , eMat , param ) .)
    OR              reduce using rule 23 (funcInt -> MULTIESCALAR ( vec , eMat , param ) .)
    :               reduce using rule 23 (funcInt -> MULTIESCALAR ( vec , eMat , param ) .)


state 212

    (12) loop -> FOR ( varAsig ; expBool ; varsOps ) bloque .

    RETURN          reduce using rule 12 (loop -> FOR ( varAsig ; expBool ; varsOps ) bloque .)
    MENOSMENOS      reduce using rule 12 (loop -> FOR ( varAsig ; expBool ; varsOps ) bloque .)
    MASMAS          reduce using rule 12 (loop -> FOR ( varAsig ; expBool ; varsOps ) bloque .)
    ID              reduce using rule 12 (loop -> FOR ( varAsig ; expBool ; varsOps ) bloque .)
    IF              reduce using rule 12 (loop -> FOR ( varAsig ; expBool ; varsOps ) bloque .)
    WHILE           reduce using rule 12 (loop -> FOR ( varAsig ; expBool ; varsOps ) bloque .)
    DO              reduce using rule 12 (loop -> FOR ( varAsig ; expBool ; varsOps ) bloque .)
    FOR             reduce using rule 12 (loop -> FOR ( varAsig ; expBool ; varsOps ) bloque .)
    PRINT           reduce using rule 12 (loop -> FOR ( varAsig ; expBool ; varsOps ) bloque .)
    MULTIESCALAR    reduce using rule 12 (loop -> FOR ( varAsig ; expBool ; varsOps ) bloque .)
    LENGTH          reduce using rule 12 (loop -> FOR ( varAsig ; expBool ; varsOps ) bloque .)
    CAPITALIZAR     reduce using rule 12 (loop -> FOR ( varAsig ; expBool ; varsOps ) bloque .)
    COLINEALES      reduce using rule 12 (loop -> FOR ( varAsig ; expBool ; varsOps ) bloque .)
    $end            reduce using rule 12 (loop -> FOR ( varAsig ; expBool ; varsOps ) bloque .)
    }               reduce using rule 12 (loop -> FOR ( varAsig ; expBool ; varsOps ) bloque .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: reduce/reduce conflict in state 79 resolved using rule (paren -> varsOps)
WARNING: rejected rule (tCompare -> varsOps) in state 79
WARNING: reduce/reduce conflict in state 83 resolved using rule (paren -> varYVals)
WARNING: rejected rule (tCompare -> varYVals) in state 83
WARNING: reduce/reduce conflict in state 85 resolved using rule (funcReturn -> funcBool)
WARNING: rejected rule (tBool -> funcBool) in state 85
WARNING: reduce/reduce conflict in state 86 resolved using rule (funcReturn -> funcInt)
WARNING: rejected rule (paren -> funcInt) in state 86
WARNING: reduce/reduce conflict in state 90 resolved using rule (paren -> varsOps)
WARNING: rejected rule (tCompare -> varsOps) in state 90
WARNING: reduce/reduce conflict in state 94 resolved using rule (funcReturn -> funcString)
WARNING: rejected rule (expString -> funcString) in state 94
WARNING: reduce/reduce conflict in state 98 resolved using rule (valores -> varYVals)
WARNING: rejected rule (expString -> varYVals) in state 98
WARNING: reduce/reduce conflict in state 98 resolved using rule (paren -> varYVals)
WARNING: rejected rule (expString -> varYVals) in state 98
WARNING: reduce/reduce conflict in state 98 resolved using rule (valores -> varYVals)
WARNING: rejected rule (paren -> varYVals) in state 98
WARNING: reduce/reduce conflict in state 98 resolved using rule (paren -> varYVals)
WARNING: rejected rule (tCompare -> varYVals) in state 98
WARNING: reduce/reduce conflict in state 98 resolved using rule (valores -> varYVals)
WARNING: rejected rule (tBool -> varYVals) in state 98
WARNING: reduce/reduce conflict in state 126 resolved using rule (paren -> varYVals)
WARNING: rejected rule (tCompare -> varYVals) in state 126
WARNING: reduce/reduce conflict in state 126 resolved using rule (paren -> varYVals)
WARNING: rejected rule (tBool -> varYVals) in state 126
WARNING: reduce/reduce conflict in state 145 resolved using rule (paren -> varYVals)
WARNING: rejected rule (tCompare -> varYVals) in state 145
WARNING: reduce/reduce conflict in state 145 resolved using rule (paren -> varYVals)
WARNING: rejected rule (tBool -> varYVals) in state 145
WARNING: reduce/reduce conflict in state 171 resolved using rule (paren -> varYVals)
WARNING: rejected rule (tCompare -> varYVals) in state 171
WARNING: Rule (tCompare -> varsOps) is never reduced
WARNING: Rule (tCompare -> varYVals) is never reduced
