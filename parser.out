Created by PLY version 3.8 (http://www.dabeaz.com/ply)

Unused terminals:

    RES
    COMMENT
    BEGIN
    END

Grammar

Rule 0     S' -> g
Rule 1     g -> sentencia
Rule 2     g -> ctrl g
Rule 3     g -> empty
Rule 4     sentencia -> varsOps ;
Rule 5     sentencia -> func ;
Rule 6     sentencia -> varAsig ;
Rule 7     sentencia -> RETURN ;
Rule 8     ctrl -> if
Rule 9     ctrl -> loop
Rule 10    loop -> WHILE ( expBool ) bloque
Rule 11    loop -> DO bloque WHILE ( expBool ) ;
Rule 12    loop -> FOR ( varAsig ; expBool ; varsOps ) bloque
Rule 13    if -> IF ( expBool ) bloque else
Rule 14    else -> ELSE bloque
Rule 15    else -> empty
Rule 16    bloque -> sentencia ;
Rule 17    bloque -> { g }
Rule 18    func -> funcReturn
Rule 19    func -> funcVoid
Rule 20    funcReturn -> funcInt
Rule 21    funcReturn -> funcString
Rule 22    funcReturn -> funcBool
Rule 23    funcInt -> MULTIESCALAR ( vec , eMat , param )
Rule 24    funcInt -> LENGTH ( vec )
Rule 25    funcString -> CAPITALIZAR ( expString )
Rule 26    funcBool -> COLINEALES ( vec , vec )
Rule 27    funcVoid -> PRINT ( valores )
Rule 28    param -> expBool
Rule 29    param -> empty
Rule 30    empty -> <empty>
Rule 31    vec -> [ elem ]
Rule 32    elem -> valores , elem
Rule 33    elem -> valores
Rule 34    valores -> eMat
Rule 35    valores -> expBool
Rule 36    valores -> expString
Rule 37    valores -> varYVals
Rule 38    valores -> funcReturn
Rule 39    valores -> reg
Rule 40    valores -> ID . ID
Rule 41    varYVals -> ID
Rule 42    varYVals -> vecVal
Rule 43    vecVal -> ID m
Rule 44    m -> [ INT ]
Rule 45    m -> [ INT ] m
Rule 46    reg -> { campos }
Rule 47    campos -> ID : valores , campos
Rule 48    campos -> valores
Rule 49    varsOps -> MENOSMENOS varYVals
Rule 50    varsOps -> MASMAS varYVals
Rule 51    varsOps -> varYVals MASMAS
Rule 52    varsOps -> varYVals MENOSMENOS
Rule 53    varAsig -> ID MULEQ varAsig
Rule 54    varAsig -> masmenAsig MULEQ varAsig
Rule 55    varAsig -> masmenAsig MULEQ ID
Rule 56    varAsig -> masmenAsig MULEQ valores
Rule 57    varAsig -> masmenAsig DIVEQ varAsig
Rule 58    varAsig -> masmenAsig DIVEQ ID
Rule 59    varAsig -> masmenAsig DIVEQ valores
Rule 60    varAsig -> finVarAsig
Rule 61    varAsig -> masmenAsig
Rule 62    masmenAsig -> ID MASEQ masmenAsig
Rule 63    masmenAsig -> ID MENOSEQ masmenAsig
Rule 64    masmenAsig -> ID MASEQ ID
Rule 65    masmenAsig -> ID MENOSEQ ID
Rule 66    masmenAsig -> asig
Rule 67    asig -> ID = asig
Rule 68    asig -> ID = ID
Rule 69    finVarAsig -> ID = valores
Rule 70    finVarAsig -> ID MASEQ valores
Rule 71    finVarAsig -> ID MENOSEQ valores
Rule 72    finVarAsig -> ID MULEQ valores
Rule 73    finVarAsig -> ID MULEQ ID
Rule 74    finVarAsig -> ID DIVEQ valores
Rule 75    finVarAsig -> ID DIVEQ ID
Rule 76    eMat -> eMat + p
Rule 77    eMat -> eMat - p
Rule 78    eMat -> p
Rule 79    p -> p * exp
Rule 80    p -> p / exp
Rule 81    p -> p % exp
Rule 82    p -> exp
Rule 83    exp -> exp ^ iSing
Rule 84    exp -> iSing
Rule 85    iSing -> - paren
Rule 86    iSing -> + paren
Rule 87    iSing -> paren
Rule 88    paren -> ( eMat )
Rule 89    paren -> INT
Rule 90    paren -> varYVals
Rule 91    paren -> FLOAT
Rule 92    paren -> varsOps
Rule 93    paren -> funcInt
Rule 94    expString -> expString + STRING
Rule 95    expString -> STRING
Rule 96    expString -> varYVals
Rule 97    expString -> funcString
Rule 98    expBool -> or ? expBool : expBool
Rule 99    expBool -> or
Rule 100   or -> or OR and
Rule 101   or -> and
Rule 102   and -> and AND eq
Rule 103   and -> eq
Rule 104   eq -> eq EQEQ tBool
Rule 105   eq -> eq DISTINTO tBool
Rule 106   eq -> mayor
Rule 107   mayor -> tCompare > tCompare
Rule 108   mayor -> menor
Rule 109   menor -> tCompare < tCompare
Rule 110   menor -> not
Rule 111   not -> NOT not
Rule 112   not -> tBool
Rule 113   tBool -> ( expBool )
Rule 114   tBool -> BOOL
Rule 115   tBool -> varYVals
Rule 116   tBool -> funcBool
Rule 117   tCompare -> eMat
Rule 118   tCompare -> varsOps
Rule 119   tCompare -> varYVals

Terminals, with rules where they appear

%                    : 81
(                    : 10 11 12 13 23 24 25 26 27 88 113
)                    : 10 11 12 13 23 24 25 26 27 88 113
*                    : 79
+                    : 76 86 94
,                    : 23 23 26 32 47
-                    : 77 85
.                    : 40
/                    : 80
:                    : 47 98
;                    : 4 5 6 7 11 12 12 16
<                    : 109
=                    : 67 68 69
>                    : 107
?                    : 98
AND                  : 102
BEGIN                : 
BOOL                 : 114
CAPITALIZAR          : 25
COLINEALES           : 26
COMMENT              : 
DISTINTO             : 105
DIVEQ                : 57 58 59 74 75
DO                   : 11
ELSE                 : 14
END                  : 
EQEQ                 : 104
FLOAT                : 91
FOR                  : 12
ID                   : 40 40 41 43 47 53 55 58 62 63 64 64 65 65 67 68 68 69 70 71 72 73 73 74 75 75
IF                   : 13
INT                  : 44 45 89
LENGTH               : 24
MASEQ                : 62 64 70
MASMAS               : 50 51
MENOSEQ              : 63 65 71
MENOSMENOS           : 49 52
MULEQ                : 53 54 55 56 72 73
MULTIESCALAR         : 23
NOT                  : 111
OR                   : 100
PRINT                : 27
RES                  : 
RETURN               : 7
STRING               : 94 95
WHILE                : 10 11
[                    : 31 44 45
]                    : 31 44 45
^                    : 83
error                : 
{                    : 17 46
}                    : 17 46

Nonterminals, with rules where they appear

and                  : 100 101 102
asig                 : 66 67
bloque               : 10 11 12 13 14
campos               : 46 47
ctrl                 : 2
eMat                 : 23 34 76 77 88 117
elem                 : 31 32
else                 : 13
empty                : 3 15 29
eq                   : 102 103 104 105
exp                  : 79 80 81 82 83
expBool              : 10 11 12 13 28 35 98 98 113
expString            : 25 36 94
finVarAsig           : 60
func                 : 5
funcBool             : 22 116
funcInt              : 20 93
funcReturn           : 18 38
funcString           : 21 97
funcVoid             : 19
g                    : 2 17 0
iSing                : 83 84
if                   : 8
loop                 : 9
m                    : 43 45
masmenAsig           : 54 55 56 57 58 59 61 62 63
mayor                : 106
menor                : 108
not                  : 110 111
or                   : 98 99 100
p                    : 76 77 78 79 80 81
param                : 23
paren                : 85 86 87
reg                  : 39
sentencia            : 1 16
tBool                : 104 105 112
tCompare             : 107 107 109 109
valores              : 27 32 33 47 48 56 59 69 70 71 72 74
varAsig              : 6 12 53 54 57
varYVals             : 37 49 50 51 52 90 96 115 119
varsOps              : 4 12 92 118
vec                  : 23 24 26 26
vecVal               : 42

Parsing method: LALR

state 0

    (0) S' -> . g
    (1) g -> . sentencia
    (2) g -> . ctrl g
    (3) g -> . empty
    (4) sentencia -> . varsOps ;
    (5) sentencia -> . func ;
    (6) sentencia -> . varAsig ;
    (7) sentencia -> . RETURN ;
    (8) ctrl -> . if
    (9) ctrl -> . loop
    (30) empty -> .
    (49) varsOps -> . MENOSMENOS varYVals
    (50) varsOps -> . MASMAS varYVals
    (51) varsOps -> . varYVals MASMAS
    (52) varsOps -> . varYVals MENOSMENOS
    (18) func -> . funcReturn
    (19) func -> . funcVoid
    (53) varAsig -> . ID MULEQ varAsig
    (54) varAsig -> . masmenAsig MULEQ varAsig
    (55) varAsig -> . masmenAsig MULEQ ID
    (56) varAsig -> . masmenAsig MULEQ valores
    (57) varAsig -> . masmenAsig DIVEQ varAsig
    (58) varAsig -> . masmenAsig DIVEQ ID
    (59) varAsig -> . masmenAsig DIVEQ valores
    (60) varAsig -> . finVarAsig
    (61) varAsig -> . masmenAsig
    (13) if -> . IF ( expBool ) bloque else
    (10) loop -> . WHILE ( expBool ) bloque
    (11) loop -> . DO bloque WHILE ( expBool ) ;
    (12) loop -> . FOR ( varAsig ; expBool ; varsOps ) bloque
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (20) funcReturn -> . funcInt
    (21) funcReturn -> . funcString
    (22) funcReturn -> . funcBool
    (27) funcVoid -> . PRINT ( valores )
    (62) masmenAsig -> . ID MASEQ masmenAsig
    (63) masmenAsig -> . ID MENOSEQ masmenAsig
    (64) masmenAsig -> . ID MASEQ ID
    (65) masmenAsig -> . ID MENOSEQ ID
    (66) masmenAsig -> . asig
    (69) finVarAsig -> . ID = valores
    (70) finVarAsig -> . ID MASEQ valores
    (71) finVarAsig -> . ID MENOSEQ valores
    (72) finVarAsig -> . ID MULEQ valores
    (73) finVarAsig -> . ID MULEQ ID
    (74) finVarAsig -> . ID DIVEQ valores
    (75) finVarAsig -> . ID DIVEQ ID
    (43) vecVal -> . ID m
    (23) funcInt -> . MULTIESCALAR ( vec , eMat , param )
    (24) funcInt -> . LENGTH ( vec )
    (25) funcString -> . CAPITALIZAR ( expString )
    (26) funcBool -> . COLINEALES ( vec , vec )
    (67) asig -> . ID = asig
    (68) asig -> . ID = ID

    RETURN          shift and go to state 2
    $end            reduce using rule 30 (empty -> .)
    MENOSMENOS      shift and go to state 32
    MASMAS          shift and go to state 29
    ID              shift and go to state 17
    IF              shift and go to state 18
    WHILE           shift and go to state 6
    DO              shift and go to state 1
    FOR             shift and go to state 15
    PRINT           shift and go to state 8
    MULTIESCALAR    shift and go to state 22
    LENGTH          shift and go to state 27
    CAPITALIZAR     shift and go to state 25
    COLINEALES      shift and go to state 14

    funcBool                       shift and go to state 3
    ctrl                           shift and go to state 4
    funcInt                        shift and go to state 5
    loop                           shift and go to state 7
    vecVal                         shift and go to state 9
    if                             shift and go to state 10
    sentencia                      shift and go to state 11
    asig                           shift and go to state 26
    masmenAsig                     shift and go to state 12
    empty                          shift and go to state 28
    funcVoid                       shift and go to state 13
    func                           shift and go to state 16
    varAsig                        shift and go to state 19
    g                              shift and go to state 20
    funcString                     shift and go to state 21
    funcReturn                     shift and go to state 23
    finVarAsig                     shift and go to state 24
    varsOps                        shift and go to state 30
    varYVals                       shift and go to state 31

state 1

    (11) loop -> DO . bloque WHILE ( expBool ) ;
    (16) bloque -> . sentencia ;
    (17) bloque -> . { g }
    (4) sentencia -> . varsOps ;
    (5) sentencia -> . func ;
    (6) sentencia -> . varAsig ;
    (7) sentencia -> . RETURN ;
    (49) varsOps -> . MENOSMENOS varYVals
    (50) varsOps -> . MASMAS varYVals
    (51) varsOps -> . varYVals MASMAS
    (52) varsOps -> . varYVals MENOSMENOS
    (18) func -> . funcReturn
    (19) func -> . funcVoid
    (53) varAsig -> . ID MULEQ varAsig
    (54) varAsig -> . masmenAsig MULEQ varAsig
    (55) varAsig -> . masmenAsig MULEQ ID
    (56) varAsig -> . masmenAsig MULEQ valores
    (57) varAsig -> . masmenAsig DIVEQ varAsig
    (58) varAsig -> . masmenAsig DIVEQ ID
    (59) varAsig -> . masmenAsig DIVEQ valores
    (60) varAsig -> . finVarAsig
    (61) varAsig -> . masmenAsig
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (20) funcReturn -> . funcInt
    (21) funcReturn -> . funcString
    (22) funcReturn -> . funcBool
    (27) funcVoid -> . PRINT ( valores )
    (62) masmenAsig -> . ID MASEQ masmenAsig
    (63) masmenAsig -> . ID MENOSEQ masmenAsig
    (64) masmenAsig -> . ID MASEQ ID
    (65) masmenAsig -> . ID MENOSEQ ID
    (66) masmenAsig -> . asig
    (69) finVarAsig -> . ID = valores
    (70) finVarAsig -> . ID MASEQ valores
    (71) finVarAsig -> . ID MENOSEQ valores
    (72) finVarAsig -> . ID MULEQ valores
    (73) finVarAsig -> . ID MULEQ ID
    (74) finVarAsig -> . ID DIVEQ valores
    (75) finVarAsig -> . ID DIVEQ ID
    (43) vecVal -> . ID m
    (23) funcInt -> . MULTIESCALAR ( vec , eMat , param )
    (24) funcInt -> . LENGTH ( vec )
    (25) funcString -> . CAPITALIZAR ( expString )
    (26) funcBool -> . COLINEALES ( vec , vec )
    (67) asig -> . ID = asig
    (68) asig -> . ID = ID

    {               shift and go to state 35
    RETURN          shift and go to state 2
    MENOSMENOS      shift and go to state 32
    MASMAS          shift and go to state 29
    ID              shift and go to state 17
    PRINT           shift and go to state 8
    MULTIESCALAR    shift and go to state 22
    LENGTH          shift and go to state 27
    CAPITALIZAR     shift and go to state 25
    COLINEALES      shift and go to state 14

    funcBool                       shift and go to state 3
    funcInt                        shift and go to state 5
    bloque                         shift and go to state 33
    vecVal                         shift and go to state 9
    sentencia                      shift and go to state 34
    asig                           shift and go to state 26
    masmenAsig                     shift and go to state 12
    funcVoid                       shift and go to state 13
    func                           shift and go to state 16
    varAsig                        shift and go to state 19
    funcString                     shift and go to state 21
    funcReturn                     shift and go to state 23
    finVarAsig                     shift and go to state 24
    varsOps                        shift and go to state 30
    varYVals                       shift and go to state 31

state 2

    (7) sentencia -> RETURN . ;

    ;               shift and go to state 36


state 3

    (22) funcReturn -> funcBool .

    ;               reduce using rule 22 (funcReturn -> funcBool .)


state 4

    (2) g -> ctrl . g
    (1) g -> . sentencia
    (2) g -> . ctrl g
    (3) g -> . empty
    (4) sentencia -> . varsOps ;
    (5) sentencia -> . func ;
    (6) sentencia -> . varAsig ;
    (7) sentencia -> . RETURN ;
    (8) ctrl -> . if
    (9) ctrl -> . loop
    (30) empty -> .
    (49) varsOps -> . MENOSMENOS varYVals
    (50) varsOps -> . MASMAS varYVals
    (51) varsOps -> . varYVals MASMAS
    (52) varsOps -> . varYVals MENOSMENOS
    (18) func -> . funcReturn
    (19) func -> . funcVoid
    (53) varAsig -> . ID MULEQ varAsig
    (54) varAsig -> . masmenAsig MULEQ varAsig
    (55) varAsig -> . masmenAsig MULEQ ID
    (56) varAsig -> . masmenAsig MULEQ valores
    (57) varAsig -> . masmenAsig DIVEQ varAsig
    (58) varAsig -> . masmenAsig DIVEQ ID
    (59) varAsig -> . masmenAsig DIVEQ valores
    (60) varAsig -> . finVarAsig
    (61) varAsig -> . masmenAsig
    (13) if -> . IF ( expBool ) bloque else
    (10) loop -> . WHILE ( expBool ) bloque
    (11) loop -> . DO bloque WHILE ( expBool ) ;
    (12) loop -> . FOR ( varAsig ; expBool ; varsOps ) bloque
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (20) funcReturn -> . funcInt
    (21) funcReturn -> . funcString
    (22) funcReturn -> . funcBool
    (27) funcVoid -> . PRINT ( valores )
    (62) masmenAsig -> . ID MASEQ masmenAsig
    (63) masmenAsig -> . ID MENOSEQ masmenAsig
    (64) masmenAsig -> . ID MASEQ ID
    (65) masmenAsig -> . ID MENOSEQ ID
    (66) masmenAsig -> . asig
    (69) finVarAsig -> . ID = valores
    (70) finVarAsig -> . ID MASEQ valores
    (71) finVarAsig -> . ID MENOSEQ valores
    (72) finVarAsig -> . ID MULEQ valores
    (73) finVarAsig -> . ID MULEQ ID
    (74) finVarAsig -> . ID DIVEQ valores
    (75) finVarAsig -> . ID DIVEQ ID
    (43) vecVal -> . ID m
    (23) funcInt -> . MULTIESCALAR ( vec , eMat , param )
    (24) funcInt -> . LENGTH ( vec )
    (25) funcString -> . CAPITALIZAR ( expString )
    (26) funcBool -> . COLINEALES ( vec , vec )
    (67) asig -> . ID = asig
    (68) asig -> . ID = ID

    RETURN          shift and go to state 2
    $end            reduce using rule 30 (empty -> .)
    }               reduce using rule 30 (empty -> .)
    MENOSMENOS      shift and go to state 32
    MASMAS          shift and go to state 29
    ID              shift and go to state 17
    IF              shift and go to state 18
    WHILE           shift and go to state 6
    DO              shift and go to state 1
    FOR             shift and go to state 15
    PRINT           shift and go to state 8
    MULTIESCALAR    shift and go to state 22
    LENGTH          shift and go to state 27
    CAPITALIZAR     shift and go to state 25
    COLINEALES      shift and go to state 14

    funcBool                       shift and go to state 3
    ctrl                           shift and go to state 4
    funcInt                        shift and go to state 5
    loop                           shift and go to state 7
    vecVal                         shift and go to state 9
    if                             shift and go to state 10
    sentencia                      shift and go to state 11
    asig                           shift and go to state 26
    masmenAsig                     shift and go to state 12
    empty                          shift and go to state 28
    funcVoid                       shift and go to state 13
    func                           shift and go to state 16
    varAsig                        shift and go to state 19
    g                              shift and go to state 37
    funcString                     shift and go to state 21
    funcReturn                     shift and go to state 23
    finVarAsig                     shift and go to state 24
    varsOps                        shift and go to state 30
    varYVals                       shift and go to state 31

state 5

    (20) funcReturn -> funcInt .

    ;               reduce using rule 20 (funcReturn -> funcInt .)


state 6

    (10) loop -> WHILE . ( expBool ) bloque

    (               shift and go to state 38


state 7

    (9) ctrl -> loop .

    RETURN          reduce using rule 9 (ctrl -> loop .)
    MENOSMENOS      reduce using rule 9 (ctrl -> loop .)
    MASMAS          reduce using rule 9 (ctrl -> loop .)
    ID              reduce using rule 9 (ctrl -> loop .)
    IF              reduce using rule 9 (ctrl -> loop .)
    WHILE           reduce using rule 9 (ctrl -> loop .)
    DO              reduce using rule 9 (ctrl -> loop .)
    FOR             reduce using rule 9 (ctrl -> loop .)
    PRINT           reduce using rule 9 (ctrl -> loop .)
    MULTIESCALAR    reduce using rule 9 (ctrl -> loop .)
    LENGTH          reduce using rule 9 (ctrl -> loop .)
    CAPITALIZAR     reduce using rule 9 (ctrl -> loop .)
    COLINEALES      reduce using rule 9 (ctrl -> loop .)
    $end            reduce using rule 9 (ctrl -> loop .)
    }               reduce using rule 9 (ctrl -> loop .)


state 8

    (27) funcVoid -> PRINT . ( valores )

    (               shift and go to state 39


state 9

    (42) varYVals -> vecVal .

    MASMAS          reduce using rule 42 (varYVals -> vecVal .)
    MENOSMENOS      reduce using rule 42 (varYVals -> vecVal .)
    >               reduce using rule 42 (varYVals -> vecVal .)
    <               reduce using rule 42 (varYVals -> vecVal .)
    EQEQ            reduce using rule 42 (varYVals -> vecVal .)
    DISTINTO        reduce using rule 42 (varYVals -> vecVal .)
    AND             reduce using rule 42 (varYVals -> vecVal .)
    ?               reduce using rule 42 (varYVals -> vecVal .)
    OR              reduce using rule 42 (varYVals -> vecVal .)
    )               reduce using rule 42 (varYVals -> vecVal .)
    ^               reduce using rule 42 (varYVals -> vecVal .)
    *               reduce using rule 42 (varYVals -> vecVal .)
    /               reduce using rule 42 (varYVals -> vecVal .)
    %               reduce using rule 42 (varYVals -> vecVal .)
    +               reduce using rule 42 (varYVals -> vecVal .)
    -               reduce using rule 42 (varYVals -> vecVal .)
    ;               reduce using rule 42 (varYVals -> vecVal .)
    ,               reduce using rule 42 (varYVals -> vecVal .)
    }               reduce using rule 42 (varYVals -> vecVal .)
    ]               reduce using rule 42 (varYVals -> vecVal .)
    :               reduce using rule 42 (varYVals -> vecVal .)


state 10

    (8) ctrl -> if .

    RETURN          reduce using rule 8 (ctrl -> if .)
    MENOSMENOS      reduce using rule 8 (ctrl -> if .)
    MASMAS          reduce using rule 8 (ctrl -> if .)
    ID              reduce using rule 8 (ctrl -> if .)
    IF              reduce using rule 8 (ctrl -> if .)
    WHILE           reduce using rule 8 (ctrl -> if .)
    DO              reduce using rule 8 (ctrl -> if .)
    FOR             reduce using rule 8 (ctrl -> if .)
    PRINT           reduce using rule 8 (ctrl -> if .)
    MULTIESCALAR    reduce using rule 8 (ctrl -> if .)
    LENGTH          reduce using rule 8 (ctrl -> if .)
    CAPITALIZAR     reduce using rule 8 (ctrl -> if .)
    COLINEALES      reduce using rule 8 (ctrl -> if .)
    $end            reduce using rule 8 (ctrl -> if .)
    }               reduce using rule 8 (ctrl -> if .)


state 11

    (1) g -> sentencia .

    $end            reduce using rule 1 (g -> sentencia .)
    }               reduce using rule 1 (g -> sentencia .)


state 12

    (54) varAsig -> masmenAsig . MULEQ varAsig
    (55) varAsig -> masmenAsig . MULEQ ID
    (56) varAsig -> masmenAsig . MULEQ valores
    (57) varAsig -> masmenAsig . DIVEQ varAsig
    (58) varAsig -> masmenAsig . DIVEQ ID
    (59) varAsig -> masmenAsig . DIVEQ valores
    (61) varAsig -> masmenAsig .

    MULEQ           shift and go to state 41
    DIVEQ           shift and go to state 40
    ;               reduce using rule 61 (varAsig -> masmenAsig .)


state 13

    (19) func -> funcVoid .

    ;               reduce using rule 19 (func -> funcVoid .)


state 14

    (26) funcBool -> COLINEALES . ( vec , vec )

    (               shift and go to state 42


state 15

    (12) loop -> FOR . ( varAsig ; expBool ; varsOps ) bloque

    (               shift and go to state 43


state 16

    (5) sentencia -> func . ;

    ;               shift and go to state 44


state 17

    (53) varAsig -> ID . MULEQ varAsig
    (41) varYVals -> ID .
    (62) masmenAsig -> ID . MASEQ masmenAsig
    (63) masmenAsig -> ID . MENOSEQ masmenAsig
    (64) masmenAsig -> ID . MASEQ ID
    (65) masmenAsig -> ID . MENOSEQ ID
    (69) finVarAsig -> ID . = valores
    (70) finVarAsig -> ID . MASEQ valores
    (71) finVarAsig -> ID . MENOSEQ valores
    (72) finVarAsig -> ID . MULEQ valores
    (73) finVarAsig -> ID . MULEQ ID
    (74) finVarAsig -> ID . DIVEQ valores
    (75) finVarAsig -> ID . DIVEQ ID
    (43) vecVal -> ID . m
    (67) asig -> ID . = asig
    (68) asig -> ID . = ID
    (44) m -> . [ INT ]
    (45) m -> . [ INT ] m

    MULEQ           shift and go to state 51
    MASMAS          reduce using rule 41 (varYVals -> ID .)
    MENOSMENOS      reduce using rule 41 (varYVals -> ID .)
    MASEQ           shift and go to state 46
    MENOSEQ         shift and go to state 45
    =               shift and go to state 49
    DIVEQ           shift and go to state 50
    [               shift and go to state 48

    m                              shift and go to state 47

state 18

    (13) if -> IF . ( expBool ) bloque else

    (               shift and go to state 52


state 19

    (6) sentencia -> varAsig . ;

    ;               shift and go to state 53


state 20

    (0) S' -> g .



state 21

    (21) funcReturn -> funcString .

    ;               reduce using rule 21 (funcReturn -> funcString .)


state 22

    (23) funcInt -> MULTIESCALAR . ( vec , eMat , param )

    (               shift and go to state 54


state 23

    (18) func -> funcReturn .

    ;               reduce using rule 18 (func -> funcReturn .)


state 24

    (60) varAsig -> finVarAsig .

    ;               reduce using rule 60 (varAsig -> finVarAsig .)


state 25

    (25) funcString -> CAPITALIZAR . ( expString )

    (               shift and go to state 55


state 26

    (66) masmenAsig -> asig .

    MULEQ           reduce using rule 66 (masmenAsig -> asig .)
    DIVEQ           reduce using rule 66 (masmenAsig -> asig .)
    ;               reduce using rule 66 (masmenAsig -> asig .)


state 27

    (24) funcInt -> LENGTH . ( vec )

    (               shift and go to state 56


state 28

    (3) g -> empty .

    $end            reduce using rule 3 (g -> empty .)
    }               reduce using rule 3 (g -> empty .)


state 29

    (50) varsOps -> MASMAS . varYVals
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (43) vecVal -> . ID m

    ID              shift and go to state 58

    varYVals                       shift and go to state 57
    vecVal                         shift and go to state 9

state 30

    (4) sentencia -> varsOps . ;

    ;               shift and go to state 59


state 31

    (51) varsOps -> varYVals . MASMAS
    (52) varsOps -> varYVals . MENOSMENOS

    MASMAS          shift and go to state 60
    MENOSMENOS      shift and go to state 61


state 32

    (49) varsOps -> MENOSMENOS . varYVals
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (43) vecVal -> . ID m

    ID              shift and go to state 58

    varYVals                       shift and go to state 62
    vecVal                         shift and go to state 9

state 33

    (11) loop -> DO bloque . WHILE ( expBool ) ;

    WHILE           shift and go to state 63


state 34

    (16) bloque -> sentencia . ;

    ;               shift and go to state 64


state 35

    (17) bloque -> { . g }
    (1) g -> . sentencia
    (2) g -> . ctrl g
    (3) g -> . empty
    (4) sentencia -> . varsOps ;
    (5) sentencia -> . func ;
    (6) sentencia -> . varAsig ;
    (7) sentencia -> . RETURN ;
    (8) ctrl -> . if
    (9) ctrl -> . loop
    (30) empty -> .
    (49) varsOps -> . MENOSMENOS varYVals
    (50) varsOps -> . MASMAS varYVals
    (51) varsOps -> . varYVals MASMAS
    (52) varsOps -> . varYVals MENOSMENOS
    (18) func -> . funcReturn
    (19) func -> . funcVoid
    (53) varAsig -> . ID MULEQ varAsig
    (54) varAsig -> . masmenAsig MULEQ varAsig
    (55) varAsig -> . masmenAsig MULEQ ID
    (56) varAsig -> . masmenAsig MULEQ valores
    (57) varAsig -> . masmenAsig DIVEQ varAsig
    (58) varAsig -> . masmenAsig DIVEQ ID
    (59) varAsig -> . masmenAsig DIVEQ valores
    (60) varAsig -> . finVarAsig
    (61) varAsig -> . masmenAsig
    (13) if -> . IF ( expBool ) bloque else
    (10) loop -> . WHILE ( expBool ) bloque
    (11) loop -> . DO bloque WHILE ( expBool ) ;
    (12) loop -> . FOR ( varAsig ; expBool ; varsOps ) bloque
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (20) funcReturn -> . funcInt
    (21) funcReturn -> . funcString
    (22) funcReturn -> . funcBool
    (27) funcVoid -> . PRINT ( valores )
    (62) masmenAsig -> . ID MASEQ masmenAsig
    (63) masmenAsig -> . ID MENOSEQ masmenAsig
    (64) masmenAsig -> . ID MASEQ ID
    (65) masmenAsig -> . ID MENOSEQ ID
    (66) masmenAsig -> . asig
    (69) finVarAsig -> . ID = valores
    (70) finVarAsig -> . ID MASEQ valores
    (71) finVarAsig -> . ID MENOSEQ valores
    (72) finVarAsig -> . ID MULEQ valores
    (73) finVarAsig -> . ID MULEQ ID
    (74) finVarAsig -> . ID DIVEQ valores
    (75) finVarAsig -> . ID DIVEQ ID
    (43) vecVal -> . ID m
    (23) funcInt -> . MULTIESCALAR ( vec , eMat , param )
    (24) funcInt -> . LENGTH ( vec )
    (25) funcString -> . CAPITALIZAR ( expString )
    (26) funcBool -> . COLINEALES ( vec , vec )
    (67) asig -> . ID = asig
    (68) asig -> . ID = ID

    RETURN          shift and go to state 2
    }               reduce using rule 30 (empty -> .)
    MENOSMENOS      shift and go to state 32
    MASMAS          shift and go to state 29
    ID              shift and go to state 17
    IF              shift and go to state 18
    WHILE           shift and go to state 6
    DO              shift and go to state 1
    FOR             shift and go to state 15
    PRINT           shift and go to state 8
    MULTIESCALAR    shift and go to state 22
    LENGTH          shift and go to state 27
    CAPITALIZAR     shift and go to state 25
    COLINEALES      shift and go to state 14

    funcBool                       shift and go to state 3
    ctrl                           shift and go to state 4
    funcInt                        shift and go to state 5
    loop                           shift and go to state 7
    vecVal                         shift and go to state 9
    if                             shift and go to state 10
    sentencia                      shift and go to state 11
    asig                           shift and go to state 26
    masmenAsig                     shift and go to state 12
    empty                          shift and go to state 28
    funcVoid                       shift and go to state 13
    func                           shift and go to state 16
    varAsig                        shift and go to state 19
    g                              shift and go to state 65
    funcString                     shift and go to state 21
    funcReturn                     shift and go to state 23
    finVarAsig                     shift and go to state 24
    varsOps                        shift and go to state 30
    varYVals                       shift and go to state 31

state 36

    (7) sentencia -> RETURN ; .

    $end            reduce using rule 7 (sentencia -> RETURN ; .)
    ;               reduce using rule 7 (sentencia -> RETURN ; .)
    }               reduce using rule 7 (sentencia -> RETURN ; .)


state 37

    (2) g -> ctrl g .

    $end            reduce using rule 2 (g -> ctrl g .)
    }               reduce using rule 2 (g -> ctrl g .)


state 38

    (10) loop -> WHILE ( . expBool ) bloque
    (98) expBool -> . or ? expBool : expBool
    (99) expBool -> . or
    (100) or -> . or OR and
    (101) or -> . and
    (102) and -> . and AND eq
    (103) and -> . eq
    (104) eq -> . eq EQEQ tBool
    (105) eq -> . eq DISTINTO tBool
    (106) eq -> . mayor
    (107) mayor -> . tCompare > tCompare
    (108) mayor -> . menor
    (117) tCompare -> . eMat
    (118) tCompare -> . varsOps
    (119) tCompare -> . varYVals
    (109) menor -> . tCompare < tCompare
    (110) menor -> . not
    (76) eMat -> . eMat + p
    (77) eMat -> . eMat - p
    (78) eMat -> . p
    (49) varsOps -> . MENOSMENOS varYVals
    (50) varsOps -> . MASMAS varYVals
    (51) varsOps -> . varYVals MASMAS
    (52) varsOps -> . varYVals MENOSMENOS
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (111) not -> . NOT not
    (112) not -> . tBool
    (79) p -> . p * exp
    (80) p -> . p / exp
    (81) p -> . p % exp
    (82) p -> . exp
    (43) vecVal -> . ID m
    (113) tBool -> . ( expBool )
    (114) tBool -> . BOOL
    (115) tBool -> . varYVals
    (116) tBool -> . funcBool
    (83) exp -> . exp ^ iSing
    (84) exp -> . iSing
    (26) funcBool -> . COLINEALES ( vec , vec )
    (85) iSing -> . - paren
    (86) iSing -> . + paren
    (87) iSing -> . paren
    (88) paren -> . ( eMat )
    (89) paren -> . INT
    (90) paren -> . varYVals
    (91) paren -> . FLOAT
    (92) paren -> . varsOps
    (93) paren -> . funcInt
    (23) funcInt -> . MULTIESCALAR ( vec , eMat , param )
    (24) funcInt -> . LENGTH ( vec )

    MENOSMENOS      shift and go to state 32
    MASMAS          shift and go to state 29
    ID              shift and go to state 58
    NOT             shift and go to state 87
    (               shift and go to state 73
    BOOL            shift and go to state 76
    COLINEALES      shift and go to state 14
    -               shift and go to state 75
    +               shift and go to state 74
    INT             shift and go to state 81
    FLOAT           shift and go to state 82
    MULTIESCALAR    shift and go to state 22
    LENGTH          shift and go to state 27

    and                            shift and go to state 66
    funcBool                       shift and go to state 67
    funcInt                        shift and go to state 68
    menor                          shift and go to state 69
    eq                             shift and go to state 70
    mayor                          shift and go to state 71
    eMat                           shift and go to state 72
    vecVal                         shift and go to state 9
    paren                          shift and go to state 79
    iSing                          shift and go to state 77
    tCompare                       shift and go to state 78
    not                            shift and go to state 80
    p                              shift and go to state 84
    varsOps                        shift and go to state 85
    exp                            shift and go to state 86
    tBool                          shift and go to state 88
    varYVals                       shift and go to state 89
    or                             shift and go to state 83
    expBool                        shift and go to state 90

state 39

    (27) funcVoid -> PRINT ( . valores )
    (34) valores -> . eMat
    (35) valores -> . expBool
    (36) valores -> . expString
    (37) valores -> . varYVals
    (38) valores -> . funcReturn
    (39) valores -> . reg
    (40) valores -> . ID . ID
    (76) eMat -> . eMat + p
    (77) eMat -> . eMat - p
    (78) eMat -> . p
    (98) expBool -> . or ? expBool : expBool
    (99) expBool -> . or
    (94) expString -> . expString + STRING
    (95) expString -> . STRING
    (96) expString -> . varYVals
    (97) expString -> . funcString
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (20) funcReturn -> . funcInt
    (21) funcReturn -> . funcString
    (22) funcReturn -> . funcBool
    (46) reg -> . { campos }
    (79) p -> . p * exp
    (80) p -> . p / exp
    (81) p -> . p % exp
    (82) p -> . exp
    (100) or -> . or OR and
    (101) or -> . and
    (25) funcString -> . CAPITALIZAR ( expString )
    (43) vecVal -> . ID m
    (23) funcInt -> . MULTIESCALAR ( vec , eMat , param )
    (24) funcInt -> . LENGTH ( vec )
    (26) funcBool -> . COLINEALES ( vec , vec )
    (83) exp -> . exp ^ iSing
    (84) exp -> . iSing
    (102) and -> . and AND eq
    (103) and -> . eq
    (85) iSing -> . - paren
    (86) iSing -> . + paren
    (87) iSing -> . paren
    (104) eq -> . eq EQEQ tBool
    (105) eq -> . eq DISTINTO tBool
    (106) eq -> . mayor
    (88) paren -> . ( eMat )
    (89) paren -> . INT
    (90) paren -> . varYVals
    (91) paren -> . FLOAT
    (92) paren -> . varsOps
    (93) paren -> . funcInt
    (107) mayor -> . tCompare > tCompare
    (108) mayor -> . menor
    (49) varsOps -> . MENOSMENOS varYVals
    (50) varsOps -> . MASMAS varYVals
    (51) varsOps -> . varYVals MASMAS
    (52) varsOps -> . varYVals MENOSMENOS
    (117) tCompare -> . eMat
    (118) tCompare -> . varsOps
    (119) tCompare -> . varYVals
    (109) menor -> . tCompare < tCompare
    (110) menor -> . not
    (111) not -> . NOT not
    (112) not -> . tBool
    (113) tBool -> . ( expBool )
    (114) tBool -> . BOOL
    (115) tBool -> . varYVals
    (116) tBool -> . funcBool

    ID              shift and go to state 99
    STRING          shift and go to state 97
    {               shift and go to state 103
    CAPITALIZAR     shift and go to state 25
    MULTIESCALAR    shift and go to state 22
    LENGTH          shift and go to state 27
    COLINEALES      shift and go to state 14
    -               shift and go to state 75
    +               shift and go to state 74
    (               shift and go to state 94
    INT             shift and go to state 81
    FLOAT           shift and go to state 82
    MENOSMENOS      shift and go to state 32
    MASMAS          shift and go to state 29
    NOT             shift and go to state 87
    BOOL            shift and go to state 76

    and                            shift and go to state 66
    funcBool                       shift and go to state 91
    funcInt                        shift and go to state 92
    menor                          shift and go to state 69
    eq                             shift and go to state 70
    vecVal                         shift and go to state 9
    eMat                           shift and go to state 93
    mayor                          shift and go to state 71
    paren                          shift and go to state 79
    reg                            shift and go to state 95
    varsOps                        shift and go to state 96
    expString                      shift and go to state 98
    tCompare                       shift and go to state 78
    not                            shift and go to state 80
    funcString                     shift and go to state 100
    funcReturn                     shift and go to state 101
    valores                        shift and go to state 102
    p                              shift and go to state 84
    iSing                          shift and go to state 77
    exp                            shift and go to state 86
    tBool                          shift and go to state 88
    varYVals                       shift and go to state 104
    or                             shift and go to state 83
    expBool                        shift and go to state 105

state 40

    (57) varAsig -> masmenAsig DIVEQ . varAsig
    (58) varAsig -> masmenAsig DIVEQ . ID
    (59) varAsig -> masmenAsig DIVEQ . valores
    (53) varAsig -> . ID MULEQ varAsig
    (54) varAsig -> . masmenAsig MULEQ varAsig
    (55) varAsig -> . masmenAsig MULEQ ID
    (56) varAsig -> . masmenAsig MULEQ valores
    (57) varAsig -> . masmenAsig DIVEQ varAsig
    (58) varAsig -> . masmenAsig DIVEQ ID
    (59) varAsig -> . masmenAsig DIVEQ valores
    (60) varAsig -> . finVarAsig
    (61) varAsig -> . masmenAsig
    (34) valores -> . eMat
    (35) valores -> . expBool
    (36) valores -> . expString
    (37) valores -> . varYVals
    (38) valores -> . funcReturn
    (39) valores -> . reg
    (40) valores -> . ID . ID
    (62) masmenAsig -> . ID MASEQ masmenAsig
    (63) masmenAsig -> . ID MENOSEQ masmenAsig
    (64) masmenAsig -> . ID MASEQ ID
    (65) masmenAsig -> . ID MENOSEQ ID
    (66) masmenAsig -> . asig
    (69) finVarAsig -> . ID = valores
    (70) finVarAsig -> . ID MASEQ valores
    (71) finVarAsig -> . ID MENOSEQ valores
    (72) finVarAsig -> . ID MULEQ valores
    (73) finVarAsig -> . ID MULEQ ID
    (74) finVarAsig -> . ID DIVEQ valores
    (75) finVarAsig -> . ID DIVEQ ID
    (76) eMat -> . eMat + p
    (77) eMat -> . eMat - p
    (78) eMat -> . p
    (98) expBool -> . or ? expBool : expBool
    (99) expBool -> . or
    (94) expString -> . expString + STRING
    (95) expString -> . STRING
    (96) expString -> . varYVals
    (97) expString -> . funcString
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (20) funcReturn -> . funcInt
    (21) funcReturn -> . funcString
    (22) funcReturn -> . funcBool
    (46) reg -> . { campos }
    (67) asig -> . ID = asig
    (68) asig -> . ID = ID
    (79) p -> . p * exp
    (80) p -> . p / exp
    (81) p -> . p % exp
    (82) p -> . exp
    (100) or -> . or OR and
    (101) or -> . and
    (25) funcString -> . CAPITALIZAR ( expString )
    (43) vecVal -> . ID m
    (23) funcInt -> . MULTIESCALAR ( vec , eMat , param )
    (24) funcInt -> . LENGTH ( vec )
    (26) funcBool -> . COLINEALES ( vec , vec )
    (83) exp -> . exp ^ iSing
    (84) exp -> . iSing
    (102) and -> . and AND eq
    (103) and -> . eq
    (85) iSing -> . - paren
    (86) iSing -> . + paren
    (87) iSing -> . paren
    (104) eq -> . eq EQEQ tBool
    (105) eq -> . eq DISTINTO tBool
    (106) eq -> . mayor
    (88) paren -> . ( eMat )
    (89) paren -> . INT
    (90) paren -> . varYVals
    (91) paren -> . FLOAT
    (92) paren -> . varsOps
    (93) paren -> . funcInt
    (107) mayor -> . tCompare > tCompare
    (108) mayor -> . menor
    (49) varsOps -> . MENOSMENOS varYVals
    (50) varsOps -> . MASMAS varYVals
    (51) varsOps -> . varYVals MASMAS
    (52) varsOps -> . varYVals MENOSMENOS
    (117) tCompare -> . eMat
    (118) tCompare -> . varsOps
    (119) tCompare -> . varYVals
    (109) menor -> . tCompare < tCompare
    (110) menor -> . not
    (111) not -> . NOT not
    (112) not -> . tBool
    (113) tBool -> . ( expBool )
    (114) tBool -> . BOOL
    (115) tBool -> . varYVals
    (116) tBool -> . funcBool

    ID              shift and go to state 106
    STRING          shift and go to state 97
    {               shift and go to state 103
    CAPITALIZAR     shift and go to state 25
    MULTIESCALAR    shift and go to state 22
    LENGTH          shift and go to state 27
    COLINEALES      shift and go to state 14
    -               shift and go to state 75
    +               shift and go to state 74
    (               shift and go to state 94
    INT             shift and go to state 81
    FLOAT           shift and go to state 82
    MENOSMENOS      shift and go to state 32
    MASMAS          shift and go to state 29
    NOT             shift and go to state 87
    BOOL            shift and go to state 76

    and                            shift and go to state 66
    funcBool                       shift and go to state 91
    finVarAsig                     shift and go to state 24
    funcInt                        shift and go to state 92
    menor                          shift and go to state 69
    eq                             shift and go to state 70
    vecVal                         shift and go to state 9
    eMat                           shift and go to state 93
    asig                           shift and go to state 26
    mayor                          shift and go to state 71
    masmenAsig                     shift and go to state 12
    paren                          shift and go to state 79
    varsOps                        shift and go to state 96
    reg                            shift and go to state 95
    expString                      shift and go to state 98
    tCompare                       shift and go to state 78
    not                            shift and go to state 80
    varAsig                        shift and go to state 107
    funcString                     shift and go to state 100
    funcReturn                     shift and go to state 101
    valores                        shift and go to state 108
    p                              shift and go to state 84
    iSing                          shift and go to state 77
    exp                            shift and go to state 86
    tBool                          shift and go to state 88
    varYVals                       shift and go to state 104
    or                             shift and go to state 83
    expBool                        shift and go to state 105

state 41

    (54) varAsig -> masmenAsig MULEQ . varAsig
    (55) varAsig -> masmenAsig MULEQ . ID
    (56) varAsig -> masmenAsig MULEQ . valores
    (53) varAsig -> . ID MULEQ varAsig
    (54) varAsig -> . masmenAsig MULEQ varAsig
    (55) varAsig -> . masmenAsig MULEQ ID
    (56) varAsig -> . masmenAsig MULEQ valores
    (57) varAsig -> . masmenAsig DIVEQ varAsig
    (58) varAsig -> . masmenAsig DIVEQ ID
    (59) varAsig -> . masmenAsig DIVEQ valores
    (60) varAsig -> . finVarAsig
    (61) varAsig -> . masmenAsig
    (34) valores -> . eMat
    (35) valores -> . expBool
    (36) valores -> . expString
    (37) valores -> . varYVals
    (38) valores -> . funcReturn
    (39) valores -> . reg
    (40) valores -> . ID . ID
    (62) masmenAsig -> . ID MASEQ masmenAsig
    (63) masmenAsig -> . ID MENOSEQ masmenAsig
    (64) masmenAsig -> . ID MASEQ ID
    (65) masmenAsig -> . ID MENOSEQ ID
    (66) masmenAsig -> . asig
    (69) finVarAsig -> . ID = valores
    (70) finVarAsig -> . ID MASEQ valores
    (71) finVarAsig -> . ID MENOSEQ valores
    (72) finVarAsig -> . ID MULEQ valores
    (73) finVarAsig -> . ID MULEQ ID
    (74) finVarAsig -> . ID DIVEQ valores
    (75) finVarAsig -> . ID DIVEQ ID
    (76) eMat -> . eMat + p
    (77) eMat -> . eMat - p
    (78) eMat -> . p
    (98) expBool -> . or ? expBool : expBool
    (99) expBool -> . or
    (94) expString -> . expString + STRING
    (95) expString -> . STRING
    (96) expString -> . varYVals
    (97) expString -> . funcString
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (20) funcReturn -> . funcInt
    (21) funcReturn -> . funcString
    (22) funcReturn -> . funcBool
    (46) reg -> . { campos }
    (67) asig -> . ID = asig
    (68) asig -> . ID = ID
    (79) p -> . p * exp
    (80) p -> . p / exp
    (81) p -> . p % exp
    (82) p -> . exp
    (100) or -> . or OR and
    (101) or -> . and
    (25) funcString -> . CAPITALIZAR ( expString )
    (43) vecVal -> . ID m
    (23) funcInt -> . MULTIESCALAR ( vec , eMat , param )
    (24) funcInt -> . LENGTH ( vec )
    (26) funcBool -> . COLINEALES ( vec , vec )
    (83) exp -> . exp ^ iSing
    (84) exp -> . iSing
    (102) and -> . and AND eq
    (103) and -> . eq
    (85) iSing -> . - paren
    (86) iSing -> . + paren
    (87) iSing -> . paren
    (104) eq -> . eq EQEQ tBool
    (105) eq -> . eq DISTINTO tBool
    (106) eq -> . mayor
    (88) paren -> . ( eMat )
    (89) paren -> . INT
    (90) paren -> . varYVals
    (91) paren -> . FLOAT
    (92) paren -> . varsOps
    (93) paren -> . funcInt
    (107) mayor -> . tCompare > tCompare
    (108) mayor -> . menor
    (49) varsOps -> . MENOSMENOS varYVals
    (50) varsOps -> . MASMAS varYVals
    (51) varsOps -> . varYVals MASMAS
    (52) varsOps -> . varYVals MENOSMENOS
    (117) tCompare -> . eMat
    (118) tCompare -> . varsOps
    (119) tCompare -> . varYVals
    (109) menor -> . tCompare < tCompare
    (110) menor -> . not
    (111) not -> . NOT not
    (112) not -> . tBool
    (113) tBool -> . ( expBool )
    (114) tBool -> . BOOL
    (115) tBool -> . varYVals
    (116) tBool -> . funcBool

    ID              shift and go to state 109
    STRING          shift and go to state 97
    {               shift and go to state 103
    CAPITALIZAR     shift and go to state 25
    MULTIESCALAR    shift and go to state 22
    LENGTH          shift and go to state 27
    COLINEALES      shift and go to state 14
    -               shift and go to state 75
    +               shift and go to state 74
    (               shift and go to state 94
    INT             shift and go to state 81
    FLOAT           shift and go to state 82
    MENOSMENOS      shift and go to state 32
    MASMAS          shift and go to state 29
    NOT             shift and go to state 87
    BOOL            shift and go to state 76

    and                            shift and go to state 66
    funcBool                       shift and go to state 91
    finVarAsig                     shift and go to state 24
    funcInt                        shift and go to state 92
    menor                          shift and go to state 69
    eq                             shift and go to state 70
    vecVal                         shift and go to state 9
    eMat                           shift and go to state 93
    asig                           shift and go to state 26
    mayor                          shift and go to state 71
    masmenAsig                     shift and go to state 12
    paren                          shift and go to state 79
    varsOps                        shift and go to state 96
    reg                            shift and go to state 95
    expString                      shift and go to state 98
    tCompare                       shift and go to state 78
    not                            shift and go to state 80
    varAsig                        shift and go to state 110
    funcString                     shift and go to state 100
    funcReturn                     shift and go to state 101
    valores                        shift and go to state 111
    p                              shift and go to state 84
    iSing                          shift and go to state 77
    exp                            shift and go to state 86
    tBool                          shift and go to state 88
    varYVals                       shift and go to state 104
    or                             shift and go to state 83
    expBool                        shift and go to state 105

state 42

    (26) funcBool -> COLINEALES ( . vec , vec )
    (31) vec -> . [ elem ]

    [               shift and go to state 113

    vec                            shift and go to state 112

state 43

    (12) loop -> FOR ( . varAsig ; expBool ; varsOps ) bloque
    (53) varAsig -> . ID MULEQ varAsig
    (54) varAsig -> . masmenAsig MULEQ varAsig
    (55) varAsig -> . masmenAsig MULEQ ID
    (56) varAsig -> . masmenAsig MULEQ valores
    (57) varAsig -> . masmenAsig DIVEQ varAsig
    (58) varAsig -> . masmenAsig DIVEQ ID
    (59) varAsig -> . masmenAsig DIVEQ valores
    (60) varAsig -> . finVarAsig
    (61) varAsig -> . masmenAsig
    (62) masmenAsig -> . ID MASEQ masmenAsig
    (63) masmenAsig -> . ID MENOSEQ masmenAsig
    (64) masmenAsig -> . ID MASEQ ID
    (65) masmenAsig -> . ID MENOSEQ ID
    (66) masmenAsig -> . asig
    (69) finVarAsig -> . ID = valores
    (70) finVarAsig -> . ID MASEQ valores
    (71) finVarAsig -> . ID MENOSEQ valores
    (72) finVarAsig -> . ID MULEQ valores
    (73) finVarAsig -> . ID MULEQ ID
    (74) finVarAsig -> . ID DIVEQ valores
    (75) finVarAsig -> . ID DIVEQ ID
    (67) asig -> . ID = asig
    (68) asig -> . ID = ID

    ID              shift and go to state 115

    varAsig                        shift and go to state 114
    asig                           shift and go to state 26
    finVarAsig                     shift and go to state 24
    masmenAsig                     shift and go to state 12

state 44

    (5) sentencia -> func ; .

    $end            reduce using rule 5 (sentencia -> func ; .)
    ;               reduce using rule 5 (sentencia -> func ; .)
    }               reduce using rule 5 (sentencia -> func ; .)


state 45

    (63) masmenAsig -> ID MENOSEQ . masmenAsig
    (65) masmenAsig -> ID MENOSEQ . ID
    (71) finVarAsig -> ID MENOSEQ . valores
    (62) masmenAsig -> . ID MASEQ masmenAsig
    (63) masmenAsig -> . ID MENOSEQ masmenAsig
    (64) masmenAsig -> . ID MASEQ ID
    (65) masmenAsig -> . ID MENOSEQ ID
    (66) masmenAsig -> . asig
    (34) valores -> . eMat
    (35) valores -> . expBool
    (36) valores -> . expString
    (37) valores -> . varYVals
    (38) valores -> . funcReturn
    (39) valores -> . reg
    (40) valores -> . ID . ID
    (67) asig -> . ID = asig
    (68) asig -> . ID = ID
    (76) eMat -> . eMat + p
    (77) eMat -> . eMat - p
    (78) eMat -> . p
    (98) expBool -> . or ? expBool : expBool
    (99) expBool -> . or
    (94) expString -> . expString + STRING
    (95) expString -> . STRING
    (96) expString -> . varYVals
    (97) expString -> . funcString
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (20) funcReturn -> . funcInt
    (21) funcReturn -> . funcString
    (22) funcReturn -> . funcBool
    (46) reg -> . { campos }
    (79) p -> . p * exp
    (80) p -> . p / exp
    (81) p -> . p % exp
    (82) p -> . exp
    (100) or -> . or OR and
    (101) or -> . and
    (25) funcString -> . CAPITALIZAR ( expString )
    (43) vecVal -> . ID m
    (23) funcInt -> . MULTIESCALAR ( vec , eMat , param )
    (24) funcInt -> . LENGTH ( vec )
    (26) funcBool -> . COLINEALES ( vec , vec )
    (83) exp -> . exp ^ iSing
    (84) exp -> . iSing
    (102) and -> . and AND eq
    (103) and -> . eq
    (85) iSing -> . - paren
    (86) iSing -> . + paren
    (87) iSing -> . paren
    (104) eq -> . eq EQEQ tBool
    (105) eq -> . eq DISTINTO tBool
    (106) eq -> . mayor
    (88) paren -> . ( eMat )
    (89) paren -> . INT
    (90) paren -> . varYVals
    (91) paren -> . FLOAT
    (92) paren -> . varsOps
    (93) paren -> . funcInt
    (107) mayor -> . tCompare > tCompare
    (108) mayor -> . menor
    (49) varsOps -> . MENOSMENOS varYVals
    (50) varsOps -> . MASMAS varYVals
    (51) varsOps -> . varYVals MASMAS
    (52) varsOps -> . varYVals MENOSMENOS
    (117) tCompare -> . eMat
    (118) tCompare -> . varsOps
    (119) tCompare -> . varYVals
    (109) menor -> . tCompare < tCompare
    (110) menor -> . not
    (111) not -> . NOT not
    (112) not -> . tBool
    (113) tBool -> . ( expBool )
    (114) tBool -> . BOOL
    (115) tBool -> . varYVals
    (116) tBool -> . funcBool

    ID              shift and go to state 117
    STRING          shift and go to state 97
    {               shift and go to state 103
    CAPITALIZAR     shift and go to state 25
    MULTIESCALAR    shift and go to state 22
    LENGTH          shift and go to state 27
    COLINEALES      shift and go to state 14
    -               shift and go to state 75
    +               shift and go to state 74
    (               shift and go to state 94
    INT             shift and go to state 81
    FLOAT           shift and go to state 82
    MENOSMENOS      shift and go to state 32
    MASMAS          shift and go to state 29
    NOT             shift and go to state 87
    BOOL            shift and go to state 76

    and                            shift and go to state 66
    funcBool                       shift and go to state 91
    funcInt                        shift and go to state 92
    menor                          shift and go to state 69
    eq                             shift and go to state 70
    vecVal                         shift and go to state 9
    eMat                           shift and go to state 93
    asig                           shift and go to state 26
    mayor                          shift and go to state 71
    masmenAsig                     shift and go to state 116
    paren                          shift and go to state 79
    varsOps                        shift and go to state 96
    reg                            shift and go to state 95
    expString                      shift and go to state 98
    tCompare                       shift and go to state 78
    not                            shift and go to state 80
    funcString                     shift and go to state 100
    funcReturn                     shift and go to state 101
    valores                        shift and go to state 118
    p                              shift and go to state 84
    iSing                          shift and go to state 77
    exp                            shift and go to state 86
    tBool                          shift and go to state 88
    varYVals                       shift and go to state 104
    or                             shift and go to state 83
    expBool                        shift and go to state 105

state 46

    (62) masmenAsig -> ID MASEQ . masmenAsig
    (64) masmenAsig -> ID MASEQ . ID
    (70) finVarAsig -> ID MASEQ . valores
    (62) masmenAsig -> . ID MASEQ masmenAsig
    (63) masmenAsig -> . ID MENOSEQ masmenAsig
    (64) masmenAsig -> . ID MASEQ ID
    (65) masmenAsig -> . ID MENOSEQ ID
    (66) masmenAsig -> . asig
    (34) valores -> . eMat
    (35) valores -> . expBool
    (36) valores -> . expString
    (37) valores -> . varYVals
    (38) valores -> . funcReturn
    (39) valores -> . reg
    (40) valores -> . ID . ID
    (67) asig -> . ID = asig
    (68) asig -> . ID = ID
    (76) eMat -> . eMat + p
    (77) eMat -> . eMat - p
    (78) eMat -> . p
    (98) expBool -> . or ? expBool : expBool
    (99) expBool -> . or
    (94) expString -> . expString + STRING
    (95) expString -> . STRING
    (96) expString -> . varYVals
    (97) expString -> . funcString
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (20) funcReturn -> . funcInt
    (21) funcReturn -> . funcString
    (22) funcReturn -> . funcBool
    (46) reg -> . { campos }
    (79) p -> . p * exp
    (80) p -> . p / exp
    (81) p -> . p % exp
    (82) p -> . exp
    (100) or -> . or OR and
    (101) or -> . and
    (25) funcString -> . CAPITALIZAR ( expString )
    (43) vecVal -> . ID m
    (23) funcInt -> . MULTIESCALAR ( vec , eMat , param )
    (24) funcInt -> . LENGTH ( vec )
    (26) funcBool -> . COLINEALES ( vec , vec )
    (83) exp -> . exp ^ iSing
    (84) exp -> . iSing
    (102) and -> . and AND eq
    (103) and -> . eq
    (85) iSing -> . - paren
    (86) iSing -> . + paren
    (87) iSing -> . paren
    (104) eq -> . eq EQEQ tBool
    (105) eq -> . eq DISTINTO tBool
    (106) eq -> . mayor
    (88) paren -> . ( eMat )
    (89) paren -> . INT
    (90) paren -> . varYVals
    (91) paren -> . FLOAT
    (92) paren -> . varsOps
    (93) paren -> . funcInt
    (107) mayor -> . tCompare > tCompare
    (108) mayor -> . menor
    (49) varsOps -> . MENOSMENOS varYVals
    (50) varsOps -> . MASMAS varYVals
    (51) varsOps -> . varYVals MASMAS
    (52) varsOps -> . varYVals MENOSMENOS
    (117) tCompare -> . eMat
    (118) tCompare -> . varsOps
    (119) tCompare -> . varYVals
    (109) menor -> . tCompare < tCompare
    (110) menor -> . not
    (111) not -> . NOT not
    (112) not -> . tBool
    (113) tBool -> . ( expBool )
    (114) tBool -> . BOOL
    (115) tBool -> . varYVals
    (116) tBool -> . funcBool

    ID              shift and go to state 120
    STRING          shift and go to state 97
    {               shift and go to state 103
    CAPITALIZAR     shift and go to state 25
    MULTIESCALAR    shift and go to state 22
    LENGTH          shift and go to state 27
    COLINEALES      shift and go to state 14
    -               shift and go to state 75
    +               shift and go to state 74
    (               shift and go to state 94
    INT             shift and go to state 81
    FLOAT           shift and go to state 82
    MENOSMENOS      shift and go to state 32
    MASMAS          shift and go to state 29
    NOT             shift and go to state 87
    BOOL            shift and go to state 76

    and                            shift and go to state 66
    funcBool                       shift and go to state 91
    funcInt                        shift and go to state 92
    menor                          shift and go to state 69
    eq                             shift and go to state 70
    vecVal                         shift and go to state 9
    eMat                           shift and go to state 93
    asig                           shift and go to state 26
    mayor                          shift and go to state 71
    masmenAsig                     shift and go to state 119
    paren                          shift and go to state 79
    varsOps                        shift and go to state 96
    reg                            shift and go to state 95
    expString                      shift and go to state 98
    tCompare                       shift and go to state 78
    not                            shift and go to state 80
    funcString                     shift and go to state 100
    funcReturn                     shift and go to state 101
    valores                        shift and go to state 121
    p                              shift and go to state 84
    iSing                          shift and go to state 77
    exp                            shift and go to state 86
    tBool                          shift and go to state 88
    varYVals                       shift and go to state 104
    or                             shift and go to state 83
    expBool                        shift and go to state 105

state 47

    (43) vecVal -> ID m .

    MASMAS          reduce using rule 43 (vecVal -> ID m .)
    MENOSMENOS      reduce using rule 43 (vecVal -> ID m .)
    ^               reduce using rule 43 (vecVal -> ID m .)
    *               reduce using rule 43 (vecVal -> ID m .)
    /               reduce using rule 43 (vecVal -> ID m .)
    %               reduce using rule 43 (vecVal -> ID m .)
    +               reduce using rule 43 (vecVal -> ID m .)
    -               reduce using rule 43 (vecVal -> ID m .)
    >               reduce using rule 43 (vecVal -> ID m .)
    <               reduce using rule 43 (vecVal -> ID m .)
    )               reduce using rule 43 (vecVal -> ID m .)
    ;               reduce using rule 43 (vecVal -> ID m .)
    }               reduce using rule 43 (vecVal -> ID m .)
    ,               reduce using rule 43 (vecVal -> ID m .)
    ]               reduce using rule 43 (vecVal -> ID m .)
    EQEQ            reduce using rule 43 (vecVal -> ID m .)
    DISTINTO        reduce using rule 43 (vecVal -> ID m .)
    AND             reduce using rule 43 (vecVal -> ID m .)
    ?               reduce using rule 43 (vecVal -> ID m .)
    OR              reduce using rule 43 (vecVal -> ID m .)
    :               reduce using rule 43 (vecVal -> ID m .)


state 48

    (44) m -> [ . INT ]
    (45) m -> [ . INT ] m

    INT             shift and go to state 122


state 49

    (69) finVarAsig -> ID = . valores
    (67) asig -> ID = . asig
    (68) asig -> ID = . ID
    (34) valores -> . eMat
    (35) valores -> . expBool
    (36) valores -> . expString
    (37) valores -> . varYVals
    (38) valores -> . funcReturn
    (39) valores -> . reg
    (40) valores -> . ID . ID
    (67) asig -> . ID = asig
    (68) asig -> . ID = ID
    (76) eMat -> . eMat + p
    (77) eMat -> . eMat - p
    (78) eMat -> . p
    (98) expBool -> . or ? expBool : expBool
    (99) expBool -> . or
    (94) expString -> . expString + STRING
    (95) expString -> . STRING
    (96) expString -> . varYVals
    (97) expString -> . funcString
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (20) funcReturn -> . funcInt
    (21) funcReturn -> . funcString
    (22) funcReturn -> . funcBool
    (46) reg -> . { campos }
    (79) p -> . p * exp
    (80) p -> . p / exp
    (81) p -> . p % exp
    (82) p -> . exp
    (100) or -> . or OR and
    (101) or -> . and
    (25) funcString -> . CAPITALIZAR ( expString )
    (43) vecVal -> . ID m
    (23) funcInt -> . MULTIESCALAR ( vec , eMat , param )
    (24) funcInt -> . LENGTH ( vec )
    (26) funcBool -> . COLINEALES ( vec , vec )
    (83) exp -> . exp ^ iSing
    (84) exp -> . iSing
    (102) and -> . and AND eq
    (103) and -> . eq
    (85) iSing -> . - paren
    (86) iSing -> . + paren
    (87) iSing -> . paren
    (104) eq -> . eq EQEQ tBool
    (105) eq -> . eq DISTINTO tBool
    (106) eq -> . mayor
    (88) paren -> . ( eMat )
    (89) paren -> . INT
    (90) paren -> . varYVals
    (91) paren -> . FLOAT
    (92) paren -> . varsOps
    (93) paren -> . funcInt
    (107) mayor -> . tCompare > tCompare
    (108) mayor -> . menor
    (49) varsOps -> . MENOSMENOS varYVals
    (50) varsOps -> . MASMAS varYVals
    (51) varsOps -> . varYVals MASMAS
    (52) varsOps -> . varYVals MENOSMENOS
    (117) tCompare -> . eMat
    (118) tCompare -> . varsOps
    (119) tCompare -> . varYVals
    (109) menor -> . tCompare < tCompare
    (110) menor -> . not
    (111) not -> . NOT not
    (112) not -> . tBool
    (113) tBool -> . ( expBool )
    (114) tBool -> . BOOL
    (115) tBool -> . varYVals
    (116) tBool -> . funcBool

    ID              shift and go to state 124
    STRING          shift and go to state 97
    {               shift and go to state 103
    CAPITALIZAR     shift and go to state 25
    MULTIESCALAR    shift and go to state 22
    LENGTH          shift and go to state 27
    COLINEALES      shift and go to state 14
    -               shift and go to state 75
    +               shift and go to state 74
    (               shift and go to state 94
    INT             shift and go to state 81
    FLOAT           shift and go to state 82
    MENOSMENOS      shift and go to state 32
    MASMAS          shift and go to state 29
    NOT             shift and go to state 87
    BOOL            shift and go to state 76

    and                            shift and go to state 66
    funcBool                       shift and go to state 91
    funcInt                        shift and go to state 92
    menor                          shift and go to state 69
    eq                             shift and go to state 70
    vecVal                         shift and go to state 9
    eMat                           shift and go to state 93
    asig                           shift and go to state 123
    mayor                          shift and go to state 71
    paren                          shift and go to state 79
    reg                            shift and go to state 95
    varsOps                        shift and go to state 96
    expString                      shift and go to state 98
    tCompare                       shift and go to state 78
    not                            shift and go to state 80
    funcString                     shift and go to state 100
    funcReturn                     shift and go to state 101
    valores                        shift and go to state 125
    p                              shift and go to state 84
    iSing                          shift and go to state 77
    exp                            shift and go to state 86
    tBool                          shift and go to state 88
    varYVals                       shift and go to state 104
    or                             shift and go to state 83
    expBool                        shift and go to state 105

state 50

    (74) finVarAsig -> ID DIVEQ . valores
    (75) finVarAsig -> ID DIVEQ . ID
    (34) valores -> . eMat
    (35) valores -> . expBool
    (36) valores -> . expString
    (37) valores -> . varYVals
    (38) valores -> . funcReturn
    (39) valores -> . reg
    (40) valores -> . ID . ID
    (76) eMat -> . eMat + p
    (77) eMat -> . eMat - p
    (78) eMat -> . p
    (98) expBool -> . or ? expBool : expBool
    (99) expBool -> . or
    (94) expString -> . expString + STRING
    (95) expString -> . STRING
    (96) expString -> . varYVals
    (97) expString -> . funcString
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (20) funcReturn -> . funcInt
    (21) funcReturn -> . funcString
    (22) funcReturn -> . funcBool
    (46) reg -> . { campos }
    (79) p -> . p * exp
    (80) p -> . p / exp
    (81) p -> . p % exp
    (82) p -> . exp
    (100) or -> . or OR and
    (101) or -> . and
    (25) funcString -> . CAPITALIZAR ( expString )
    (43) vecVal -> . ID m
    (23) funcInt -> . MULTIESCALAR ( vec , eMat , param )
    (24) funcInt -> . LENGTH ( vec )
    (26) funcBool -> . COLINEALES ( vec , vec )
    (83) exp -> . exp ^ iSing
    (84) exp -> . iSing
    (102) and -> . and AND eq
    (103) and -> . eq
    (85) iSing -> . - paren
    (86) iSing -> . + paren
    (87) iSing -> . paren
    (104) eq -> . eq EQEQ tBool
    (105) eq -> . eq DISTINTO tBool
    (106) eq -> . mayor
    (88) paren -> . ( eMat )
    (89) paren -> . INT
    (90) paren -> . varYVals
    (91) paren -> . FLOAT
    (92) paren -> . varsOps
    (93) paren -> . funcInt
    (107) mayor -> . tCompare > tCompare
    (108) mayor -> . menor
    (49) varsOps -> . MENOSMENOS varYVals
    (50) varsOps -> . MASMAS varYVals
    (51) varsOps -> . varYVals MASMAS
    (52) varsOps -> . varYVals MENOSMENOS
    (117) tCompare -> . eMat
    (118) tCompare -> . varsOps
    (119) tCompare -> . varYVals
    (109) menor -> . tCompare < tCompare
    (110) menor -> . not
    (111) not -> . NOT not
    (112) not -> . tBool
    (113) tBool -> . ( expBool )
    (114) tBool -> . BOOL
    (115) tBool -> . varYVals
    (116) tBool -> . funcBool

    ID              shift and go to state 126
    STRING          shift and go to state 97
    {               shift and go to state 103
    CAPITALIZAR     shift and go to state 25
    MULTIESCALAR    shift and go to state 22
    LENGTH          shift and go to state 27
    COLINEALES      shift and go to state 14
    -               shift and go to state 75
    +               shift and go to state 74
    (               shift and go to state 94
    INT             shift and go to state 81
    FLOAT           shift and go to state 82
    MENOSMENOS      shift and go to state 32
    MASMAS          shift and go to state 29
    NOT             shift and go to state 87
    BOOL            shift and go to state 76

    and                            shift and go to state 66
    funcBool                       shift and go to state 91
    funcInt                        shift and go to state 92
    menor                          shift and go to state 69
    eq                             shift and go to state 70
    vecVal                         shift and go to state 9
    eMat                           shift and go to state 93
    mayor                          shift and go to state 71
    paren                          shift and go to state 79
    reg                            shift and go to state 95
    varsOps                        shift and go to state 96
    expString                      shift and go to state 98
    tCompare                       shift and go to state 78
    not                            shift and go to state 80
    funcString                     shift and go to state 100
    funcReturn                     shift and go to state 101
    valores                        shift and go to state 127
    p                              shift and go to state 84
    iSing                          shift and go to state 77
    exp                            shift and go to state 86
    tBool                          shift and go to state 88
    varYVals                       shift and go to state 104
    or                             shift and go to state 83
    expBool                        shift and go to state 105

state 51

    (53) varAsig -> ID MULEQ . varAsig
    (72) finVarAsig -> ID MULEQ . valores
    (73) finVarAsig -> ID MULEQ . ID
    (53) varAsig -> . ID MULEQ varAsig
    (54) varAsig -> . masmenAsig MULEQ varAsig
    (55) varAsig -> . masmenAsig MULEQ ID
    (56) varAsig -> . masmenAsig MULEQ valores
    (57) varAsig -> . masmenAsig DIVEQ varAsig
    (58) varAsig -> . masmenAsig DIVEQ ID
    (59) varAsig -> . masmenAsig DIVEQ valores
    (60) varAsig -> . finVarAsig
    (61) varAsig -> . masmenAsig
    (34) valores -> . eMat
    (35) valores -> . expBool
    (36) valores -> . expString
    (37) valores -> . varYVals
    (38) valores -> . funcReturn
    (39) valores -> . reg
    (40) valores -> . ID . ID
    (62) masmenAsig -> . ID MASEQ masmenAsig
    (63) masmenAsig -> . ID MENOSEQ masmenAsig
    (64) masmenAsig -> . ID MASEQ ID
    (65) masmenAsig -> . ID MENOSEQ ID
    (66) masmenAsig -> . asig
    (69) finVarAsig -> . ID = valores
    (70) finVarAsig -> . ID MASEQ valores
    (71) finVarAsig -> . ID MENOSEQ valores
    (72) finVarAsig -> . ID MULEQ valores
    (73) finVarAsig -> . ID MULEQ ID
    (74) finVarAsig -> . ID DIVEQ valores
    (75) finVarAsig -> . ID DIVEQ ID
    (76) eMat -> . eMat + p
    (77) eMat -> . eMat - p
    (78) eMat -> . p
    (98) expBool -> . or ? expBool : expBool
    (99) expBool -> . or
    (94) expString -> . expString + STRING
    (95) expString -> . STRING
    (96) expString -> . varYVals
    (97) expString -> . funcString
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (20) funcReturn -> . funcInt
    (21) funcReturn -> . funcString
    (22) funcReturn -> . funcBool
    (46) reg -> . { campos }
    (67) asig -> . ID = asig
    (68) asig -> . ID = ID
    (79) p -> . p * exp
    (80) p -> . p / exp
    (81) p -> . p % exp
    (82) p -> . exp
    (100) or -> . or OR and
    (101) or -> . and
    (25) funcString -> . CAPITALIZAR ( expString )
    (43) vecVal -> . ID m
    (23) funcInt -> . MULTIESCALAR ( vec , eMat , param )
    (24) funcInt -> . LENGTH ( vec )
    (26) funcBool -> . COLINEALES ( vec , vec )
    (83) exp -> . exp ^ iSing
    (84) exp -> . iSing
    (102) and -> . and AND eq
    (103) and -> . eq
    (85) iSing -> . - paren
    (86) iSing -> . + paren
    (87) iSing -> . paren
    (104) eq -> . eq EQEQ tBool
    (105) eq -> . eq DISTINTO tBool
    (106) eq -> . mayor
    (88) paren -> . ( eMat )
    (89) paren -> . INT
    (90) paren -> . varYVals
    (91) paren -> . FLOAT
    (92) paren -> . varsOps
    (93) paren -> . funcInt
    (107) mayor -> . tCompare > tCompare
    (108) mayor -> . menor
    (49) varsOps -> . MENOSMENOS varYVals
    (50) varsOps -> . MASMAS varYVals
    (51) varsOps -> . varYVals MASMAS
    (52) varsOps -> . varYVals MENOSMENOS
    (117) tCompare -> . eMat
    (118) tCompare -> . varsOps
    (119) tCompare -> . varYVals
    (109) menor -> . tCompare < tCompare
    (110) menor -> . not
    (111) not -> . NOT not
    (112) not -> . tBool
    (113) tBool -> . ( expBool )
    (114) tBool -> . BOOL
    (115) tBool -> . varYVals
    (116) tBool -> . funcBool

    ID              shift and go to state 128
    STRING          shift and go to state 97
    {               shift and go to state 103
    CAPITALIZAR     shift and go to state 25
    MULTIESCALAR    shift and go to state 22
    LENGTH          shift and go to state 27
    COLINEALES      shift and go to state 14
    -               shift and go to state 75
    +               shift and go to state 74
    (               shift and go to state 94
    INT             shift and go to state 81
    FLOAT           shift and go to state 82
    MENOSMENOS      shift and go to state 32
    MASMAS          shift and go to state 29
    NOT             shift and go to state 87
    BOOL            shift and go to state 76

    and                            shift and go to state 66
    funcBool                       shift and go to state 91
    finVarAsig                     shift and go to state 24
    funcInt                        shift and go to state 92
    menor                          shift and go to state 69
    eq                             shift and go to state 70
    vecVal                         shift and go to state 9
    eMat                           shift and go to state 93
    asig                           shift and go to state 26
    mayor                          shift and go to state 71
    masmenAsig                     shift and go to state 12
    paren                          shift and go to state 79
    varsOps                        shift and go to state 96
    reg                            shift and go to state 95
    expString                      shift and go to state 98
    tCompare                       shift and go to state 78
    not                            shift and go to state 80
    varAsig                        shift and go to state 129
    funcString                     shift and go to state 100
    funcReturn                     shift and go to state 101
    valores                        shift and go to state 130
    p                              shift and go to state 84
    iSing                          shift and go to state 77
    exp                            shift and go to state 86
    tBool                          shift and go to state 88
    varYVals                       shift and go to state 104
    or                             shift and go to state 83
    expBool                        shift and go to state 105

state 52

    (13) if -> IF ( . expBool ) bloque else
    (98) expBool -> . or ? expBool : expBool
    (99) expBool -> . or
    (100) or -> . or OR and
    (101) or -> . and
    (102) and -> . and AND eq
    (103) and -> . eq
    (104) eq -> . eq EQEQ tBool
    (105) eq -> . eq DISTINTO tBool
    (106) eq -> . mayor
    (107) mayor -> . tCompare > tCompare
    (108) mayor -> . menor
    (117) tCompare -> . eMat
    (118) tCompare -> . varsOps
    (119) tCompare -> . varYVals
    (109) menor -> . tCompare < tCompare
    (110) menor -> . not
    (76) eMat -> . eMat + p
    (77) eMat -> . eMat - p
    (78) eMat -> . p
    (49) varsOps -> . MENOSMENOS varYVals
    (50) varsOps -> . MASMAS varYVals
    (51) varsOps -> . varYVals MASMAS
    (52) varsOps -> . varYVals MENOSMENOS
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (111) not -> . NOT not
    (112) not -> . tBool
    (79) p -> . p * exp
    (80) p -> . p / exp
    (81) p -> . p % exp
    (82) p -> . exp
    (43) vecVal -> . ID m
    (113) tBool -> . ( expBool )
    (114) tBool -> . BOOL
    (115) tBool -> . varYVals
    (116) tBool -> . funcBool
    (83) exp -> . exp ^ iSing
    (84) exp -> . iSing
    (26) funcBool -> . COLINEALES ( vec , vec )
    (85) iSing -> . - paren
    (86) iSing -> . + paren
    (87) iSing -> . paren
    (88) paren -> . ( eMat )
    (89) paren -> . INT
    (90) paren -> . varYVals
    (91) paren -> . FLOAT
    (92) paren -> . varsOps
    (93) paren -> . funcInt
    (23) funcInt -> . MULTIESCALAR ( vec , eMat , param )
    (24) funcInt -> . LENGTH ( vec )

    MENOSMENOS      shift and go to state 32
    MASMAS          shift and go to state 29
    ID              shift and go to state 58
    NOT             shift and go to state 87
    (               shift and go to state 73
    BOOL            shift and go to state 76
    COLINEALES      shift and go to state 14
    -               shift and go to state 75
    +               shift and go to state 74
    INT             shift and go to state 81
    FLOAT           shift and go to state 82
    MULTIESCALAR    shift and go to state 22
    LENGTH          shift and go to state 27

    and                            shift and go to state 66
    funcBool                       shift and go to state 67
    funcInt                        shift and go to state 68
    menor                          shift and go to state 69
    eq                             shift and go to state 70
    mayor                          shift and go to state 71
    eMat                           shift and go to state 72
    vecVal                         shift and go to state 9
    paren                          shift and go to state 79
    varsOps                        shift and go to state 85
    tCompare                       shift and go to state 78
    not                            shift and go to state 80
    p                              shift and go to state 84
    iSing                          shift and go to state 77
    exp                            shift and go to state 86
    tBool                          shift and go to state 88
    varYVals                       shift and go to state 89
    or                             shift and go to state 83
    expBool                        shift and go to state 131

state 53

    (6) sentencia -> varAsig ; .

    $end            reduce using rule 6 (sentencia -> varAsig ; .)
    ;               reduce using rule 6 (sentencia -> varAsig ; .)
    }               reduce using rule 6 (sentencia -> varAsig ; .)


state 54

    (23) funcInt -> MULTIESCALAR ( . vec , eMat , param )
    (31) vec -> . [ elem ]

    [               shift and go to state 113

    vec                            shift and go to state 132

state 55

    (25) funcString -> CAPITALIZAR ( . expString )
    (94) expString -> . expString + STRING
    (95) expString -> . STRING
    (96) expString -> . varYVals
    (97) expString -> . funcString
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (25) funcString -> . CAPITALIZAR ( expString )
    (43) vecVal -> . ID m

    STRING          shift and go to state 97
    ID              shift and go to state 58
    CAPITALIZAR     shift and go to state 25

    funcString                     shift and go to state 134
    varYVals                       shift and go to state 135
    vecVal                         shift and go to state 9
    expString                      shift and go to state 133

state 56

    (24) funcInt -> LENGTH ( . vec )
    (31) vec -> . [ elem ]

    [               shift and go to state 113

    vec                            shift and go to state 136

state 57

    (50) varsOps -> MASMAS varYVals .

    ^               reduce using rule 50 (varsOps -> MASMAS varYVals .)
    *               reduce using rule 50 (varsOps -> MASMAS varYVals .)
    /               reduce using rule 50 (varsOps -> MASMAS varYVals .)
    %               reduce using rule 50 (varsOps -> MASMAS varYVals .)
    +               reduce using rule 50 (varsOps -> MASMAS varYVals .)
    -               reduce using rule 50 (varsOps -> MASMAS varYVals .)
    >               reduce using rule 50 (varsOps -> MASMAS varYVals .)
    <               reduce using rule 50 (varsOps -> MASMAS varYVals .)
    )               reduce using rule 50 (varsOps -> MASMAS varYVals .)
    ;               reduce using rule 50 (varsOps -> MASMAS varYVals .)
    }               reduce using rule 50 (varsOps -> MASMAS varYVals .)
    ,               reduce using rule 50 (varsOps -> MASMAS varYVals .)
    ]               reduce using rule 50 (varsOps -> MASMAS varYVals .)
    EQEQ            reduce using rule 50 (varsOps -> MASMAS varYVals .)
    DISTINTO        reduce using rule 50 (varsOps -> MASMAS varYVals .)
    AND             reduce using rule 50 (varsOps -> MASMAS varYVals .)
    ?               reduce using rule 50 (varsOps -> MASMAS varYVals .)
    OR              reduce using rule 50 (varsOps -> MASMAS varYVals .)
    :               reduce using rule 50 (varsOps -> MASMAS varYVals .)


state 58

    (41) varYVals -> ID .
    (43) vecVal -> ID . m
    (44) m -> . [ INT ]
    (45) m -> . [ INT ] m

    MASMAS          reduce using rule 41 (varYVals -> ID .)
    MENOSMENOS      reduce using rule 41 (varYVals -> ID .)
    >               reduce using rule 41 (varYVals -> ID .)
    <               reduce using rule 41 (varYVals -> ID .)
    EQEQ            reduce using rule 41 (varYVals -> ID .)
    DISTINTO        reduce using rule 41 (varYVals -> ID .)
    AND             reduce using rule 41 (varYVals -> ID .)
    ?               reduce using rule 41 (varYVals -> ID .)
    OR              reduce using rule 41 (varYVals -> ID .)
    )               reduce using rule 41 (varYVals -> ID .)
    ^               reduce using rule 41 (varYVals -> ID .)
    *               reduce using rule 41 (varYVals -> ID .)
    /               reduce using rule 41 (varYVals -> ID .)
    %               reduce using rule 41 (varYVals -> ID .)
    +               reduce using rule 41 (varYVals -> ID .)
    -               reduce using rule 41 (varYVals -> ID .)
    ,               reduce using rule 41 (varYVals -> ID .)
    ;               reduce using rule 41 (varYVals -> ID .)
    }               reduce using rule 41 (varYVals -> ID .)
    ]               reduce using rule 41 (varYVals -> ID .)
    :               reduce using rule 41 (varYVals -> ID .)
    [               shift and go to state 48

    m                              shift and go to state 47

state 59

    (4) sentencia -> varsOps ; .

    $end            reduce using rule 4 (sentencia -> varsOps ; .)
    ;               reduce using rule 4 (sentencia -> varsOps ; .)
    }               reduce using rule 4 (sentencia -> varsOps ; .)


state 60

    (51) varsOps -> varYVals MASMAS .

    ^               reduce using rule 51 (varsOps -> varYVals MASMAS .)
    *               reduce using rule 51 (varsOps -> varYVals MASMAS .)
    /               reduce using rule 51 (varsOps -> varYVals MASMAS .)
    %               reduce using rule 51 (varsOps -> varYVals MASMAS .)
    +               reduce using rule 51 (varsOps -> varYVals MASMAS .)
    -               reduce using rule 51 (varsOps -> varYVals MASMAS .)
    >               reduce using rule 51 (varsOps -> varYVals MASMAS .)
    <               reduce using rule 51 (varsOps -> varYVals MASMAS .)
    )               reduce using rule 51 (varsOps -> varYVals MASMAS .)
    ;               reduce using rule 51 (varsOps -> varYVals MASMAS .)
    }               reduce using rule 51 (varsOps -> varYVals MASMAS .)
    ,               reduce using rule 51 (varsOps -> varYVals MASMAS .)
    ]               reduce using rule 51 (varsOps -> varYVals MASMAS .)
    EQEQ            reduce using rule 51 (varsOps -> varYVals MASMAS .)
    DISTINTO        reduce using rule 51 (varsOps -> varYVals MASMAS .)
    AND             reduce using rule 51 (varsOps -> varYVals MASMAS .)
    ?               reduce using rule 51 (varsOps -> varYVals MASMAS .)
    OR              reduce using rule 51 (varsOps -> varYVals MASMAS .)
    :               reduce using rule 51 (varsOps -> varYVals MASMAS .)


state 61

    (52) varsOps -> varYVals MENOSMENOS .

    ^               reduce using rule 52 (varsOps -> varYVals MENOSMENOS .)
    *               reduce using rule 52 (varsOps -> varYVals MENOSMENOS .)
    /               reduce using rule 52 (varsOps -> varYVals MENOSMENOS .)
    %               reduce using rule 52 (varsOps -> varYVals MENOSMENOS .)
    +               reduce using rule 52 (varsOps -> varYVals MENOSMENOS .)
    -               reduce using rule 52 (varsOps -> varYVals MENOSMENOS .)
    >               reduce using rule 52 (varsOps -> varYVals MENOSMENOS .)
    <               reduce using rule 52 (varsOps -> varYVals MENOSMENOS .)
    )               reduce using rule 52 (varsOps -> varYVals MENOSMENOS .)
    ;               reduce using rule 52 (varsOps -> varYVals MENOSMENOS .)
    }               reduce using rule 52 (varsOps -> varYVals MENOSMENOS .)
    ,               reduce using rule 52 (varsOps -> varYVals MENOSMENOS .)
    ]               reduce using rule 52 (varsOps -> varYVals MENOSMENOS .)
    EQEQ            reduce using rule 52 (varsOps -> varYVals MENOSMENOS .)
    DISTINTO        reduce using rule 52 (varsOps -> varYVals MENOSMENOS .)
    AND             reduce using rule 52 (varsOps -> varYVals MENOSMENOS .)
    ?               reduce using rule 52 (varsOps -> varYVals MENOSMENOS .)
    OR              reduce using rule 52 (varsOps -> varYVals MENOSMENOS .)
    :               reduce using rule 52 (varsOps -> varYVals MENOSMENOS .)


state 62

    (49) varsOps -> MENOSMENOS varYVals .

    ^               reduce using rule 49 (varsOps -> MENOSMENOS varYVals .)
    *               reduce using rule 49 (varsOps -> MENOSMENOS varYVals .)
    /               reduce using rule 49 (varsOps -> MENOSMENOS varYVals .)
    %               reduce using rule 49 (varsOps -> MENOSMENOS varYVals .)
    +               reduce using rule 49 (varsOps -> MENOSMENOS varYVals .)
    -               reduce using rule 49 (varsOps -> MENOSMENOS varYVals .)
    >               reduce using rule 49 (varsOps -> MENOSMENOS varYVals .)
    <               reduce using rule 49 (varsOps -> MENOSMENOS varYVals .)
    )               reduce using rule 49 (varsOps -> MENOSMENOS varYVals .)
    ;               reduce using rule 49 (varsOps -> MENOSMENOS varYVals .)
    }               reduce using rule 49 (varsOps -> MENOSMENOS varYVals .)
    ,               reduce using rule 49 (varsOps -> MENOSMENOS varYVals .)
    ]               reduce using rule 49 (varsOps -> MENOSMENOS varYVals .)
    EQEQ            reduce using rule 49 (varsOps -> MENOSMENOS varYVals .)
    DISTINTO        reduce using rule 49 (varsOps -> MENOSMENOS varYVals .)
    AND             reduce using rule 49 (varsOps -> MENOSMENOS varYVals .)
    ?               reduce using rule 49 (varsOps -> MENOSMENOS varYVals .)
    OR              reduce using rule 49 (varsOps -> MENOSMENOS varYVals .)
    :               reduce using rule 49 (varsOps -> MENOSMENOS varYVals .)


state 63

    (11) loop -> DO bloque WHILE . ( expBool ) ;

    (               shift and go to state 137


state 64

    (16) bloque -> sentencia ; .

    RETURN          reduce using rule 16 (bloque -> sentencia ; .)
    MENOSMENOS      reduce using rule 16 (bloque -> sentencia ; .)
    MASMAS          reduce using rule 16 (bloque -> sentencia ; .)
    ID              reduce using rule 16 (bloque -> sentencia ; .)
    IF              reduce using rule 16 (bloque -> sentencia ; .)
    WHILE           reduce using rule 16 (bloque -> sentencia ; .)
    DO              reduce using rule 16 (bloque -> sentencia ; .)
    FOR             reduce using rule 16 (bloque -> sentencia ; .)
    PRINT           reduce using rule 16 (bloque -> sentencia ; .)
    MULTIESCALAR    reduce using rule 16 (bloque -> sentencia ; .)
    LENGTH          reduce using rule 16 (bloque -> sentencia ; .)
    CAPITALIZAR     reduce using rule 16 (bloque -> sentencia ; .)
    COLINEALES      reduce using rule 16 (bloque -> sentencia ; .)
    $end            reduce using rule 16 (bloque -> sentencia ; .)
    }               reduce using rule 16 (bloque -> sentencia ; .)
    ELSE            reduce using rule 16 (bloque -> sentencia ; .)


state 65

    (17) bloque -> { g . }

    }               shift and go to state 138


state 66

    (101) or -> and .
    (102) and -> and . AND eq

    ?               reduce using rule 101 (or -> and .)
    OR              reduce using rule 101 (or -> and .)
    )               reduce using rule 101 (or -> and .)
    ;               reduce using rule 101 (or -> and .)
    ,               reduce using rule 101 (or -> and .)
    ]               reduce using rule 101 (or -> and .)
    :               reduce using rule 101 (or -> and .)
    }               reduce using rule 101 (or -> and .)
    AND             shift and go to state 139


state 67

    (116) tBool -> funcBool .

    EQEQ            reduce using rule 116 (tBool -> funcBool .)
    DISTINTO        reduce using rule 116 (tBool -> funcBool .)
    AND             reduce using rule 116 (tBool -> funcBool .)
    ?               reduce using rule 116 (tBool -> funcBool .)
    OR              reduce using rule 116 (tBool -> funcBool .)
    )               reduce using rule 116 (tBool -> funcBool .)
    ;               reduce using rule 116 (tBool -> funcBool .)
    }               reduce using rule 116 (tBool -> funcBool .)
    ,               reduce using rule 116 (tBool -> funcBool .)
    ]               reduce using rule 116 (tBool -> funcBool .)
    :               reduce using rule 116 (tBool -> funcBool .)


state 68

    (93) paren -> funcInt .

    ^               reduce using rule 93 (paren -> funcInt .)
    *               reduce using rule 93 (paren -> funcInt .)
    /               reduce using rule 93 (paren -> funcInt .)
    %               reduce using rule 93 (paren -> funcInt .)
    +               reduce using rule 93 (paren -> funcInt .)
    -               reduce using rule 93 (paren -> funcInt .)
    >               reduce using rule 93 (paren -> funcInt .)
    <               reduce using rule 93 (paren -> funcInt .)
    )               reduce using rule 93 (paren -> funcInt .)
    ;               reduce using rule 93 (paren -> funcInt .)
    }               reduce using rule 93 (paren -> funcInt .)
    ,               reduce using rule 93 (paren -> funcInt .)
    ]               reduce using rule 93 (paren -> funcInt .)
    EQEQ            reduce using rule 93 (paren -> funcInt .)
    DISTINTO        reduce using rule 93 (paren -> funcInt .)
    AND             reduce using rule 93 (paren -> funcInt .)
    ?               reduce using rule 93 (paren -> funcInt .)
    OR              reduce using rule 93 (paren -> funcInt .)
    :               reduce using rule 93 (paren -> funcInt .)


state 69

    (108) mayor -> menor .

    EQEQ            reduce using rule 108 (mayor -> menor .)
    DISTINTO        reduce using rule 108 (mayor -> menor .)
    AND             reduce using rule 108 (mayor -> menor .)
    ?               reduce using rule 108 (mayor -> menor .)
    OR              reduce using rule 108 (mayor -> menor .)
    ;               reduce using rule 108 (mayor -> menor .)
    :               reduce using rule 108 (mayor -> menor .)
    )               reduce using rule 108 (mayor -> menor .)
    }               reduce using rule 108 (mayor -> menor .)
    ,               reduce using rule 108 (mayor -> menor .)
    ]               reduce using rule 108 (mayor -> menor .)


state 70

    (103) and -> eq .
    (104) eq -> eq . EQEQ tBool
    (105) eq -> eq . DISTINTO tBool

    AND             reduce using rule 103 (and -> eq .)
    ?               reduce using rule 103 (and -> eq .)
    OR              reduce using rule 103 (and -> eq .)
    }               reduce using rule 103 (and -> eq .)
    ,               reduce using rule 103 (and -> eq .)
    ]               reduce using rule 103 (and -> eq .)
    )               reduce using rule 103 (and -> eq .)
    ;               reduce using rule 103 (and -> eq .)
    :               reduce using rule 103 (and -> eq .)
    EQEQ            shift and go to state 140
    DISTINTO        shift and go to state 141


state 71

    (106) eq -> mayor .

    EQEQ            reduce using rule 106 (eq -> mayor .)
    DISTINTO        reduce using rule 106 (eq -> mayor .)
    AND             reduce using rule 106 (eq -> mayor .)
    ?               reduce using rule 106 (eq -> mayor .)
    OR              reduce using rule 106 (eq -> mayor .)
    )               reduce using rule 106 (eq -> mayor .)
    }               reduce using rule 106 (eq -> mayor .)
    ;               reduce using rule 106 (eq -> mayor .)
    ,               reduce using rule 106 (eq -> mayor .)
    ]               reduce using rule 106 (eq -> mayor .)
    :               reduce using rule 106 (eq -> mayor .)


state 72

    (117) tCompare -> eMat .
    (76) eMat -> eMat . + p
    (77) eMat -> eMat . - p

    >               reduce using rule 117 (tCompare -> eMat .)
    <               reduce using rule 117 (tCompare -> eMat .)
    EQEQ            reduce using rule 117 (tCompare -> eMat .)
    DISTINTO        reduce using rule 117 (tCompare -> eMat .)
    AND             reduce using rule 117 (tCompare -> eMat .)
    ?               reduce using rule 117 (tCompare -> eMat .)
    OR              reduce using rule 117 (tCompare -> eMat .)
    )               reduce using rule 117 (tCompare -> eMat .)
    ;               reduce using rule 117 (tCompare -> eMat .)
    }               reduce using rule 117 (tCompare -> eMat .)
    ,               reduce using rule 117 (tCompare -> eMat .)
    ]               reduce using rule 117 (tCompare -> eMat .)
    :               reduce using rule 117 (tCompare -> eMat .)
    +               shift and go to state 142
    -               shift and go to state 143


state 73

    (113) tBool -> ( . expBool )
    (88) paren -> ( . eMat )
    (98) expBool -> . or ? expBool : expBool
    (99) expBool -> . or
    (76) eMat -> . eMat + p
    (77) eMat -> . eMat - p
    (78) eMat -> . p
    (100) or -> . or OR and
    (101) or -> . and
    (79) p -> . p * exp
    (80) p -> . p / exp
    (81) p -> . p % exp
    (82) p -> . exp
    (102) and -> . and AND eq
    (103) and -> . eq
    (83) exp -> . exp ^ iSing
    (84) exp -> . iSing
    (104) eq -> . eq EQEQ tBool
    (105) eq -> . eq DISTINTO tBool
    (106) eq -> . mayor
    (85) iSing -> . - paren
    (86) iSing -> . + paren
    (87) iSing -> . paren
    (107) mayor -> . tCompare > tCompare
    (108) mayor -> . menor
    (88) paren -> . ( eMat )
    (89) paren -> . INT
    (90) paren -> . varYVals
    (91) paren -> . FLOAT
    (92) paren -> . varsOps
    (93) paren -> . funcInt
    (117) tCompare -> . eMat
    (118) tCompare -> . varsOps
    (119) tCompare -> . varYVals
    (109) menor -> . tCompare < tCompare
    (110) menor -> . not
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (49) varsOps -> . MENOSMENOS varYVals
    (50) varsOps -> . MASMAS varYVals
    (51) varsOps -> . varYVals MASMAS
    (52) varsOps -> . varYVals MENOSMENOS
    (23) funcInt -> . MULTIESCALAR ( vec , eMat , param )
    (24) funcInt -> . LENGTH ( vec )
    (111) not -> . NOT not
    (112) not -> . tBool
    (43) vecVal -> . ID m
    (113) tBool -> . ( expBool )
    (114) tBool -> . BOOL
    (115) tBool -> . varYVals
    (116) tBool -> . funcBool
    (26) funcBool -> . COLINEALES ( vec , vec )

    -               shift and go to state 75
    +               shift and go to state 74
    (               shift and go to state 94
    INT             shift and go to state 81
    FLOAT           shift and go to state 82
    ID              shift and go to state 58
    MENOSMENOS      shift and go to state 32
    MASMAS          shift and go to state 29
    MULTIESCALAR    shift and go to state 22
    LENGTH          shift and go to state 27
    NOT             shift and go to state 87
    BOOL            shift and go to state 76
    COLINEALES      shift and go to state 14

    and                            shift and go to state 66
    funcBool                       shift and go to state 67
    funcInt                        shift and go to state 68
    menor                          shift and go to state 69
    eq                             shift and go to state 70
    mayor                          shift and go to state 71
    eMat                           shift and go to state 144
    vecVal                         shift and go to state 9
    paren                          shift and go to state 79
    varsOps                        shift and go to state 96
    tCompare                       shift and go to state 78
    not                            shift and go to state 80
    p                              shift and go to state 84
    iSing                          shift and go to state 77
    exp                            shift and go to state 86
    tBool                          shift and go to state 88
    varYVals                       shift and go to state 145
    or                             shift and go to state 83
    expBool                        shift and go to state 146

state 74

    (86) iSing -> + . paren
    (88) paren -> . ( eMat )
    (89) paren -> . INT
    (90) paren -> . varYVals
    (91) paren -> . FLOAT
    (92) paren -> . varsOps
    (93) paren -> . funcInt
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (49) varsOps -> . MENOSMENOS varYVals
    (50) varsOps -> . MASMAS varYVals
    (51) varsOps -> . varYVals MASMAS
    (52) varsOps -> . varYVals MENOSMENOS
    (23) funcInt -> . MULTIESCALAR ( vec , eMat , param )
    (24) funcInt -> . LENGTH ( vec )
    (43) vecVal -> . ID m

    (               shift and go to state 147
    INT             shift and go to state 81
    FLOAT           shift and go to state 82
    ID              shift and go to state 58
    MENOSMENOS      shift and go to state 32
    MASMAS          shift and go to state 29
    MULTIESCALAR    shift and go to state 22
    LENGTH          shift and go to state 27

    funcInt                        shift and go to state 68
    varsOps                        shift and go to state 148
    paren                          shift and go to state 149
    varYVals                       shift and go to state 150
    vecVal                         shift and go to state 9

state 75

    (85) iSing -> - . paren
    (88) paren -> . ( eMat )
    (89) paren -> . INT
    (90) paren -> . varYVals
    (91) paren -> . FLOAT
    (92) paren -> . varsOps
    (93) paren -> . funcInt
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (49) varsOps -> . MENOSMENOS varYVals
    (50) varsOps -> . MASMAS varYVals
    (51) varsOps -> . varYVals MASMAS
    (52) varsOps -> . varYVals MENOSMENOS
    (23) funcInt -> . MULTIESCALAR ( vec , eMat , param )
    (24) funcInt -> . LENGTH ( vec )
    (43) vecVal -> . ID m

    (               shift and go to state 147
    INT             shift and go to state 81
    FLOAT           shift and go to state 82
    ID              shift and go to state 58
    MENOSMENOS      shift and go to state 32
    MASMAS          shift and go to state 29
    MULTIESCALAR    shift and go to state 22
    LENGTH          shift and go to state 27

    funcInt                        shift and go to state 68
    varsOps                        shift and go to state 148
    paren                          shift and go to state 151
    varYVals                       shift and go to state 150
    vecVal                         shift and go to state 9

state 76

    (114) tBool -> BOOL .

    EQEQ            reduce using rule 114 (tBool -> BOOL .)
    DISTINTO        reduce using rule 114 (tBool -> BOOL .)
    AND             reduce using rule 114 (tBool -> BOOL .)
    ?               reduce using rule 114 (tBool -> BOOL .)
    OR              reduce using rule 114 (tBool -> BOOL .)
    )               reduce using rule 114 (tBool -> BOOL .)
    ;               reduce using rule 114 (tBool -> BOOL .)
    }               reduce using rule 114 (tBool -> BOOL .)
    ,               reduce using rule 114 (tBool -> BOOL .)
    ]               reduce using rule 114 (tBool -> BOOL .)
    :               reduce using rule 114 (tBool -> BOOL .)


state 77

    (84) exp -> iSing .

    ^               reduce using rule 84 (exp -> iSing .)
    *               reduce using rule 84 (exp -> iSing .)
    /               reduce using rule 84 (exp -> iSing .)
    %               reduce using rule 84 (exp -> iSing .)
    +               reduce using rule 84 (exp -> iSing .)
    -               reduce using rule 84 (exp -> iSing .)
    }               reduce using rule 84 (exp -> iSing .)
    >               reduce using rule 84 (exp -> iSing .)
    <               reduce using rule 84 (exp -> iSing .)
    ;               reduce using rule 84 (exp -> iSing .)
    ,               reduce using rule 84 (exp -> iSing .)
    ]               reduce using rule 84 (exp -> iSing .)
    )               reduce using rule 84 (exp -> iSing .)
    EQEQ            reduce using rule 84 (exp -> iSing .)
    DISTINTO        reduce using rule 84 (exp -> iSing .)
    AND             reduce using rule 84 (exp -> iSing .)
    ?               reduce using rule 84 (exp -> iSing .)
    OR              reduce using rule 84 (exp -> iSing .)
    :               reduce using rule 84 (exp -> iSing .)


state 78

    (107) mayor -> tCompare . > tCompare
    (109) menor -> tCompare . < tCompare

    >               shift and go to state 153
    <               shift and go to state 152


state 79

    (87) iSing -> paren .

    ^               reduce using rule 87 (iSing -> paren .)
    *               reduce using rule 87 (iSing -> paren .)
    /               reduce using rule 87 (iSing -> paren .)
    %               reduce using rule 87 (iSing -> paren .)
    +               reduce using rule 87 (iSing -> paren .)
    -               reduce using rule 87 (iSing -> paren .)
    >               reduce using rule 87 (iSing -> paren .)
    <               reduce using rule 87 (iSing -> paren .)
    EQEQ            reduce using rule 87 (iSing -> paren .)
    DISTINTO        reduce using rule 87 (iSing -> paren .)
    AND             reduce using rule 87 (iSing -> paren .)
    ?               reduce using rule 87 (iSing -> paren .)
    OR              reduce using rule 87 (iSing -> paren .)
    )               reduce using rule 87 (iSing -> paren .)
    ;               reduce using rule 87 (iSing -> paren .)
    }               reduce using rule 87 (iSing -> paren .)
    ,               reduce using rule 87 (iSing -> paren .)
    ]               reduce using rule 87 (iSing -> paren .)
    :               reduce using rule 87 (iSing -> paren .)


state 80

    (110) menor -> not .

    EQEQ            reduce using rule 110 (menor -> not .)
    DISTINTO        reduce using rule 110 (menor -> not .)
    AND             reduce using rule 110 (menor -> not .)
    ?               reduce using rule 110 (menor -> not .)
    OR              reduce using rule 110 (menor -> not .)
    }               reduce using rule 110 (menor -> not .)
    )               reduce using rule 110 (menor -> not .)
    ;               reduce using rule 110 (menor -> not .)
    ,               reduce using rule 110 (menor -> not .)
    ]               reduce using rule 110 (menor -> not .)
    :               reduce using rule 110 (menor -> not .)


state 81

    (89) paren -> INT .

    ^               reduce using rule 89 (paren -> INT .)
    *               reduce using rule 89 (paren -> INT .)
    /               reduce using rule 89 (paren -> INT .)
    %               reduce using rule 89 (paren -> INT .)
    +               reduce using rule 89 (paren -> INT .)
    -               reduce using rule 89 (paren -> INT .)
    >               reduce using rule 89 (paren -> INT .)
    <               reduce using rule 89 (paren -> INT .)
    )               reduce using rule 89 (paren -> INT .)
    ;               reduce using rule 89 (paren -> INT .)
    }               reduce using rule 89 (paren -> INT .)
    ,               reduce using rule 89 (paren -> INT .)
    ]               reduce using rule 89 (paren -> INT .)
    EQEQ            reduce using rule 89 (paren -> INT .)
    DISTINTO        reduce using rule 89 (paren -> INT .)
    AND             reduce using rule 89 (paren -> INT .)
    ?               reduce using rule 89 (paren -> INT .)
    OR              reduce using rule 89 (paren -> INT .)
    :               reduce using rule 89 (paren -> INT .)


state 82

    (91) paren -> FLOAT .

    ^               reduce using rule 91 (paren -> FLOAT .)
    *               reduce using rule 91 (paren -> FLOAT .)
    /               reduce using rule 91 (paren -> FLOAT .)
    %               reduce using rule 91 (paren -> FLOAT .)
    +               reduce using rule 91 (paren -> FLOAT .)
    -               reduce using rule 91 (paren -> FLOAT .)
    >               reduce using rule 91 (paren -> FLOAT .)
    <               reduce using rule 91 (paren -> FLOAT .)
    )               reduce using rule 91 (paren -> FLOAT .)
    ;               reduce using rule 91 (paren -> FLOAT .)
    }               reduce using rule 91 (paren -> FLOAT .)
    ,               reduce using rule 91 (paren -> FLOAT .)
    ]               reduce using rule 91 (paren -> FLOAT .)
    EQEQ            reduce using rule 91 (paren -> FLOAT .)
    DISTINTO        reduce using rule 91 (paren -> FLOAT .)
    AND             reduce using rule 91 (paren -> FLOAT .)
    ?               reduce using rule 91 (paren -> FLOAT .)
    OR              reduce using rule 91 (paren -> FLOAT .)
    :               reduce using rule 91 (paren -> FLOAT .)


state 83

    (98) expBool -> or . ? expBool : expBool
    (99) expBool -> or .
    (100) or -> or . OR and

    ?               shift and go to state 155
    ,               reduce using rule 99 (expBool -> or .)
    ]               reduce using rule 99 (expBool -> or .)
    }               reduce using rule 99 (expBool -> or .)
    ;               reduce using rule 99 (expBool -> or .)
    :               reduce using rule 99 (expBool -> or .)
    )               reduce using rule 99 (expBool -> or .)
    OR              shift and go to state 154


state 84

    (78) eMat -> p .
    (79) p -> p . * exp
    (80) p -> p . / exp
    (81) p -> p . % exp

    +               reduce using rule 78 (eMat -> p .)
    -               reduce using rule 78 (eMat -> p .)
    >               reduce using rule 78 (eMat -> p .)
    <               reduce using rule 78 (eMat -> p .)
    )               reduce using rule 78 (eMat -> p .)
    ,               reduce using rule 78 (eMat -> p .)
    ]               reduce using rule 78 (eMat -> p .)
    ;               reduce using rule 78 (eMat -> p .)
    EQEQ            reduce using rule 78 (eMat -> p .)
    DISTINTO        reduce using rule 78 (eMat -> p .)
    AND             reduce using rule 78 (eMat -> p .)
    ?               reduce using rule 78 (eMat -> p .)
    OR              reduce using rule 78 (eMat -> p .)
    }               reduce using rule 78 (eMat -> p .)
    :               reduce using rule 78 (eMat -> p .)
    *               shift and go to state 156
    /               shift and go to state 158
    %               shift and go to state 157


state 85

    (118) tCompare -> varsOps .
    (92) paren -> varsOps .

  ! reduce/reduce conflict for > resolved using rule 92 (paren -> varsOps .)
  ! reduce/reduce conflict for < resolved using rule 92 (paren -> varsOps .)
  ! reduce/reduce conflict for EQEQ resolved using rule 92 (paren -> varsOps .)
  ! reduce/reduce conflict for DISTINTO resolved using rule 92 (paren -> varsOps .)
  ! reduce/reduce conflict for AND resolved using rule 92 (paren -> varsOps .)
  ! reduce/reduce conflict for ? resolved using rule 92 (paren -> varsOps .)
  ! reduce/reduce conflict for OR resolved using rule 92 (paren -> varsOps .)
  ! reduce/reduce conflict for ) resolved using rule 92 (paren -> varsOps .)
  ! reduce/reduce conflict for ; resolved using rule 92 (paren -> varsOps .)
  ! reduce/reduce conflict for } resolved using rule 92 (paren -> varsOps .)
  ! reduce/reduce conflict for , resolved using rule 92 (paren -> varsOps .)
  ! reduce/reduce conflict for ] resolved using rule 92 (paren -> varsOps .)
  ! reduce/reduce conflict for : resolved using rule 92 (paren -> varsOps .)
    ^               reduce using rule 92 (paren -> varsOps .)
    *               reduce using rule 92 (paren -> varsOps .)
    /               reduce using rule 92 (paren -> varsOps .)
    %               reduce using rule 92 (paren -> varsOps .)
    +               reduce using rule 92 (paren -> varsOps .)
    -               reduce using rule 92 (paren -> varsOps .)
    >               reduce using rule 92 (paren -> varsOps .)
    <               reduce using rule 92 (paren -> varsOps .)
    EQEQ            reduce using rule 92 (paren -> varsOps .)
    DISTINTO        reduce using rule 92 (paren -> varsOps .)
    AND             reduce using rule 92 (paren -> varsOps .)
    ?               reduce using rule 92 (paren -> varsOps .)
    OR              reduce using rule 92 (paren -> varsOps .)
    )               reduce using rule 92 (paren -> varsOps .)
    ;               reduce using rule 92 (paren -> varsOps .)
    }               reduce using rule 92 (paren -> varsOps .)
    ,               reduce using rule 92 (paren -> varsOps .)
    ]               reduce using rule 92 (paren -> varsOps .)
    :               reduce using rule 92 (paren -> varsOps .)

  ! >               [ reduce using rule 118 (tCompare -> varsOps .) ]
  ! <               [ reduce using rule 118 (tCompare -> varsOps .) ]
  ! EQEQ            [ reduce using rule 118 (tCompare -> varsOps .) ]
  ! DISTINTO        [ reduce using rule 118 (tCompare -> varsOps .) ]
  ! AND             [ reduce using rule 118 (tCompare -> varsOps .) ]
  ! ?               [ reduce using rule 118 (tCompare -> varsOps .) ]
  ! OR              [ reduce using rule 118 (tCompare -> varsOps .) ]
  ! )               [ reduce using rule 118 (tCompare -> varsOps .) ]
  ! ;               [ reduce using rule 118 (tCompare -> varsOps .) ]
  ! }               [ reduce using rule 118 (tCompare -> varsOps .) ]
  ! ,               [ reduce using rule 118 (tCompare -> varsOps .) ]
  ! ]               [ reduce using rule 118 (tCompare -> varsOps .) ]
  ! :               [ reduce using rule 118 (tCompare -> varsOps .) ]


state 86

    (82) p -> exp .
    (83) exp -> exp . ^ iSing

    *               reduce using rule 82 (p -> exp .)
    /               reduce using rule 82 (p -> exp .)
    %               reduce using rule 82 (p -> exp .)
    +               reduce using rule 82 (p -> exp .)
    -               reduce using rule 82 (p -> exp .)
    >               reduce using rule 82 (p -> exp .)
    <               reduce using rule 82 (p -> exp .)
    )               reduce using rule 82 (p -> exp .)
    ,               reduce using rule 82 (p -> exp .)
    ]               reduce using rule 82 (p -> exp .)
    ;               reduce using rule 82 (p -> exp .)
    }               reduce using rule 82 (p -> exp .)
    EQEQ            reduce using rule 82 (p -> exp .)
    DISTINTO        reduce using rule 82 (p -> exp .)
    AND             reduce using rule 82 (p -> exp .)
    ?               reduce using rule 82 (p -> exp .)
    OR              reduce using rule 82 (p -> exp .)
    :               reduce using rule 82 (p -> exp .)
    ^               shift and go to state 159


state 87

    (111) not -> NOT . not
    (111) not -> . NOT not
    (112) not -> . tBool
    (113) tBool -> . ( expBool )
    (114) tBool -> . BOOL
    (115) tBool -> . varYVals
    (116) tBool -> . funcBool
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (26) funcBool -> . COLINEALES ( vec , vec )
    (43) vecVal -> . ID m

    NOT             shift and go to state 87
    (               shift and go to state 160
    BOOL            shift and go to state 76
    ID              shift and go to state 58
    COLINEALES      shift and go to state 14

    funcBool                       shift and go to state 67
    not                            shift and go to state 161
    tBool                          shift and go to state 88
    varYVals                       shift and go to state 162
    vecVal                         shift and go to state 9

state 88

    (112) not -> tBool .

    EQEQ            reduce using rule 112 (not -> tBool .)
    DISTINTO        reduce using rule 112 (not -> tBool .)
    AND             reduce using rule 112 (not -> tBool .)
    ?               reduce using rule 112 (not -> tBool .)
    OR              reduce using rule 112 (not -> tBool .)
    ;               reduce using rule 112 (not -> tBool .)
    )               reduce using rule 112 (not -> tBool .)
    }               reduce using rule 112 (not -> tBool .)
    ,               reduce using rule 112 (not -> tBool .)
    ]               reduce using rule 112 (not -> tBool .)
    :               reduce using rule 112 (not -> tBool .)


state 89

    (119) tCompare -> varYVals .
    (51) varsOps -> varYVals . MASMAS
    (52) varsOps -> varYVals . MENOSMENOS
    (115) tBool -> varYVals .
    (90) paren -> varYVals .

  ! reduce/reduce conflict for > resolved using rule 90 (paren -> varYVals .)
  ! reduce/reduce conflict for < resolved using rule 90 (paren -> varYVals .)
    MASMAS          shift and go to state 60
    MENOSMENOS      shift and go to state 61
    EQEQ            reduce using rule 115 (tBool -> varYVals .)
    DISTINTO        reduce using rule 115 (tBool -> varYVals .)
    AND             reduce using rule 115 (tBool -> varYVals .)
    ?               reduce using rule 115 (tBool -> varYVals .)
    OR              reduce using rule 115 (tBool -> varYVals .)
    )               reduce using rule 115 (tBool -> varYVals .)
    ;               reduce using rule 115 (tBool -> varYVals .)
    }               reduce using rule 115 (tBool -> varYVals .)
    ,               reduce using rule 115 (tBool -> varYVals .)
    ]               reduce using rule 115 (tBool -> varYVals .)
    :               reduce using rule 115 (tBool -> varYVals .)
    ^               reduce using rule 90 (paren -> varYVals .)
    *               reduce using rule 90 (paren -> varYVals .)
    /               reduce using rule 90 (paren -> varYVals .)
    %               reduce using rule 90 (paren -> varYVals .)
    +               reduce using rule 90 (paren -> varYVals .)
    -               reduce using rule 90 (paren -> varYVals .)
    >               reduce using rule 90 (paren -> varYVals .)
    <               reduce using rule 90 (paren -> varYVals .)

  ! >               [ reduce using rule 119 (tCompare -> varYVals .) ]
  ! <               [ reduce using rule 119 (tCompare -> varYVals .) ]


state 90

    (10) loop -> WHILE ( expBool . ) bloque

    )               shift and go to state 163


state 91

    (22) funcReturn -> funcBool .
    (116) tBool -> funcBool .

  ! reduce/reduce conflict for ; resolved using rule 22 (funcReturn -> funcBool .)
  ! reduce/reduce conflict for } resolved using rule 22 (funcReturn -> funcBool .)
  ! reduce/reduce conflict for , resolved using rule 22 (funcReturn -> funcBool .)
  ! reduce/reduce conflict for ] resolved using rule 22 (funcReturn -> funcBool .)
  ! reduce/reduce conflict for ) resolved using rule 22 (funcReturn -> funcBool .)
    }               reduce using rule 22 (funcReturn -> funcBool .)
    ;               reduce using rule 22 (funcReturn -> funcBool .)
    ,               reduce using rule 22 (funcReturn -> funcBool .)
    ]               reduce using rule 22 (funcReturn -> funcBool .)
    )               reduce using rule 22 (funcReturn -> funcBool .)
    EQEQ            reduce using rule 116 (tBool -> funcBool .)
    DISTINTO        reduce using rule 116 (tBool -> funcBool .)
    AND             reduce using rule 116 (tBool -> funcBool .)
    ?               reduce using rule 116 (tBool -> funcBool .)
    OR              reduce using rule 116 (tBool -> funcBool .)

  ! ;               [ reduce using rule 116 (tBool -> funcBool .) ]
  ! }               [ reduce using rule 116 (tBool -> funcBool .) ]
  ! ,               [ reduce using rule 116 (tBool -> funcBool .) ]
  ! ]               [ reduce using rule 116 (tBool -> funcBool .) ]
  ! )               [ reduce using rule 116 (tBool -> funcBool .) ]


state 92

    (20) funcReturn -> funcInt .
    (93) paren -> funcInt .

  ! reduce/reduce conflict for ; resolved using rule 20 (funcReturn -> funcInt .)
  ! reduce/reduce conflict for ) resolved using rule 20 (funcReturn -> funcInt .)
  ! reduce/reduce conflict for , resolved using rule 20 (funcReturn -> funcInt .)
  ! reduce/reduce conflict for ] resolved using rule 20 (funcReturn -> funcInt .)
  ! reduce/reduce conflict for } resolved using rule 20 (funcReturn -> funcInt .)
    }               reduce using rule 20 (funcReturn -> funcInt .)
    ;               reduce using rule 20 (funcReturn -> funcInt .)
    ,               reduce using rule 20 (funcReturn -> funcInt .)
    ]               reduce using rule 20 (funcReturn -> funcInt .)
    )               reduce using rule 20 (funcReturn -> funcInt .)
    ^               reduce using rule 93 (paren -> funcInt .)
    *               reduce using rule 93 (paren -> funcInt .)
    /               reduce using rule 93 (paren -> funcInt .)
    %               reduce using rule 93 (paren -> funcInt .)
    +               reduce using rule 93 (paren -> funcInt .)
    -               reduce using rule 93 (paren -> funcInt .)
    >               reduce using rule 93 (paren -> funcInt .)
    <               reduce using rule 93 (paren -> funcInt .)

  ! ;               [ reduce using rule 93 (paren -> funcInt .) ]
  ! )               [ reduce using rule 93 (paren -> funcInt .) ]
  ! ,               [ reduce using rule 93 (paren -> funcInt .) ]
  ! ]               [ reduce using rule 93 (paren -> funcInt .) ]
  ! }               [ reduce using rule 93 (paren -> funcInt .) ]


state 93

    (34) valores -> eMat .
    (76) eMat -> eMat . + p
    (77) eMat -> eMat . - p
    (117) tCompare -> eMat .

    ;               reduce using rule 34 (valores -> eMat .)
    ,               reduce using rule 34 (valores -> eMat .)
    ]               reduce using rule 34 (valores -> eMat .)
    }               reduce using rule 34 (valores -> eMat .)
    )               reduce using rule 34 (valores -> eMat .)
    +               shift and go to state 142
    -               shift and go to state 143
    >               reduce using rule 117 (tCompare -> eMat .)
    <               reduce using rule 117 (tCompare -> eMat .)


state 94

    (88) paren -> ( . eMat )
    (113) tBool -> ( . expBool )
    (76) eMat -> . eMat + p
    (77) eMat -> . eMat - p
    (78) eMat -> . p
    (98) expBool -> . or ? expBool : expBool
    (99) expBool -> . or
    (79) p -> . p * exp
    (80) p -> . p / exp
    (81) p -> . p % exp
    (82) p -> . exp
    (100) or -> . or OR and
    (101) or -> . and
    (83) exp -> . exp ^ iSing
    (84) exp -> . iSing
    (102) and -> . and AND eq
    (103) and -> . eq
    (85) iSing -> . - paren
    (86) iSing -> . + paren
    (87) iSing -> . paren
    (104) eq -> . eq EQEQ tBool
    (105) eq -> . eq DISTINTO tBool
    (106) eq -> . mayor
    (88) paren -> . ( eMat )
    (89) paren -> . INT
    (90) paren -> . varYVals
    (91) paren -> . FLOAT
    (92) paren -> . varsOps
    (93) paren -> . funcInt
    (107) mayor -> . tCompare > tCompare
    (108) mayor -> . menor
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (49) varsOps -> . MENOSMENOS varYVals
    (50) varsOps -> . MASMAS varYVals
    (51) varsOps -> . varYVals MASMAS
    (52) varsOps -> . varYVals MENOSMENOS
    (23) funcInt -> . MULTIESCALAR ( vec , eMat , param )
    (24) funcInt -> . LENGTH ( vec )
    (117) tCompare -> . eMat
    (118) tCompare -> . varsOps
    (119) tCompare -> . varYVals
    (109) menor -> . tCompare < tCompare
    (110) menor -> . not
    (43) vecVal -> . ID m
    (111) not -> . NOT not
    (112) not -> . tBool
    (113) tBool -> . ( expBool )
    (114) tBool -> . BOOL
    (115) tBool -> . varYVals
    (116) tBool -> . funcBool
    (26) funcBool -> . COLINEALES ( vec , vec )

    -               shift and go to state 75
    +               shift and go to state 74
    (               shift and go to state 94
    INT             shift and go to state 81
    FLOAT           shift and go to state 82
    ID              shift and go to state 58
    MENOSMENOS      shift and go to state 32
    MASMAS          shift and go to state 29
    MULTIESCALAR    shift and go to state 22
    LENGTH          shift and go to state 27
    NOT             shift and go to state 87
    BOOL            shift and go to state 76
    COLINEALES      shift and go to state 14

    and                            shift and go to state 66
    funcBool                       shift and go to state 67
    funcInt                        shift and go to state 68
    menor                          shift and go to state 69
    eq                             shift and go to state 70
    mayor                          shift and go to state 71
    eMat                           shift and go to state 144
    vecVal                         shift and go to state 9
    paren                          shift and go to state 79
    varsOps                        shift and go to state 96
    tCompare                       shift and go to state 78
    not                            shift and go to state 80
    p                              shift and go to state 84
    iSing                          shift and go to state 77
    exp                            shift and go to state 86
    tBool                          shift and go to state 88
    varYVals                       shift and go to state 164
    or                             shift and go to state 83
    expBool                        shift and go to state 146

state 95

    (39) valores -> reg .

    ;               reduce using rule 39 (valores -> reg .)
    ,               reduce using rule 39 (valores -> reg .)
    ]               reduce using rule 39 (valores -> reg .)
    }               reduce using rule 39 (valores -> reg .)
    )               reduce using rule 39 (valores -> reg .)


state 96

    (92) paren -> varsOps .
    (118) tCompare -> varsOps .

  ! reduce/reduce conflict for > resolved using rule 92 (paren -> varsOps .)
  ! reduce/reduce conflict for < resolved using rule 92 (paren -> varsOps .)
    ^               reduce using rule 92 (paren -> varsOps .)
    *               reduce using rule 92 (paren -> varsOps .)
    /               reduce using rule 92 (paren -> varsOps .)
    %               reduce using rule 92 (paren -> varsOps .)
    +               reduce using rule 92 (paren -> varsOps .)
    -               reduce using rule 92 (paren -> varsOps .)
    ;               reduce using rule 92 (paren -> varsOps .)
    >               reduce using rule 92 (paren -> varsOps .)
    <               reduce using rule 92 (paren -> varsOps .)
    )               reduce using rule 92 (paren -> varsOps .)
    ,               reduce using rule 92 (paren -> varsOps .)
    ]               reduce using rule 92 (paren -> varsOps .)
    }               reduce using rule 92 (paren -> varsOps .)

  ! >               [ reduce using rule 118 (tCompare -> varsOps .) ]
  ! <               [ reduce using rule 118 (tCompare -> varsOps .) ]


state 97

    (95) expString -> STRING .

    +               reduce using rule 95 (expString -> STRING .)
    ;               reduce using rule 95 (expString -> STRING .)
    ,               reduce using rule 95 (expString -> STRING .)
    ]               reduce using rule 95 (expString -> STRING .)
    )               reduce using rule 95 (expString -> STRING .)
    }               reduce using rule 95 (expString -> STRING .)


state 98

    (36) valores -> expString .
    (94) expString -> expString . + STRING

    ;               reduce using rule 36 (valores -> expString .)
    ,               reduce using rule 36 (valores -> expString .)
    ]               reduce using rule 36 (valores -> expString .)
    }               reduce using rule 36 (valores -> expString .)
    )               reduce using rule 36 (valores -> expString .)
    +               shift and go to state 165


state 99

    (40) valores -> ID . . ID
    (41) varYVals -> ID .
    (43) vecVal -> ID . m
    (44) m -> . [ INT ]
    (45) m -> . [ INT ] m

    .               shift and go to state 166
    MASMAS          reduce using rule 41 (varYVals -> ID .)
    MENOSMENOS      reduce using rule 41 (varYVals -> ID .)
    )               reduce using rule 41 (varYVals -> ID .)
    +               reduce using rule 41 (varYVals -> ID .)
    ^               reduce using rule 41 (varYVals -> ID .)
    *               reduce using rule 41 (varYVals -> ID .)
    /               reduce using rule 41 (varYVals -> ID .)
    %               reduce using rule 41 (varYVals -> ID .)
    -               reduce using rule 41 (varYVals -> ID .)
    >               reduce using rule 41 (varYVals -> ID .)
    <               reduce using rule 41 (varYVals -> ID .)
    EQEQ            reduce using rule 41 (varYVals -> ID .)
    DISTINTO        reduce using rule 41 (varYVals -> ID .)
    AND             reduce using rule 41 (varYVals -> ID .)
    ?               reduce using rule 41 (varYVals -> ID .)
    OR              reduce using rule 41 (varYVals -> ID .)
    ,               reduce using rule 41 (varYVals -> ID .)
    ]               reduce using rule 41 (varYVals -> ID .)
    [               shift and go to state 48

    m                              shift and go to state 47

state 100

    (97) expString -> funcString .
    (21) funcReturn -> funcString .

  ! reduce/reduce conflict for } resolved using rule 21 (funcReturn -> funcString .)
  ! reduce/reduce conflict for ; resolved using rule 21 (funcReturn -> funcString .)
  ! reduce/reduce conflict for , resolved using rule 21 (funcReturn -> funcString .)
  ! reduce/reduce conflict for ] resolved using rule 21 (funcReturn -> funcString .)
  ! reduce/reduce conflict for ) resolved using rule 21 (funcReturn -> funcString .)
    +               reduce using rule 97 (expString -> funcString .)
    }               reduce using rule 21 (funcReturn -> funcString .)
    ;               reduce using rule 21 (funcReturn -> funcString .)
    ,               reduce using rule 21 (funcReturn -> funcString .)
    ]               reduce using rule 21 (funcReturn -> funcString .)
    )               reduce using rule 21 (funcReturn -> funcString .)

  ! ;               [ reduce using rule 97 (expString -> funcString .) ]
  ! ,               [ reduce using rule 97 (expString -> funcString .) ]
  ! ]               [ reduce using rule 97 (expString -> funcString .) ]
  ! }               [ reduce using rule 97 (expString -> funcString .) ]
  ! )               [ reduce using rule 97 (expString -> funcString .) ]


state 101

    (38) valores -> funcReturn .

    ;               reduce using rule 38 (valores -> funcReturn .)
    ,               reduce using rule 38 (valores -> funcReturn .)
    ]               reduce using rule 38 (valores -> funcReturn .)
    }               reduce using rule 38 (valores -> funcReturn .)
    )               reduce using rule 38 (valores -> funcReturn .)


state 102

    (27) funcVoid -> PRINT ( valores . )

    )               shift and go to state 167


state 103

    (46) reg -> { . campos }
    (47) campos -> . ID : valores , campos
    (48) campos -> . valores
    (34) valores -> . eMat
    (35) valores -> . expBool
    (36) valores -> . expString
    (37) valores -> . varYVals
    (38) valores -> . funcReturn
    (39) valores -> . reg
    (40) valores -> . ID . ID
    (76) eMat -> . eMat + p
    (77) eMat -> . eMat - p
    (78) eMat -> . p
    (98) expBool -> . or ? expBool : expBool
    (99) expBool -> . or
    (94) expString -> . expString + STRING
    (95) expString -> . STRING
    (96) expString -> . varYVals
    (97) expString -> . funcString
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (20) funcReturn -> . funcInt
    (21) funcReturn -> . funcString
    (22) funcReturn -> . funcBool
    (46) reg -> . { campos }
    (79) p -> . p * exp
    (80) p -> . p / exp
    (81) p -> . p % exp
    (82) p -> . exp
    (100) or -> . or OR and
    (101) or -> . and
    (25) funcString -> . CAPITALIZAR ( expString )
    (43) vecVal -> . ID m
    (23) funcInt -> . MULTIESCALAR ( vec , eMat , param )
    (24) funcInt -> . LENGTH ( vec )
    (26) funcBool -> . COLINEALES ( vec , vec )
    (83) exp -> . exp ^ iSing
    (84) exp -> . iSing
    (102) and -> . and AND eq
    (103) and -> . eq
    (85) iSing -> . - paren
    (86) iSing -> . + paren
    (87) iSing -> . paren
    (104) eq -> . eq EQEQ tBool
    (105) eq -> . eq DISTINTO tBool
    (106) eq -> . mayor
    (88) paren -> . ( eMat )
    (89) paren -> . INT
    (90) paren -> . varYVals
    (91) paren -> . FLOAT
    (92) paren -> . varsOps
    (93) paren -> . funcInt
    (107) mayor -> . tCompare > tCompare
    (108) mayor -> . menor
    (49) varsOps -> . MENOSMENOS varYVals
    (50) varsOps -> . MASMAS varYVals
    (51) varsOps -> . varYVals MASMAS
    (52) varsOps -> . varYVals MENOSMENOS
    (117) tCompare -> . eMat
    (118) tCompare -> . varsOps
    (119) tCompare -> . varYVals
    (109) menor -> . tCompare < tCompare
    (110) menor -> . not
    (111) not -> . NOT not
    (112) not -> . tBool
    (113) tBool -> . ( expBool )
    (114) tBool -> . BOOL
    (115) tBool -> . varYVals
    (116) tBool -> . funcBool

    ID              shift and go to state 169
    STRING          shift and go to state 97
    {               shift and go to state 103
    CAPITALIZAR     shift and go to state 25
    MULTIESCALAR    shift and go to state 22
    LENGTH          shift and go to state 27
    COLINEALES      shift and go to state 14
    -               shift and go to state 75
    +               shift and go to state 74
    (               shift and go to state 94
    INT             shift and go to state 81
    FLOAT           shift and go to state 82
    MENOSMENOS      shift and go to state 32
    MASMAS          shift and go to state 29
    NOT             shift and go to state 87
    BOOL            shift and go to state 76

    and                            shift and go to state 66
    funcBool                       shift and go to state 91
    funcInt                        shift and go to state 92
    menor                          shift and go to state 69
    eq                             shift and go to state 70
    vecVal                         shift and go to state 9
    eMat                           shift and go to state 93
    mayor                          shift and go to state 71
    paren                          shift and go to state 79
    reg                            shift and go to state 95
    varsOps                        shift and go to state 96
    expString                      shift and go to state 98
    tCompare                       shift and go to state 78
    campos                         shift and go to state 168
    not                            shift and go to state 80
    funcString                     shift and go to state 100
    funcReturn                     shift and go to state 101
    valores                        shift and go to state 170
    p                              shift and go to state 84
    iSing                          shift and go to state 77
    exp                            shift and go to state 86
    tBool                          shift and go to state 88
    varYVals                       shift and go to state 104
    or                             shift and go to state 83
    expBool                        shift and go to state 105

state 104

    (37) valores -> varYVals .
    (96) expString -> varYVals .
    (90) paren -> varYVals .
    (51) varsOps -> varYVals . MASMAS
    (52) varsOps -> varYVals . MENOSMENOS
    (119) tCompare -> varYVals .
    (115) tBool -> varYVals .

  ! reduce/reduce conflict for ; resolved using rule 37 (valores -> varYVals .)
  ! reduce/reduce conflict for , resolved using rule 37 (valores -> varYVals .)
  ! reduce/reduce conflict for ] resolved using rule 37 (valores -> varYVals .)
  ! reduce/reduce conflict for } resolved using rule 37 (valores -> varYVals .)
  ! reduce/reduce conflict for ) resolved using rule 37 (valores -> varYVals .)
  ! reduce/reduce conflict for + resolved using rule 90 (paren -> varYVals .)
  ! reduce/reduce conflict for ; resolved using rule 37 (valores -> varYVals .)
  ! reduce/reduce conflict for ) resolved using rule 37 (valores -> varYVals .)
  ! reduce/reduce conflict for , resolved using rule 37 (valores -> varYVals .)
  ! reduce/reduce conflict for ] resolved using rule 37 (valores -> varYVals .)
  ! reduce/reduce conflict for } resolved using rule 37 (valores -> varYVals .)
  ! reduce/reduce conflict for > resolved using rule 90 (paren -> varYVals .)
  ! reduce/reduce conflict for < resolved using rule 90 (paren -> varYVals .)
  ! reduce/reduce conflict for ; resolved using rule 37 (valores -> varYVals .)
  ! reduce/reduce conflict for } resolved using rule 37 (valores -> varYVals .)
  ! reduce/reduce conflict for , resolved using rule 37 (valores -> varYVals .)
  ! reduce/reduce conflict for ] resolved using rule 37 (valores -> varYVals .)
  ! reduce/reduce conflict for ) resolved using rule 37 (valores -> varYVals .)
    ;               reduce using rule 37 (valores -> varYVals .)
    ,               reduce using rule 37 (valores -> varYVals .)
    ]               reduce using rule 37 (valores -> varYVals .)
    }               reduce using rule 37 (valores -> varYVals .)
    )               reduce using rule 37 (valores -> varYVals .)
    ^               reduce using rule 90 (paren -> varYVals .)
    *               reduce using rule 90 (paren -> varYVals .)
    /               reduce using rule 90 (paren -> varYVals .)
    %               reduce using rule 90 (paren -> varYVals .)
    +               reduce using rule 90 (paren -> varYVals .)
    -               reduce using rule 90 (paren -> varYVals .)
    >               reduce using rule 90 (paren -> varYVals .)
    <               reduce using rule 90 (paren -> varYVals .)
    MASMAS          shift and go to state 60
    MENOSMENOS      shift and go to state 61
    EQEQ            reduce using rule 115 (tBool -> varYVals .)
    DISTINTO        reduce using rule 115 (tBool -> varYVals .)
    AND             reduce using rule 115 (tBool -> varYVals .)
    ?               reduce using rule 115 (tBool -> varYVals .)
    OR              reduce using rule 115 (tBool -> varYVals .)

  ! +               [ reduce using rule 96 (expString -> varYVals .) ]
  ! ;               [ reduce using rule 96 (expString -> varYVals .) ]
  ! ,               [ reduce using rule 96 (expString -> varYVals .) ]
  ! ]               [ reduce using rule 96 (expString -> varYVals .) ]
  ! }               [ reduce using rule 96 (expString -> varYVals .) ]
  ! )               [ reduce using rule 96 (expString -> varYVals .) ]
  ! ;               [ reduce using rule 90 (paren -> varYVals .) ]
  ! )               [ reduce using rule 90 (paren -> varYVals .) ]
  ! ,               [ reduce using rule 90 (paren -> varYVals .) ]
  ! ]               [ reduce using rule 90 (paren -> varYVals .) ]
  ! }               [ reduce using rule 90 (paren -> varYVals .) ]
  ! >               [ reduce using rule 119 (tCompare -> varYVals .) ]
  ! <               [ reduce using rule 119 (tCompare -> varYVals .) ]
  ! ;               [ reduce using rule 115 (tBool -> varYVals .) ]
  ! }               [ reduce using rule 115 (tBool -> varYVals .) ]
  ! ,               [ reduce using rule 115 (tBool -> varYVals .) ]
  ! ]               [ reduce using rule 115 (tBool -> varYVals .) ]
  ! )               [ reduce using rule 115 (tBool -> varYVals .) ]


state 105

    (35) valores -> expBool .

    ;               reduce using rule 35 (valores -> expBool .)
    ,               reduce using rule 35 (valores -> expBool .)
    ]               reduce using rule 35 (valores -> expBool .)
    }               reduce using rule 35 (valores -> expBool .)
    )               reduce using rule 35 (valores -> expBool .)


state 106

    (58) varAsig -> masmenAsig DIVEQ ID .
    (53) varAsig -> ID . MULEQ varAsig
    (40) valores -> ID . . ID
    (62) masmenAsig -> ID . MASEQ masmenAsig
    (63) masmenAsig -> ID . MENOSEQ masmenAsig
    (64) masmenAsig -> ID . MASEQ ID
    (65) masmenAsig -> ID . MENOSEQ ID
    (69) finVarAsig -> ID . = valores
    (70) finVarAsig -> ID . MASEQ valores
    (71) finVarAsig -> ID . MENOSEQ valores
    (72) finVarAsig -> ID . MULEQ valores
    (73) finVarAsig -> ID . MULEQ ID
    (74) finVarAsig -> ID . DIVEQ valores
    (75) finVarAsig -> ID . DIVEQ ID
    (41) varYVals -> ID .
    (67) asig -> ID . = asig
    (68) asig -> ID . = ID
    (43) vecVal -> ID . m
    (44) m -> . [ INT ]
    (45) m -> . [ INT ] m

  ! reduce/reduce conflict for ; resolved using rule 41 (varYVals -> ID .)
    MULEQ           shift and go to state 51
    .               shift and go to state 166
    MASEQ           shift and go to state 46
    MENOSEQ         shift and go to state 45
    =               shift and go to state 49
    DIVEQ           shift and go to state 50
    MASMAS          reduce using rule 41 (varYVals -> ID .)
    MENOSMENOS      reduce using rule 41 (varYVals -> ID .)
    ;               reduce using rule 41 (varYVals -> ID .)
    +               reduce using rule 41 (varYVals -> ID .)
    ^               reduce using rule 41 (varYVals -> ID .)
    *               reduce using rule 41 (varYVals -> ID .)
    /               reduce using rule 41 (varYVals -> ID .)
    %               reduce using rule 41 (varYVals -> ID .)
    -               reduce using rule 41 (varYVals -> ID .)
    >               reduce using rule 41 (varYVals -> ID .)
    <               reduce using rule 41 (varYVals -> ID .)
    EQEQ            reduce using rule 41 (varYVals -> ID .)
    DISTINTO        reduce using rule 41 (varYVals -> ID .)
    AND             reduce using rule 41 (varYVals -> ID .)
    ?               reduce using rule 41 (varYVals -> ID .)
    OR              reduce using rule 41 (varYVals -> ID .)
    [               shift and go to state 48

  ! ;               [ reduce using rule 58 (varAsig -> masmenAsig DIVEQ ID .) ]

    m                              shift and go to state 47

state 107

    (57) varAsig -> masmenAsig DIVEQ varAsig .

    ;               reduce using rule 57 (varAsig -> masmenAsig DIVEQ varAsig .)


state 108

    (59) varAsig -> masmenAsig DIVEQ valores .

    ;               reduce using rule 59 (varAsig -> masmenAsig DIVEQ valores .)


state 109

    (55) varAsig -> masmenAsig MULEQ ID .
    (53) varAsig -> ID . MULEQ varAsig
    (40) valores -> ID . . ID
    (62) masmenAsig -> ID . MASEQ masmenAsig
    (63) masmenAsig -> ID . MENOSEQ masmenAsig
    (64) masmenAsig -> ID . MASEQ ID
    (65) masmenAsig -> ID . MENOSEQ ID
    (69) finVarAsig -> ID . = valores
    (70) finVarAsig -> ID . MASEQ valores
    (71) finVarAsig -> ID . MENOSEQ valores
    (72) finVarAsig -> ID . MULEQ valores
    (73) finVarAsig -> ID . MULEQ ID
    (74) finVarAsig -> ID . DIVEQ valores
    (75) finVarAsig -> ID . DIVEQ ID
    (41) varYVals -> ID .
    (67) asig -> ID . = asig
    (68) asig -> ID . = ID
    (43) vecVal -> ID . m
    (44) m -> . [ INT ]
    (45) m -> . [ INT ] m

  ! reduce/reduce conflict for ; resolved using rule 41 (varYVals -> ID .)
    MULEQ           shift and go to state 51
    .               shift and go to state 166
    MASEQ           shift and go to state 46
    MENOSEQ         shift and go to state 45
    =               shift and go to state 49
    DIVEQ           shift and go to state 50
    MASMAS          reduce using rule 41 (varYVals -> ID .)
    MENOSMENOS      reduce using rule 41 (varYVals -> ID .)
    ;               reduce using rule 41 (varYVals -> ID .)
    +               reduce using rule 41 (varYVals -> ID .)
    ^               reduce using rule 41 (varYVals -> ID .)
    *               reduce using rule 41 (varYVals -> ID .)
    /               reduce using rule 41 (varYVals -> ID .)
    %               reduce using rule 41 (varYVals -> ID .)
    -               reduce using rule 41 (varYVals -> ID .)
    >               reduce using rule 41 (varYVals -> ID .)
    <               reduce using rule 41 (varYVals -> ID .)
    EQEQ            reduce using rule 41 (varYVals -> ID .)
    DISTINTO        reduce using rule 41 (varYVals -> ID .)
    AND             reduce using rule 41 (varYVals -> ID .)
    ?               reduce using rule 41 (varYVals -> ID .)
    OR              reduce using rule 41 (varYVals -> ID .)
    [               shift and go to state 48

  ! ;               [ reduce using rule 55 (varAsig -> masmenAsig MULEQ ID .) ]

    m                              shift and go to state 47

state 110

    (54) varAsig -> masmenAsig MULEQ varAsig .

    ;               reduce using rule 54 (varAsig -> masmenAsig MULEQ varAsig .)


state 111

    (56) varAsig -> masmenAsig MULEQ valores .

    ;               reduce using rule 56 (varAsig -> masmenAsig MULEQ valores .)


state 112

    (26) funcBool -> COLINEALES ( vec . , vec )

    ,               shift and go to state 171


state 113

    (31) vec -> [ . elem ]
    (32) elem -> . valores , elem
    (33) elem -> . valores
    (34) valores -> . eMat
    (35) valores -> . expBool
    (36) valores -> . expString
    (37) valores -> . varYVals
    (38) valores -> . funcReturn
    (39) valores -> . reg
    (40) valores -> . ID . ID
    (76) eMat -> . eMat + p
    (77) eMat -> . eMat - p
    (78) eMat -> . p
    (98) expBool -> . or ? expBool : expBool
    (99) expBool -> . or
    (94) expString -> . expString + STRING
    (95) expString -> . STRING
    (96) expString -> . varYVals
    (97) expString -> . funcString
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (20) funcReturn -> . funcInt
    (21) funcReturn -> . funcString
    (22) funcReturn -> . funcBool
    (46) reg -> . { campos }
    (79) p -> . p * exp
    (80) p -> . p / exp
    (81) p -> . p % exp
    (82) p -> . exp
    (100) or -> . or OR and
    (101) or -> . and
    (25) funcString -> . CAPITALIZAR ( expString )
    (43) vecVal -> . ID m
    (23) funcInt -> . MULTIESCALAR ( vec , eMat , param )
    (24) funcInt -> . LENGTH ( vec )
    (26) funcBool -> . COLINEALES ( vec , vec )
    (83) exp -> . exp ^ iSing
    (84) exp -> . iSing
    (102) and -> . and AND eq
    (103) and -> . eq
    (85) iSing -> . - paren
    (86) iSing -> . + paren
    (87) iSing -> . paren
    (104) eq -> . eq EQEQ tBool
    (105) eq -> . eq DISTINTO tBool
    (106) eq -> . mayor
    (88) paren -> . ( eMat )
    (89) paren -> . INT
    (90) paren -> . varYVals
    (91) paren -> . FLOAT
    (92) paren -> . varsOps
    (93) paren -> . funcInt
    (107) mayor -> . tCompare > tCompare
    (108) mayor -> . menor
    (49) varsOps -> . MENOSMENOS varYVals
    (50) varsOps -> . MASMAS varYVals
    (51) varsOps -> . varYVals MASMAS
    (52) varsOps -> . varYVals MENOSMENOS
    (117) tCompare -> . eMat
    (118) tCompare -> . varsOps
    (119) tCompare -> . varYVals
    (109) menor -> . tCompare < tCompare
    (110) menor -> . not
    (111) not -> . NOT not
    (112) not -> . tBool
    (113) tBool -> . ( expBool )
    (114) tBool -> . BOOL
    (115) tBool -> . varYVals
    (116) tBool -> . funcBool

    ID              shift and go to state 99
    STRING          shift and go to state 97
    {               shift and go to state 103
    CAPITALIZAR     shift and go to state 25
    MULTIESCALAR    shift and go to state 22
    LENGTH          shift and go to state 27
    COLINEALES      shift and go to state 14
    -               shift and go to state 75
    +               shift and go to state 74
    (               shift and go to state 94
    INT             shift and go to state 81
    FLOAT           shift and go to state 82
    MENOSMENOS      shift and go to state 32
    MASMAS          shift and go to state 29
    NOT             shift and go to state 87
    BOOL            shift and go to state 76

    and                            shift and go to state 66
    funcBool                       shift and go to state 91
    funcInt                        shift and go to state 92
    valores                        shift and go to state 172
    menor                          shift and go to state 69
    eq                             shift and go to state 70
    vecVal                         shift and go to state 9
    eMat                           shift and go to state 93
    mayor                          shift and go to state 71
    paren                          shift and go to state 79
    reg                            shift and go to state 95
    varsOps                        shift and go to state 96
    expString                      shift and go to state 98
    tCompare                       shift and go to state 78
    not                            shift and go to state 80
    funcString                     shift and go to state 100
    funcReturn                     shift and go to state 101
    elem                           shift and go to state 173
    p                              shift and go to state 84
    iSing                          shift and go to state 77
    exp                            shift and go to state 86
    tBool                          shift and go to state 88
    varYVals                       shift and go to state 104
    or                             shift and go to state 83
    expBool                        shift and go to state 105

state 114

    (12) loop -> FOR ( varAsig . ; expBool ; varsOps ) bloque

    ;               shift and go to state 174


state 115

    (53) varAsig -> ID . MULEQ varAsig
    (62) masmenAsig -> ID . MASEQ masmenAsig
    (63) masmenAsig -> ID . MENOSEQ masmenAsig
    (64) masmenAsig -> ID . MASEQ ID
    (65) masmenAsig -> ID . MENOSEQ ID
    (69) finVarAsig -> ID . = valores
    (70) finVarAsig -> ID . MASEQ valores
    (71) finVarAsig -> ID . MENOSEQ valores
    (72) finVarAsig -> ID . MULEQ valores
    (73) finVarAsig -> ID . MULEQ ID
    (74) finVarAsig -> ID . DIVEQ valores
    (75) finVarAsig -> ID . DIVEQ ID
    (67) asig -> ID . = asig
    (68) asig -> ID . = ID

    MULEQ           shift and go to state 51
    MASEQ           shift and go to state 46
    MENOSEQ         shift and go to state 45
    =               shift and go to state 49
    DIVEQ           shift and go to state 50


state 116

    (63) masmenAsig -> ID MENOSEQ masmenAsig .

    MULEQ           reduce using rule 63 (masmenAsig -> ID MENOSEQ masmenAsig .)
    DIVEQ           reduce using rule 63 (masmenAsig -> ID MENOSEQ masmenAsig .)
    ;               reduce using rule 63 (masmenAsig -> ID MENOSEQ masmenAsig .)


state 117

    (65) masmenAsig -> ID MENOSEQ ID .
    (62) masmenAsig -> ID . MASEQ masmenAsig
    (63) masmenAsig -> ID . MENOSEQ masmenAsig
    (64) masmenAsig -> ID . MASEQ ID
    (65) masmenAsig -> ID . MENOSEQ ID
    (40) valores -> ID . . ID
    (67) asig -> ID . = asig
    (68) asig -> ID . = ID
    (41) varYVals -> ID .
    (43) vecVal -> ID . m
    (44) m -> . [ INT ]
    (45) m -> . [ INT ] m

  ! reduce/reduce conflict for ; resolved using rule 41 (varYVals -> ID .)
    MULEQ           reduce using rule 65 (masmenAsig -> ID MENOSEQ ID .)
    DIVEQ           reduce using rule 65 (masmenAsig -> ID MENOSEQ ID .)
    MASEQ           shift and go to state 176
    MENOSEQ         shift and go to state 175
    .               shift and go to state 166
    =               shift and go to state 177
    MASMAS          reduce using rule 41 (varYVals -> ID .)
    MENOSMENOS      reduce using rule 41 (varYVals -> ID .)
    ;               reduce using rule 41 (varYVals -> ID .)
    +               reduce using rule 41 (varYVals -> ID .)
    ^               reduce using rule 41 (varYVals -> ID .)
    *               reduce using rule 41 (varYVals -> ID .)
    /               reduce using rule 41 (varYVals -> ID .)
    %               reduce using rule 41 (varYVals -> ID .)
    -               reduce using rule 41 (varYVals -> ID .)
    >               reduce using rule 41 (varYVals -> ID .)
    <               reduce using rule 41 (varYVals -> ID .)
    EQEQ            reduce using rule 41 (varYVals -> ID .)
    DISTINTO        reduce using rule 41 (varYVals -> ID .)
    AND             reduce using rule 41 (varYVals -> ID .)
    ?               reduce using rule 41 (varYVals -> ID .)
    OR              reduce using rule 41 (varYVals -> ID .)
    [               shift and go to state 48

  ! ;               [ reduce using rule 65 (masmenAsig -> ID MENOSEQ ID .) ]

    m                              shift and go to state 47

state 118

    (71) finVarAsig -> ID MENOSEQ valores .

    ;               reduce using rule 71 (finVarAsig -> ID MENOSEQ valores .)


state 119

    (62) masmenAsig -> ID MASEQ masmenAsig .

    MULEQ           reduce using rule 62 (masmenAsig -> ID MASEQ masmenAsig .)
    DIVEQ           reduce using rule 62 (masmenAsig -> ID MASEQ masmenAsig .)
    ;               reduce using rule 62 (masmenAsig -> ID MASEQ masmenAsig .)


state 120

    (64) masmenAsig -> ID MASEQ ID .
    (62) masmenAsig -> ID . MASEQ masmenAsig
    (63) masmenAsig -> ID . MENOSEQ masmenAsig
    (64) masmenAsig -> ID . MASEQ ID
    (65) masmenAsig -> ID . MENOSEQ ID
    (40) valores -> ID . . ID
    (67) asig -> ID . = asig
    (68) asig -> ID . = ID
    (41) varYVals -> ID .
    (43) vecVal -> ID . m
    (44) m -> . [ INT ]
    (45) m -> . [ INT ] m

  ! reduce/reduce conflict for ; resolved using rule 41 (varYVals -> ID .)
    MULEQ           reduce using rule 64 (masmenAsig -> ID MASEQ ID .)
    DIVEQ           reduce using rule 64 (masmenAsig -> ID MASEQ ID .)
    MASEQ           shift and go to state 176
    MENOSEQ         shift and go to state 175
    .               shift and go to state 166
    =               shift and go to state 177
    MASMAS          reduce using rule 41 (varYVals -> ID .)
    MENOSMENOS      reduce using rule 41 (varYVals -> ID .)
    ;               reduce using rule 41 (varYVals -> ID .)
    +               reduce using rule 41 (varYVals -> ID .)
    ^               reduce using rule 41 (varYVals -> ID .)
    *               reduce using rule 41 (varYVals -> ID .)
    /               reduce using rule 41 (varYVals -> ID .)
    %               reduce using rule 41 (varYVals -> ID .)
    -               reduce using rule 41 (varYVals -> ID .)
    >               reduce using rule 41 (varYVals -> ID .)
    <               reduce using rule 41 (varYVals -> ID .)
    EQEQ            reduce using rule 41 (varYVals -> ID .)
    DISTINTO        reduce using rule 41 (varYVals -> ID .)
    AND             reduce using rule 41 (varYVals -> ID .)
    ?               reduce using rule 41 (varYVals -> ID .)
    OR              reduce using rule 41 (varYVals -> ID .)
    [               shift and go to state 48

  ! ;               [ reduce using rule 64 (masmenAsig -> ID MASEQ ID .) ]

    m                              shift and go to state 47

state 121

    (70) finVarAsig -> ID MASEQ valores .

    ;               reduce using rule 70 (finVarAsig -> ID MASEQ valores .)


state 122

    (44) m -> [ INT . ]
    (45) m -> [ INT . ] m

    ]               shift and go to state 178


state 123

    (67) asig -> ID = asig .

    MULEQ           reduce using rule 67 (asig -> ID = asig .)
    DIVEQ           reduce using rule 67 (asig -> ID = asig .)
    ;               reduce using rule 67 (asig -> ID = asig .)


state 124

    (68) asig -> ID = ID .
    (40) valores -> ID . . ID
    (67) asig -> ID . = asig
    (68) asig -> ID . = ID
    (41) varYVals -> ID .
    (43) vecVal -> ID . m
    (44) m -> . [ INT ]
    (45) m -> . [ INT ] m

  ! reduce/reduce conflict for ; resolved using rule 41 (varYVals -> ID .)
    MULEQ           reduce using rule 68 (asig -> ID = ID .)
    DIVEQ           reduce using rule 68 (asig -> ID = ID .)
    .               shift and go to state 166
    =               shift and go to state 177
    MASMAS          reduce using rule 41 (varYVals -> ID .)
    MENOSMENOS      reduce using rule 41 (varYVals -> ID .)
    ;               reduce using rule 41 (varYVals -> ID .)
    +               reduce using rule 41 (varYVals -> ID .)
    ^               reduce using rule 41 (varYVals -> ID .)
    *               reduce using rule 41 (varYVals -> ID .)
    /               reduce using rule 41 (varYVals -> ID .)
    %               reduce using rule 41 (varYVals -> ID .)
    -               reduce using rule 41 (varYVals -> ID .)
    >               reduce using rule 41 (varYVals -> ID .)
    <               reduce using rule 41 (varYVals -> ID .)
    EQEQ            reduce using rule 41 (varYVals -> ID .)
    DISTINTO        reduce using rule 41 (varYVals -> ID .)
    AND             reduce using rule 41 (varYVals -> ID .)
    ?               reduce using rule 41 (varYVals -> ID .)
    OR              reduce using rule 41 (varYVals -> ID .)
    [               shift and go to state 48

  ! ;               [ reduce using rule 68 (asig -> ID = ID .) ]

    m                              shift and go to state 47

state 125

    (69) finVarAsig -> ID = valores .

    ;               reduce using rule 69 (finVarAsig -> ID = valores .)


state 126

    (75) finVarAsig -> ID DIVEQ ID .
    (40) valores -> ID . . ID
    (41) varYVals -> ID .
    (43) vecVal -> ID . m
    (44) m -> . [ INT ]
    (45) m -> . [ INT ] m

  ! reduce/reduce conflict for ; resolved using rule 41 (varYVals -> ID .)
    .               shift and go to state 166
    MASMAS          reduce using rule 41 (varYVals -> ID .)
    MENOSMENOS      reduce using rule 41 (varYVals -> ID .)
    ;               reduce using rule 41 (varYVals -> ID .)
    +               reduce using rule 41 (varYVals -> ID .)
    ^               reduce using rule 41 (varYVals -> ID .)
    *               reduce using rule 41 (varYVals -> ID .)
    /               reduce using rule 41 (varYVals -> ID .)
    %               reduce using rule 41 (varYVals -> ID .)
    -               reduce using rule 41 (varYVals -> ID .)
    >               reduce using rule 41 (varYVals -> ID .)
    <               reduce using rule 41 (varYVals -> ID .)
    EQEQ            reduce using rule 41 (varYVals -> ID .)
    DISTINTO        reduce using rule 41 (varYVals -> ID .)
    AND             reduce using rule 41 (varYVals -> ID .)
    ?               reduce using rule 41 (varYVals -> ID .)
    OR              reduce using rule 41 (varYVals -> ID .)
    [               shift and go to state 48

  ! ;               [ reduce using rule 75 (finVarAsig -> ID DIVEQ ID .) ]

    m                              shift and go to state 47

state 127

    (74) finVarAsig -> ID DIVEQ valores .

    ;               reduce using rule 74 (finVarAsig -> ID DIVEQ valores .)


state 128

    (73) finVarAsig -> ID MULEQ ID .
    (53) varAsig -> ID . MULEQ varAsig
    (40) valores -> ID . . ID
    (62) masmenAsig -> ID . MASEQ masmenAsig
    (63) masmenAsig -> ID . MENOSEQ masmenAsig
    (64) masmenAsig -> ID . MASEQ ID
    (65) masmenAsig -> ID . MENOSEQ ID
    (69) finVarAsig -> ID . = valores
    (70) finVarAsig -> ID . MASEQ valores
    (71) finVarAsig -> ID . MENOSEQ valores
    (72) finVarAsig -> ID . MULEQ valores
    (73) finVarAsig -> ID . MULEQ ID
    (74) finVarAsig -> ID . DIVEQ valores
    (75) finVarAsig -> ID . DIVEQ ID
    (41) varYVals -> ID .
    (67) asig -> ID . = asig
    (68) asig -> ID . = ID
    (43) vecVal -> ID . m
    (44) m -> . [ INT ]
    (45) m -> . [ INT ] m

  ! reduce/reduce conflict for ; resolved using rule 41 (varYVals -> ID .)
    MULEQ           shift and go to state 51
    .               shift and go to state 166
    MASEQ           shift and go to state 46
    MENOSEQ         shift and go to state 45
    =               shift and go to state 49
    DIVEQ           shift and go to state 50
    MASMAS          reduce using rule 41 (varYVals -> ID .)
    MENOSMENOS      reduce using rule 41 (varYVals -> ID .)
    ;               reduce using rule 41 (varYVals -> ID .)
    +               reduce using rule 41 (varYVals -> ID .)
    ^               reduce using rule 41 (varYVals -> ID .)
    *               reduce using rule 41 (varYVals -> ID .)
    /               reduce using rule 41 (varYVals -> ID .)
    %               reduce using rule 41 (varYVals -> ID .)
    -               reduce using rule 41 (varYVals -> ID .)
    >               reduce using rule 41 (varYVals -> ID .)
    <               reduce using rule 41 (varYVals -> ID .)
    EQEQ            reduce using rule 41 (varYVals -> ID .)
    DISTINTO        reduce using rule 41 (varYVals -> ID .)
    AND             reduce using rule 41 (varYVals -> ID .)
    ?               reduce using rule 41 (varYVals -> ID .)
    OR              reduce using rule 41 (varYVals -> ID .)
    [               shift and go to state 48

  ! ;               [ reduce using rule 73 (finVarAsig -> ID MULEQ ID .) ]

    m                              shift and go to state 47

state 129

    (53) varAsig -> ID MULEQ varAsig .

    ;               reduce using rule 53 (varAsig -> ID MULEQ varAsig .)


state 130

    (72) finVarAsig -> ID MULEQ valores .

    ;               reduce using rule 72 (finVarAsig -> ID MULEQ valores .)


state 131

    (13) if -> IF ( expBool . ) bloque else

    )               shift and go to state 179


state 132

    (23) funcInt -> MULTIESCALAR ( vec . , eMat , param )

    ,               shift and go to state 180


state 133

    (25) funcString -> CAPITALIZAR ( expString . )
    (94) expString -> expString . + STRING

    )               shift and go to state 181
    +               shift and go to state 165


state 134

    (97) expString -> funcString .

    )               reduce using rule 97 (expString -> funcString .)
    +               reduce using rule 97 (expString -> funcString .)


state 135

    (96) expString -> varYVals .

    )               reduce using rule 96 (expString -> varYVals .)
    +               reduce using rule 96 (expString -> varYVals .)


state 136

    (24) funcInt -> LENGTH ( vec . )

    )               shift and go to state 182


state 137

    (11) loop -> DO bloque WHILE ( . expBool ) ;
    (98) expBool -> . or ? expBool : expBool
    (99) expBool -> . or
    (100) or -> . or OR and
    (101) or -> . and
    (102) and -> . and AND eq
    (103) and -> . eq
    (104) eq -> . eq EQEQ tBool
    (105) eq -> . eq DISTINTO tBool
    (106) eq -> . mayor
    (107) mayor -> . tCompare > tCompare
    (108) mayor -> . menor
    (117) tCompare -> . eMat
    (118) tCompare -> . varsOps
    (119) tCompare -> . varYVals
    (109) menor -> . tCompare < tCompare
    (110) menor -> . not
    (76) eMat -> . eMat + p
    (77) eMat -> . eMat - p
    (78) eMat -> . p
    (49) varsOps -> . MENOSMENOS varYVals
    (50) varsOps -> . MASMAS varYVals
    (51) varsOps -> . varYVals MASMAS
    (52) varsOps -> . varYVals MENOSMENOS
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (111) not -> . NOT not
    (112) not -> . tBool
    (79) p -> . p * exp
    (80) p -> . p / exp
    (81) p -> . p % exp
    (82) p -> . exp
    (43) vecVal -> . ID m
    (113) tBool -> . ( expBool )
    (114) tBool -> . BOOL
    (115) tBool -> . varYVals
    (116) tBool -> . funcBool
    (83) exp -> . exp ^ iSing
    (84) exp -> . iSing
    (26) funcBool -> . COLINEALES ( vec , vec )
    (85) iSing -> . - paren
    (86) iSing -> . + paren
    (87) iSing -> . paren
    (88) paren -> . ( eMat )
    (89) paren -> . INT
    (90) paren -> . varYVals
    (91) paren -> . FLOAT
    (92) paren -> . varsOps
    (93) paren -> . funcInt
    (23) funcInt -> . MULTIESCALAR ( vec , eMat , param )
    (24) funcInt -> . LENGTH ( vec )

    MENOSMENOS      shift and go to state 32
    MASMAS          shift and go to state 29
    ID              shift and go to state 58
    NOT             shift and go to state 87
    (               shift and go to state 73
    BOOL            shift and go to state 76
    COLINEALES      shift and go to state 14
    -               shift and go to state 75
    +               shift and go to state 74
    INT             shift and go to state 81
    FLOAT           shift and go to state 82
    MULTIESCALAR    shift and go to state 22
    LENGTH          shift and go to state 27

    and                            shift and go to state 66
    funcBool                       shift and go to state 67
    funcInt                        shift and go to state 68
    menor                          shift and go to state 69
    eq                             shift and go to state 70
    mayor                          shift and go to state 71
    eMat                           shift and go to state 72
    vecVal                         shift and go to state 9
    paren                          shift and go to state 79
    iSing                          shift and go to state 77
    tCompare                       shift and go to state 78
    not                            shift and go to state 80
    p                              shift and go to state 84
    varsOps                        shift and go to state 85
    exp                            shift and go to state 86
    tBool                          shift and go to state 88
    varYVals                       shift and go to state 89
    or                             shift and go to state 83
    expBool                        shift and go to state 183

state 138

    (17) bloque -> { g } .

    RETURN          reduce using rule 17 (bloque -> { g } .)
    MENOSMENOS      reduce using rule 17 (bloque -> { g } .)
    MASMAS          reduce using rule 17 (bloque -> { g } .)
    ID              reduce using rule 17 (bloque -> { g } .)
    IF              reduce using rule 17 (bloque -> { g } .)
    WHILE           reduce using rule 17 (bloque -> { g } .)
    DO              reduce using rule 17 (bloque -> { g } .)
    FOR             reduce using rule 17 (bloque -> { g } .)
    PRINT           reduce using rule 17 (bloque -> { g } .)
    MULTIESCALAR    reduce using rule 17 (bloque -> { g } .)
    LENGTH          reduce using rule 17 (bloque -> { g } .)
    CAPITALIZAR     reduce using rule 17 (bloque -> { g } .)
    COLINEALES      reduce using rule 17 (bloque -> { g } .)
    $end            reduce using rule 17 (bloque -> { g } .)
    }               reduce using rule 17 (bloque -> { g } .)
    ELSE            reduce using rule 17 (bloque -> { g } .)


state 139

    (102) and -> and AND . eq
    (104) eq -> . eq EQEQ tBool
    (105) eq -> . eq DISTINTO tBool
    (106) eq -> . mayor
    (107) mayor -> . tCompare > tCompare
    (108) mayor -> . menor
    (117) tCompare -> . eMat
    (118) tCompare -> . varsOps
    (119) tCompare -> . varYVals
    (109) menor -> . tCompare < tCompare
    (110) menor -> . not
    (76) eMat -> . eMat + p
    (77) eMat -> . eMat - p
    (78) eMat -> . p
    (49) varsOps -> . MENOSMENOS varYVals
    (50) varsOps -> . MASMAS varYVals
    (51) varsOps -> . varYVals MASMAS
    (52) varsOps -> . varYVals MENOSMENOS
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (111) not -> . NOT not
    (112) not -> . tBool
    (79) p -> . p * exp
    (80) p -> . p / exp
    (81) p -> . p % exp
    (82) p -> . exp
    (43) vecVal -> . ID m
    (113) tBool -> . ( expBool )
    (114) tBool -> . BOOL
    (115) tBool -> . varYVals
    (116) tBool -> . funcBool
    (83) exp -> . exp ^ iSing
    (84) exp -> . iSing
    (26) funcBool -> . COLINEALES ( vec , vec )
    (85) iSing -> . - paren
    (86) iSing -> . + paren
    (87) iSing -> . paren
    (88) paren -> . ( eMat )
    (89) paren -> . INT
    (90) paren -> . varYVals
    (91) paren -> . FLOAT
    (92) paren -> . varsOps
    (93) paren -> . funcInt
    (23) funcInt -> . MULTIESCALAR ( vec , eMat , param )
    (24) funcInt -> . LENGTH ( vec )

    MENOSMENOS      shift and go to state 32
    MASMAS          shift and go to state 29
    ID              shift and go to state 58
    NOT             shift and go to state 87
    (               shift and go to state 73
    BOOL            shift and go to state 76
    COLINEALES      shift and go to state 14
    -               shift and go to state 75
    +               shift and go to state 74
    INT             shift and go to state 81
    FLOAT           shift and go to state 82
    MULTIESCALAR    shift and go to state 22
    LENGTH          shift and go to state 27

    eMat                           shift and go to state 72
    funcBool                       shift and go to state 67
    p                              shift and go to state 84
    varYVals                       shift and go to state 89
    funcInt                        shift and go to state 68
    vecVal                         shift and go to state 9
    tCompare                       shift and go to state 78
    menor                          shift and go to state 69
    varsOps                        shift and go to state 85
    exp                            shift and go to state 86
    paren                          shift and go to state 79
    not                            shift and go to state 80
    tBool                          shift and go to state 88
    eq                             shift and go to state 184
    mayor                          shift and go to state 71
    iSing                          shift and go to state 77

state 140

    (104) eq -> eq EQEQ . tBool
    (113) tBool -> . ( expBool )
    (114) tBool -> . BOOL
    (115) tBool -> . varYVals
    (116) tBool -> . funcBool
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (26) funcBool -> . COLINEALES ( vec , vec )
    (43) vecVal -> . ID m

    (               shift and go to state 160
    BOOL            shift and go to state 76
    ID              shift and go to state 58
    COLINEALES      shift and go to state 14

    funcBool                       shift and go to state 67
    varYVals                       shift and go to state 162
    tBool                          shift and go to state 185
    vecVal                         shift and go to state 9

state 141

    (105) eq -> eq DISTINTO . tBool
    (113) tBool -> . ( expBool )
    (114) tBool -> . BOOL
    (115) tBool -> . varYVals
    (116) tBool -> . funcBool
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (26) funcBool -> . COLINEALES ( vec , vec )
    (43) vecVal -> . ID m

    (               shift and go to state 160
    BOOL            shift and go to state 76
    ID              shift and go to state 58
    COLINEALES      shift and go to state 14

    funcBool                       shift and go to state 67
    varYVals                       shift and go to state 162
    tBool                          shift and go to state 186
    vecVal                         shift and go to state 9

state 142

    (76) eMat -> eMat + . p
    (79) p -> . p * exp
    (80) p -> . p / exp
    (81) p -> . p % exp
    (82) p -> . exp
    (83) exp -> . exp ^ iSing
    (84) exp -> . iSing
    (85) iSing -> . - paren
    (86) iSing -> . + paren
    (87) iSing -> . paren
    (88) paren -> . ( eMat )
    (89) paren -> . INT
    (90) paren -> . varYVals
    (91) paren -> . FLOAT
    (92) paren -> . varsOps
    (93) paren -> . funcInt
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (49) varsOps -> . MENOSMENOS varYVals
    (50) varsOps -> . MASMAS varYVals
    (51) varsOps -> . varYVals MASMAS
    (52) varsOps -> . varYVals MENOSMENOS
    (23) funcInt -> . MULTIESCALAR ( vec , eMat , param )
    (24) funcInt -> . LENGTH ( vec )
    (43) vecVal -> . ID m

    -               shift and go to state 75
    +               shift and go to state 74
    (               shift and go to state 147
    INT             shift and go to state 81
    FLOAT           shift and go to state 82
    ID              shift and go to state 58
    MENOSMENOS      shift and go to state 32
    MASMAS          shift and go to state 29
    MULTIESCALAR    shift and go to state 22
    LENGTH          shift and go to state 27

    funcInt                        shift and go to state 68
    p                              shift and go to state 187
    iSing                          shift and go to state 77
    exp                            shift and go to state 86
    paren                          shift and go to state 79
    varYVals                       shift and go to state 150
    vecVal                         shift and go to state 9
    varsOps                        shift and go to state 148

state 143

    (77) eMat -> eMat - . p
    (79) p -> . p * exp
    (80) p -> . p / exp
    (81) p -> . p % exp
    (82) p -> . exp
    (83) exp -> . exp ^ iSing
    (84) exp -> . iSing
    (85) iSing -> . - paren
    (86) iSing -> . + paren
    (87) iSing -> . paren
    (88) paren -> . ( eMat )
    (89) paren -> . INT
    (90) paren -> . varYVals
    (91) paren -> . FLOAT
    (92) paren -> . varsOps
    (93) paren -> . funcInt
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (49) varsOps -> . MENOSMENOS varYVals
    (50) varsOps -> . MASMAS varYVals
    (51) varsOps -> . varYVals MASMAS
    (52) varsOps -> . varYVals MENOSMENOS
    (23) funcInt -> . MULTIESCALAR ( vec , eMat , param )
    (24) funcInt -> . LENGTH ( vec )
    (43) vecVal -> . ID m

    -               shift and go to state 75
    +               shift and go to state 74
    (               shift and go to state 147
    INT             shift and go to state 81
    FLOAT           shift and go to state 82
    ID              shift and go to state 58
    MENOSMENOS      shift and go to state 32
    MASMAS          shift and go to state 29
    MULTIESCALAR    shift and go to state 22
    LENGTH          shift and go to state 27

    funcInt                        shift and go to state 68
    p                              shift and go to state 188
    iSing                          shift and go to state 77
    exp                            shift and go to state 86
    paren                          shift and go to state 79
    varYVals                       shift and go to state 150
    vecVal                         shift and go to state 9
    varsOps                        shift and go to state 148

state 144

    (88) paren -> ( eMat . )
    (76) eMat -> eMat . + p
    (77) eMat -> eMat . - p
    (117) tCompare -> eMat .

    )               shift and go to state 189
    +               shift and go to state 142
    -               shift and go to state 143
    >               reduce using rule 117 (tCompare -> eMat .)
    <               reduce using rule 117 (tCompare -> eMat .)


state 145

    (90) paren -> varYVals .
    (119) tCompare -> varYVals .
    (51) varsOps -> varYVals . MASMAS
    (52) varsOps -> varYVals . MENOSMENOS
    (115) tBool -> varYVals .

  ! reduce/reduce conflict for > resolved using rule 90 (paren -> varYVals .)
  ! reduce/reduce conflict for < resolved using rule 90 (paren -> varYVals .)
  ! reduce/reduce conflict for ) resolved using rule 90 (paren -> varYVals .)
    ^               reduce using rule 90 (paren -> varYVals .)
    *               reduce using rule 90 (paren -> varYVals .)
    /               reduce using rule 90 (paren -> varYVals .)
    %               reduce using rule 90 (paren -> varYVals .)
    )               reduce using rule 90 (paren -> varYVals .)
    +               reduce using rule 90 (paren -> varYVals .)
    -               reduce using rule 90 (paren -> varYVals .)
    >               reduce using rule 90 (paren -> varYVals .)
    <               reduce using rule 90 (paren -> varYVals .)
    MASMAS          shift and go to state 60
    MENOSMENOS      shift and go to state 61
    EQEQ            reduce using rule 115 (tBool -> varYVals .)
    DISTINTO        reduce using rule 115 (tBool -> varYVals .)
    AND             reduce using rule 115 (tBool -> varYVals .)
    ?               reduce using rule 115 (tBool -> varYVals .)
    OR              reduce using rule 115 (tBool -> varYVals .)

  ! >               [ reduce using rule 119 (tCompare -> varYVals .) ]
  ! <               [ reduce using rule 119 (tCompare -> varYVals .) ]
  ! )               [ reduce using rule 115 (tBool -> varYVals .) ]


state 146

    (113) tBool -> ( expBool . )

    )               shift and go to state 190


state 147

    (88) paren -> ( . eMat )
    (76) eMat -> . eMat + p
    (77) eMat -> . eMat - p
    (78) eMat -> . p
    (79) p -> . p * exp
    (80) p -> . p / exp
    (81) p -> . p % exp
    (82) p -> . exp
    (83) exp -> . exp ^ iSing
    (84) exp -> . iSing
    (85) iSing -> . - paren
    (86) iSing -> . + paren
    (87) iSing -> . paren
    (88) paren -> . ( eMat )
    (89) paren -> . INT
    (90) paren -> . varYVals
    (91) paren -> . FLOAT
    (92) paren -> . varsOps
    (93) paren -> . funcInt
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (49) varsOps -> . MENOSMENOS varYVals
    (50) varsOps -> . MASMAS varYVals
    (51) varsOps -> . varYVals MASMAS
    (52) varsOps -> . varYVals MENOSMENOS
    (23) funcInt -> . MULTIESCALAR ( vec , eMat , param )
    (24) funcInt -> . LENGTH ( vec )
    (43) vecVal -> . ID m

    -               shift and go to state 75
    +               shift and go to state 74
    (               shift and go to state 147
    INT             shift and go to state 81
    FLOAT           shift and go to state 82
    ID              shift and go to state 58
    MENOSMENOS      shift and go to state 32
    MASMAS          shift and go to state 29
    MULTIESCALAR    shift and go to state 22
    LENGTH          shift and go to state 27

    eMat                           shift and go to state 191
    funcInt                        shift and go to state 68
    p                              shift and go to state 84
    iSing                          shift and go to state 77
    exp                            shift and go to state 86
    paren                          shift and go to state 79
    varYVals                       shift and go to state 150
    vecVal                         shift and go to state 9
    varsOps                        shift and go to state 148

state 148

    (92) paren -> varsOps .

    ^               reduce using rule 92 (paren -> varsOps .)
    *               reduce using rule 92 (paren -> varsOps .)
    /               reduce using rule 92 (paren -> varsOps .)
    %               reduce using rule 92 (paren -> varsOps .)
    +               reduce using rule 92 (paren -> varsOps .)
    -               reduce using rule 92 (paren -> varsOps .)
    >               reduce using rule 92 (paren -> varsOps .)
    <               reduce using rule 92 (paren -> varsOps .)
    )               reduce using rule 92 (paren -> varsOps .)
    ;               reduce using rule 92 (paren -> varsOps .)
    }               reduce using rule 92 (paren -> varsOps .)
    ,               reduce using rule 92 (paren -> varsOps .)
    ]               reduce using rule 92 (paren -> varsOps .)
    EQEQ            reduce using rule 92 (paren -> varsOps .)
    DISTINTO        reduce using rule 92 (paren -> varsOps .)
    AND             reduce using rule 92 (paren -> varsOps .)
    ?               reduce using rule 92 (paren -> varsOps .)
    OR              reduce using rule 92 (paren -> varsOps .)
    :               reduce using rule 92 (paren -> varsOps .)


state 149

    (86) iSing -> + paren .

    ^               reduce using rule 86 (iSing -> + paren .)
    *               reduce using rule 86 (iSing -> + paren .)
    /               reduce using rule 86 (iSing -> + paren .)
    %               reduce using rule 86 (iSing -> + paren .)
    +               reduce using rule 86 (iSing -> + paren .)
    -               reduce using rule 86 (iSing -> + paren .)
    >               reduce using rule 86 (iSing -> + paren .)
    <               reduce using rule 86 (iSing -> + paren .)
    EQEQ            reduce using rule 86 (iSing -> + paren .)
    DISTINTO        reduce using rule 86 (iSing -> + paren .)
    AND             reduce using rule 86 (iSing -> + paren .)
    ?               reduce using rule 86 (iSing -> + paren .)
    OR              reduce using rule 86 (iSing -> + paren .)
    )               reduce using rule 86 (iSing -> + paren .)
    ;               reduce using rule 86 (iSing -> + paren .)
    }               reduce using rule 86 (iSing -> + paren .)
    ,               reduce using rule 86 (iSing -> + paren .)
    ]               reduce using rule 86 (iSing -> + paren .)
    :               reduce using rule 86 (iSing -> + paren .)


state 150

    (90) paren -> varYVals .
    (51) varsOps -> varYVals . MASMAS
    (52) varsOps -> varYVals . MENOSMENOS

    ^               reduce using rule 90 (paren -> varYVals .)
    *               reduce using rule 90 (paren -> varYVals .)
    /               reduce using rule 90 (paren -> varYVals .)
    %               reduce using rule 90 (paren -> varYVals .)
    +               reduce using rule 90 (paren -> varYVals .)
    -               reduce using rule 90 (paren -> varYVals .)
    >               reduce using rule 90 (paren -> varYVals .)
    <               reduce using rule 90 (paren -> varYVals .)
    )               reduce using rule 90 (paren -> varYVals .)
    ;               reduce using rule 90 (paren -> varYVals .)
    }               reduce using rule 90 (paren -> varYVals .)
    ,               reduce using rule 90 (paren -> varYVals .)
    ]               reduce using rule 90 (paren -> varYVals .)
    EQEQ            reduce using rule 90 (paren -> varYVals .)
    DISTINTO        reduce using rule 90 (paren -> varYVals .)
    AND             reduce using rule 90 (paren -> varYVals .)
    ?               reduce using rule 90 (paren -> varYVals .)
    OR              reduce using rule 90 (paren -> varYVals .)
    :               reduce using rule 90 (paren -> varYVals .)
    MASMAS          shift and go to state 60
    MENOSMENOS      shift and go to state 61


state 151

    (85) iSing -> - paren .

    ^               reduce using rule 85 (iSing -> - paren .)
    *               reduce using rule 85 (iSing -> - paren .)
    /               reduce using rule 85 (iSing -> - paren .)
    %               reduce using rule 85 (iSing -> - paren .)
    +               reduce using rule 85 (iSing -> - paren .)
    -               reduce using rule 85 (iSing -> - paren .)
    >               reduce using rule 85 (iSing -> - paren .)
    <               reduce using rule 85 (iSing -> - paren .)
    EQEQ            reduce using rule 85 (iSing -> - paren .)
    DISTINTO        reduce using rule 85 (iSing -> - paren .)
    AND             reduce using rule 85 (iSing -> - paren .)
    ?               reduce using rule 85 (iSing -> - paren .)
    OR              reduce using rule 85 (iSing -> - paren .)
    )               reduce using rule 85 (iSing -> - paren .)
    ;               reduce using rule 85 (iSing -> - paren .)
    }               reduce using rule 85 (iSing -> - paren .)
    ,               reduce using rule 85 (iSing -> - paren .)
    ]               reduce using rule 85 (iSing -> - paren .)
    :               reduce using rule 85 (iSing -> - paren .)


state 152

    (109) menor -> tCompare < . tCompare
    (117) tCompare -> . eMat
    (118) tCompare -> . varsOps
    (119) tCompare -> . varYVals
    (76) eMat -> . eMat + p
    (77) eMat -> . eMat - p
    (78) eMat -> . p
    (49) varsOps -> . MENOSMENOS varYVals
    (50) varsOps -> . MASMAS varYVals
    (51) varsOps -> . varYVals MASMAS
    (52) varsOps -> . varYVals MENOSMENOS
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (79) p -> . p * exp
    (80) p -> . p / exp
    (81) p -> . p % exp
    (82) p -> . exp
    (43) vecVal -> . ID m
    (83) exp -> . exp ^ iSing
    (84) exp -> . iSing
    (85) iSing -> . - paren
    (86) iSing -> . + paren
    (87) iSing -> . paren
    (88) paren -> . ( eMat )
    (89) paren -> . INT
    (90) paren -> . varYVals
    (91) paren -> . FLOAT
    (92) paren -> . varsOps
    (93) paren -> . funcInt
    (23) funcInt -> . MULTIESCALAR ( vec , eMat , param )
    (24) funcInt -> . LENGTH ( vec )

    MENOSMENOS      shift and go to state 32
    MASMAS          shift and go to state 29
    ID              shift and go to state 58
    -               shift and go to state 75
    +               shift and go to state 74
    (               shift and go to state 147
    INT             shift and go to state 81
    FLOAT           shift and go to state 82
    MULTIESCALAR    shift and go to state 22
    LENGTH          shift and go to state 27

    eMat                           shift and go to state 72
    p                              shift and go to state 84
    funcInt                        shift and go to state 68
    tCompare                       shift and go to state 192
    varsOps                        shift and go to state 85
    exp                            shift and go to state 86
    paren                          shift and go to state 79
    varYVals                       shift and go to state 193
    vecVal                         shift and go to state 9
    iSing                          shift and go to state 77

state 153

    (107) mayor -> tCompare > . tCompare
    (117) tCompare -> . eMat
    (118) tCompare -> . varsOps
    (119) tCompare -> . varYVals
    (76) eMat -> . eMat + p
    (77) eMat -> . eMat - p
    (78) eMat -> . p
    (49) varsOps -> . MENOSMENOS varYVals
    (50) varsOps -> . MASMAS varYVals
    (51) varsOps -> . varYVals MASMAS
    (52) varsOps -> . varYVals MENOSMENOS
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (79) p -> . p * exp
    (80) p -> . p / exp
    (81) p -> . p % exp
    (82) p -> . exp
    (43) vecVal -> . ID m
    (83) exp -> . exp ^ iSing
    (84) exp -> . iSing
    (85) iSing -> . - paren
    (86) iSing -> . + paren
    (87) iSing -> . paren
    (88) paren -> . ( eMat )
    (89) paren -> . INT
    (90) paren -> . varYVals
    (91) paren -> . FLOAT
    (92) paren -> . varsOps
    (93) paren -> . funcInt
    (23) funcInt -> . MULTIESCALAR ( vec , eMat , param )
    (24) funcInt -> . LENGTH ( vec )

    MENOSMENOS      shift and go to state 32
    MASMAS          shift and go to state 29
    ID              shift and go to state 58
    -               shift and go to state 75
    +               shift and go to state 74
    (               shift and go to state 147
    INT             shift and go to state 81
    FLOAT           shift and go to state 82
    MULTIESCALAR    shift and go to state 22
    LENGTH          shift and go to state 27

    eMat                           shift and go to state 72
    p                              shift and go to state 84
    funcInt                        shift and go to state 68
    tCompare                       shift and go to state 194
    varsOps                        shift and go to state 85
    exp                            shift and go to state 86
    paren                          shift and go to state 79
    varYVals                       shift and go to state 193
    vecVal                         shift and go to state 9
    iSing                          shift and go to state 77

state 154

    (100) or -> or OR . and
    (102) and -> . and AND eq
    (103) and -> . eq
    (104) eq -> . eq EQEQ tBool
    (105) eq -> . eq DISTINTO tBool
    (106) eq -> . mayor
    (107) mayor -> . tCompare > tCompare
    (108) mayor -> . menor
    (117) tCompare -> . eMat
    (118) tCompare -> . varsOps
    (119) tCompare -> . varYVals
    (109) menor -> . tCompare < tCompare
    (110) menor -> . not
    (76) eMat -> . eMat + p
    (77) eMat -> . eMat - p
    (78) eMat -> . p
    (49) varsOps -> . MENOSMENOS varYVals
    (50) varsOps -> . MASMAS varYVals
    (51) varsOps -> . varYVals MASMAS
    (52) varsOps -> . varYVals MENOSMENOS
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (111) not -> . NOT not
    (112) not -> . tBool
    (79) p -> . p * exp
    (80) p -> . p / exp
    (81) p -> . p % exp
    (82) p -> . exp
    (43) vecVal -> . ID m
    (113) tBool -> . ( expBool )
    (114) tBool -> . BOOL
    (115) tBool -> . varYVals
    (116) tBool -> . funcBool
    (83) exp -> . exp ^ iSing
    (84) exp -> . iSing
    (26) funcBool -> . COLINEALES ( vec , vec )
    (85) iSing -> . - paren
    (86) iSing -> . + paren
    (87) iSing -> . paren
    (88) paren -> . ( eMat )
    (89) paren -> . INT
    (90) paren -> . varYVals
    (91) paren -> . FLOAT
    (92) paren -> . varsOps
    (93) paren -> . funcInt
    (23) funcInt -> . MULTIESCALAR ( vec , eMat , param )
    (24) funcInt -> . LENGTH ( vec )

    MENOSMENOS      shift and go to state 32
    MASMAS          shift and go to state 29
    ID              shift and go to state 58
    NOT             shift and go to state 87
    (               shift and go to state 73
    BOOL            shift and go to state 76
    COLINEALES      shift and go to state 14
    -               shift and go to state 75
    +               shift and go to state 74
    INT             shift and go to state 81
    FLOAT           shift and go to state 82
    MULTIESCALAR    shift and go to state 22
    LENGTH          shift and go to state 27

    and                            shift and go to state 195
    funcBool                       shift and go to state 67
    funcInt                        shift and go to state 68
    menor                          shift and go to state 69
    eq                             shift and go to state 70
    mayor                          shift and go to state 71
    eMat                           shift and go to state 72
    vecVal                         shift and go to state 9
    paren                          shift and go to state 79
    iSing                          shift and go to state 77
    tCompare                       shift and go to state 78
    not                            shift and go to state 80
    p                              shift and go to state 84
    varsOps                        shift and go to state 85
    exp                            shift and go to state 86
    tBool                          shift and go to state 88
    varYVals                       shift and go to state 89

state 155

    (98) expBool -> or ? . expBool : expBool
    (98) expBool -> . or ? expBool : expBool
    (99) expBool -> . or
    (100) or -> . or OR and
    (101) or -> . and
    (102) and -> . and AND eq
    (103) and -> . eq
    (104) eq -> . eq EQEQ tBool
    (105) eq -> . eq DISTINTO tBool
    (106) eq -> . mayor
    (107) mayor -> . tCompare > tCompare
    (108) mayor -> . menor
    (117) tCompare -> . eMat
    (118) tCompare -> . varsOps
    (119) tCompare -> . varYVals
    (109) menor -> . tCompare < tCompare
    (110) menor -> . not
    (76) eMat -> . eMat + p
    (77) eMat -> . eMat - p
    (78) eMat -> . p
    (49) varsOps -> . MENOSMENOS varYVals
    (50) varsOps -> . MASMAS varYVals
    (51) varsOps -> . varYVals MASMAS
    (52) varsOps -> . varYVals MENOSMENOS
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (111) not -> . NOT not
    (112) not -> . tBool
    (79) p -> . p * exp
    (80) p -> . p / exp
    (81) p -> . p % exp
    (82) p -> . exp
    (43) vecVal -> . ID m
    (113) tBool -> . ( expBool )
    (114) tBool -> . BOOL
    (115) tBool -> . varYVals
    (116) tBool -> . funcBool
    (83) exp -> . exp ^ iSing
    (84) exp -> . iSing
    (26) funcBool -> . COLINEALES ( vec , vec )
    (85) iSing -> . - paren
    (86) iSing -> . + paren
    (87) iSing -> . paren
    (88) paren -> . ( eMat )
    (89) paren -> . INT
    (90) paren -> . varYVals
    (91) paren -> . FLOAT
    (92) paren -> . varsOps
    (93) paren -> . funcInt
    (23) funcInt -> . MULTIESCALAR ( vec , eMat , param )
    (24) funcInt -> . LENGTH ( vec )

    MENOSMENOS      shift and go to state 32
    MASMAS          shift and go to state 29
    ID              shift and go to state 58
    NOT             shift and go to state 87
    (               shift and go to state 73
    BOOL            shift and go to state 76
    COLINEALES      shift and go to state 14
    -               shift and go to state 75
    +               shift and go to state 74
    INT             shift and go to state 81
    FLOAT           shift and go to state 82
    MULTIESCALAR    shift and go to state 22
    LENGTH          shift and go to state 27

    and                            shift and go to state 66
    funcBool                       shift and go to state 67
    funcInt                        shift and go to state 68
    menor                          shift and go to state 69
    eq                             shift and go to state 70
    mayor                          shift and go to state 71
    eMat                           shift and go to state 72
    vecVal                         shift and go to state 9
    paren                          shift and go to state 79
    iSing                          shift and go to state 77
    tCompare                       shift and go to state 78
    not                            shift and go to state 80
    p                              shift and go to state 84
    varsOps                        shift and go to state 85
    exp                            shift and go to state 86
    tBool                          shift and go to state 88
    varYVals                       shift and go to state 89
    or                             shift and go to state 83
    expBool                        shift and go to state 196

state 156

    (79) p -> p * . exp
    (83) exp -> . exp ^ iSing
    (84) exp -> . iSing
    (85) iSing -> . - paren
    (86) iSing -> . + paren
    (87) iSing -> . paren
    (88) paren -> . ( eMat )
    (89) paren -> . INT
    (90) paren -> . varYVals
    (91) paren -> . FLOAT
    (92) paren -> . varsOps
    (93) paren -> . funcInt
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (49) varsOps -> . MENOSMENOS varYVals
    (50) varsOps -> . MASMAS varYVals
    (51) varsOps -> . varYVals MASMAS
    (52) varsOps -> . varYVals MENOSMENOS
    (23) funcInt -> . MULTIESCALAR ( vec , eMat , param )
    (24) funcInt -> . LENGTH ( vec )
    (43) vecVal -> . ID m

    -               shift and go to state 75
    +               shift and go to state 74
    (               shift and go to state 147
    INT             shift and go to state 81
    FLOAT           shift and go to state 82
    ID              shift and go to state 58
    MENOSMENOS      shift and go to state 32
    MASMAS          shift and go to state 29
    MULTIESCALAR    shift and go to state 22
    LENGTH          shift and go to state 27

    funcInt                        shift and go to state 68
    iSing                          shift and go to state 77
    exp                            shift and go to state 197
    paren                          shift and go to state 79
    varYVals                       shift and go to state 150
    vecVal                         shift and go to state 9
    varsOps                        shift and go to state 148

state 157

    (81) p -> p % . exp
    (83) exp -> . exp ^ iSing
    (84) exp -> . iSing
    (85) iSing -> . - paren
    (86) iSing -> . + paren
    (87) iSing -> . paren
    (88) paren -> . ( eMat )
    (89) paren -> . INT
    (90) paren -> . varYVals
    (91) paren -> . FLOAT
    (92) paren -> . varsOps
    (93) paren -> . funcInt
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (49) varsOps -> . MENOSMENOS varYVals
    (50) varsOps -> . MASMAS varYVals
    (51) varsOps -> . varYVals MASMAS
    (52) varsOps -> . varYVals MENOSMENOS
    (23) funcInt -> . MULTIESCALAR ( vec , eMat , param )
    (24) funcInt -> . LENGTH ( vec )
    (43) vecVal -> . ID m

    -               shift and go to state 75
    +               shift and go to state 74
    (               shift and go to state 147
    INT             shift and go to state 81
    FLOAT           shift and go to state 82
    ID              shift and go to state 58
    MENOSMENOS      shift and go to state 32
    MASMAS          shift and go to state 29
    MULTIESCALAR    shift and go to state 22
    LENGTH          shift and go to state 27

    funcInt                        shift and go to state 68
    iSing                          shift and go to state 77
    exp                            shift and go to state 198
    paren                          shift and go to state 79
    varYVals                       shift and go to state 150
    vecVal                         shift and go to state 9
    varsOps                        shift and go to state 148

state 158

    (80) p -> p / . exp
    (83) exp -> . exp ^ iSing
    (84) exp -> . iSing
    (85) iSing -> . - paren
    (86) iSing -> . + paren
    (87) iSing -> . paren
    (88) paren -> . ( eMat )
    (89) paren -> . INT
    (90) paren -> . varYVals
    (91) paren -> . FLOAT
    (92) paren -> . varsOps
    (93) paren -> . funcInt
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (49) varsOps -> . MENOSMENOS varYVals
    (50) varsOps -> . MASMAS varYVals
    (51) varsOps -> . varYVals MASMAS
    (52) varsOps -> . varYVals MENOSMENOS
    (23) funcInt -> . MULTIESCALAR ( vec , eMat , param )
    (24) funcInt -> . LENGTH ( vec )
    (43) vecVal -> . ID m

    -               shift and go to state 75
    +               shift and go to state 74
    (               shift and go to state 147
    INT             shift and go to state 81
    FLOAT           shift and go to state 82
    ID              shift and go to state 58
    MENOSMENOS      shift and go to state 32
    MASMAS          shift and go to state 29
    MULTIESCALAR    shift and go to state 22
    LENGTH          shift and go to state 27

    funcInt                        shift and go to state 68
    iSing                          shift and go to state 77
    exp                            shift and go to state 199
    paren                          shift and go to state 79
    varYVals                       shift and go to state 150
    vecVal                         shift and go to state 9
    varsOps                        shift and go to state 148

state 159

    (83) exp -> exp ^ . iSing
    (85) iSing -> . - paren
    (86) iSing -> . + paren
    (87) iSing -> . paren
    (88) paren -> . ( eMat )
    (89) paren -> . INT
    (90) paren -> . varYVals
    (91) paren -> . FLOAT
    (92) paren -> . varsOps
    (93) paren -> . funcInt
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (49) varsOps -> . MENOSMENOS varYVals
    (50) varsOps -> . MASMAS varYVals
    (51) varsOps -> . varYVals MASMAS
    (52) varsOps -> . varYVals MENOSMENOS
    (23) funcInt -> . MULTIESCALAR ( vec , eMat , param )
    (24) funcInt -> . LENGTH ( vec )
    (43) vecVal -> . ID m

    -               shift and go to state 75
    +               shift and go to state 74
    (               shift and go to state 147
    INT             shift and go to state 81
    FLOAT           shift and go to state 82
    ID              shift and go to state 58
    MENOSMENOS      shift and go to state 32
    MASMAS          shift and go to state 29
    MULTIESCALAR    shift and go to state 22
    LENGTH          shift and go to state 27

    funcInt                        shift and go to state 68
    varsOps                        shift and go to state 148
    paren                          shift and go to state 79
    varYVals                       shift and go to state 150
    vecVal                         shift and go to state 9
    iSing                          shift and go to state 200

state 160

    (113) tBool -> ( . expBool )
    (98) expBool -> . or ? expBool : expBool
    (99) expBool -> . or
    (100) or -> . or OR and
    (101) or -> . and
    (102) and -> . and AND eq
    (103) and -> . eq
    (104) eq -> . eq EQEQ tBool
    (105) eq -> . eq DISTINTO tBool
    (106) eq -> . mayor
    (107) mayor -> . tCompare > tCompare
    (108) mayor -> . menor
    (117) tCompare -> . eMat
    (118) tCompare -> . varsOps
    (119) tCompare -> . varYVals
    (109) menor -> . tCompare < tCompare
    (110) menor -> . not
    (76) eMat -> . eMat + p
    (77) eMat -> . eMat - p
    (78) eMat -> . p
    (49) varsOps -> . MENOSMENOS varYVals
    (50) varsOps -> . MASMAS varYVals
    (51) varsOps -> . varYVals MASMAS
    (52) varsOps -> . varYVals MENOSMENOS
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (111) not -> . NOT not
    (112) not -> . tBool
    (79) p -> . p * exp
    (80) p -> . p / exp
    (81) p -> . p % exp
    (82) p -> . exp
    (43) vecVal -> . ID m
    (113) tBool -> . ( expBool )
    (114) tBool -> . BOOL
    (115) tBool -> . varYVals
    (116) tBool -> . funcBool
    (83) exp -> . exp ^ iSing
    (84) exp -> . iSing
    (26) funcBool -> . COLINEALES ( vec , vec )
    (85) iSing -> . - paren
    (86) iSing -> . + paren
    (87) iSing -> . paren
    (88) paren -> . ( eMat )
    (89) paren -> . INT
    (90) paren -> . varYVals
    (91) paren -> . FLOAT
    (92) paren -> . varsOps
    (93) paren -> . funcInt
    (23) funcInt -> . MULTIESCALAR ( vec , eMat , param )
    (24) funcInt -> . LENGTH ( vec )

    MENOSMENOS      shift and go to state 32
    MASMAS          shift and go to state 29
    ID              shift and go to state 58
    NOT             shift and go to state 87
    (               shift and go to state 73
    BOOL            shift and go to state 76
    COLINEALES      shift and go to state 14
    -               shift and go to state 75
    +               shift and go to state 74
    INT             shift and go to state 81
    FLOAT           shift and go to state 82
    MULTIESCALAR    shift and go to state 22
    LENGTH          shift and go to state 27

    and                            shift and go to state 66
    funcBool                       shift and go to state 67
    funcInt                        shift and go to state 68
    menor                          shift and go to state 69
    eq                             shift and go to state 70
    mayor                          shift and go to state 71
    eMat                           shift and go to state 72
    vecVal                         shift and go to state 9
    paren                          shift and go to state 79
    iSing                          shift and go to state 77
    tCompare                       shift and go to state 78
    not                            shift and go to state 80
    p                              shift and go to state 84
    varsOps                        shift and go to state 85
    exp                            shift and go to state 86
    tBool                          shift and go to state 88
    varYVals                       shift and go to state 89
    or                             shift and go to state 83
    expBool                        shift and go to state 146

state 161

    (111) not -> NOT not .

    EQEQ            reduce using rule 111 (not -> NOT not .)
    DISTINTO        reduce using rule 111 (not -> NOT not .)
    AND             reduce using rule 111 (not -> NOT not .)
    ?               reduce using rule 111 (not -> NOT not .)
    OR              reduce using rule 111 (not -> NOT not .)
    ;               reduce using rule 111 (not -> NOT not .)
    )               reduce using rule 111 (not -> NOT not .)
    }               reduce using rule 111 (not -> NOT not .)
    ,               reduce using rule 111 (not -> NOT not .)
    ]               reduce using rule 111 (not -> NOT not .)
    :               reduce using rule 111 (not -> NOT not .)


state 162

    (115) tBool -> varYVals .

    EQEQ            reduce using rule 115 (tBool -> varYVals .)
    DISTINTO        reduce using rule 115 (tBool -> varYVals .)
    AND             reduce using rule 115 (tBool -> varYVals .)
    ?               reduce using rule 115 (tBool -> varYVals .)
    OR              reduce using rule 115 (tBool -> varYVals .)
    )               reduce using rule 115 (tBool -> varYVals .)
    ;               reduce using rule 115 (tBool -> varYVals .)
    }               reduce using rule 115 (tBool -> varYVals .)
    ,               reduce using rule 115 (tBool -> varYVals .)
    ]               reduce using rule 115 (tBool -> varYVals .)
    :               reduce using rule 115 (tBool -> varYVals .)


state 163

    (10) loop -> WHILE ( expBool ) . bloque
    (16) bloque -> . sentencia ;
    (17) bloque -> . { g }
    (4) sentencia -> . varsOps ;
    (5) sentencia -> . func ;
    (6) sentencia -> . varAsig ;
    (7) sentencia -> . RETURN ;
    (49) varsOps -> . MENOSMENOS varYVals
    (50) varsOps -> . MASMAS varYVals
    (51) varsOps -> . varYVals MASMAS
    (52) varsOps -> . varYVals MENOSMENOS
    (18) func -> . funcReturn
    (19) func -> . funcVoid
    (53) varAsig -> . ID MULEQ varAsig
    (54) varAsig -> . masmenAsig MULEQ varAsig
    (55) varAsig -> . masmenAsig MULEQ ID
    (56) varAsig -> . masmenAsig MULEQ valores
    (57) varAsig -> . masmenAsig DIVEQ varAsig
    (58) varAsig -> . masmenAsig DIVEQ ID
    (59) varAsig -> . masmenAsig DIVEQ valores
    (60) varAsig -> . finVarAsig
    (61) varAsig -> . masmenAsig
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (20) funcReturn -> . funcInt
    (21) funcReturn -> . funcString
    (22) funcReturn -> . funcBool
    (27) funcVoid -> . PRINT ( valores )
    (62) masmenAsig -> . ID MASEQ masmenAsig
    (63) masmenAsig -> . ID MENOSEQ masmenAsig
    (64) masmenAsig -> . ID MASEQ ID
    (65) masmenAsig -> . ID MENOSEQ ID
    (66) masmenAsig -> . asig
    (69) finVarAsig -> . ID = valores
    (70) finVarAsig -> . ID MASEQ valores
    (71) finVarAsig -> . ID MENOSEQ valores
    (72) finVarAsig -> . ID MULEQ valores
    (73) finVarAsig -> . ID MULEQ ID
    (74) finVarAsig -> . ID DIVEQ valores
    (75) finVarAsig -> . ID DIVEQ ID
    (43) vecVal -> . ID m
    (23) funcInt -> . MULTIESCALAR ( vec , eMat , param )
    (24) funcInt -> . LENGTH ( vec )
    (25) funcString -> . CAPITALIZAR ( expString )
    (26) funcBool -> . COLINEALES ( vec , vec )
    (67) asig -> . ID = asig
    (68) asig -> . ID = ID

    {               shift and go to state 35
    RETURN          shift and go to state 2
    MENOSMENOS      shift and go to state 32
    MASMAS          shift and go to state 29
    ID              shift and go to state 17
    PRINT           shift and go to state 8
    MULTIESCALAR    shift and go to state 22
    LENGTH          shift and go to state 27
    CAPITALIZAR     shift and go to state 25
    COLINEALES      shift and go to state 14

    funcBool                       shift and go to state 3
    funcInt                        shift and go to state 5
    bloque                         shift and go to state 201
    vecVal                         shift and go to state 9
    sentencia                      shift and go to state 34
    asig                           shift and go to state 26
    masmenAsig                     shift and go to state 12
    funcVoid                       shift and go to state 13
    func                           shift and go to state 16
    varAsig                        shift and go to state 19
    funcString                     shift and go to state 21
    funcReturn                     shift and go to state 23
    finVarAsig                     shift and go to state 24
    varsOps                        shift and go to state 30
    varYVals                       shift and go to state 31

state 164

    (90) paren -> varYVals .
    (51) varsOps -> varYVals . MASMAS
    (52) varsOps -> varYVals . MENOSMENOS
    (119) tCompare -> varYVals .
    (115) tBool -> varYVals .

  ! reduce/reduce conflict for > resolved using rule 90 (paren -> varYVals .)
  ! reduce/reduce conflict for < resolved using rule 90 (paren -> varYVals .)
  ! reduce/reduce conflict for ) resolved using rule 90 (paren -> varYVals .)
    ^               reduce using rule 90 (paren -> varYVals .)
    *               reduce using rule 90 (paren -> varYVals .)
    /               reduce using rule 90 (paren -> varYVals .)
    %               reduce using rule 90 (paren -> varYVals .)
    )               reduce using rule 90 (paren -> varYVals .)
    +               reduce using rule 90 (paren -> varYVals .)
    -               reduce using rule 90 (paren -> varYVals .)
    >               reduce using rule 90 (paren -> varYVals .)
    <               reduce using rule 90 (paren -> varYVals .)
    MASMAS          shift and go to state 60
    MENOSMENOS      shift and go to state 61
    EQEQ            reduce using rule 115 (tBool -> varYVals .)
    DISTINTO        reduce using rule 115 (tBool -> varYVals .)
    AND             reduce using rule 115 (tBool -> varYVals .)
    ?               reduce using rule 115 (tBool -> varYVals .)
    OR              reduce using rule 115 (tBool -> varYVals .)

  ! >               [ reduce using rule 119 (tCompare -> varYVals .) ]
  ! <               [ reduce using rule 119 (tCompare -> varYVals .) ]
  ! )               [ reduce using rule 115 (tBool -> varYVals .) ]


state 165

    (94) expString -> expString + . STRING

    STRING          shift and go to state 202


state 166

    (40) valores -> ID . . ID

    ID              shift and go to state 203


state 167

    (27) funcVoid -> PRINT ( valores ) .

    ;               reduce using rule 27 (funcVoid -> PRINT ( valores ) .)


state 168

    (46) reg -> { campos . }

    }               shift and go to state 204


state 169

    (47) campos -> ID . : valores , campos
    (40) valores -> ID . . ID
    (41) varYVals -> ID .
    (43) vecVal -> ID . m
    (44) m -> . [ INT ]
    (45) m -> . [ INT ] m

    :               shift and go to state 205
    .               shift and go to state 166
    MASMAS          reduce using rule 41 (varYVals -> ID .)
    MENOSMENOS      reduce using rule 41 (varYVals -> ID .)
    }               reduce using rule 41 (varYVals -> ID .)
    +               reduce using rule 41 (varYVals -> ID .)
    ^               reduce using rule 41 (varYVals -> ID .)
    *               reduce using rule 41 (varYVals -> ID .)
    /               reduce using rule 41 (varYVals -> ID .)
    %               reduce using rule 41 (varYVals -> ID .)
    -               reduce using rule 41 (varYVals -> ID .)
    >               reduce using rule 41 (varYVals -> ID .)
    <               reduce using rule 41 (varYVals -> ID .)
    EQEQ            reduce using rule 41 (varYVals -> ID .)
    DISTINTO        reduce using rule 41 (varYVals -> ID .)
    AND             reduce using rule 41 (varYVals -> ID .)
    ?               reduce using rule 41 (varYVals -> ID .)
    OR              reduce using rule 41 (varYVals -> ID .)
    [               shift and go to state 48

    m                              shift and go to state 47

state 170

    (48) campos -> valores .

    }               reduce using rule 48 (campos -> valores .)


state 171

    (26) funcBool -> COLINEALES ( vec , . vec )
    (31) vec -> . [ elem ]

    [               shift and go to state 113

    vec                            shift and go to state 206

state 172

    (32) elem -> valores . , elem
    (33) elem -> valores .

    ,               shift and go to state 207
    ]               reduce using rule 33 (elem -> valores .)


state 173

    (31) vec -> [ elem . ]

    ]               shift and go to state 208


state 174

    (12) loop -> FOR ( varAsig ; . expBool ; varsOps ) bloque
    (98) expBool -> . or ? expBool : expBool
    (99) expBool -> . or
    (100) or -> . or OR and
    (101) or -> . and
    (102) and -> . and AND eq
    (103) and -> . eq
    (104) eq -> . eq EQEQ tBool
    (105) eq -> . eq DISTINTO tBool
    (106) eq -> . mayor
    (107) mayor -> . tCompare > tCompare
    (108) mayor -> . menor
    (117) tCompare -> . eMat
    (118) tCompare -> . varsOps
    (119) tCompare -> . varYVals
    (109) menor -> . tCompare < tCompare
    (110) menor -> . not
    (76) eMat -> . eMat + p
    (77) eMat -> . eMat - p
    (78) eMat -> . p
    (49) varsOps -> . MENOSMENOS varYVals
    (50) varsOps -> . MASMAS varYVals
    (51) varsOps -> . varYVals MASMAS
    (52) varsOps -> . varYVals MENOSMENOS
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (111) not -> . NOT not
    (112) not -> . tBool
    (79) p -> . p * exp
    (80) p -> . p / exp
    (81) p -> . p % exp
    (82) p -> . exp
    (43) vecVal -> . ID m
    (113) tBool -> . ( expBool )
    (114) tBool -> . BOOL
    (115) tBool -> . varYVals
    (116) tBool -> . funcBool
    (83) exp -> . exp ^ iSing
    (84) exp -> . iSing
    (26) funcBool -> . COLINEALES ( vec , vec )
    (85) iSing -> . - paren
    (86) iSing -> . + paren
    (87) iSing -> . paren
    (88) paren -> . ( eMat )
    (89) paren -> . INT
    (90) paren -> . varYVals
    (91) paren -> . FLOAT
    (92) paren -> . varsOps
    (93) paren -> . funcInt
    (23) funcInt -> . MULTIESCALAR ( vec , eMat , param )
    (24) funcInt -> . LENGTH ( vec )

    MENOSMENOS      shift and go to state 32
    MASMAS          shift and go to state 29
    ID              shift and go to state 58
    NOT             shift and go to state 87
    (               shift and go to state 73
    BOOL            shift and go to state 76
    COLINEALES      shift and go to state 14
    -               shift and go to state 75
    +               shift and go to state 74
    INT             shift and go to state 81
    FLOAT           shift and go to state 82
    MULTIESCALAR    shift and go to state 22
    LENGTH          shift and go to state 27

    and                            shift and go to state 66
    funcBool                       shift and go to state 67
    funcInt                        shift and go to state 68
    menor                          shift and go to state 69
    eq                             shift and go to state 70
    mayor                          shift and go to state 71
    eMat                           shift and go to state 72
    vecVal                         shift and go to state 9
    paren                          shift and go to state 79
    iSing                          shift and go to state 77
    tCompare                       shift and go to state 78
    not                            shift and go to state 80
    p                              shift and go to state 84
    varsOps                        shift and go to state 85
    exp                            shift and go to state 86
    tBool                          shift and go to state 88
    varYVals                       shift and go to state 89
    or                             shift and go to state 83
    expBool                        shift and go to state 209

state 175

    (63) masmenAsig -> ID MENOSEQ . masmenAsig
    (65) masmenAsig -> ID MENOSEQ . ID
    (62) masmenAsig -> . ID MASEQ masmenAsig
    (63) masmenAsig -> . ID MENOSEQ masmenAsig
    (64) masmenAsig -> . ID MASEQ ID
    (65) masmenAsig -> . ID MENOSEQ ID
    (66) masmenAsig -> . asig
    (67) asig -> . ID = asig
    (68) asig -> . ID = ID

    ID              shift and go to state 210

    asig                           shift and go to state 26
    masmenAsig                     shift and go to state 116

state 176

    (62) masmenAsig -> ID MASEQ . masmenAsig
    (64) masmenAsig -> ID MASEQ . ID
    (62) masmenAsig -> . ID MASEQ masmenAsig
    (63) masmenAsig -> . ID MENOSEQ masmenAsig
    (64) masmenAsig -> . ID MASEQ ID
    (65) masmenAsig -> . ID MENOSEQ ID
    (66) masmenAsig -> . asig
    (67) asig -> . ID = asig
    (68) asig -> . ID = ID

    ID              shift and go to state 211

    asig                           shift and go to state 26
    masmenAsig                     shift and go to state 119

state 177

    (67) asig -> ID = . asig
    (68) asig -> ID = . ID
    (67) asig -> . ID = asig
    (68) asig -> . ID = ID

    ID              shift and go to state 212

    asig                           shift and go to state 123

state 178

    (44) m -> [ INT ] .
    (45) m -> [ INT ] . m
    (44) m -> . [ INT ]
    (45) m -> . [ INT ] m

    MASMAS          reduce using rule 44 (m -> [ INT ] .)
    MENOSMENOS      reduce using rule 44 (m -> [ INT ] .)
    )               reduce using rule 44 (m -> [ INT ] .)
    +               reduce using rule 44 (m -> [ INT ] .)
    ^               reduce using rule 44 (m -> [ INT ] .)
    *               reduce using rule 44 (m -> [ INT ] .)
    /               reduce using rule 44 (m -> [ INT ] .)
    %               reduce using rule 44 (m -> [ INT ] .)
    -               reduce using rule 44 (m -> [ INT ] .)
    >               reduce using rule 44 (m -> [ INT ] .)
    <               reduce using rule 44 (m -> [ INT ] .)
    EQEQ            reduce using rule 44 (m -> [ INT ] .)
    DISTINTO        reduce using rule 44 (m -> [ INT ] .)
    AND             reduce using rule 44 (m -> [ INT ] .)
    ?               reduce using rule 44 (m -> [ INT ] .)
    OR              reduce using rule 44 (m -> [ INT ] .)
    ,               reduce using rule 44 (m -> [ INT ] .)
    ]               reduce using rule 44 (m -> [ INT ] .)
    }               reduce using rule 44 (m -> [ INT ] .)
    ;               reduce using rule 44 (m -> [ INT ] .)
    :               reduce using rule 44 (m -> [ INT ] .)
    [               shift and go to state 48

    m                              shift and go to state 213

state 179

    (13) if -> IF ( expBool ) . bloque else
    (16) bloque -> . sentencia ;
    (17) bloque -> . { g }
    (4) sentencia -> . varsOps ;
    (5) sentencia -> . func ;
    (6) sentencia -> . varAsig ;
    (7) sentencia -> . RETURN ;
    (49) varsOps -> . MENOSMENOS varYVals
    (50) varsOps -> . MASMAS varYVals
    (51) varsOps -> . varYVals MASMAS
    (52) varsOps -> . varYVals MENOSMENOS
    (18) func -> . funcReturn
    (19) func -> . funcVoid
    (53) varAsig -> . ID MULEQ varAsig
    (54) varAsig -> . masmenAsig MULEQ varAsig
    (55) varAsig -> . masmenAsig MULEQ ID
    (56) varAsig -> . masmenAsig MULEQ valores
    (57) varAsig -> . masmenAsig DIVEQ varAsig
    (58) varAsig -> . masmenAsig DIVEQ ID
    (59) varAsig -> . masmenAsig DIVEQ valores
    (60) varAsig -> . finVarAsig
    (61) varAsig -> . masmenAsig
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (20) funcReturn -> . funcInt
    (21) funcReturn -> . funcString
    (22) funcReturn -> . funcBool
    (27) funcVoid -> . PRINT ( valores )
    (62) masmenAsig -> . ID MASEQ masmenAsig
    (63) masmenAsig -> . ID MENOSEQ masmenAsig
    (64) masmenAsig -> . ID MASEQ ID
    (65) masmenAsig -> . ID MENOSEQ ID
    (66) masmenAsig -> . asig
    (69) finVarAsig -> . ID = valores
    (70) finVarAsig -> . ID MASEQ valores
    (71) finVarAsig -> . ID MENOSEQ valores
    (72) finVarAsig -> . ID MULEQ valores
    (73) finVarAsig -> . ID MULEQ ID
    (74) finVarAsig -> . ID DIVEQ valores
    (75) finVarAsig -> . ID DIVEQ ID
    (43) vecVal -> . ID m
    (23) funcInt -> . MULTIESCALAR ( vec , eMat , param )
    (24) funcInt -> . LENGTH ( vec )
    (25) funcString -> . CAPITALIZAR ( expString )
    (26) funcBool -> . COLINEALES ( vec , vec )
    (67) asig -> . ID = asig
    (68) asig -> . ID = ID

    {               shift and go to state 35
    RETURN          shift and go to state 2
    MENOSMENOS      shift and go to state 32
    MASMAS          shift and go to state 29
    ID              shift and go to state 17
    PRINT           shift and go to state 8
    MULTIESCALAR    shift and go to state 22
    LENGTH          shift and go to state 27
    CAPITALIZAR     shift and go to state 25
    COLINEALES      shift and go to state 14

    funcBool                       shift and go to state 3
    funcInt                        shift and go to state 5
    bloque                         shift and go to state 214
    vecVal                         shift and go to state 9
    sentencia                      shift and go to state 34
    asig                           shift and go to state 26
    masmenAsig                     shift and go to state 12
    funcVoid                       shift and go to state 13
    func                           shift and go to state 16
    varAsig                        shift and go to state 19
    funcString                     shift and go to state 21
    funcReturn                     shift and go to state 23
    finVarAsig                     shift and go to state 24
    varsOps                        shift and go to state 30
    varYVals                       shift and go to state 31

state 180

    (23) funcInt -> MULTIESCALAR ( vec , . eMat , param )
    (76) eMat -> . eMat + p
    (77) eMat -> . eMat - p
    (78) eMat -> . p
    (79) p -> . p * exp
    (80) p -> . p / exp
    (81) p -> . p % exp
    (82) p -> . exp
    (83) exp -> . exp ^ iSing
    (84) exp -> . iSing
    (85) iSing -> . - paren
    (86) iSing -> . + paren
    (87) iSing -> . paren
    (88) paren -> . ( eMat )
    (89) paren -> . INT
    (90) paren -> . varYVals
    (91) paren -> . FLOAT
    (92) paren -> . varsOps
    (93) paren -> . funcInt
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (49) varsOps -> . MENOSMENOS varYVals
    (50) varsOps -> . MASMAS varYVals
    (51) varsOps -> . varYVals MASMAS
    (52) varsOps -> . varYVals MENOSMENOS
    (23) funcInt -> . MULTIESCALAR ( vec , eMat , param )
    (24) funcInt -> . LENGTH ( vec )
    (43) vecVal -> . ID m

    -               shift and go to state 75
    +               shift and go to state 74
    (               shift and go to state 147
    INT             shift and go to state 81
    FLOAT           shift and go to state 82
    ID              shift and go to state 58
    MENOSMENOS      shift and go to state 32
    MASMAS          shift and go to state 29
    MULTIESCALAR    shift and go to state 22
    LENGTH          shift and go to state 27

    eMat                           shift and go to state 215
    funcInt                        shift and go to state 68
    p                              shift and go to state 84
    iSing                          shift and go to state 77
    exp                            shift and go to state 86
    paren                          shift and go to state 79
    varsOps                        shift and go to state 148
    varYVals                       shift and go to state 150
    vecVal                         shift and go to state 9

state 181

    (25) funcString -> CAPITALIZAR ( expString ) .

    +               reduce using rule 25 (funcString -> CAPITALIZAR ( expString ) .)
    )               reduce using rule 25 (funcString -> CAPITALIZAR ( expString ) .)
    ;               reduce using rule 25 (funcString -> CAPITALIZAR ( expString ) .)
    ,               reduce using rule 25 (funcString -> CAPITALIZAR ( expString ) .)
    ]               reduce using rule 25 (funcString -> CAPITALIZAR ( expString ) .)
    }               reduce using rule 25 (funcString -> CAPITALIZAR ( expString ) .)


state 182

    (24) funcInt -> LENGTH ( vec ) .

    ;               reduce using rule 24 (funcInt -> LENGTH ( vec ) .)
    ^               reduce using rule 24 (funcInt -> LENGTH ( vec ) .)
    *               reduce using rule 24 (funcInt -> LENGTH ( vec ) .)
    /               reduce using rule 24 (funcInt -> LENGTH ( vec ) .)
    %               reduce using rule 24 (funcInt -> LENGTH ( vec ) .)
    +               reduce using rule 24 (funcInt -> LENGTH ( vec ) .)
    -               reduce using rule 24 (funcInt -> LENGTH ( vec ) .)
    >               reduce using rule 24 (funcInt -> LENGTH ( vec ) .)
    <               reduce using rule 24 (funcInt -> LENGTH ( vec ) .)
    )               reduce using rule 24 (funcInt -> LENGTH ( vec ) .)
    }               reduce using rule 24 (funcInt -> LENGTH ( vec ) .)
    ,               reduce using rule 24 (funcInt -> LENGTH ( vec ) .)
    ]               reduce using rule 24 (funcInt -> LENGTH ( vec ) .)
    EQEQ            reduce using rule 24 (funcInt -> LENGTH ( vec ) .)
    DISTINTO        reduce using rule 24 (funcInt -> LENGTH ( vec ) .)
    AND             reduce using rule 24 (funcInt -> LENGTH ( vec ) .)
    ?               reduce using rule 24 (funcInt -> LENGTH ( vec ) .)
    OR              reduce using rule 24 (funcInt -> LENGTH ( vec ) .)
    :               reduce using rule 24 (funcInt -> LENGTH ( vec ) .)


state 183

    (11) loop -> DO bloque WHILE ( expBool . ) ;

    )               shift and go to state 216


state 184

    (102) and -> and AND eq .
    (104) eq -> eq . EQEQ tBool
    (105) eq -> eq . DISTINTO tBool

    AND             reduce using rule 102 (and -> and AND eq .)
    ?               reduce using rule 102 (and -> and AND eq .)
    OR              reduce using rule 102 (and -> and AND eq .)
    }               reduce using rule 102 (and -> and AND eq .)
    ,               reduce using rule 102 (and -> and AND eq .)
    ]               reduce using rule 102 (and -> and AND eq .)
    )               reduce using rule 102 (and -> and AND eq .)
    ;               reduce using rule 102 (and -> and AND eq .)
    :               reduce using rule 102 (and -> and AND eq .)
    EQEQ            shift and go to state 140
    DISTINTO        shift and go to state 141


state 185

    (104) eq -> eq EQEQ tBool .

    EQEQ            reduce using rule 104 (eq -> eq EQEQ tBool .)
    DISTINTO        reduce using rule 104 (eq -> eq EQEQ tBool .)
    AND             reduce using rule 104 (eq -> eq EQEQ tBool .)
    ?               reduce using rule 104 (eq -> eq EQEQ tBool .)
    OR              reduce using rule 104 (eq -> eq EQEQ tBool .)
    )               reduce using rule 104 (eq -> eq EQEQ tBool .)
    }               reduce using rule 104 (eq -> eq EQEQ tBool .)
    ;               reduce using rule 104 (eq -> eq EQEQ tBool .)
    ,               reduce using rule 104 (eq -> eq EQEQ tBool .)
    ]               reduce using rule 104 (eq -> eq EQEQ tBool .)
    :               reduce using rule 104 (eq -> eq EQEQ tBool .)


state 186

    (105) eq -> eq DISTINTO tBool .

    EQEQ            reduce using rule 105 (eq -> eq DISTINTO tBool .)
    DISTINTO        reduce using rule 105 (eq -> eq DISTINTO tBool .)
    AND             reduce using rule 105 (eq -> eq DISTINTO tBool .)
    ?               reduce using rule 105 (eq -> eq DISTINTO tBool .)
    OR              reduce using rule 105 (eq -> eq DISTINTO tBool .)
    )               reduce using rule 105 (eq -> eq DISTINTO tBool .)
    }               reduce using rule 105 (eq -> eq DISTINTO tBool .)
    ;               reduce using rule 105 (eq -> eq DISTINTO tBool .)
    ,               reduce using rule 105 (eq -> eq DISTINTO tBool .)
    ]               reduce using rule 105 (eq -> eq DISTINTO tBool .)
    :               reduce using rule 105 (eq -> eq DISTINTO tBool .)


state 187

    (76) eMat -> eMat + p .
    (79) p -> p . * exp
    (80) p -> p . / exp
    (81) p -> p . % exp

    +               reduce using rule 76 (eMat -> eMat + p .)
    -               reduce using rule 76 (eMat -> eMat + p .)
    >               reduce using rule 76 (eMat -> eMat + p .)
    <               reduce using rule 76 (eMat -> eMat + p .)
    )               reduce using rule 76 (eMat -> eMat + p .)
    ,               reduce using rule 76 (eMat -> eMat + p .)
    ]               reduce using rule 76 (eMat -> eMat + p .)
    ;               reduce using rule 76 (eMat -> eMat + p .)
    EQEQ            reduce using rule 76 (eMat -> eMat + p .)
    DISTINTO        reduce using rule 76 (eMat -> eMat + p .)
    AND             reduce using rule 76 (eMat -> eMat + p .)
    ?               reduce using rule 76 (eMat -> eMat + p .)
    OR              reduce using rule 76 (eMat -> eMat + p .)
    }               reduce using rule 76 (eMat -> eMat + p .)
    :               reduce using rule 76 (eMat -> eMat + p .)
    *               shift and go to state 156
    /               shift and go to state 158
    %               shift and go to state 157


state 188

    (77) eMat -> eMat - p .
    (79) p -> p . * exp
    (80) p -> p . / exp
    (81) p -> p . % exp

    +               reduce using rule 77 (eMat -> eMat - p .)
    -               reduce using rule 77 (eMat -> eMat - p .)
    >               reduce using rule 77 (eMat -> eMat - p .)
    <               reduce using rule 77 (eMat -> eMat - p .)
    )               reduce using rule 77 (eMat -> eMat - p .)
    ,               reduce using rule 77 (eMat -> eMat - p .)
    ]               reduce using rule 77 (eMat -> eMat - p .)
    ;               reduce using rule 77 (eMat -> eMat - p .)
    EQEQ            reduce using rule 77 (eMat -> eMat - p .)
    DISTINTO        reduce using rule 77 (eMat -> eMat - p .)
    AND             reduce using rule 77 (eMat -> eMat - p .)
    ?               reduce using rule 77 (eMat -> eMat - p .)
    OR              reduce using rule 77 (eMat -> eMat - p .)
    }               reduce using rule 77 (eMat -> eMat - p .)
    :               reduce using rule 77 (eMat -> eMat - p .)
    *               shift and go to state 156
    /               shift and go to state 158
    %               shift and go to state 157


state 189

    (88) paren -> ( eMat ) .

    ^               reduce using rule 88 (paren -> ( eMat ) .)
    *               reduce using rule 88 (paren -> ( eMat ) .)
    /               reduce using rule 88 (paren -> ( eMat ) .)
    %               reduce using rule 88 (paren -> ( eMat ) .)
    +               reduce using rule 88 (paren -> ( eMat ) .)
    -               reduce using rule 88 (paren -> ( eMat ) .)
    >               reduce using rule 88 (paren -> ( eMat ) .)
    <               reduce using rule 88 (paren -> ( eMat ) .)
    )               reduce using rule 88 (paren -> ( eMat ) .)
    ;               reduce using rule 88 (paren -> ( eMat ) .)
    }               reduce using rule 88 (paren -> ( eMat ) .)
    ,               reduce using rule 88 (paren -> ( eMat ) .)
    ]               reduce using rule 88 (paren -> ( eMat ) .)
    EQEQ            reduce using rule 88 (paren -> ( eMat ) .)
    DISTINTO        reduce using rule 88 (paren -> ( eMat ) .)
    AND             reduce using rule 88 (paren -> ( eMat ) .)
    ?               reduce using rule 88 (paren -> ( eMat ) .)
    OR              reduce using rule 88 (paren -> ( eMat ) .)
    :               reduce using rule 88 (paren -> ( eMat ) .)


state 190

    (113) tBool -> ( expBool ) .

    EQEQ            reduce using rule 113 (tBool -> ( expBool ) .)
    DISTINTO        reduce using rule 113 (tBool -> ( expBool ) .)
    AND             reduce using rule 113 (tBool -> ( expBool ) .)
    ?               reduce using rule 113 (tBool -> ( expBool ) .)
    OR              reduce using rule 113 (tBool -> ( expBool ) .)
    )               reduce using rule 113 (tBool -> ( expBool ) .)
    ;               reduce using rule 113 (tBool -> ( expBool ) .)
    }               reduce using rule 113 (tBool -> ( expBool ) .)
    ,               reduce using rule 113 (tBool -> ( expBool ) .)
    ]               reduce using rule 113 (tBool -> ( expBool ) .)
    :               reduce using rule 113 (tBool -> ( expBool ) .)


state 191

    (88) paren -> ( eMat . )
    (76) eMat -> eMat . + p
    (77) eMat -> eMat . - p

    )               shift and go to state 189
    +               shift and go to state 142
    -               shift and go to state 143


state 192

    (109) menor -> tCompare < tCompare .

    EQEQ            reduce using rule 109 (menor -> tCompare < tCompare .)
    DISTINTO        reduce using rule 109 (menor -> tCompare < tCompare .)
    AND             reduce using rule 109 (menor -> tCompare < tCompare .)
    ?               reduce using rule 109 (menor -> tCompare < tCompare .)
    OR              reduce using rule 109 (menor -> tCompare < tCompare .)
    }               reduce using rule 109 (menor -> tCompare < tCompare .)
    )               reduce using rule 109 (menor -> tCompare < tCompare .)
    ;               reduce using rule 109 (menor -> tCompare < tCompare .)
    ,               reduce using rule 109 (menor -> tCompare < tCompare .)
    ]               reduce using rule 109 (menor -> tCompare < tCompare .)
    :               reduce using rule 109 (menor -> tCompare < tCompare .)


state 193

    (119) tCompare -> varYVals .
    (51) varsOps -> varYVals . MASMAS
    (52) varsOps -> varYVals . MENOSMENOS
    (90) paren -> varYVals .

  ! reduce/reduce conflict for EQEQ resolved using rule 90 (paren -> varYVals .)
  ! reduce/reduce conflict for DISTINTO resolved using rule 90 (paren -> varYVals .)
  ! reduce/reduce conflict for AND resolved using rule 90 (paren -> varYVals .)
  ! reduce/reduce conflict for ? resolved using rule 90 (paren -> varYVals .)
  ! reduce/reduce conflict for OR resolved using rule 90 (paren -> varYVals .)
  ! reduce/reduce conflict for ) resolved using rule 90 (paren -> varYVals .)
  ! reduce/reduce conflict for ; resolved using rule 90 (paren -> varYVals .)
  ! reduce/reduce conflict for } resolved using rule 90 (paren -> varYVals .)
  ! reduce/reduce conflict for , resolved using rule 90 (paren -> varYVals .)
  ! reduce/reduce conflict for ] resolved using rule 90 (paren -> varYVals .)
  ! reduce/reduce conflict for : resolved using rule 90 (paren -> varYVals .)
    MASMAS          shift and go to state 60
    MENOSMENOS      shift and go to state 61
    ^               reduce using rule 90 (paren -> varYVals .)
    *               reduce using rule 90 (paren -> varYVals .)
    /               reduce using rule 90 (paren -> varYVals .)
    %               reduce using rule 90 (paren -> varYVals .)
    +               reduce using rule 90 (paren -> varYVals .)
    -               reduce using rule 90 (paren -> varYVals .)
    EQEQ            reduce using rule 90 (paren -> varYVals .)
    DISTINTO        reduce using rule 90 (paren -> varYVals .)
    AND             reduce using rule 90 (paren -> varYVals .)
    ?               reduce using rule 90 (paren -> varYVals .)
    OR              reduce using rule 90 (paren -> varYVals .)
    )               reduce using rule 90 (paren -> varYVals .)
    ;               reduce using rule 90 (paren -> varYVals .)
    }               reduce using rule 90 (paren -> varYVals .)
    ,               reduce using rule 90 (paren -> varYVals .)
    ]               reduce using rule 90 (paren -> varYVals .)
    :               reduce using rule 90 (paren -> varYVals .)

  ! EQEQ            [ reduce using rule 119 (tCompare -> varYVals .) ]
  ! DISTINTO        [ reduce using rule 119 (tCompare -> varYVals .) ]
  ! AND             [ reduce using rule 119 (tCompare -> varYVals .) ]
  ! ?               [ reduce using rule 119 (tCompare -> varYVals .) ]
  ! OR              [ reduce using rule 119 (tCompare -> varYVals .) ]
  ! )               [ reduce using rule 119 (tCompare -> varYVals .) ]
  ! ;               [ reduce using rule 119 (tCompare -> varYVals .) ]
  ! }               [ reduce using rule 119 (tCompare -> varYVals .) ]
  ! ,               [ reduce using rule 119 (tCompare -> varYVals .) ]
  ! ]               [ reduce using rule 119 (tCompare -> varYVals .) ]
  ! :               [ reduce using rule 119 (tCompare -> varYVals .) ]


state 194

    (107) mayor -> tCompare > tCompare .

    EQEQ            reduce using rule 107 (mayor -> tCompare > tCompare .)
    DISTINTO        reduce using rule 107 (mayor -> tCompare > tCompare .)
    AND             reduce using rule 107 (mayor -> tCompare > tCompare .)
    ?               reduce using rule 107 (mayor -> tCompare > tCompare .)
    OR              reduce using rule 107 (mayor -> tCompare > tCompare .)
    ;               reduce using rule 107 (mayor -> tCompare > tCompare .)
    :               reduce using rule 107 (mayor -> tCompare > tCompare .)
    )               reduce using rule 107 (mayor -> tCompare > tCompare .)
    }               reduce using rule 107 (mayor -> tCompare > tCompare .)
    ,               reduce using rule 107 (mayor -> tCompare > tCompare .)
    ]               reduce using rule 107 (mayor -> tCompare > tCompare .)


state 195

    (100) or -> or OR and .
    (102) and -> and . AND eq

    ?               reduce using rule 100 (or -> or OR and .)
    OR              reduce using rule 100 (or -> or OR and .)
    )               reduce using rule 100 (or -> or OR and .)
    ;               reduce using rule 100 (or -> or OR and .)
    ,               reduce using rule 100 (or -> or OR and .)
    ]               reduce using rule 100 (or -> or OR and .)
    :               reduce using rule 100 (or -> or OR and .)
    }               reduce using rule 100 (or -> or OR and .)
    AND             shift and go to state 139


state 196

    (98) expBool -> or ? expBool . : expBool

    :               shift and go to state 217


state 197

    (79) p -> p * exp .
    (83) exp -> exp . ^ iSing

    *               reduce using rule 79 (p -> p * exp .)
    /               reduce using rule 79 (p -> p * exp .)
    %               reduce using rule 79 (p -> p * exp .)
    +               reduce using rule 79 (p -> p * exp .)
    -               reduce using rule 79 (p -> p * exp .)
    >               reduce using rule 79 (p -> p * exp .)
    <               reduce using rule 79 (p -> p * exp .)
    )               reduce using rule 79 (p -> p * exp .)
    ,               reduce using rule 79 (p -> p * exp .)
    ]               reduce using rule 79 (p -> p * exp .)
    ;               reduce using rule 79 (p -> p * exp .)
    }               reduce using rule 79 (p -> p * exp .)
    EQEQ            reduce using rule 79 (p -> p * exp .)
    DISTINTO        reduce using rule 79 (p -> p * exp .)
    AND             reduce using rule 79 (p -> p * exp .)
    ?               reduce using rule 79 (p -> p * exp .)
    OR              reduce using rule 79 (p -> p * exp .)
    :               reduce using rule 79 (p -> p * exp .)
    ^               shift and go to state 159


state 198

    (81) p -> p % exp .
    (83) exp -> exp . ^ iSing

    *               reduce using rule 81 (p -> p % exp .)
    /               reduce using rule 81 (p -> p % exp .)
    %               reduce using rule 81 (p -> p % exp .)
    +               reduce using rule 81 (p -> p % exp .)
    -               reduce using rule 81 (p -> p % exp .)
    >               reduce using rule 81 (p -> p % exp .)
    <               reduce using rule 81 (p -> p % exp .)
    )               reduce using rule 81 (p -> p % exp .)
    ,               reduce using rule 81 (p -> p % exp .)
    ]               reduce using rule 81 (p -> p % exp .)
    ;               reduce using rule 81 (p -> p % exp .)
    }               reduce using rule 81 (p -> p % exp .)
    EQEQ            reduce using rule 81 (p -> p % exp .)
    DISTINTO        reduce using rule 81 (p -> p % exp .)
    AND             reduce using rule 81 (p -> p % exp .)
    ?               reduce using rule 81 (p -> p % exp .)
    OR              reduce using rule 81 (p -> p % exp .)
    :               reduce using rule 81 (p -> p % exp .)
    ^               shift and go to state 159


state 199

    (80) p -> p / exp .
    (83) exp -> exp . ^ iSing

    *               reduce using rule 80 (p -> p / exp .)
    /               reduce using rule 80 (p -> p / exp .)
    %               reduce using rule 80 (p -> p / exp .)
    +               reduce using rule 80 (p -> p / exp .)
    -               reduce using rule 80 (p -> p / exp .)
    >               reduce using rule 80 (p -> p / exp .)
    <               reduce using rule 80 (p -> p / exp .)
    )               reduce using rule 80 (p -> p / exp .)
    ,               reduce using rule 80 (p -> p / exp .)
    ]               reduce using rule 80 (p -> p / exp .)
    ;               reduce using rule 80 (p -> p / exp .)
    }               reduce using rule 80 (p -> p / exp .)
    EQEQ            reduce using rule 80 (p -> p / exp .)
    DISTINTO        reduce using rule 80 (p -> p / exp .)
    AND             reduce using rule 80 (p -> p / exp .)
    ?               reduce using rule 80 (p -> p / exp .)
    OR              reduce using rule 80 (p -> p / exp .)
    :               reduce using rule 80 (p -> p / exp .)
    ^               shift and go to state 159


state 200

    (83) exp -> exp ^ iSing .

    ^               reduce using rule 83 (exp -> exp ^ iSing .)
    *               reduce using rule 83 (exp -> exp ^ iSing .)
    /               reduce using rule 83 (exp -> exp ^ iSing .)
    %               reduce using rule 83 (exp -> exp ^ iSing .)
    +               reduce using rule 83 (exp -> exp ^ iSing .)
    -               reduce using rule 83 (exp -> exp ^ iSing .)
    }               reduce using rule 83 (exp -> exp ^ iSing .)
    >               reduce using rule 83 (exp -> exp ^ iSing .)
    <               reduce using rule 83 (exp -> exp ^ iSing .)
    ;               reduce using rule 83 (exp -> exp ^ iSing .)
    ,               reduce using rule 83 (exp -> exp ^ iSing .)
    ]               reduce using rule 83 (exp -> exp ^ iSing .)
    )               reduce using rule 83 (exp -> exp ^ iSing .)
    EQEQ            reduce using rule 83 (exp -> exp ^ iSing .)
    DISTINTO        reduce using rule 83 (exp -> exp ^ iSing .)
    AND             reduce using rule 83 (exp -> exp ^ iSing .)
    ?               reduce using rule 83 (exp -> exp ^ iSing .)
    OR              reduce using rule 83 (exp -> exp ^ iSing .)
    :               reduce using rule 83 (exp -> exp ^ iSing .)


state 201

    (10) loop -> WHILE ( expBool ) bloque .

    RETURN          reduce using rule 10 (loop -> WHILE ( expBool ) bloque .)
    MENOSMENOS      reduce using rule 10 (loop -> WHILE ( expBool ) bloque .)
    MASMAS          reduce using rule 10 (loop -> WHILE ( expBool ) bloque .)
    ID              reduce using rule 10 (loop -> WHILE ( expBool ) bloque .)
    IF              reduce using rule 10 (loop -> WHILE ( expBool ) bloque .)
    WHILE           reduce using rule 10 (loop -> WHILE ( expBool ) bloque .)
    DO              reduce using rule 10 (loop -> WHILE ( expBool ) bloque .)
    FOR             reduce using rule 10 (loop -> WHILE ( expBool ) bloque .)
    PRINT           reduce using rule 10 (loop -> WHILE ( expBool ) bloque .)
    MULTIESCALAR    reduce using rule 10 (loop -> WHILE ( expBool ) bloque .)
    LENGTH          reduce using rule 10 (loop -> WHILE ( expBool ) bloque .)
    CAPITALIZAR     reduce using rule 10 (loop -> WHILE ( expBool ) bloque .)
    COLINEALES      reduce using rule 10 (loop -> WHILE ( expBool ) bloque .)
    $end            reduce using rule 10 (loop -> WHILE ( expBool ) bloque .)
    }               reduce using rule 10 (loop -> WHILE ( expBool ) bloque .)


state 202

    (94) expString -> expString + STRING .

    +               reduce using rule 94 (expString -> expString + STRING .)
    ;               reduce using rule 94 (expString -> expString + STRING .)
    ,               reduce using rule 94 (expString -> expString + STRING .)
    ]               reduce using rule 94 (expString -> expString + STRING .)
    )               reduce using rule 94 (expString -> expString + STRING .)
    }               reduce using rule 94 (expString -> expString + STRING .)


state 203

    (40) valores -> ID . ID .

    ;               reduce using rule 40 (valores -> ID . ID .)
    ,               reduce using rule 40 (valores -> ID . ID .)
    ]               reduce using rule 40 (valores -> ID . ID .)
    }               reduce using rule 40 (valores -> ID . ID .)
    )               reduce using rule 40 (valores -> ID . ID .)


state 204

    (46) reg -> { campos } .

    }               reduce using rule 46 (reg -> { campos } .)
    )               reduce using rule 46 (reg -> { campos } .)
    ;               reduce using rule 46 (reg -> { campos } .)
    ,               reduce using rule 46 (reg -> { campos } .)
    ]               reduce using rule 46 (reg -> { campos } .)


state 205

    (47) campos -> ID : . valores , campos
    (34) valores -> . eMat
    (35) valores -> . expBool
    (36) valores -> . expString
    (37) valores -> . varYVals
    (38) valores -> . funcReturn
    (39) valores -> . reg
    (40) valores -> . ID . ID
    (76) eMat -> . eMat + p
    (77) eMat -> . eMat - p
    (78) eMat -> . p
    (98) expBool -> . or ? expBool : expBool
    (99) expBool -> . or
    (94) expString -> . expString + STRING
    (95) expString -> . STRING
    (96) expString -> . varYVals
    (97) expString -> . funcString
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (20) funcReturn -> . funcInt
    (21) funcReturn -> . funcString
    (22) funcReturn -> . funcBool
    (46) reg -> . { campos }
    (79) p -> . p * exp
    (80) p -> . p / exp
    (81) p -> . p % exp
    (82) p -> . exp
    (100) or -> . or OR and
    (101) or -> . and
    (25) funcString -> . CAPITALIZAR ( expString )
    (43) vecVal -> . ID m
    (23) funcInt -> . MULTIESCALAR ( vec , eMat , param )
    (24) funcInt -> . LENGTH ( vec )
    (26) funcBool -> . COLINEALES ( vec , vec )
    (83) exp -> . exp ^ iSing
    (84) exp -> . iSing
    (102) and -> . and AND eq
    (103) and -> . eq
    (85) iSing -> . - paren
    (86) iSing -> . + paren
    (87) iSing -> . paren
    (104) eq -> . eq EQEQ tBool
    (105) eq -> . eq DISTINTO tBool
    (106) eq -> . mayor
    (88) paren -> . ( eMat )
    (89) paren -> . INT
    (90) paren -> . varYVals
    (91) paren -> . FLOAT
    (92) paren -> . varsOps
    (93) paren -> . funcInt
    (107) mayor -> . tCompare > tCompare
    (108) mayor -> . menor
    (49) varsOps -> . MENOSMENOS varYVals
    (50) varsOps -> . MASMAS varYVals
    (51) varsOps -> . varYVals MASMAS
    (52) varsOps -> . varYVals MENOSMENOS
    (117) tCompare -> . eMat
    (118) tCompare -> . varsOps
    (119) tCompare -> . varYVals
    (109) menor -> . tCompare < tCompare
    (110) menor -> . not
    (111) not -> . NOT not
    (112) not -> . tBool
    (113) tBool -> . ( expBool )
    (114) tBool -> . BOOL
    (115) tBool -> . varYVals
    (116) tBool -> . funcBool

    ID              shift and go to state 99
    STRING          shift and go to state 97
    {               shift and go to state 103
    CAPITALIZAR     shift and go to state 25
    MULTIESCALAR    shift and go to state 22
    LENGTH          shift and go to state 27
    COLINEALES      shift and go to state 14
    -               shift and go to state 75
    +               shift and go to state 74
    (               shift and go to state 94
    INT             shift and go to state 81
    FLOAT           shift and go to state 82
    MENOSMENOS      shift and go to state 32
    MASMAS          shift and go to state 29
    NOT             shift and go to state 87
    BOOL            shift and go to state 76

    and                            shift and go to state 66
    funcBool                       shift and go to state 91
    funcInt                        shift and go to state 92
    menor                          shift and go to state 69
    eq                             shift and go to state 70
    vecVal                         shift and go to state 9
    eMat                           shift and go to state 93
    mayor                          shift and go to state 71
    paren                          shift and go to state 79
    reg                            shift and go to state 95
    varsOps                        shift and go to state 96
    expString                      shift and go to state 98
    tCompare                       shift and go to state 78
    not                            shift and go to state 80
    funcString                     shift and go to state 100
    funcReturn                     shift and go to state 101
    valores                        shift and go to state 218
    p                              shift and go to state 84
    iSing                          shift and go to state 77
    exp                            shift and go to state 86
    tBool                          shift and go to state 88
    varYVals                       shift and go to state 104
    or                             shift and go to state 83
    expBool                        shift and go to state 105

state 206

    (26) funcBool -> COLINEALES ( vec , vec . )

    )               shift and go to state 219


state 207

    (32) elem -> valores , . elem
    (32) elem -> . valores , elem
    (33) elem -> . valores
    (34) valores -> . eMat
    (35) valores -> . expBool
    (36) valores -> . expString
    (37) valores -> . varYVals
    (38) valores -> . funcReturn
    (39) valores -> . reg
    (40) valores -> . ID . ID
    (76) eMat -> . eMat + p
    (77) eMat -> . eMat - p
    (78) eMat -> . p
    (98) expBool -> . or ? expBool : expBool
    (99) expBool -> . or
    (94) expString -> . expString + STRING
    (95) expString -> . STRING
    (96) expString -> . varYVals
    (97) expString -> . funcString
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (20) funcReturn -> . funcInt
    (21) funcReturn -> . funcString
    (22) funcReturn -> . funcBool
    (46) reg -> . { campos }
    (79) p -> . p * exp
    (80) p -> . p / exp
    (81) p -> . p % exp
    (82) p -> . exp
    (100) or -> . or OR and
    (101) or -> . and
    (25) funcString -> . CAPITALIZAR ( expString )
    (43) vecVal -> . ID m
    (23) funcInt -> . MULTIESCALAR ( vec , eMat , param )
    (24) funcInt -> . LENGTH ( vec )
    (26) funcBool -> . COLINEALES ( vec , vec )
    (83) exp -> . exp ^ iSing
    (84) exp -> . iSing
    (102) and -> . and AND eq
    (103) and -> . eq
    (85) iSing -> . - paren
    (86) iSing -> . + paren
    (87) iSing -> . paren
    (104) eq -> . eq EQEQ tBool
    (105) eq -> . eq DISTINTO tBool
    (106) eq -> . mayor
    (88) paren -> . ( eMat )
    (89) paren -> . INT
    (90) paren -> . varYVals
    (91) paren -> . FLOAT
    (92) paren -> . varsOps
    (93) paren -> . funcInt
    (107) mayor -> . tCompare > tCompare
    (108) mayor -> . menor
    (49) varsOps -> . MENOSMENOS varYVals
    (50) varsOps -> . MASMAS varYVals
    (51) varsOps -> . varYVals MASMAS
    (52) varsOps -> . varYVals MENOSMENOS
    (117) tCompare -> . eMat
    (118) tCompare -> . varsOps
    (119) tCompare -> . varYVals
    (109) menor -> . tCompare < tCompare
    (110) menor -> . not
    (111) not -> . NOT not
    (112) not -> . tBool
    (113) tBool -> . ( expBool )
    (114) tBool -> . BOOL
    (115) tBool -> . varYVals
    (116) tBool -> . funcBool

    ID              shift and go to state 99
    STRING          shift and go to state 97
    {               shift and go to state 103
    CAPITALIZAR     shift and go to state 25
    MULTIESCALAR    shift and go to state 22
    LENGTH          shift and go to state 27
    COLINEALES      shift and go to state 14
    -               shift and go to state 75
    +               shift and go to state 74
    (               shift and go to state 94
    INT             shift and go to state 81
    FLOAT           shift and go to state 82
    MENOSMENOS      shift and go to state 32
    MASMAS          shift and go to state 29
    NOT             shift and go to state 87
    BOOL            shift and go to state 76

    and                            shift and go to state 66
    funcBool                       shift and go to state 91
    funcInt                        shift and go to state 92
    elem                           shift and go to state 220
    menor                          shift and go to state 69
    eq                             shift and go to state 70
    vecVal                         shift and go to state 9
    eMat                           shift and go to state 93
    mayor                          shift and go to state 71
    paren                          shift and go to state 79
    reg                            shift and go to state 95
    varsOps                        shift and go to state 96
    expString                      shift and go to state 98
    tCompare                       shift and go to state 78
    not                            shift and go to state 80
    funcString                     shift and go to state 100
    funcReturn                     shift and go to state 101
    valores                        shift and go to state 172
    p                              shift and go to state 84
    iSing                          shift and go to state 77
    exp                            shift and go to state 86
    tBool                          shift and go to state 88
    varYVals                       shift and go to state 104
    or                             shift and go to state 83
    expBool                        shift and go to state 105

state 208

    (31) vec -> [ elem ] .

    ,               reduce using rule 31 (vec -> [ elem ] .)
    )               reduce using rule 31 (vec -> [ elem ] .)


state 209

    (12) loop -> FOR ( varAsig ; expBool . ; varsOps ) bloque

    ;               shift and go to state 221


state 210

    (65) masmenAsig -> ID MENOSEQ ID .
    (62) masmenAsig -> ID . MASEQ masmenAsig
    (63) masmenAsig -> ID . MENOSEQ masmenAsig
    (64) masmenAsig -> ID . MASEQ ID
    (65) masmenAsig -> ID . MENOSEQ ID
    (67) asig -> ID . = asig
    (68) asig -> ID . = ID

    MULEQ           reduce using rule 65 (masmenAsig -> ID MENOSEQ ID .)
    DIVEQ           reduce using rule 65 (masmenAsig -> ID MENOSEQ ID .)
    ;               reduce using rule 65 (masmenAsig -> ID MENOSEQ ID .)
    MASEQ           shift and go to state 176
    MENOSEQ         shift and go to state 175
    =               shift and go to state 177


state 211

    (64) masmenAsig -> ID MASEQ ID .
    (62) masmenAsig -> ID . MASEQ masmenAsig
    (63) masmenAsig -> ID . MENOSEQ masmenAsig
    (64) masmenAsig -> ID . MASEQ ID
    (65) masmenAsig -> ID . MENOSEQ ID
    (67) asig -> ID . = asig
    (68) asig -> ID . = ID

    MULEQ           reduce using rule 64 (masmenAsig -> ID MASEQ ID .)
    DIVEQ           reduce using rule 64 (masmenAsig -> ID MASEQ ID .)
    ;               reduce using rule 64 (masmenAsig -> ID MASEQ ID .)
    MASEQ           shift and go to state 176
    MENOSEQ         shift and go to state 175
    =               shift and go to state 177


state 212

    (68) asig -> ID = ID .
    (67) asig -> ID . = asig
    (68) asig -> ID . = ID

    MULEQ           reduce using rule 68 (asig -> ID = ID .)
    DIVEQ           reduce using rule 68 (asig -> ID = ID .)
    ;               reduce using rule 68 (asig -> ID = ID .)
    =               shift and go to state 177


state 213

    (45) m -> [ INT ] m .

    MASMAS          reduce using rule 45 (m -> [ INT ] m .)
    MENOSMENOS      reduce using rule 45 (m -> [ INT ] m .)
    )               reduce using rule 45 (m -> [ INT ] m .)
    +               reduce using rule 45 (m -> [ INT ] m .)
    ^               reduce using rule 45 (m -> [ INT ] m .)
    *               reduce using rule 45 (m -> [ INT ] m .)
    /               reduce using rule 45 (m -> [ INT ] m .)
    %               reduce using rule 45 (m -> [ INT ] m .)
    -               reduce using rule 45 (m -> [ INT ] m .)
    >               reduce using rule 45 (m -> [ INT ] m .)
    <               reduce using rule 45 (m -> [ INT ] m .)
    EQEQ            reduce using rule 45 (m -> [ INT ] m .)
    DISTINTO        reduce using rule 45 (m -> [ INT ] m .)
    AND             reduce using rule 45 (m -> [ INT ] m .)
    ?               reduce using rule 45 (m -> [ INT ] m .)
    OR              reduce using rule 45 (m -> [ INT ] m .)
    ,               reduce using rule 45 (m -> [ INT ] m .)
    ]               reduce using rule 45 (m -> [ INT ] m .)
    }               reduce using rule 45 (m -> [ INT ] m .)
    ;               reduce using rule 45 (m -> [ INT ] m .)
    :               reduce using rule 45 (m -> [ INT ] m .)


state 214

    (13) if -> IF ( expBool ) bloque . else
    (14) else -> . ELSE bloque
    (15) else -> . empty
    (30) empty -> .

    ELSE            shift and go to state 224
    RETURN          reduce using rule 30 (empty -> .)
    MENOSMENOS      reduce using rule 30 (empty -> .)
    MASMAS          reduce using rule 30 (empty -> .)
    ID              reduce using rule 30 (empty -> .)
    IF              reduce using rule 30 (empty -> .)
    WHILE           reduce using rule 30 (empty -> .)
    DO              reduce using rule 30 (empty -> .)
    FOR             reduce using rule 30 (empty -> .)
    PRINT           reduce using rule 30 (empty -> .)
    MULTIESCALAR    reduce using rule 30 (empty -> .)
    LENGTH          reduce using rule 30 (empty -> .)
    CAPITALIZAR     reduce using rule 30 (empty -> .)
    COLINEALES      reduce using rule 30 (empty -> .)
    $end            reduce using rule 30 (empty -> .)
    }               reduce using rule 30 (empty -> .)

    empty                          shift and go to state 223
    else                           shift and go to state 222

state 215

    (23) funcInt -> MULTIESCALAR ( vec , eMat . , param )
    (76) eMat -> eMat . + p
    (77) eMat -> eMat . - p

    ,               shift and go to state 225
    +               shift and go to state 142
    -               shift and go to state 143


state 216

    (11) loop -> DO bloque WHILE ( expBool ) . ;

    ;               shift and go to state 226


state 217

    (98) expBool -> or ? expBool : . expBool
    (98) expBool -> . or ? expBool : expBool
    (99) expBool -> . or
    (100) or -> . or OR and
    (101) or -> . and
    (102) and -> . and AND eq
    (103) and -> . eq
    (104) eq -> . eq EQEQ tBool
    (105) eq -> . eq DISTINTO tBool
    (106) eq -> . mayor
    (107) mayor -> . tCompare > tCompare
    (108) mayor -> . menor
    (117) tCompare -> . eMat
    (118) tCompare -> . varsOps
    (119) tCompare -> . varYVals
    (109) menor -> . tCompare < tCompare
    (110) menor -> . not
    (76) eMat -> . eMat + p
    (77) eMat -> . eMat - p
    (78) eMat -> . p
    (49) varsOps -> . MENOSMENOS varYVals
    (50) varsOps -> . MASMAS varYVals
    (51) varsOps -> . varYVals MASMAS
    (52) varsOps -> . varYVals MENOSMENOS
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (111) not -> . NOT not
    (112) not -> . tBool
    (79) p -> . p * exp
    (80) p -> . p / exp
    (81) p -> . p % exp
    (82) p -> . exp
    (43) vecVal -> . ID m
    (113) tBool -> . ( expBool )
    (114) tBool -> . BOOL
    (115) tBool -> . varYVals
    (116) tBool -> . funcBool
    (83) exp -> . exp ^ iSing
    (84) exp -> . iSing
    (26) funcBool -> . COLINEALES ( vec , vec )
    (85) iSing -> . - paren
    (86) iSing -> . + paren
    (87) iSing -> . paren
    (88) paren -> . ( eMat )
    (89) paren -> . INT
    (90) paren -> . varYVals
    (91) paren -> . FLOAT
    (92) paren -> . varsOps
    (93) paren -> . funcInt
    (23) funcInt -> . MULTIESCALAR ( vec , eMat , param )
    (24) funcInt -> . LENGTH ( vec )

    MENOSMENOS      shift and go to state 32
    MASMAS          shift and go to state 29
    ID              shift and go to state 58
    NOT             shift and go to state 87
    (               shift and go to state 73
    BOOL            shift and go to state 76
    COLINEALES      shift and go to state 14
    -               shift and go to state 75
    +               shift and go to state 74
    INT             shift and go to state 81
    FLOAT           shift and go to state 82
    MULTIESCALAR    shift and go to state 22
    LENGTH          shift and go to state 27

    and                            shift and go to state 66
    funcBool                       shift and go to state 67
    funcInt                        shift and go to state 68
    menor                          shift and go to state 69
    eq                             shift and go to state 70
    mayor                          shift and go to state 71
    eMat                           shift and go to state 72
    vecVal                         shift and go to state 9
    paren                          shift and go to state 79
    iSing                          shift and go to state 77
    tCompare                       shift and go to state 78
    not                            shift and go to state 80
    p                              shift and go to state 84
    varsOps                        shift and go to state 85
    exp                            shift and go to state 86
    tBool                          shift and go to state 88
    varYVals                       shift and go to state 89
    or                             shift and go to state 83
    expBool                        shift and go to state 227

state 218

    (47) campos -> ID : valores . , campos

    ,               shift and go to state 228


state 219

    (26) funcBool -> COLINEALES ( vec , vec ) .

    ,               reduce using rule 26 (funcBool -> COLINEALES ( vec , vec ) .)
    ]               reduce using rule 26 (funcBool -> COLINEALES ( vec , vec ) .)
    EQEQ            reduce using rule 26 (funcBool -> COLINEALES ( vec , vec ) .)
    DISTINTO        reduce using rule 26 (funcBool -> COLINEALES ( vec , vec ) .)
    AND             reduce using rule 26 (funcBool -> COLINEALES ( vec , vec ) .)
    ?               reduce using rule 26 (funcBool -> COLINEALES ( vec , vec ) .)
    OR              reduce using rule 26 (funcBool -> COLINEALES ( vec , vec ) .)
    ;               reduce using rule 26 (funcBool -> COLINEALES ( vec , vec ) .)
    }               reduce using rule 26 (funcBool -> COLINEALES ( vec , vec ) .)
    )               reduce using rule 26 (funcBool -> COLINEALES ( vec , vec ) .)
    :               reduce using rule 26 (funcBool -> COLINEALES ( vec , vec ) .)


state 220

    (32) elem -> valores , elem .

    ]               reduce using rule 32 (elem -> valores , elem .)


state 221

    (12) loop -> FOR ( varAsig ; expBool ; . varsOps ) bloque
    (49) varsOps -> . MENOSMENOS varYVals
    (50) varsOps -> . MASMAS varYVals
    (51) varsOps -> . varYVals MASMAS
    (52) varsOps -> . varYVals MENOSMENOS
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (43) vecVal -> . ID m

    MENOSMENOS      shift and go to state 32
    MASMAS          shift and go to state 29
    ID              shift and go to state 58

    varsOps                        shift and go to state 229
    varYVals                       shift and go to state 31
    vecVal                         shift and go to state 9

state 222

    (13) if -> IF ( expBool ) bloque else .

    RETURN          reduce using rule 13 (if -> IF ( expBool ) bloque else .)
    MENOSMENOS      reduce using rule 13 (if -> IF ( expBool ) bloque else .)
    MASMAS          reduce using rule 13 (if -> IF ( expBool ) bloque else .)
    ID              reduce using rule 13 (if -> IF ( expBool ) bloque else .)
    IF              reduce using rule 13 (if -> IF ( expBool ) bloque else .)
    WHILE           reduce using rule 13 (if -> IF ( expBool ) bloque else .)
    DO              reduce using rule 13 (if -> IF ( expBool ) bloque else .)
    FOR             reduce using rule 13 (if -> IF ( expBool ) bloque else .)
    PRINT           reduce using rule 13 (if -> IF ( expBool ) bloque else .)
    MULTIESCALAR    reduce using rule 13 (if -> IF ( expBool ) bloque else .)
    LENGTH          reduce using rule 13 (if -> IF ( expBool ) bloque else .)
    CAPITALIZAR     reduce using rule 13 (if -> IF ( expBool ) bloque else .)
    COLINEALES      reduce using rule 13 (if -> IF ( expBool ) bloque else .)
    $end            reduce using rule 13 (if -> IF ( expBool ) bloque else .)
    }               reduce using rule 13 (if -> IF ( expBool ) bloque else .)


state 223

    (15) else -> empty .

    RETURN          reduce using rule 15 (else -> empty .)
    MENOSMENOS      reduce using rule 15 (else -> empty .)
    MASMAS          reduce using rule 15 (else -> empty .)
    ID              reduce using rule 15 (else -> empty .)
    IF              reduce using rule 15 (else -> empty .)
    WHILE           reduce using rule 15 (else -> empty .)
    DO              reduce using rule 15 (else -> empty .)
    FOR             reduce using rule 15 (else -> empty .)
    PRINT           reduce using rule 15 (else -> empty .)
    MULTIESCALAR    reduce using rule 15 (else -> empty .)
    LENGTH          reduce using rule 15 (else -> empty .)
    CAPITALIZAR     reduce using rule 15 (else -> empty .)
    COLINEALES      reduce using rule 15 (else -> empty .)
    $end            reduce using rule 15 (else -> empty .)
    }               reduce using rule 15 (else -> empty .)


state 224

    (14) else -> ELSE . bloque
    (16) bloque -> . sentencia ;
    (17) bloque -> . { g }
    (4) sentencia -> . varsOps ;
    (5) sentencia -> . func ;
    (6) sentencia -> . varAsig ;
    (7) sentencia -> . RETURN ;
    (49) varsOps -> . MENOSMENOS varYVals
    (50) varsOps -> . MASMAS varYVals
    (51) varsOps -> . varYVals MASMAS
    (52) varsOps -> . varYVals MENOSMENOS
    (18) func -> . funcReturn
    (19) func -> . funcVoid
    (53) varAsig -> . ID MULEQ varAsig
    (54) varAsig -> . masmenAsig MULEQ varAsig
    (55) varAsig -> . masmenAsig MULEQ ID
    (56) varAsig -> . masmenAsig MULEQ valores
    (57) varAsig -> . masmenAsig DIVEQ varAsig
    (58) varAsig -> . masmenAsig DIVEQ ID
    (59) varAsig -> . masmenAsig DIVEQ valores
    (60) varAsig -> . finVarAsig
    (61) varAsig -> . masmenAsig
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (20) funcReturn -> . funcInt
    (21) funcReturn -> . funcString
    (22) funcReturn -> . funcBool
    (27) funcVoid -> . PRINT ( valores )
    (62) masmenAsig -> . ID MASEQ masmenAsig
    (63) masmenAsig -> . ID MENOSEQ masmenAsig
    (64) masmenAsig -> . ID MASEQ ID
    (65) masmenAsig -> . ID MENOSEQ ID
    (66) masmenAsig -> . asig
    (69) finVarAsig -> . ID = valores
    (70) finVarAsig -> . ID MASEQ valores
    (71) finVarAsig -> . ID MENOSEQ valores
    (72) finVarAsig -> . ID MULEQ valores
    (73) finVarAsig -> . ID MULEQ ID
    (74) finVarAsig -> . ID DIVEQ valores
    (75) finVarAsig -> . ID DIVEQ ID
    (43) vecVal -> . ID m
    (23) funcInt -> . MULTIESCALAR ( vec , eMat , param )
    (24) funcInt -> . LENGTH ( vec )
    (25) funcString -> . CAPITALIZAR ( expString )
    (26) funcBool -> . COLINEALES ( vec , vec )
    (67) asig -> . ID = asig
    (68) asig -> . ID = ID

    {               shift and go to state 35
    RETURN          shift and go to state 2
    MENOSMENOS      shift and go to state 32
    MASMAS          shift and go to state 29
    ID              shift and go to state 17
    PRINT           shift and go to state 8
    MULTIESCALAR    shift and go to state 22
    LENGTH          shift and go to state 27
    CAPITALIZAR     shift and go to state 25
    COLINEALES      shift and go to state 14

    funcBool                       shift and go to state 3
    funcInt                        shift and go to state 5
    bloque                         shift and go to state 230
    vecVal                         shift and go to state 9
    sentencia                      shift and go to state 34
    asig                           shift and go to state 26
    masmenAsig                     shift and go to state 12
    funcVoid                       shift and go to state 13
    func                           shift and go to state 16
    varAsig                        shift and go to state 19
    funcString                     shift and go to state 21
    funcReturn                     shift and go to state 23
    finVarAsig                     shift and go to state 24
    varsOps                        shift and go to state 30
    varYVals                       shift and go to state 31

state 225

    (23) funcInt -> MULTIESCALAR ( vec , eMat , . param )
    (28) param -> . expBool
    (29) param -> . empty
    (98) expBool -> . or ? expBool : expBool
    (99) expBool -> . or
    (30) empty -> .
    (100) or -> . or OR and
    (101) or -> . and
    (102) and -> . and AND eq
    (103) and -> . eq
    (104) eq -> . eq EQEQ tBool
    (105) eq -> . eq DISTINTO tBool
    (106) eq -> . mayor
    (107) mayor -> . tCompare > tCompare
    (108) mayor -> . menor
    (117) tCompare -> . eMat
    (118) tCompare -> . varsOps
    (119) tCompare -> . varYVals
    (109) menor -> . tCompare < tCompare
    (110) menor -> . not
    (76) eMat -> . eMat + p
    (77) eMat -> . eMat - p
    (78) eMat -> . p
    (49) varsOps -> . MENOSMENOS varYVals
    (50) varsOps -> . MASMAS varYVals
    (51) varsOps -> . varYVals MASMAS
    (52) varsOps -> . varYVals MENOSMENOS
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (111) not -> . NOT not
    (112) not -> . tBool
    (79) p -> . p * exp
    (80) p -> . p / exp
    (81) p -> . p % exp
    (82) p -> . exp
    (43) vecVal -> . ID m
    (113) tBool -> . ( expBool )
    (114) tBool -> . BOOL
    (115) tBool -> . varYVals
    (116) tBool -> . funcBool
    (83) exp -> . exp ^ iSing
    (84) exp -> . iSing
    (26) funcBool -> . COLINEALES ( vec , vec )
    (85) iSing -> . - paren
    (86) iSing -> . + paren
    (87) iSing -> . paren
    (88) paren -> . ( eMat )
    (89) paren -> . INT
    (90) paren -> . varYVals
    (91) paren -> . FLOAT
    (92) paren -> . varsOps
    (93) paren -> . funcInt
    (23) funcInt -> . MULTIESCALAR ( vec , eMat , param )
    (24) funcInt -> . LENGTH ( vec )

    )               reduce using rule 30 (empty -> .)
    MENOSMENOS      shift and go to state 32
    MASMAS          shift and go to state 29
    ID              shift and go to state 58
    NOT             shift and go to state 87
    (               shift and go to state 73
    BOOL            shift and go to state 76
    COLINEALES      shift and go to state 14
    -               shift and go to state 75
    +               shift and go to state 74
    INT             shift and go to state 81
    FLOAT           shift and go to state 82
    MULTIESCALAR    shift and go to state 22
    LENGTH          shift and go to state 27

    and                            shift and go to state 66
    funcBool                       shift and go to state 67
    funcInt                        shift and go to state 68
    menor                          shift and go to state 69
    eq                             shift and go to state 70
    mayor                          shift and go to state 71
    eMat                           shift and go to state 72
    param                          shift and go to state 231
    vecVal                         shift and go to state 9
    paren                          shift and go to state 79
    empty                          shift and go to state 232
    varsOps                        shift and go to state 85
    tCompare                       shift and go to state 78
    not                            shift and go to state 80
    p                              shift and go to state 84
    iSing                          shift and go to state 77
    exp                            shift and go to state 86
    tBool                          shift and go to state 88
    varYVals                       shift and go to state 89
    or                             shift and go to state 83
    expBool                        shift and go to state 233

state 226

    (11) loop -> DO bloque WHILE ( expBool ) ; .

    RETURN          reduce using rule 11 (loop -> DO bloque WHILE ( expBool ) ; .)
    MENOSMENOS      reduce using rule 11 (loop -> DO bloque WHILE ( expBool ) ; .)
    MASMAS          reduce using rule 11 (loop -> DO bloque WHILE ( expBool ) ; .)
    ID              reduce using rule 11 (loop -> DO bloque WHILE ( expBool ) ; .)
    IF              reduce using rule 11 (loop -> DO bloque WHILE ( expBool ) ; .)
    WHILE           reduce using rule 11 (loop -> DO bloque WHILE ( expBool ) ; .)
    DO              reduce using rule 11 (loop -> DO bloque WHILE ( expBool ) ; .)
    FOR             reduce using rule 11 (loop -> DO bloque WHILE ( expBool ) ; .)
    PRINT           reduce using rule 11 (loop -> DO bloque WHILE ( expBool ) ; .)
    MULTIESCALAR    reduce using rule 11 (loop -> DO bloque WHILE ( expBool ) ; .)
    LENGTH          reduce using rule 11 (loop -> DO bloque WHILE ( expBool ) ; .)
    CAPITALIZAR     reduce using rule 11 (loop -> DO bloque WHILE ( expBool ) ; .)
    COLINEALES      reduce using rule 11 (loop -> DO bloque WHILE ( expBool ) ; .)
    $end            reduce using rule 11 (loop -> DO bloque WHILE ( expBool ) ; .)
    }               reduce using rule 11 (loop -> DO bloque WHILE ( expBool ) ; .)


state 227

    (98) expBool -> or ? expBool : expBool .

    ,               reduce using rule 98 (expBool -> or ? expBool : expBool .)
    ]               reduce using rule 98 (expBool -> or ? expBool : expBool .)
    }               reduce using rule 98 (expBool -> or ? expBool : expBool .)
    ;               reduce using rule 98 (expBool -> or ? expBool : expBool .)
    :               reduce using rule 98 (expBool -> or ? expBool : expBool .)
    )               reduce using rule 98 (expBool -> or ? expBool : expBool .)


state 228

    (47) campos -> ID : valores , . campos
    (47) campos -> . ID : valores , campos
    (48) campos -> . valores
    (34) valores -> . eMat
    (35) valores -> . expBool
    (36) valores -> . expString
    (37) valores -> . varYVals
    (38) valores -> . funcReturn
    (39) valores -> . reg
    (40) valores -> . ID . ID
    (76) eMat -> . eMat + p
    (77) eMat -> . eMat - p
    (78) eMat -> . p
    (98) expBool -> . or ? expBool : expBool
    (99) expBool -> . or
    (94) expString -> . expString + STRING
    (95) expString -> . STRING
    (96) expString -> . varYVals
    (97) expString -> . funcString
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (20) funcReturn -> . funcInt
    (21) funcReturn -> . funcString
    (22) funcReturn -> . funcBool
    (46) reg -> . { campos }
    (79) p -> . p * exp
    (80) p -> . p / exp
    (81) p -> . p % exp
    (82) p -> . exp
    (100) or -> . or OR and
    (101) or -> . and
    (25) funcString -> . CAPITALIZAR ( expString )
    (43) vecVal -> . ID m
    (23) funcInt -> . MULTIESCALAR ( vec , eMat , param )
    (24) funcInt -> . LENGTH ( vec )
    (26) funcBool -> . COLINEALES ( vec , vec )
    (83) exp -> . exp ^ iSing
    (84) exp -> . iSing
    (102) and -> . and AND eq
    (103) and -> . eq
    (85) iSing -> . - paren
    (86) iSing -> . + paren
    (87) iSing -> . paren
    (104) eq -> . eq EQEQ tBool
    (105) eq -> . eq DISTINTO tBool
    (106) eq -> . mayor
    (88) paren -> . ( eMat )
    (89) paren -> . INT
    (90) paren -> . varYVals
    (91) paren -> . FLOAT
    (92) paren -> . varsOps
    (93) paren -> . funcInt
    (107) mayor -> . tCompare > tCompare
    (108) mayor -> . menor
    (49) varsOps -> . MENOSMENOS varYVals
    (50) varsOps -> . MASMAS varYVals
    (51) varsOps -> . varYVals MASMAS
    (52) varsOps -> . varYVals MENOSMENOS
    (117) tCompare -> . eMat
    (118) tCompare -> . varsOps
    (119) tCompare -> . varYVals
    (109) menor -> . tCompare < tCompare
    (110) menor -> . not
    (111) not -> . NOT not
    (112) not -> . tBool
    (113) tBool -> . ( expBool )
    (114) tBool -> . BOOL
    (115) tBool -> . varYVals
    (116) tBool -> . funcBool

    ID              shift and go to state 169
    STRING          shift and go to state 97
    {               shift and go to state 103
    CAPITALIZAR     shift and go to state 25
    MULTIESCALAR    shift and go to state 22
    LENGTH          shift and go to state 27
    COLINEALES      shift and go to state 14
    -               shift and go to state 75
    +               shift and go to state 74
    (               shift and go to state 94
    INT             shift and go to state 81
    FLOAT           shift and go to state 82
    MENOSMENOS      shift and go to state 32
    MASMAS          shift and go to state 29
    NOT             shift and go to state 87
    BOOL            shift and go to state 76

    and                            shift and go to state 66
    funcBool                       shift and go to state 91
    funcInt                        shift and go to state 92
    menor                          shift and go to state 69
    eq                             shift and go to state 70
    vecVal                         shift and go to state 9
    eMat                           shift and go to state 93
    mayor                          shift and go to state 71
    paren                          shift and go to state 79
    reg                            shift and go to state 95
    varsOps                        shift and go to state 96
    expString                      shift and go to state 98
    tCompare                       shift and go to state 78
    campos                         shift and go to state 234
    not                            shift and go to state 80
    funcString                     shift and go to state 100
    funcReturn                     shift and go to state 101
    valores                        shift and go to state 170
    p                              shift and go to state 84
    iSing                          shift and go to state 77
    exp                            shift and go to state 86
    tBool                          shift and go to state 88
    varYVals                       shift and go to state 104
    or                             shift and go to state 83
    expBool                        shift and go to state 105

state 229

    (12) loop -> FOR ( varAsig ; expBool ; varsOps . ) bloque

    )               shift and go to state 235


state 230

    (14) else -> ELSE bloque .

    RETURN          reduce using rule 14 (else -> ELSE bloque .)
    MENOSMENOS      reduce using rule 14 (else -> ELSE bloque .)
    MASMAS          reduce using rule 14 (else -> ELSE bloque .)
    ID              reduce using rule 14 (else -> ELSE bloque .)
    IF              reduce using rule 14 (else -> ELSE bloque .)
    WHILE           reduce using rule 14 (else -> ELSE bloque .)
    DO              reduce using rule 14 (else -> ELSE bloque .)
    FOR             reduce using rule 14 (else -> ELSE bloque .)
    PRINT           reduce using rule 14 (else -> ELSE bloque .)
    MULTIESCALAR    reduce using rule 14 (else -> ELSE bloque .)
    LENGTH          reduce using rule 14 (else -> ELSE bloque .)
    CAPITALIZAR     reduce using rule 14 (else -> ELSE bloque .)
    COLINEALES      reduce using rule 14 (else -> ELSE bloque .)
    $end            reduce using rule 14 (else -> ELSE bloque .)
    }               reduce using rule 14 (else -> ELSE bloque .)


state 231

    (23) funcInt -> MULTIESCALAR ( vec , eMat , param . )

    )               shift and go to state 236


state 232

    (29) param -> empty .

    )               reduce using rule 29 (param -> empty .)


state 233

    (28) param -> expBool .

    )               reduce using rule 28 (param -> expBool .)


state 234

    (47) campos -> ID : valores , campos .

    }               reduce using rule 47 (campos -> ID : valores , campos .)


state 235

    (12) loop -> FOR ( varAsig ; expBool ; varsOps ) . bloque
    (16) bloque -> . sentencia ;
    (17) bloque -> . { g }
    (4) sentencia -> . varsOps ;
    (5) sentencia -> . func ;
    (6) sentencia -> . varAsig ;
    (7) sentencia -> . RETURN ;
    (49) varsOps -> . MENOSMENOS varYVals
    (50) varsOps -> . MASMAS varYVals
    (51) varsOps -> . varYVals MASMAS
    (52) varsOps -> . varYVals MENOSMENOS
    (18) func -> . funcReturn
    (19) func -> . funcVoid
    (53) varAsig -> . ID MULEQ varAsig
    (54) varAsig -> . masmenAsig MULEQ varAsig
    (55) varAsig -> . masmenAsig MULEQ ID
    (56) varAsig -> . masmenAsig MULEQ valores
    (57) varAsig -> . masmenAsig DIVEQ varAsig
    (58) varAsig -> . masmenAsig DIVEQ ID
    (59) varAsig -> . masmenAsig DIVEQ valores
    (60) varAsig -> . finVarAsig
    (61) varAsig -> . masmenAsig
    (41) varYVals -> . ID
    (42) varYVals -> . vecVal
    (20) funcReturn -> . funcInt
    (21) funcReturn -> . funcString
    (22) funcReturn -> . funcBool
    (27) funcVoid -> . PRINT ( valores )
    (62) masmenAsig -> . ID MASEQ masmenAsig
    (63) masmenAsig -> . ID MENOSEQ masmenAsig
    (64) masmenAsig -> . ID MASEQ ID
    (65) masmenAsig -> . ID MENOSEQ ID
    (66) masmenAsig -> . asig
    (69) finVarAsig -> . ID = valores
    (70) finVarAsig -> . ID MASEQ valores
    (71) finVarAsig -> . ID MENOSEQ valores
    (72) finVarAsig -> . ID MULEQ valores
    (73) finVarAsig -> . ID MULEQ ID
    (74) finVarAsig -> . ID DIVEQ valores
    (75) finVarAsig -> . ID DIVEQ ID
    (43) vecVal -> . ID m
    (23) funcInt -> . MULTIESCALAR ( vec , eMat , param )
    (24) funcInt -> . LENGTH ( vec )
    (25) funcString -> . CAPITALIZAR ( expString )
    (26) funcBool -> . COLINEALES ( vec , vec )
    (67) asig -> . ID = asig
    (68) asig -> . ID = ID

    {               shift and go to state 35
    RETURN          shift and go to state 2
    MENOSMENOS      shift and go to state 32
    MASMAS          shift and go to state 29
    ID              shift and go to state 17
    PRINT           shift and go to state 8
    MULTIESCALAR    shift and go to state 22
    LENGTH          shift and go to state 27
    CAPITALIZAR     shift and go to state 25
    COLINEALES      shift and go to state 14

    funcBool                       shift and go to state 3
    funcInt                        shift and go to state 5
    bloque                         shift and go to state 237
    vecVal                         shift and go to state 9
    sentencia                      shift and go to state 34
    asig                           shift and go to state 26
    masmenAsig                     shift and go to state 12
    funcVoid                       shift and go to state 13
    func                           shift and go to state 16
    varAsig                        shift and go to state 19
    funcString                     shift and go to state 21
    funcReturn                     shift and go to state 23
    finVarAsig                     shift and go to state 24
    varsOps                        shift and go to state 30
    varYVals                       shift and go to state 31

state 236

    (23) funcInt -> MULTIESCALAR ( vec , eMat , param ) .

    ;               reduce using rule 23 (funcInt -> MULTIESCALAR ( vec , eMat , param ) .)
    ^               reduce using rule 23 (funcInt -> MULTIESCALAR ( vec , eMat , param ) .)
    *               reduce using rule 23 (funcInt -> MULTIESCALAR ( vec , eMat , param ) .)
    /               reduce using rule 23 (funcInt -> MULTIESCALAR ( vec , eMat , param ) .)
    %               reduce using rule 23 (funcInt -> MULTIESCALAR ( vec , eMat , param ) .)
    +               reduce using rule 23 (funcInt -> MULTIESCALAR ( vec , eMat , param ) .)
    -               reduce using rule 23 (funcInt -> MULTIESCALAR ( vec , eMat , param ) .)
    >               reduce using rule 23 (funcInt -> MULTIESCALAR ( vec , eMat , param ) .)
    <               reduce using rule 23 (funcInt -> MULTIESCALAR ( vec , eMat , param ) .)
    )               reduce using rule 23 (funcInt -> MULTIESCALAR ( vec , eMat , param ) .)
    }               reduce using rule 23 (funcInt -> MULTIESCALAR ( vec , eMat , param ) .)
    ,               reduce using rule 23 (funcInt -> MULTIESCALAR ( vec , eMat , param ) .)
    ]               reduce using rule 23 (funcInt -> MULTIESCALAR ( vec , eMat , param ) .)
    EQEQ            reduce using rule 23 (funcInt -> MULTIESCALAR ( vec , eMat , param ) .)
    DISTINTO        reduce using rule 23 (funcInt -> MULTIESCALAR ( vec , eMat , param ) .)
    AND             reduce using rule 23 (funcInt -> MULTIESCALAR ( vec , eMat , param ) .)
    ?               reduce using rule 23 (funcInt -> MULTIESCALAR ( vec , eMat , param ) .)
    OR              reduce using rule 23 (funcInt -> MULTIESCALAR ( vec , eMat , param ) .)
    :               reduce using rule 23 (funcInt -> MULTIESCALAR ( vec , eMat , param ) .)


state 237

    (12) loop -> FOR ( varAsig ; expBool ; varsOps ) bloque .

    RETURN          reduce using rule 12 (loop -> FOR ( varAsig ; expBool ; varsOps ) bloque .)
    MENOSMENOS      reduce using rule 12 (loop -> FOR ( varAsig ; expBool ; varsOps ) bloque .)
    MASMAS          reduce using rule 12 (loop -> FOR ( varAsig ; expBool ; varsOps ) bloque .)
    ID              reduce using rule 12 (loop -> FOR ( varAsig ; expBool ; varsOps ) bloque .)
    IF              reduce using rule 12 (loop -> FOR ( varAsig ; expBool ; varsOps ) bloque .)
    WHILE           reduce using rule 12 (loop -> FOR ( varAsig ; expBool ; varsOps ) bloque .)
    DO              reduce using rule 12 (loop -> FOR ( varAsig ; expBool ; varsOps ) bloque .)
    FOR             reduce using rule 12 (loop -> FOR ( varAsig ; expBool ; varsOps ) bloque .)
    PRINT           reduce using rule 12 (loop -> FOR ( varAsig ; expBool ; varsOps ) bloque .)
    MULTIESCALAR    reduce using rule 12 (loop -> FOR ( varAsig ; expBool ; varsOps ) bloque .)
    LENGTH          reduce using rule 12 (loop -> FOR ( varAsig ; expBool ; varsOps ) bloque .)
    CAPITALIZAR     reduce using rule 12 (loop -> FOR ( varAsig ; expBool ; varsOps ) bloque .)
    COLINEALES      reduce using rule 12 (loop -> FOR ( varAsig ; expBool ; varsOps ) bloque .)
    $end            reduce using rule 12 (loop -> FOR ( varAsig ; expBool ; varsOps ) bloque .)
    }               reduce using rule 12 (loop -> FOR ( varAsig ; expBool ; varsOps ) bloque .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: reduce/reduce conflict in state 85 resolved using rule (paren -> varsOps)
WARNING: rejected rule (tCompare -> varsOps) in state 85
WARNING: reduce/reduce conflict in state 89 resolved using rule (paren -> varYVals)
WARNING: rejected rule (tCompare -> varYVals) in state 89
WARNING: reduce/reduce conflict in state 91 resolved using rule (funcReturn -> funcBool)
WARNING: rejected rule (tBool -> funcBool) in state 91
WARNING: reduce/reduce conflict in state 92 resolved using rule (funcReturn -> funcInt)
WARNING: rejected rule (paren -> funcInt) in state 92
WARNING: reduce/reduce conflict in state 96 resolved using rule (paren -> varsOps)
WARNING: rejected rule (tCompare -> varsOps) in state 96
WARNING: reduce/reduce conflict in state 100 resolved using rule (funcReturn -> funcString)
WARNING: rejected rule (expString -> funcString) in state 100
WARNING: reduce/reduce conflict in state 104 resolved using rule (valores -> varYVals)
WARNING: rejected rule (expString -> varYVals) in state 104
WARNING: reduce/reduce conflict in state 104 resolved using rule (paren -> varYVals)
WARNING: rejected rule (expString -> varYVals) in state 104
WARNING: reduce/reduce conflict in state 104 resolved using rule (valores -> varYVals)
WARNING: rejected rule (paren -> varYVals) in state 104
WARNING: reduce/reduce conflict in state 104 resolved using rule (paren -> varYVals)
WARNING: rejected rule (tCompare -> varYVals) in state 104
WARNING: reduce/reduce conflict in state 104 resolved using rule (valores -> varYVals)
WARNING: rejected rule (tBool -> varYVals) in state 104
WARNING: reduce/reduce conflict in state 106 resolved using rule (varYVals -> ID)
WARNING: rejected rule (varAsig -> masmenAsig DIVEQ ID) in state 106
WARNING: reduce/reduce conflict in state 109 resolved using rule (varYVals -> ID)
WARNING: rejected rule (varAsig -> masmenAsig MULEQ ID) in state 109
WARNING: reduce/reduce conflict in state 117 resolved using rule (varYVals -> ID)
WARNING: rejected rule (masmenAsig -> ID MENOSEQ ID) in state 117
WARNING: reduce/reduce conflict in state 120 resolved using rule (varYVals -> ID)
WARNING: rejected rule (masmenAsig -> ID MASEQ ID) in state 120
WARNING: reduce/reduce conflict in state 124 resolved using rule (varYVals -> ID)
WARNING: rejected rule (asig -> ID = ID) in state 124
WARNING: reduce/reduce conflict in state 126 resolved using rule (varYVals -> ID)
WARNING: rejected rule (finVarAsig -> ID DIVEQ ID) in state 126
WARNING: reduce/reduce conflict in state 128 resolved using rule (varYVals -> ID)
WARNING: rejected rule (finVarAsig -> ID MULEQ ID) in state 128
WARNING: reduce/reduce conflict in state 145 resolved using rule (paren -> varYVals)
WARNING: rejected rule (tCompare -> varYVals) in state 145
WARNING: reduce/reduce conflict in state 145 resolved using rule (paren -> varYVals)
WARNING: rejected rule (tBool -> varYVals) in state 145
WARNING: reduce/reduce conflict in state 164 resolved using rule (paren -> varYVals)
WARNING: rejected rule (tCompare -> varYVals) in state 164
WARNING: reduce/reduce conflict in state 164 resolved using rule (paren -> varYVals)
WARNING: rejected rule (tBool -> varYVals) in state 164
WARNING: reduce/reduce conflict in state 193 resolved using rule (paren -> varYVals)
WARNING: rejected rule (tCompare -> varYVals) in state 193
WARNING: Rule (tCompare -> varsOps) is never reduced
WARNING: Rule (tCompare -> varYVals) is never reduced
WARNING: Rule (varAsig -> masmenAsig DIVEQ ID) is never reduced
WARNING: Rule (varAsig -> masmenAsig MULEQ ID) is never reduced
WARNING: Rule (finVarAsig -> ID DIVEQ ID) is never reduced
WARNING: Rule (finVarAsig -> ID MULEQ ID) is never reduced
